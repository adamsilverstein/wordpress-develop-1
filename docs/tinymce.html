<!DOCTYPE html>

<html>
<head>
  <title>tinymce.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="accordion.html">
                  accordion.js
                </a>
              
                
                <a class="source" href="bookmarklet.html">
                  bookmarklet.js
                </a>
              
                
                <a class="source" href="bookmarklet.min.html">
                  bookmarklet.min.js
                </a>
              
                
                <a class="source" href="color-picker.html">
                  color-picker.js
                </a>
              
                
                <a class="source" href="comment.html">
                  comment.js
                </a>
              
                
                <a class="source" href="common.html">
                  common.js
                </a>
              
                
                <a class="source" href="custom-background.html">
                  custom-background.js
                </a>
              
                
                <a class="source" href="custom-header.html">
                  custom-header.js
                </a>
              
                
                <a class="source" href="customize-controls.html">
                  customize-controls.js
                </a>
              
                
                <a class="source" href="customize-nav-menus.html">
                  customize-nav-menus.js
                </a>
              
                
                <a class="source" href="customize-widgets.html">
                  customize-widgets.js
                </a>
              
                
                <a class="source" href="dashboard.html">
                  dashboard.js
                </a>
              
                
                <a class="source" href="edit-comments.html">
                  edit-comments.js
                </a>
              
                
                <a class="source" href="editor-expand.html">
                  editor-expand.js
                </a>
              
                
                <a class="source" href="editor.html">
                  editor.js
                </a>
              
                
                <a class="source" href="farbtastic.html">
                  farbtastic.js
                </a>
              
                
                <a class="source" href="gallery.html">
                  gallery.js
                </a>
              
                
                <a class="source" href="image-edit.html">
                  image-edit.js
                </a>
              
                
                <a class="source" href="inline-edit-post.html">
                  inline-edit-post.js
                </a>
              
                
                <a class="source" href="inline-edit-tax.html">
                  inline-edit-tax.js
                </a>
              
                
                <a class="source" href="iris.min.html">
                  iris.min.js
                </a>
              
                
                <a class="source" href="language-chooser.html">
                  language-chooser.js
                </a>
              
                
                <a class="source" href="link.html">
                  link.js
                </a>
              
                
                <a class="source" href="media-gallery.html">
                  media-gallery.js
                </a>
              
                
                <a class="source" href="media-upload.html">
                  media-upload.js
                </a>
              
                
                <a class="source" href="media.html">
                  media.js
                </a>
              
                
                <a class="source" href="nav-menu.html">
                  nav-menu.js
                </a>
              
                
                <a class="source" href="password-strength-meter.html">
                  password-strength-meter.js
                </a>
              
                
                <a class="source" href="plugin-install.html">
                  plugin-install.js
                </a>
              
                
                <a class="source" href="post.html">
                  post.js
                </a>
              
                
                <a class="source" href="postbox.html">
                  postbox.js
                </a>
              
                
                <a class="source" href="press-this.html">
                  press-this.js
                </a>
              
                
                <a class="source" href="revisions.html">
                  revisions.js
                </a>
              
                
                <a class="source" href="set-post-thumbnail.html">
                  set-post-thumbnail.js
                </a>
              
                
                <a class="source" href="svg-painter.html">
                  svg-painter.js
                </a>
              
                
                <a class="source" href="tags-box.html">
                  tags-box.js
                </a>
              
                
                <a class="source" href="tags-suggest.html">
                  tags-suggest.js
                </a>
              
                
                <a class="source" href="tags.html">
                  tags.js
                </a>
              
                
                <a class="source" href="theme.html">
                  theme.js
                </a>
              
                
                <a class="source" href="updates.html">
                  updates.js
                </a>
              
                
                <a class="source" href="user-profile.html">
                  user-profile.js
                </a>
              
                
                <a class="source" href="user-suggest.html">
                  user-suggest.js
                </a>
              
                
                <a class="source" href="widgets.html">
                  widgets.js
                </a>
              
                
                <a class="source" href="media-audio-widget.html">
                  media-audio-widget.js
                </a>
              
                
                <a class="source" href="media-image-widget.html">
                  media-image-widget.js
                </a>
              
                
                <a class="source" href="media-video-widget.html">
                  media-video-widget.js
                </a>
              
                
                <a class="source" href="media-widgets.html">
                  media-widgets.js
                </a>
              
                
                <a class="source" href="text-widgets.html">
                  text-widgets.js
                </a>
              
                
                <a class="source" href="word-count.html">
                  word-count.js
                </a>
              
                
                <a class="source" href="wp-fullscreen-stub.html">
                  wp-fullscreen-stub.js
                </a>
              
                
                <a class="source" href="xfn.html">
                  xfn.js
                </a>
              
                
                <a class="source" href="theme-customizer.html">
                  theme-customizer.js
                </a>
              
                
                <a class="source" href="theme-options.html">
                  theme-options.js
                </a>
              
                
                <a class="source" href="html5.html">
                  html5.js
                </a>
              
                
                <a class="source" href="showcase.html">
                  showcase.js
                </a>
              
                
                <a class="source" href="color-scheme-control.html">
                  color-scheme-control.js
                </a>
              
                
                <a class="source" href="customize-preview.html">
                  customize-preview.js
                </a>
              
                
                <a class="source" href="functions.html">
                  functions.js
                </a>
              
                
                <a class="source" href="html5.html">
                  html5.js
                </a>
              
                
                <a class="source" href="keyboard-image-navigation.html">
                  keyboard-image-navigation.js
                </a>
              
                
                <a class="source" href="skip-link-focus-fix.html">
                  skip-link-focus-fix.js
                </a>
              
                
                <a class="source" href="customizer.html">
                  customizer.js
                </a>
              
                
                <a class="source" href="featured-content-admin.html">
                  featured-content-admin.js
                </a>
              
                
                <a class="source" href="functions.html">
                  functions.js
                </a>
              
                
                <a class="source" href="html5.html">
                  html5.js
                </a>
              
                
                <a class="source" href="keyboard-image-navigation.html">
                  keyboard-image-navigation.js
                </a>
              
                
                <a class="source" href="slider.html">
                  slider.js
                </a>
              
                
                <a class="source" href="customize-controls.html">
                  customize-controls.js
                </a>
              
                
                <a class="source" href="customize-preview.html">
                  customize-preview.js
                </a>
              
                
                <a class="source" href="global.html">
                  global.js
                </a>
              
                
                <a class="source" href="html5.html">
                  html5.js
                </a>
              
                
                <a class="source" href="jquery.scrollTo.html">
                  jquery.scrollTo.js
                </a>
              
                
                <a class="source" href="navigation.html">
                  navigation.js
                </a>
              
                
                <a class="source" href="skip-link-focus-fix.html">
                  skip-link-focus-fix.js
                </a>
              
                
                <a class="source" href="functions.html">
                  functions.js
                </a>
              
                
                <a class="source" href="html5.html">
                  html5.js
                </a>
              
                
                <a class="source" href="theme-customizer.html">
                  theme-customizer.js
                </a>
              
                
                <a class="source" href="html5.html">
                  html5.js
                </a>
              
                
                <a class="source" href="navigation.html">
                  navigation.js
                </a>
              
                
                <a class="source" href="theme-customizer.html">
                  theme-customizer.js
                </a>
              
                
                <a class="source" href="admin-bar.html">
                  admin-bar.js
                </a>
              
                
                <a class="source" href="autosave.html">
                  autosave.js
                </a>
              
                
                <a class="source" href="backbone.html">
                  backbone.js
                </a>
              
                
                <a class="source" href="backbone.min.html">
                  backbone.min.js
                </a>
              
                
                <a class="source" href="colorpicker.html">
                  colorpicker.js
                </a>
              
                
                <a class="source" href="comment-reply.html">
                  comment-reply.js
                </a>
              
                
                <a class="source" href="cropper.html">
                  cropper.js
                </a>
              
                
                <a class="source" href="customize-base.html">
                  customize-base.js
                </a>
              
                
                <a class="source" href="customize-loader.html">
                  customize-loader.js
                </a>
              
                
                <a class="source" href="customize-models.html">
                  customize-models.js
                </a>
              
                
                <a class="source" href="customize-preview-nav-menus.html">
                  customize-preview-nav-menus.js
                </a>
              
                
                <a class="source" href="customize-preview-widgets.html">
                  customize-preview-widgets.js
                </a>
              
                
                <a class="source" href="customize-preview.html">
                  customize-preview.js
                </a>
              
                
                <a class="source" href="customize-selective-refresh.html">
                  customize-selective-refresh.js
                </a>
              
                
                <a class="source" href="customize-views.html">
                  customize-views.js
                </a>
              
                
                <a class="source" href="heartbeat.html">
                  heartbeat.js
                </a>
              
                
                <a class="source" href="hoverIntent.html">
                  hoverIntent.js
                </a>
              
                
                <a class="source" href="imagesloaded.min.html">
                  imagesloaded.min.js
                </a>
              
                
                <a class="source" href="jquery.imgareaselect.html">
                  jquery.imgareaselect.js
                </a>
              
                
                <a class="source" href="jquery.imgareaselect.min.html">
                  jquery.imgareaselect.min.js
                </a>
              
                
                <a class="source" href="jquery.Jcrop.min.html">
                  jquery.Jcrop.min.js
                </a>
              
                
                <a class="source" href="jquery-migrate.html">
                  jquery-migrate.js
                </a>
              
                
                <a class="source" href="jquery-migrate.min.html">
                  jquery-migrate.min.js
                </a>
              
                
                <a class="source" href="jquery.color.min.html">
                  jquery.color.min.js
                </a>
              
                
                <a class="source" href="jquery.form.html">
                  jquery.form.js
                </a>
              
                
                <a class="source" href="jquery.form.min.html">
                  jquery.form.min.js
                </a>
              
                
                <a class="source" href="jquery.hotkeys.html">
                  jquery.hotkeys.js
                </a>
              
                
                <a class="source" href="jquery.hotkeys.min.html">
                  jquery.hotkeys.min.js
                </a>
              
                
                <a class="source" href="jquery.html">
                  jquery.js
                </a>
              
                
                <a class="source" href="jquery.masonry.html">
                  jquery.masonry.js
                </a>
              
                
                <a class="source" href="jquery.masonry.min.html">
                  jquery.masonry.min.js
                </a>
              
                
                <a class="source" href="jquery.query.html">
                  jquery.query.js
                </a>
              
                
                <a class="source" href="jquery.schedule.html">
                  jquery.schedule.js
                </a>
              
                
                <a class="source" href="jquery.serialize-object.html">
                  jquery.serialize-object.js
                </a>
              
                
                <a class="source" href="jquery.table-hotkeys.html">
                  jquery.table-hotkeys.js
                </a>
              
                
                <a class="source" href="jquery.table-hotkeys.min.html">
                  jquery.table-hotkeys.min.js
                </a>
              
                
                <a class="source" href="jquery.ui.touch-punch.html">
                  jquery.ui.touch-punch.js
                </a>
              
                
                <a class="source" href="suggest.html">
                  suggest.js
                </a>
              
                
                <a class="source" href="suggest.min.html">
                  suggest.min.js
                </a>
              
                
                <a class="source" href="accordion.html">
                  accordion.js
                </a>
              
                
                <a class="source" href="autocomplete.html">
                  autocomplete.js
                </a>
              
                
                <a class="source" href="button.html">
                  button.js
                </a>
              
                
                <a class="source" href="core.html">
                  core.js
                </a>
              
                
                <a class="source" href="datepicker.html">
                  datepicker.js
                </a>
              
                
                <a class="source" href="dialog.html">
                  dialog.js
                </a>
              
                
                <a class="source" href="draggable.html">
                  draggable.js
                </a>
              
                
                <a class="source" href="droppable.html">
                  droppable.js
                </a>
              
                
                <a class="source" href="effect-blind.html">
                  effect-blind.js
                </a>
              
                
                <a class="source" href="effect-bounce.html">
                  effect-bounce.js
                </a>
              
                
                <a class="source" href="effect-clip.html">
                  effect-clip.js
                </a>
              
                
                <a class="source" href="effect-drop.html">
                  effect-drop.js
                </a>
              
                
                <a class="source" href="effect-explode.html">
                  effect-explode.js
                </a>
              
                
                <a class="source" href="effect-fade.html">
                  effect-fade.js
                </a>
              
                
                <a class="source" href="effect-fold.html">
                  effect-fold.js
                </a>
              
                
                <a class="source" href="effect-highlight.html">
                  effect-highlight.js
                </a>
              
                
                <a class="source" href="effect-puff.html">
                  effect-puff.js
                </a>
              
                
                <a class="source" href="effect-pulsate.html">
                  effect-pulsate.js
                </a>
              
                
                <a class="source" href="effect-scale.html">
                  effect-scale.js
                </a>
              
                
                <a class="source" href="effect-shake.html">
                  effect-shake.js
                </a>
              
                
                <a class="source" href="effect-size.html">
                  effect-size.js
                </a>
              
                
                <a class="source" href="effect-slide.html">
                  effect-slide.js
                </a>
              
                
                <a class="source" href="effect-transfer.html">
                  effect-transfer.js
                </a>
              
                
                <a class="source" href="effect.html">
                  effect.js
                </a>
              
                
                <a class="source" href="menu.html">
                  menu.js
                </a>
              
                
                <a class="source" href="mouse.html">
                  mouse.js
                </a>
              
                
                <a class="source" href="position.html">
                  position.js
                </a>
              
                
                <a class="source" href="progressbar.html">
                  progressbar.js
                </a>
              
                
                <a class="source" href="resizable.html">
                  resizable.js
                </a>
              
                
                <a class="source" href="selectable.html">
                  selectable.js
                </a>
              
                
                <a class="source" href="selectmenu.html">
                  selectmenu.js
                </a>
              
                
                <a class="source" href="slider.html">
                  slider.js
                </a>
              
                
                <a class="source" href="sortable.html">
                  sortable.js
                </a>
              
                
                <a class="source" href="spinner.html">
                  spinner.js
                </a>
              
                
                <a class="source" href="tabs.html">
                  tabs.js
                </a>
              
                
                <a class="source" href="tooltip.html">
                  tooltip.js
                </a>
              
                
                <a class="source" href="widget.html">
                  widget.js
                </a>
              
                
                <a class="source" href="json2.html">
                  json2.js
                </a>
              
                
                <a class="source" href="masonry.min.html">
                  masonry.min.js
                </a>
              
                
                <a class="source" href="mce-view.html">
                  mce-view.js
                </a>
              
                
                <a class="source" href="media-audiovideo.html">
                  media-audiovideo.js
                </a>
              
                
                <a class="source" href="media-editor.html">
                  media-editor.js
                </a>
              
                
                <a class="source" href="media-grid.html">
                  media-grid.js
                </a>
              
                
                <a class="source" href="media-models.html">
                  media-models.js
                </a>
              
                
                <a class="source" href="media-views.html">
                  media-views.js
                </a>
              
                
                <a class="source" href="audiovideo.manifest.html">
                  audiovideo.manifest.js
                </a>
              
                
                <a class="source" href="audio-details.html">
                  audio-details.js
                </a>
              
                
                <a class="source" href="collection-add.html">
                  collection-add.js
                </a>
              
                
                <a class="source" href="collection-edit.html">
                  collection-edit.js
                </a>
              
                
                <a class="source" href="cropper.html">
                  cropper.js
                </a>
              
                
                <a class="source" href="customize-image-cropper.html">
                  customize-image-cropper.js
                </a>
              
                
                <a class="source" href="edit-attachment-metadata.html">
                  edit-attachment-metadata.js
                </a>
              
                
                <a class="source" href="edit-image.html">
                  edit-image.js
                </a>
              
                
                <a class="source" href="embed.html">
                  embed.js
                </a>
              
                
                <a class="source" href="featured-image.html">
                  featured-image.js
                </a>
              
                
                <a class="source" href="gallery-add.html">
                  gallery-add.js
                </a>
              
                
                <a class="source" href="gallery-edit.html">
                  gallery-edit.js
                </a>
              
                
                <a class="source" href="image-details.html">
                  image-details.js
                </a>
              
                
                <a class="source" href="library.html">
                  library.js
                </a>
              
                
                <a class="source" href="media-library.html">
                  media-library.js
                </a>
              
                
                <a class="source" href="region.html">
                  region.js
                </a>
              
                
                <a class="source" href="replace-image.html">
                  replace-image.js
                </a>
              
                
                <a class="source" href="site-icon-cropper.html">
                  site-icon-cropper.js
                </a>
              
                
                <a class="source" href="state-machine.html">
                  state-machine.js
                </a>
              
                
                <a class="source" href="state.html">
                  state.js
                </a>
              
                
                <a class="source" href="video-details.html">
                  video-details.js
                </a>
              
                
                <a class="source" href="grid.manifest.html">
                  grid.manifest.js
                </a>
              
                
                <a class="source" href="models.manifest.html">
                  models.manifest.js
                </a>
              
                
                <a class="source" href="attachment.html">
                  attachment.js
                </a>
              
                
                <a class="source" href="attachments.html">
                  attachments.js
                </a>
              
                
                <a class="source" href="post-image.html">
                  post-image.js
                </a>
              
                
                <a class="source" href="post-media.html">
                  post-media.js
                </a>
              
                
                <a class="source" href="query.html">
                  query.js
                </a>
              
                
                <a class="source" href="selection.html">
                  selection.js
                </a>
              
                
                <a class="source" href="manage.html">
                  manage.js
                </a>
              
                
                <a class="source" href="selection-sync.html">
                  selection-sync.js
                </a>
              
                
                <a class="source" href="views.manifest.html">
                  views.manifest.js
                </a>
              
                
                <a class="source" href="attachment-compat.html">
                  attachment-compat.js
                </a>
              
                
                <a class="source" href="attachment-filters.html">
                  attachment-filters.js
                </a>
              
                
                <a class="source" href="all.html">
                  all.js
                </a>
              
                
                <a class="source" href="date.html">
                  date.js
                </a>
              
                
                <a class="source" href="uploaded.html">
                  uploaded.js
                </a>
              
                
                <a class="source" href="attachment.html">
                  attachment.js
                </a>
              
                
                <a class="source" href="details-two-column.html">
                  details-two-column.js
                </a>
              
                
                <a class="source" href="details.html">
                  details.js
                </a>
              
                
                <a class="source" href="edit-library.html">
                  edit-library.js
                </a>
              
                
                <a class="source" href="edit-selection.html">
                  edit-selection.js
                </a>
              
                
                <a class="source" href="library.html">
                  library.js
                </a>
              
                
                <a class="source" href="selection.html">
                  selection.js
                </a>
              
                
                <a class="source" href="attachments.html">
                  attachments.js
                </a>
              
                
                <a class="source" href="browser.html">
                  browser.js
                </a>
              
                
                <a class="source" href="selection.html">
                  selection.js
                </a>
              
                
                <a class="source" href="audio-details.html">
                  audio-details.js
                </a>
              
                
                <a class="source" href="button-group.html">
                  button-group.js
                </a>
              
                
                <a class="source" href="button.html">
                  button.js
                </a>
              
                
                <a class="source" href="delete-selected-permanently.html">
                  delete-selected-permanently.js
                </a>
              
                
                <a class="source" href="delete-selected.html">
                  delete-selected.js
                </a>
              
                
                <a class="source" href="select-mode-toggle.html">
                  select-mode-toggle.js
                </a>
              
                
                <a class="source" href="cropper.html">
                  cropper.js
                </a>
              
                
                <a class="source" href="edit-image-details.html">
                  edit-image-details.js
                </a>
              
                
                <a class="source" href="edit-image.html">
                  edit-image.js
                </a>
              
                
                <a class="source" href="embed.html">
                  embed.js
                </a>
              
                
                <a class="source" href="image.html">
                  image.js
                </a>
              
                
                <a class="source" href="link.html">
                  link.js
                </a>
              
                
                <a class="source" href="url.html">
                  url.js
                </a>
              
                
                <a class="source" href="focus-manager.html">
                  focus-manager.js
                </a>
              
                
                <a class="source" href="frame.html">
                  frame.js
                </a>
              
                
                <a class="source" href="audio-details.html">
                  audio-details.js
                </a>
              
                
                <a class="source" href="edit-attachments.html">
                  edit-attachments.js
                </a>
              
                
                <a class="source" href="image-details.html">
                  image-details.js
                </a>
              
                
                <a class="source" href="manage.html">
                  manage.js
                </a>
              
                
                <a class="source" href="media-details.html">
                  media-details.js
                </a>
              
                
                <a class="source" href="post.html">
                  post.js
                </a>
              
                
                <a class="source" href="select.html">
                  select.js
                </a>
              
                
                <a class="source" href="video-details.html">
                  video-details.js
                </a>
              
                
                <a class="source" href="iframe.html">
                  iframe.js
                </a>
              
                
                <a class="source" href="image-details.html">
                  image-details.js
                </a>
              
                
                <a class="source" href="label.html">
                  label.js
                </a>
              
                
                <a class="source" href="media-details.html">
                  media-details.js
                </a>
              
                
                <a class="source" href="media-frame.html">
                  media-frame.js
                </a>
              
                
                <a class="source" href="menu-item.html">
                  menu-item.js
                </a>
              
                
                <a class="source" href="menu.html">
                  menu.js
                </a>
              
                
                <a class="source" href="modal.html">
                  modal.js
                </a>
              
                
                <a class="source" href="priority-list.html">
                  priority-list.js
                </a>
              
                
                <a class="source" href="router-item.html">
                  router-item.js
                </a>
              
                
                <a class="source" href="router.html">
                  router.js
                </a>
              
                
                <a class="source" href="search.html">
                  search.js
                </a>
              
                
                <a class="source" href="selection.html">
                  selection.js
                </a>
              
                
                <a class="source" href="settings.html">
                  settings.js
                </a>
              
                
                <a class="source" href="attachment-display.html">
                  attachment-display.js
                </a>
              
                
                <a class="source" href="gallery.html">
                  gallery.js
                </a>
              
                
                <a class="source" href="playlist.html">
                  playlist.js
                </a>
              
                
                <a class="source" href="sidebar.html">
                  sidebar.js
                </a>
              
                
                <a class="source" href="site-icon-cropper.html">
                  site-icon-cropper.js
                </a>
              
                
                <a class="source" href="site-icon-preview.html">
                  site-icon-preview.js
                </a>
              
                
                <a class="source" href="spinner.html">
                  spinner.js
                </a>
              
                
                <a class="source" href="toolbar.html">
                  toolbar.js
                </a>
              
                
                <a class="source" href="embed.html">
                  embed.js
                </a>
              
                
                <a class="source" href="select.html">
                  select.js
                </a>
              
                
                <a class="source" href="editor.html">
                  editor.js
                </a>
              
                
                <a class="source" href="inline.html">
                  inline.js
                </a>
              
                
                <a class="source" href="status-error.html">
                  status-error.js
                </a>
              
                
                <a class="source" href="status.html">
                  status.js
                </a>
              
                
                <a class="source" href="window.html">
                  window.js
                </a>
              
                
                <a class="source" href="video-details.html">
                  video-details.js
                </a>
              
                
                <a class="source" href="view.html">
                  view.js
                </a>
              
                
                <a class="source" href="froogaloop.min.html">
                  froogaloop.min.js
                </a>
              
                
                <a class="source" href="mediaelement-and-player.min.html">
                  mediaelement-and-player.min.js
                </a>
              
                
                <a class="source" href="wp-mediaelement.html">
                  wp-mediaelement.js
                </a>
              
                
                <a class="source" href="wp-playlist.html">
                  wp-playlist.js
                </a>
              
                
                <a class="source" href="handlers.html">
                  handlers.js
                </a>
              
                
                <a class="source" href="plupload.full.min.html">
                  plupload.full.min.js
                </a>
              
                
                <a class="source" href="wp-plupload.html">
                  wp-plupload.js
                </a>
              
                
                <a class="source" href="quicktags.html">
                  quicktags.js
                </a>
              
                
                <a class="source" href="shortcode.html">
                  shortcode.js
                </a>
              
                
                <a class="source" href="swfobject.html">
                  swfobject.js
                </a>
              
                
                <a class="source" href="handlers.html">
                  handlers.js
                </a>
              
                
                <a class="source" href="handlers.min.html">
                  handlers.min.js
                </a>
              
                
                <a class="source" href="swfupload.cookies.html">
                  swfupload.cookies.js
                </a>
              
                
                <a class="source" href="swfupload.queue.html">
                  swfupload.queue.js
                </a>
              
                
                <a class="source" href="swfupload.speed.html">
                  swfupload.speed.js
                </a>
              
                
                <a class="source" href="swfupload.swfobject.html">
                  swfupload.swfobject.js
                </a>
              
                
                <a class="source" href="swfupload.html">
                  swfupload.js
                </a>
              
                
                <a class="source" href="thickbox.html">
                  thickbox.js
                </a>
              
                
                <a class="source" href="wp-langs-en.html">
                  wp-langs-en.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.min.html">
                  plugin.min.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.min.html">
                  plugin.min.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.min.html">
                  plugin.min.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.min.html">
                  plugin.min.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.min.html">
                  plugin.min.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.min.html">
                  plugin.min.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.min.html">
                  plugin.min.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.min.html">
                  plugin.min.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.min.html">
                  plugin.min.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.min.html">
                  plugin.min.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.min.html">
                  plugin.min.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.min.html">
                  plugin.min.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="plugin.html">
                  plugin.js
                </a>
              
                
                <a class="source" href="theme.html">
                  theme.js
                </a>
              
                
                <a class="source" href="theme.min.html">
                  theme.min.js
                </a>
              
                
                <a class="source" href="theme.html">
                  theme.js
                </a>
              
                
                <a class="source" href="theme.min.html">
                  theme.min.js
                </a>
              
                
                <a class="source" href="tiny_mce_popup.html">
                  tiny_mce_popup.js
                </a>
              
                
                <a class="source" href="tinymce.html">
                  tinymce.js
                </a>
              
                
                <a class="source" href="tinymce.min.html">
                  tinymce.min.js
                </a>
              
                
                <a class="source" href="editable_selects.html">
                  editable_selects.js
                </a>
              
                
                <a class="source" href="form_utils.html">
                  form_utils.js
                </a>
              
                
                <a class="source" href="mctabs.html">
                  mctabs.js
                </a>
              
                
                <a class="source" href="validate.html">
                  validate.js
                </a>
              
                
                <a class="source" href="tw-sack.html">
                  tw-sack.js
                </a>
              
                
                <a class="source" href="twemoji.html">
                  twemoji.js
                </a>
              
                
                <a class="source" href="underscore.html">
                  underscore.js
                </a>
              
                
                <a class="source" href="underscore.min.html">
                  underscore.min.js
                </a>
              
                
                <a class="source" href="utils.html">
                  utils.js
                </a>
              
                
                <a class="source" href="wp-a11y.html">
                  wp-a11y.js
                </a>
              
                
                <a class="source" href="wp-ajax-response.html">
                  wp-ajax-response.js
                </a>
              
                
                <a class="source" href="wp-api.html">
                  wp-api.js
                </a>
              
                
                <a class="source" href="wp-auth-check.html">
                  wp-auth-check.js
                </a>
              
                
                <a class="source" href="wp-backbone.html">
                  wp-backbone.js
                </a>
              
                
                <a class="source" href="wp-custom-header.html">
                  wp-custom-header.js
                </a>
              
                
                <a class="source" href="wp-embed-template.html">
                  wp-embed-template.js
                </a>
              
                
                <a class="source" href="wp-embed.html">
                  wp-embed.js
                </a>
              
                
                <a class="source" href="wp-emoji-loader.html">
                  wp-emoji-loader.js
                </a>
              
                
                <a class="source" href="wp-emoji.html">
                  wp-emoji.js
                </a>
              
                
                <a class="source" href="wp-list-revisions.html">
                  wp-list-revisions.js
                </a>
              
                
                <a class="source" href="wp-lists.html">
                  wp-lists.js
                </a>
              
                
                <a class="source" href="wp-pointer.html">
                  wp-pointer.js
                </a>
              
                
                <a class="source" href="wp-util.html">
                  wp-util.js
                </a>
              
                
                <a class="source" href="wpdialog.html">
                  wpdialog.js
                </a>
              
                
                <a class="source" href="wplink.html">
                  wplink.js
                </a>
              
                
                <a class="source" href="zxcvbn-async.html">
                  zxcvbn-async.js
                </a>
              
                
                <a class="source" href="zxcvbn.min.html">
                  zxcvbn.min.js
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>tinymce.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>4.6.1 (2017-05-10)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

<span class="hljs-keyword">var</span> defs = {}; <span class="hljs-comment">// id -&gt; {dependencies, definition, instance (possibly undefined)}</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Used when there is no main module.
The name is probably (hopefully) unique so minification removes for releases.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> register_3795 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
  <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = dem(id);
  <span class="hljs-keyword">var</span> fragments = id.split(<span class="hljs-string">'.'</span>);
  <span class="hljs-keyword">var</span> target = <span class="hljs-built_in">Function</span>(<span class="hljs-string">'return this;'</span>)();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; fragments.length - <span class="hljs-number">1</span>; ++i) {
    <span class="hljs-keyword">if</span> (target[fragments[i]] === <span class="hljs-literal">undefined</span>)
      target[fragments[i]] = {};
    target = target[fragments[i]];
  }
  target[fragments[fragments.length - <span class="hljs-number">1</span>]] = <span class="hljs-built_in">module</span>;
};

<span class="hljs-keyword">var</span> instantiate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
  <span class="hljs-keyword">var</span> actual = defs[id];
  <span class="hljs-keyword">var</span> dependencies = actual.deps;
  <span class="hljs-keyword">var</span> definition = actual.defn;
  <span class="hljs-keyword">var</span> len = dependencies.length;
  <span class="hljs-keyword">var</span> instances = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)
    instances[i] = dem(dependencies[i]);
  <span class="hljs-keyword">var</span> defResult = definition.apply(<span class="hljs-literal">null</span>, instances);
  <span class="hljs-keyword">if</span> (defResult === <span class="hljs-literal">undefined</span>)
     <span class="hljs-keyword">throw</span> <span class="hljs-string">'module ['</span> + id + <span class="hljs-string">'] returned undefined'</span>;
  actual.instance = defResult;
};

<span class="hljs-keyword">var</span> def = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, dependencies, definition</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> id !== <span class="hljs-string">'string'</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-string">'module id must be a string'</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dependencies === <span class="hljs-literal">undefined</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-string">'no dependencies for '</span> + id;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (definition === <span class="hljs-literal">undefined</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-string">'no definition function for '</span> + id;
  defs[id] = {
    <span class="hljs-attr">deps</span>: dependencies,
    <span class="hljs-attr">defn</span>: definition,
    <span class="hljs-attr">instance</span>: <span class="hljs-literal">undefined</span>
  };
};

<span class="hljs-keyword">var</span> dem = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
  <span class="hljs-keyword">var</span> actual = defs[id];
  <span class="hljs-keyword">if</span> (actual === <span class="hljs-literal">undefined</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-string">'module ['</span> + id + <span class="hljs-string">'] was undefined'</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (actual.instance === <span class="hljs-literal">undefined</span>)
    instantiate(id);
  <span class="hljs-keyword">return</span> actual.instance;
};

<span class="hljs-keyword">var</span> req = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ids, callback</span>) </span>{
  <span class="hljs-keyword">var</span> len = ids.length;
  <span class="hljs-keyword">var</span> instances = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)
    instances.push(dem(ids[i]));
  callback.apply(<span class="hljs-literal">null</span>, callback);
};

<span class="hljs-keyword">var</span> ephox = {};

ephox.bolt = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">api</span>: {
      <span class="hljs-attr">define</span>: def,
      <span class="hljs-attr">require</span>: req,
      <span class="hljs-attr">demand</span>: dem
    }
  }
};

<span class="hljs-keyword">var</span> define = def;
<span class="hljs-keyword">var</span> <span class="hljs-built_in">require</span> = req;
<span class="hljs-keyword">var</span> demand = dem;</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>this helps with minificiation when using a lot of global references</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> defineGlobal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, ref</span>) </span>{
  define(id, [], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> ref; });
};
<span class="hljs-comment">/*jsc
["tinymce.core.api.Main","tinymce.core.api.Tinymce","tinymce.core.Register","tinymce.core.geom.Rect","tinymce.core.util.Promise","tinymce.core.util.Delay","tinymce.core.Env","tinymce.core.dom.EventUtils","tinymce.core.dom.Sizzle","tinymce.core.util.Tools","tinymce.core.dom.DomQuery","tinymce.core.html.Styles","tinymce.core.dom.TreeWalker","tinymce.core.html.Entities","tinymce.core.dom.DOMUtils","tinymce.core.dom.ScriptLoader","tinymce.core.AddOnManager","tinymce.core.dom.RangeUtils","tinymce.core.html.Node","tinymce.core.html.Schema","tinymce.core.html.SaxParser","tinymce.core.html.DomParser","tinymce.core.html.Writer","tinymce.core.html.Serializer","tinymce.core.dom.Serializer","tinymce.core.util.VK","tinymce.core.dom.ControlSelection","tinymce.core.dom.BookmarkManager","tinymce.core.dom.Selection","tinymce.core.Formatter","tinymce.core.UndoManager","tinymce.core.EditorCommands","tinymce.core.util.URI","tinymce.core.util.Class","tinymce.core.util.EventDispatcher","tinymce.core.util.Observable","tinymce.core.WindowManager","tinymce.core.NotificationManager","tinymce.core.EditorObservable","tinymce.core.Shortcuts","tinymce.core.Editor","tinymce.core.util.I18n","tinymce.core.FocusManager","tinymce.core.EditorManager","tinymce.core.util.XHR","tinymce.core.util.JSON","tinymce.core.util.JSONRequest","tinymce.core.util.JSONP","tinymce.core.util.LocalStorage","tinymce.core.api.Compat","tinymce.core.util.Color","tinymce.core.ui.Api","tinymce.core.util.Arr","tinymce.core.dom.Range","tinymce.core.dom.StyleSheetLoader","tinymce.core.dom.NodeType","tinymce.core.caret.CaretContainer","tinymce.core.text.Zwsp","tinymce.core.caret.CaretBookmark","tinymce.core.caret.CaretPosition","tinymce.core.dom.ScrollIntoView","tinymce.core.dom.TridentSelection","tinymce.core.dom.ElementUtils","tinymce.core.util.Fun","tinymce.core.fmt.Preview","tinymce.core.fmt.Hooks","tinymce.core.undo.Levels","tinymce.core.delete.DeleteCommands","tinymce.core.InsertContent","global!document","tinymce.core.ui.Window","tinymce.core.ui.MessageBox","tinymce.core.ui.Notification","tinymce.core.init.Render","tinymce.core.Mode","tinymce.core.ui.Sidebar","tinymce.core.util.Uuid","tinymce.core.ErrorReporter","tinymce.core.LegacyInput","tinymce.core.ui.Selector","tinymce.core.ui.Collection","tinymce.core.ui.ReflowQueue","tinymce.core.ui.Control","tinymce.core.ui.Factory","tinymce.core.ui.KeyboardNavigation","tinymce.core.ui.Container","tinymce.core.ui.DragHelper","tinymce.core.ui.Scrollable","tinymce.core.ui.Panel","tinymce.core.ui.Movable","tinymce.core.ui.Resizable","tinymce.core.ui.FloatPanel","tinymce.core.ui.Tooltip","tinymce.core.ui.Widget","tinymce.core.ui.Progress","tinymce.core.ui.Layout","tinymce.core.ui.AbsoluteLayout","tinymce.core.ui.Button","tinymce.core.ui.ButtonGroup","tinymce.core.ui.Checkbox","tinymce.core.ui.ComboBox","tinymce.core.ui.ColorBox","tinymce.core.ui.PanelButton","tinymce.core.ui.ColorButton","tinymce.core.ui.ColorPicker","tinymce.core.ui.Path","tinymce.core.ui.ElementPath","tinymce.core.ui.FormItem","tinymce.core.ui.Form","tinymce.core.ui.FieldSet","tinymce.core.ui.FilePicker","tinymce.core.ui.FitLayout","tinymce.core.ui.FlexLayout","tinymce.core.ui.FlowLayout","tinymce.core.ui.FormatControls","tinymce.core.ui.GridLayout","tinymce.core.ui.Iframe","tinymce.core.ui.InfoBox","tinymce.core.ui.Label","tinymce.core.ui.Toolbar","tinymce.core.ui.MenuBar","tinymce.core.ui.MenuButton","tinymce.core.ui.MenuItem","tinymce.core.ui.Throbber","tinymce.core.ui.Menu","tinymce.core.ui.ListBox","tinymce.core.ui.Radio","tinymce.core.ui.ResizeHandle","tinymce.core.ui.SelectBox","tinymce.core.ui.Slider","tinymce.core.ui.Spacer","tinymce.core.ui.SplitButton","tinymce.core.ui.StackLayout","tinymce.core.ui.TabPanel","tinymce.core.ui.TextBox","ephox.katamari.api.Arr","ephox.katamari.api.Fun","ephox.katamari.api.Future","ephox.katamari.api.Futures","ephox.katamari.api.Result","tinymce.core.caret.CaretCandidate","tinymce.core.geom.ClientRect","tinymce.core.text.ExtendingChar","tinymce.core.undo.Fragments","tinymce.core.delete.BlockBoundaryDelete","tinymce.core.delete.BlockRangeDelete","tinymce.core.delete.CefDelete","tinymce.core.delete.InlineBoundaryDelete","tinymce.core.caret.CaretWalker","tinymce.core.dom.RangeNormalizer","tinymce.core.InsertList","tinymce.core.data.ObservableObject","tinymce.core.ui.DomUtils","tinymce.core.ui.BoxUtils","tinymce.core.ui.ClassList","global!window","tinymce.core.init.Init","tinymce.core.PluginManager","tinymce.core.ThemeManager","tinymce.core.content.LinkTargets","tinymce.core.fmt.FontInfo","ephox.katamari.api.Option","global!Array","global!Error","global!String","ephox.katamari.api.LazyValue","ephox.katamari.async.Bounce","ephox.katamari.async.AsyncValues","tinymce.core.undo.Diff","tinymce.core.delete.BlockBoundary","tinymce.core.delete.MergeBlocks","ephox.katamari.api.Options","ephox.sugar.api.dom.Compare","ephox.sugar.api.node.Element","tinymce.core.delete.DeleteUtils","tinymce.core.caret.CaretUtils","tinymce.core.delete.CefDeleteAction","tinymce.core.delete.DeleteElement","tinymce.core.keyboard.BoundaryCaret","tinymce.core.keyboard.BoundaryLocation","tinymce.core.keyboard.BoundarySelection","tinymce.core.keyboard.InlineUtils","tinymce.core.caret.CaretFinder","tinymce.core.data.Binding","tinymce.core.init.InitContentBody","global!Object","global!setTimeout","ephox.katamari.api.Struct","ephox.sand.api.Node","ephox.sand.api.PlatformDetection","ephox.sugar.api.search.Selectors","global!console","ephox.sugar.api.node.Node","ephox.sugar.api.search.PredicateFind","ephox.sugar.api.search.Traverse","tinymce.core.dom.Empty","ephox.sugar.api.dom.Insert","ephox.sugar.api.dom.Remove","ephox.katamari.api.Adt","tinymce.core.text.Bidi","tinymce.core.caret.CaretContainerInline","tinymce.core.caret.CaretContainerRemove","tinymce.core.util.LazyEvaluator","ephox.katamari.api.Cell","tinymce.core.caret.CaretContainerInput","tinymce.core.EditorUpload","tinymce.core.ForceBlocks","tinymce.core.keyboard.KeyboardOverrides","tinymce.core.NodeChange","tinymce.core.SelectionOverrides","tinymce.core.util.Quirks","ephox.katamari.data.Immutable","ephox.katamari.data.MixedBag","ephox.sand.util.Global","ephox.katamari.api.Thunk","ephox.sand.core.PlatformDetection","global!navigator","ephox.sugar.api.node.NodeTypes","ephox.katamari.api.Type","ephox.sugar.api.node.Body","ephox.sugar.impl.ClosestOrAncestor","ephox.sugar.alien.Recurse","ephox.sugar.api.search.SelectorExists","ephox.sugar.api.dom.InsertAll","ephox.katamari.api.Obj","tinymce.core.file.Uploader","tinymce.core.file.ImageScanner","tinymce.core.file.BlobCache","tinymce.core.file.UploadStatus","tinymce.core.keyboard.ArrowKeys","tinymce.core.keyboard.DeleteBackspaceKeys","tinymce.core.keyboard.EnterKey","tinymce.core.keyboard.SpaceKey","tinymce.core.caret.FakeCaret","tinymce.core.caret.LineWalker","tinymce.core.caret.LineUtils","tinymce.core.DragDropOverrides","tinymce.core.dom.NodePath","ephox.katamari.util.BagUtils","ephox.katamari.api.Resolve","ephox.sand.core.Browser","ephox.sand.core.OperatingSystem","ephox.sand.detect.DeviceType","ephox.sand.detect.UaString","ephox.sand.info.PlatformInfo","ephox.sugar.api.search.SelectorFind","tinymce.core.file.Conversions","global!URL","tinymce.core.keyboard.MatchKeys","tinymce.core.keyboard.InsertSpace","tinymce.core.dom.Dimensions","tinymce.core.dom.MousePosition","ephox.katamari.api.Global","ephox.sand.detect.Version","ephox.katamari.api.Strings","ephox.katamari.api.Merger","global!Number","ephox.katamari.str.StrAppend","ephox.katamari.str.StringParts"]
jsc*/</span>
<span class="hljs-comment">/**
 * Rect.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Contains various tools for rect/position calculation.
 *
 * @class tinymce.geom.Rect
 */</span>
define(
  <span class="hljs-string">'tinymce.core.geom.Rect'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> min = <span class="hljs-built_in">Math</span>.min, max = <span class="hljs-built_in">Math</span>.max, round = <span class="hljs-built_in">Math</span>.round;

    <span class="hljs-comment">/**
     * Returns the rect positioned based on the relative position name
     * to the target rect.
     *
     * @method relativePosition
     * @param {Rect} rect Source rect to modify into a new rect.
     * @param {Rect} targetRect Rect to move relative to based on the rel option.
     * @param {String} rel Relative position. For example: tr-bl.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">relativePosition</span>(<span class="hljs-params">rect, targetRect, rel</span>) </span>{
      <span class="hljs-keyword">var</span> x, y, w, h, targetW, targetH;

      x = targetRect.x;
      y = targetRect.y;
      w = rect.w;
      h = rect.h;
      targetW = targetRect.w;
      targetH = targetRect.h;

      rel = (rel || <span class="hljs-string">''</span>).split(<span class="hljs-string">''</span>);

      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">0</span>] === <span class="hljs-string">'b'</span>) {
        y += targetH;
      }

      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">1</span>] === <span class="hljs-string">'r'</span>) {
        x += targetW;
      }

      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">0</span>] === <span class="hljs-string">'c'</span>) {
        y += round(targetH / <span class="hljs-number">2</span>);
      }

      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">1</span>] === <span class="hljs-string">'c'</span>) {
        x += round(targetW / <span class="hljs-number">2</span>);
      }

      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">3</span>] === <span class="hljs-string">'b'</span>) {
        y -= h;
      }

      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">4</span>] === <span class="hljs-string">'r'</span>) {
        x -= w;
      }

      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">3</span>] === <span class="hljs-string">'c'</span>) {
        y -= round(h / <span class="hljs-number">2</span>);
      }

      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">4</span>] === <span class="hljs-string">'c'</span>) {
        x -= round(w / <span class="hljs-number">2</span>);
      }

      <span class="hljs-keyword">return</span> create(x, y, w, h);
    }

    <span class="hljs-comment">/**
     * Tests various positions to get the most suitable one.
     *
     * @method findBestRelativePosition
     * @param {Rect} rect Rect to use as source.
     * @param {Rect} targetRect Rect to move relative to.
     * @param {Rect} constrainRect Rect to constrain within.
     * @param {Array} rels Array of relative positions to test against.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findBestRelativePosition</span>(<span class="hljs-params">rect, targetRect, constrainRect, rels</span>) </span>{
      <span class="hljs-keyword">var</span> pos, i;

      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; rels.length; i++) {
        pos = relativePosition(rect, targetRect, rels[i]);

        <span class="hljs-keyword">if</span> (pos.x &gt;= constrainRect.x &amp;&amp; pos.x + pos.w &lt;= constrainRect.w + constrainRect.x &amp;&amp;
          pos.y &gt;= constrainRect.y &amp;&amp; pos.y + pos.h &lt;= constrainRect.h + constrainRect.y) {
          <span class="hljs-keyword">return</span> rels[i];
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-comment">/**
     * Inflates the rect in all directions.
     *
     * @method inflate
     * @param {Rect} rect Rect to expand.
     * @param {Number} w Relative width to expand by.
     * @param {Number} h Relative height to expand by.
     * @return {Rect} New expanded rect.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inflate</span>(<span class="hljs-params">rect, w, h</span>) </span>{
      <span class="hljs-keyword">return</span> create(rect.x - w, rect.y - h, rect.w + w * <span class="hljs-number">2</span>, rect.h + h * <span class="hljs-number">2</span>);
    }

    <span class="hljs-comment">/**
     * Returns the intersection of the specified rectangles.
     *
     * @method intersect
     * @param {Rect} rect The first rectangle to compare.
     * @param {Rect} cropRect The second rectangle to compare.
     * @return {Rect} The intersection of the two rectangles or null if they don't intersect.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersect</span>(<span class="hljs-params">rect, cropRect</span>) </span>{
      <span class="hljs-keyword">var</span> x1, y1, x2, y2;

      x1 = max(rect.x, cropRect.x);
      y1 = max(rect.y, cropRect.y);
      x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
      y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);

      <span class="hljs-keyword">if</span> (x2 - x1 &lt; <span class="hljs-number">0</span> || y2 - y1 &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">return</span> create(x1, y1, x2 - x1, y2 - y1);
    }

    <span class="hljs-comment">/**
     * Returns a rect clamped within the specified clamp rect. This forces the
     * rect to be inside the clamp rect.
     *
     * @method clamp
     * @param {Rect} rect Rectangle to force within clamp rect.
     * @param {Rect} clampRect Rectable to force within.
     * @param {Boolean} fixedSize True/false if size should be fixed.
     * @return {Rect} Clamped rect.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clamp</span>(<span class="hljs-params">rect, clampRect, fixedSize</span>) </span>{
      <span class="hljs-keyword">var</span> underflowX1, underflowY1, overflowX2, overflowY2,
        x1, y1, x2, y2, cx2, cy2;

      x1 = rect.x;
      y1 = rect.y;
      x2 = rect.x + rect.w;
      y2 = rect.y + rect.h;
      cx2 = clampRect.x + clampRect.w;
      cy2 = clampRect.y + clampRect.h;

      underflowX1 = max(<span class="hljs-number">0</span>, clampRect.x - x1);
      underflowY1 = max(<span class="hljs-number">0</span>, clampRect.y - y1);
      overflowX2 = max(<span class="hljs-number">0</span>, x2 - cx2);
      overflowY2 = max(<span class="hljs-number">0</span>, y2 - cy2);

      x1 += underflowX1;
      y1 += underflowY1;

      <span class="hljs-keyword">if</span> (fixedSize) {
        x2 += underflowX1;
        y2 += underflowY1;
        x1 -= overflowX2;
        y1 -= overflowY2;
      }

      x2 -= overflowX2;
      y2 -= overflowY2;

      <span class="hljs-keyword">return</span> create(x1, y1, x2 - x1, y2 - y1);
    }

    <span class="hljs-comment">/**
     * Creates a new rectangle object.
     *
     * @method create
     * @param {Number} x Rectangle x location.
     * @param {Number} y Rectangle y location.
     * @param {Number} w Rectangle width.
     * @param {Number} h Rectangle height.
     * @return {Rect} New rectangle object.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">x, y, w, h</span>) </span>{
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y, <span class="hljs-attr">w</span>: w, <span class="hljs-attr">h</span>: h };
    }

    <span class="hljs-comment">/**
     * Creates a new rectangle object form a clientRects object.
     *
     * @method fromClientRect
     * @param {ClientRect} clientRect DOM ClientRect object.
     * @return {Rect} New rectangle object.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromClientRect</span>(<span class="hljs-params">clientRect</span>) </span>{
      <span class="hljs-keyword">return</span> create(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">inflate</span>: inflate,
      <span class="hljs-attr">relativePosition</span>: relativePosition,
      <span class="hljs-attr">findBestRelativePosition</span>: findBestRelativePosition,
      <span class="hljs-attr">intersect</span>: intersect,
      <span class="hljs-attr">clamp</span>: clamp,
      <span class="hljs-attr">create</span>: create,
      <span class="hljs-attr">fromClientRect</span>: fromClientRect
    };
  }
);

<span class="hljs-comment">/**
 * Promise.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * Promise polyfill under MIT license: https://github.com/taylorhakes/promise-polyfill
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/* eslint-disable */</span>
<span class="hljs-comment">/* jshint ignore:start */</span>

<span class="hljs-comment">/**
 * Modifed to be a feature fill and wrapped as tinymce module.
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.Promise'</span>,
  [],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.Promise) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.Promise;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Use polyfill for setImmediate for performance gains</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> asap = <span class="hljs-built_in">Promise</span>.immediateFn || (<span class="hljs-keyword">typeof</span> setImmediate === <span class="hljs-string">'function'</span> &amp;&amp; setImmediate) ||
      <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>{ setTimeout(fn, <span class="hljs-number">1</span>); };</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Polyfill for Function.prototype.bind</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">fn, thisArg</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        fn.apply(thisArg, <span class="hljs-built_in">arguments</span>);
      };
    }

    <span class="hljs-keyword">var</span> isArray = <span class="hljs-built_in">Array</span>.isArray || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(value) === <span class="hljs-string">"[object Array]"</span>; };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">fn</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">'object'</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Promises must be constructed via new'</span>);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'not a function'</span>);
      <span class="hljs-keyword">this</span>._state = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>._value = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>._deferreds = [];

      doResolve(fn, bind(resolve, <span class="hljs-keyword">this</span>), bind(reject, <span class="hljs-keyword">this</span>));
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span>(<span class="hljs-params">deferred</span>) </span>{
      <span class="hljs-keyword">var</span> me = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._state === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">this</span>._deferreds.push(deferred);
        <span class="hljs-keyword">return</span>;
      }
      asap(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> cb = me._state ? deferred.onFulfilled : deferred.onRejected;
        <span class="hljs-keyword">if</span> (cb === <span class="hljs-literal">null</span>) {
          (me._state ? deferred.resolve : deferred.reject)(me._value);
          <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">var</span> ret;
        <span class="hljs-keyword">try</span> {
          ret = cb(me._value);
        }
        <span class="hljs-keyword">catch</span> (e) {
          deferred.reject(e);
          <span class="hljs-keyword">return</span>;
        }
        deferred.resolve(ret);
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">newValue</span>) </span>{
      <span class="hljs-keyword">try</span> { <span class="hljs-comment">//Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure</span>
        <span class="hljs-keyword">if</span> (newValue === <span class="hljs-keyword">this</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'A promise cannot be resolved with itself.'</span>);
        <span class="hljs-keyword">if</span> (newValue &amp;&amp; (<span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">'function'</span>)) {
          <span class="hljs-keyword">var</span> then = newValue.then;
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">'function'</span>) {
            doResolve(bind(then, newValue), bind(resolve, <span class="hljs-keyword">this</span>), bind(reject, <span class="hljs-keyword">this</span>));
            <span class="hljs-keyword">return</span>;
          }
        }
        <span class="hljs-keyword">this</span>._state = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">this</span>._value = newValue;
        finale.call(<span class="hljs-keyword">this</span>);
      } <span class="hljs-keyword">catch</span> (e) { reject.call(<span class="hljs-keyword">this</span>, e); }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">newValue</span>) </span>{
      <span class="hljs-keyword">this</span>._state = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">this</span>._value = newValue;
      finale.call(<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finale</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-keyword">this</span>._deferreds.length; i &lt; len; i++) {
        handle.call(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>._deferreds[i]);
      }
      <span class="hljs-keyword">this</span>._deferreds = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Handler</span>(<span class="hljs-params">onFulfilled, onRejected, resolve, reject</span>) </span>{
      <span class="hljs-keyword">this</span>.onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">'function'</span> ? onFulfilled : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">'function'</span> ? onRejected : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.resolve = resolve;
      <span class="hljs-keyword">this</span>.reject = reject;
    }

    <span class="hljs-comment">/**
     * Take a potentially misbehaving resolver function and make sure
     * onFulfilled and onRejected are only called once.
     *
     * Makes no guarantees about asynchrony.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doResolve</span>(<span class="hljs-params">fn, onFulfilled, onRejected</span>) </span>{
      <span class="hljs-keyword">var</span> done = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">try</span> {
        fn(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
          <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">return</span>;
          done = <span class="hljs-literal">true</span>;
          onFulfilled(value);
        }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>{
          <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">return</span>;
          done = <span class="hljs-literal">true</span>;
          onRejected(reason);
        });
      } <span class="hljs-keyword">catch</span> (ex) {
        <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">return</span>;
        done = <span class="hljs-literal">true</span>;
        onRejected(ex);
      }
    }

    <span class="hljs-built_in">Promise</span>.prototype[<span class="hljs-string">'catch'</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onRejected</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, onRejected);
    };

    <span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>{
      <span class="hljs-keyword">var</span> me = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
        handle.call(me, <span class="hljs-keyword">new</span> Handler(onFulfilled, onRejected, resolve, reject));
      });
    };

    <span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">1</span> &amp;&amp; isArray(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]) ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] : <span class="hljs-built_in">arguments</span>);

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
        <span class="hljs-keyword">if</span> (args.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> resolve([]);
        <span class="hljs-keyword">var</span> remaining = args.length;
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">res</span>(<span class="hljs-params">i, val</span>) </span>{
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (val &amp;&amp; (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'function'</span>)) {
              <span class="hljs-keyword">var</span> then = val.then;
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">'function'</span>) {
                then.call(val, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{ res(i, val); }, reject);
                <span class="hljs-keyword">return</span>;
              }
            }
            args[i] = val;
            <span class="hljs-keyword">if</span> (--remaining === <span class="hljs-number">0</span>) {
              resolve(args);
            }
          } <span class="hljs-keyword">catch</span> (ex) {
            reject(ex);
          }
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) {
          res(i, args[i]);
        }
      });
    };

    <span class="hljs-built_in">Promise</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">if</span> (value &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; value.constructor === <span class="hljs-built_in">Promise</span>) {
        <span class="hljs-keyword">return</span> value;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
        resolve(value);
      });
    };

    <span class="hljs-built_in">Promise</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
        reject(value);
      });
    };

    <span class="hljs-built_in">Promise</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">values</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = values.length; i &lt; len; i++) {
          values[i].then(resolve, reject);
        }
      });
    };

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>;
  }
);

<span class="hljs-comment">/* jshint ignore:end */</span>
<span class="hljs-comment">/* eslint-enable */</span>
<span class="hljs-comment">/**
 * Delay.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Utility class for working with delayed actions like setTimeout.
 *
 * @class tinymce.util.Delay
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.Delay'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Promise"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Promise</span>) </span>{
    <span class="hljs-keyword">var</span> requestAnimationFramePromise;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestAnimationFrame</span>(<span class="hljs-params">callback, element</span>) </span>{
      <span class="hljs-keyword">var</span> i, requestAnimationFrameFunc = <span class="hljs-built_in">window</span>.requestAnimationFrame, vendors = [<span class="hljs-string">'ms'</span>, <span class="hljs-string">'moz'</span>, <span class="hljs-string">'webkit'</span>];

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">featurefill</span>(<span class="hljs-params">callback</span>) </span>{
        <span class="hljs-built_in">window</span>.setTimeout(callback, <span class="hljs-number">0</span>);
      }

      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; vendors.length &amp;&amp; !requestAnimationFrameFunc; i++) {
        requestAnimationFrameFunc = <span class="hljs-built_in">window</span>[vendors[i] + <span class="hljs-string">'RequestAnimationFrame'</span>];
      }

      <span class="hljs-keyword">if</span> (!requestAnimationFrameFunc) {
        requestAnimationFrameFunc = featurefill;
      }

      requestAnimationFrameFunc(callback, element);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrappedSetTimeout</span>(<span class="hljs-params">callback, time</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> time != <span class="hljs-string">'number'</span>) {
        time = <span class="hljs-number">0</span>;
      }

      <span class="hljs-keyword">return</span> setTimeout(callback, time);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrappedSetInterval</span>(<span class="hljs-params">callback, time</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> time != <span class="hljs-string">'number'</span>) {
        time = <span class="hljs-number">1</span>; <span class="hljs-comment">// IE 8 needs it to be &gt; 0</span>
      }

      <span class="hljs-keyword">return</span> setInterval(callback, time);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrappedClearTimeout</span>(<span class="hljs-params">id</span>) </span>{
      <span class="hljs-keyword">return</span> clearTimeout(id);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrappedClearInterval</span>(<span class="hljs-params">id</span>) </span>{
      <span class="hljs-keyword">return</span> clearInterval(id);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">callback, time</span>) </span>{
      <span class="hljs-keyword">var</span> timer, func;

      func = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;

        clearTimeout(timer);

        timer = wrappedSetTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          callback.apply(<span class="hljs-keyword">this</span>, args);
        }, time);
      };

      func.stop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        clearTimeout(timer);
      };

      <span class="hljs-keyword">return</span> func;
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">/**
       * Requests an animation frame and fallbacks to a timeout on older browsers.
       *
       * @method requestAnimationFrame
       * @param {function} callback Callback to execute when a new frame is available.
       * @param {DOMElement} element Optional element to scope it to.
       */</span>
      requestAnimationFrame: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, element</span>) </span>{
        <span class="hljs-keyword">if</span> (requestAnimationFramePromise) {
          requestAnimationFramePromise.then(callback);
          <span class="hljs-keyword">return</span>;
        }

        requestAnimationFramePromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
          <span class="hljs-keyword">if</span> (!element) {
            element = <span class="hljs-built_in">document</span>.body;
          }

          requestAnimationFrame(resolve, element);
        }).then(callback);
      },

      <span class="hljs-comment">/**
       * Sets a timer in ms and executes the specified callback when the timer runs out.
       *
       * @method setTimeout
       * @param {function} callback Callback to execute when timer runs out.
       * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
       * @return {Number} Timeout id number.
       */</span>
      setTimeout: wrappedSetTimeout,

      <span class="hljs-comment">/**
       * Sets an interval timer in ms and executes the specified callback at every interval of that time.
       *
       * @method setInterval
       * @param {function} callback Callback to execute when interval time runs out.
       * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
       * @return {Number} Timeout id number.
       */</span>
      setInterval: wrappedSetInterval,

      <span class="hljs-comment">/**
       * Sets an editor timeout it's similar to setTimeout except that it checks if the editor instance is
       * still alive when the callback gets executed.
       *
       * @method setEditorTimeout
       * @param {tinymce.Editor} editor Editor instance to check the removed state on.
       * @param {function} callback Callback to execute when timer runs out.
       * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
       * @return {Number} Timeout id number.
       */</span>
      setEditorTimeout: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, callback, time</span>) </span>{
        <span class="hljs-keyword">return</span> wrappedSetTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (!editor.removed) {
            callback();
          }
        }, time);
      },

      <span class="hljs-comment">/**
       * Sets an interval timer it's similar to setInterval except that it checks if the editor instance is
       * still alive when the callback gets executed.
       *
       * @method setEditorInterval
       * @param {function} callback Callback to execute when interval time runs out.
       * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
       * @return {Number} Timeout id number.
       */</span>
      setEditorInterval: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, callback, time</span>) </span>{
        <span class="hljs-keyword">var</span> timer;

        timer = wrappedSetInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (!editor.removed) {
            callback();
          } <span class="hljs-keyword">else</span> {
            clearInterval(timer);
          }
        }, time);

        <span class="hljs-keyword">return</span> timer;
      },

      <span class="hljs-comment">/**
       * Creates debounced callback function that only gets executed once within the specified time.
       *
       * @method debounce
       * @param {function} callback Callback to execute when timer finishes.
       * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
       * @return {Function} debounced function callback.
       */</span>
      debounce: debounce,</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Throttle needs to be debounce due to backwards compatibility.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      throttle: debounce,

      <span class="hljs-comment">/**
       * Clears an interval timer so it won't execute.
       *
       * @method clearInterval
       * @param {Number} Interval timer id number.
       */</span>
      clearInterval: wrappedClearInterval,

      <span class="hljs-comment">/**
       * Clears an timeout timer so it won't execute.
       *
       * @method clearTimeout
       * @param {Number} Timeout timer id number.
       */</span>
      clearTimeout: wrappedClearTimeout
    };
  }
);

<span class="hljs-comment">/**
 * Env.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class contains various environment constants like browser versions etc.
 * Normally you don't want to sniff specific browser versions but sometimes you have
 * to when it's impossible to feature detect. So use this with care.
 *
 * @class tinymce.Env
 * @static
 */</span>
define(
  <span class="hljs-string">'tinymce.core.Env'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> nav = navigator, userAgent = nav.userAgent;
    <span class="hljs-keyword">var</span> opera, webkit, ie, ie11, ie12, gecko, mac, iDevice, android, fileApi, phone, tablet, windowsPhone;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchMediaQuery</span>(<span class="hljs-params">query</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-string">"matchMedia"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span> ? matchMedia(query).matches : <span class="hljs-literal">false</span>;
    }

    opera = <span class="hljs-built_in">window</span>.opera &amp;&amp; <span class="hljs-built_in">window</span>.opera.buildNumber;
    android = <span class="hljs-regexp">/Android/</span>.test(userAgent);
    webkit = <span class="hljs-regexp">/WebKit/</span>.test(userAgent);
    ie = !webkit &amp;&amp; !opera &amp;&amp; (<span class="hljs-regexp">/MSIE/gi</span>).test(userAgent) &amp;&amp; (<span class="hljs-regexp">/Explorer/gi</span>).test(nav.appName);
    ie = ie &amp;&amp; <span class="hljs-regexp">/MSIE (\w+)\./</span>.exec(userAgent)[<span class="hljs-number">1</span>];
    ie11 = userAgent.indexOf(<span class="hljs-string">'Trident/'</span>) != <span class="hljs-number">-1</span> &amp;&amp; (userAgent.indexOf(<span class="hljs-string">'rv:'</span>) != <span class="hljs-number">-1</span> || nav.appName.indexOf(<span class="hljs-string">'Netscape'</span>) != <span class="hljs-number">-1</span>) ? <span class="hljs-number">11</span> : <span class="hljs-literal">false</span>;
    ie12 = (userAgent.indexOf(<span class="hljs-string">'Edge/'</span>) != <span class="hljs-number">-1</span> &amp;&amp; !ie &amp;&amp; !ie11) ? <span class="hljs-number">12</span> : <span class="hljs-literal">false</span>;
    ie = ie || ie11 || ie12;
    gecko = !webkit &amp;&amp; !ie11 &amp;&amp; <span class="hljs-regexp">/Gecko/</span>.test(userAgent);
    mac = userAgent.indexOf(<span class="hljs-string">'Mac'</span>) != <span class="hljs-number">-1</span>;
    iDevice = <span class="hljs-regexp">/(iPad|iPhone)/</span>.test(userAgent);
    fileApi = <span class="hljs-string">"FormData"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span> &amp;&amp; <span class="hljs-string">"FileReader"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span> &amp;&amp; <span class="hljs-string">"URL"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span> &amp;&amp; !!URL.createObjectURL;
    phone = matchMediaQuery(<span class="hljs-string">"only screen and (max-device-width: 480px)"</span>) &amp;&amp; (android || iDevice);
    tablet = matchMediaQuery(<span class="hljs-string">"only screen and (min-width: 800px)"</span>) &amp;&amp; (android || iDevice);
    windowsPhone = userAgent.indexOf(<span class="hljs-string">'Windows Phone'</span>) != <span class="hljs-number">-1</span>;

    <span class="hljs-keyword">if</span> (ie12) {
      webkit = <span class="hljs-literal">false</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Is a iPad/iPhone and not on iOS5 sniff the WebKit version since older iOS WebKit versions
says it has contentEditable support but there is no visible caret.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> contentEditable = !iDevice || fileApi || userAgent.match(<span class="hljs-regexp">/AppleWebKit\/(\d*)/</span>)[<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">534</span>;

    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">/**
       * Constant that is true if the browser is Opera.
       *
       * @property opera
       * @type Boolean
       * @final
       */</span>
      opera: opera,

      <span class="hljs-comment">/**
       * Constant that is true if the browser is WebKit (Safari/Chrome).
       *
       * @property webKit
       * @type Boolean
       * @final
       */</span>
      webkit: webkit,

      <span class="hljs-comment">/**
       * Constant that is more than zero if the browser is IE.
       *
       * @property ie
       * @type Boolean
       * @final
       */</span>
      ie: ie,

      <span class="hljs-comment">/**
       * Constant that is true if the browser is Gecko.
       *
       * @property gecko
       * @type Boolean
       * @final
       */</span>
      gecko: gecko,

      <span class="hljs-comment">/**
       * Constant that is true if the os is Mac OS.
       *
       * @property mac
       * @type Boolean
       * @final
       */</span>
      mac: mac,

      <span class="hljs-comment">/**
       * Constant that is true if the os is iOS.
       *
       * @property iOS
       * @type Boolean
       * @final
       */</span>
      iOS: iDevice,

      <span class="hljs-comment">/**
       * Constant that is true if the os is android.
       *
       * @property android
       * @type Boolean
       * @final
       */</span>
      android: android,

      <span class="hljs-comment">/**
       * Constant that is true if the browser supports editing.
       *
       * @property contentEditable
       * @type Boolean
       * @final
       */</span>
      contentEditable: contentEditable,

      <span class="hljs-comment">/**
       * Transparent image data url.
       *
       * @property transparentSrc
       * @type Boolean
       * @final
       */</span>
      transparentSrc: <span class="hljs-string">"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"</span>,

      <span class="hljs-comment">/**
       * Returns true/false if the browser can or can't place the caret after a inline block like an image.
       *
       * @property noCaretAfter
       * @type Boolean
       * @final
       */</span>
      caretAfter: ie != <span class="hljs-number">8</span>,

      <span class="hljs-comment">/**
       * Constant that is true if the browser supports native DOM Ranges. IE 9+.
       *
       * @property range
       * @type Boolean
       */</span>
      range: <span class="hljs-built_in">window</span>.getSelection &amp;&amp; <span class="hljs-string">"Range"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>,

      <span class="hljs-comment">/**
       * Returns the IE document mode for non IE browsers this will fake IE 10.
       *
       * @property documentMode
       * @type Number
       */</span>
      documentMode: ie &amp;&amp; !ie12 ? (<span class="hljs-built_in">document</span>.documentMode || <span class="hljs-number">7</span>) : <span class="hljs-number">10</span>,

      <span class="hljs-comment">/**
       * Constant that is true if the browser has a modern file api.
       *
       * @property fileApi
       * @type Boolean
       */</span>
      fileApi: fileApi,

      <span class="hljs-comment">/**
       * Constant that is true if the browser supports contentEditable=false regions.
       *
       * @property ceFalse
       * @type Boolean
       */</span>
      ceFalse: (ie === <span class="hljs-literal">false</span> || ie &gt; <span class="hljs-number">8</span>),

      <span class="hljs-comment">/**
       * Constant if CSP mode is possible or not. Meaning we can't use script urls for the iframe.
       */</span>
      canHaveCSP: (ie === <span class="hljs-literal">false</span> || ie &gt; <span class="hljs-number">11</span>),

      <span class="hljs-attr">desktop</span>: !phone &amp;&amp; !tablet,
      <span class="hljs-attr">windowsPhone</span>: windowsPhone
    };
  }
);

<span class="hljs-comment">/**
 * EventUtils.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/*jshint loopfunc:true*/</span>
<span class="hljs-comment">/*eslint no-loop-func:0 */</span>

<span class="hljs-comment">/**
 * This class wraps the browsers native event logic with more convenient methods.
 *
 * @class tinymce.dom.EventUtils
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.EventUtils'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Delay"</span>,
    <span class="hljs-string">"tinymce.core.Env"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Delay, Env</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> eventExpandoPrefix = <span class="hljs-string">"mce-data-"</span>;
    <span class="hljs-keyword">var</span> mouseEventRe = <span class="hljs-regexp">/^(?:mouse|contextmenu)|click/</span>;
    <span class="hljs-keyword">var</span> deprecated = {
      <span class="hljs-attr">keyLocation</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">layerX</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">layerY</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">returnValue</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">webkitMovementX</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">webkitMovementY</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">keyIdentifier</span>: <span class="hljs-number">1</span>
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Checks if it is our own isDefaultPrevented function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> hasIsDefaultPrevented = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
      <span class="hljs-keyword">return</span> event.isDefaultPrevented === returnTrue || event.isDefaultPrevented === returnFalse;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Dummy function that gets replaced on the delegation state functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> returnFalse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Dummy function that gets replaced on the delegation state functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> returnTrue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    };

    <span class="hljs-comment">/**
     * Binds a native event to a callback on the speified target.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">target, name, callback, capture</span>) </span>{
      <span class="hljs-keyword">if</span> (target.addEventListener) {
        target.addEventListener(name, callback, capture || <span class="hljs-literal">false</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target.attachEvent) {
        target.attachEvent(<span class="hljs-string">'on'</span> + name, callback);
      }
    }

    <span class="hljs-comment">/**
     * Unbinds a native event callback on the specified target.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeEvent</span>(<span class="hljs-params">target, name, callback, capture</span>) </span>{
      <span class="hljs-keyword">if</span> (target.removeEventListener) {
        target.removeEventListener(name, callback, capture || <span class="hljs-literal">false</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target.detachEvent) {
        target.detachEvent(<span class="hljs-string">'on'</span> + name, callback);
      }
    }

    <span class="hljs-comment">/**
     * Gets the event target based on shadow dom properties like path and deepPath.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTargetFromShadowDom</span>(<span class="hljs-params">event, defaultTarget</span>) </span>{
      <span class="hljs-keyword">var</span> path, target = defaultTarget;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>When target element is inside Shadow DOM we need to take first element from path
otherwise well get Shadow Root parent, not actual target element</p>

            </div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Normalize target for WebComponents v0 implementation (in Chrome)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      path = event.path;
      <span class="hljs-keyword">if</span> (path &amp;&amp; path.length &gt; <span class="hljs-number">0</span>) {
        target = path[<span class="hljs-number">0</span>];
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Normalize target for WebComponents v1 implementation (standard)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (event.deepPath) {
        path = event.deepPath();
        <span class="hljs-keyword">if</span> (path &amp;&amp; path.length &gt; <span class="hljs-number">0</span>) {
          target = path[<span class="hljs-number">0</span>];
        }
      }

      <span class="hljs-keyword">return</span> target;
    }

    <span class="hljs-comment">/**
     * Normalizes a native event object or just adds the event specific methods on a custom event.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fix</span>(<span class="hljs-params">originalEvent, data</span>) </span>{
      <span class="hljs-keyword">var</span> name, event = data || {}, undef;</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Copy all properties from the original event</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> originalEvent) {</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>layerX/layerY is deprecated in Chrome and produces a warning</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!deprecated[name]) {
          event[name] = originalEvent[name];
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Normalize target IE uses srcElement</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!event.target) {
        event.target = event.srcElement || <span class="hljs-built_in">document</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Experimental shadow dom support</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (Env.experimentalShadowDom) {
        event.target = getTargetFromShadowDom(originalEvent, event.target);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Calculate pageX/Y if missing and clientX/Y available</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (originalEvent &amp;&amp; mouseEventRe.test(originalEvent.type) &amp;&amp; originalEvent.pageX === undef &amp;&amp; originalEvent.clientX !== undef) {
        <span class="hljs-keyword">var</span> eventDoc = event.target.ownerDocument || <span class="hljs-built_in">document</span>;
        <span class="hljs-keyword">var</span> doc = eventDoc.documentElement;
        <span class="hljs-keyword">var</span> body = eventDoc.body;

        event.pageX = originalEvent.clientX + (doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || <span class="hljs-number">0</span>) -
          (doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || <span class="hljs-number">0</span>);

        event.pageY = originalEvent.clientY + (doc &amp;&amp; doc.scrollTop || body &amp;&amp; body.scrollTop || <span class="hljs-number">0</span>) -
          (doc &amp;&amp; doc.clientTop || body &amp;&amp; body.clientTop || <span class="hljs-number">0</span>);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Add preventDefault method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      event.preventDefault = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        event.isDefaultPrevented = returnTrue;</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Execute preventDefault on the original event object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (originalEvent) {
          <span class="hljs-keyword">if</span> (originalEvent.preventDefault) {
            originalEvent.preventDefault();
          } <span class="hljs-keyword">else</span> {
            originalEvent.returnValue = <span class="hljs-literal">false</span>; <span class="hljs-comment">// IE</span>
          }
        }
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Add stopPropagation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      event.stopPropagation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        event.isPropagationStopped = returnTrue;</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Execute stopPropagation on the original event object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (originalEvent) {
          <span class="hljs-keyword">if</span> (originalEvent.stopPropagation) {
            originalEvent.stopPropagation();
          } <span class="hljs-keyword">else</span> {
            originalEvent.cancelBubble = <span class="hljs-literal">true</span>; <span class="hljs-comment">// IE</span>
          }
        }
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Add stopImmediatePropagation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      event.stopImmediatePropagation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        event.isImmediatePropagationStopped = returnTrue;
        event.stopPropagation();
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Add event delegation states</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (hasIsDefaultPrevented(event) === <span class="hljs-literal">false</span>) {
        event.isDefaultPrevented = returnFalse;
        event.isPropagationStopped = returnFalse;
        event.isImmediatePropagationStopped = returnFalse;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Add missing metaKey for IE 8</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event.metaKey == <span class="hljs-string">'undefined'</span>) {
        event.metaKey = <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">return</span> event;
    }

    <span class="hljs-comment">/**
     * Bind a DOMContentLoaded event across browsers and executes the callback once the page DOM is initialized.
     * It will also set/check the domLoaded state of the event_utils instance so ready isn't called multiple times.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindOnReady</span>(<span class="hljs-params">win, callback, eventUtils</span>) </span>{
      <span class="hljs-keyword">var</span> doc = win.document, event = { <span class="hljs-attr">type</span>: <span class="hljs-string">'ready'</span> };

      <span class="hljs-keyword">if</span> (eventUtils.domLoaded) {
        callback(event);
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDocReady</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Check complete or interactive state if there is a body
element on some iframes IE 8 will produce a null body</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> doc.readyState === <span class="hljs-string">"complete"</span> || (doc.readyState === <span class="hljs-string">"interactive"</span> &amp;&amp; doc.body);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Gets called when the DOM is ready</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readyHandler</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!eventUtils.domLoaded) {
          eventUtils.domLoaded = <span class="hljs-literal">true</span>;
          callback(event);
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitForDomLoaded</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (isDocReady()) {
          removeEvent(doc, <span class="hljs-string">"readystatechange"</span>, waitForDomLoaded);
          readyHandler();
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryScroll</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>If IE is used, use the trick by Diego Perini licensed under MIT by request to the author.
<a href="http://javascript.nwbox.com/IEContentLoaded/">http://javascript.nwbox.com/IEContentLoaded/</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          doc.documentElement.doScroll(<span class="hljs-string">"left"</span>);
        } <span class="hljs-keyword">catch</span> (ex) {
          Delay.setTimeout(tryScroll);
          <span class="hljs-keyword">return</span>;
        }

        readyHandler();
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Use W3C method (exclude IE 9,10 - readyState interactive became valid only in IE 11)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (doc.addEventListener &amp;&amp; !(Env.ie &amp;&amp; Env.ie &lt; <span class="hljs-number">11</span>)) {
        <span class="hljs-keyword">if</span> (isDocReady()) {
          readyHandler();
        } <span class="hljs-keyword">else</span> {
          addEvent(win, <span class="hljs-string">'DOMContentLoaded'</span>, readyHandler);
        }
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Use IE method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        addEvent(doc, <span class="hljs-string">"readystatechange"</span>, waitForDomLoaded);</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Wait until we can scroll, when we can the DOM is initialized</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (doc.documentElement.doScroll &amp;&amp; win.self === win.top) {
          tryScroll();
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Fallback if any of the above methods should fail for some odd reason</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      addEvent(win, <span class="hljs-string">'load'</span>, readyHandler);
    }

    <span class="hljs-comment">/**
     * This class enables you to bind/unbind native events to elements and normalize it's behavior across browsers.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EventUtils</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, events = {}, count, expando, hasFocusIn, hasMouseEnterLeave, mouseEnterLeave;

      expando = eventExpandoPrefix + (+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).toString(<span class="hljs-number">32</span>);
      hasMouseEnterLeave = <span class="hljs-string">"onmouseenter"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">document</span>.documentElement;
      hasFocusIn = <span class="hljs-string">"onfocusin"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">document</span>.documentElement;
      mouseEnterLeave = { <span class="hljs-attr">mouseenter</span>: <span class="hljs-string">'mouseover'</span>, <span class="hljs-attr">mouseleave</span>: <span class="hljs-string">'mouseout'</span> };
      count = <span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>State if the DOMContentLoaded was executed or not</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      self.domLoaded = <span class="hljs-literal">false</span>;
      self.events = events;

      <span class="hljs-comment">/**
       * Executes all event handler callbacks for a specific event.
       *
       * @private
       * @param {Event} evt Event object.
       * @param {String} id Expando id value to look for.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executeHandlers</span>(<span class="hljs-params">evt, id</span>) </span>{
        <span class="hljs-keyword">var</span> callbackList, i, l, callback, container = events[id];

        callbackList = container &amp;&amp; container[evt.type];
        <span class="hljs-keyword">if</span> (callbackList) {
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = callbackList.length; i &lt; l; i++) {
            callback = callbackList[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Check if callback exists might be removed if a unbind is called inside the callback</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (callback &amp;&amp; callback.func.call(callback.scope, evt) === <span class="hljs-literal">false</span>) {
              evt.preventDefault();
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Should we stop propagation to immediate listeners</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (evt.isImmediatePropagationStopped()) {
              <span class="hljs-keyword">return</span>;
            }
          }
        }
      }

      <span class="hljs-comment">/**
       * Binds a callback to an event on the specified target.
       *
       * @method bind
       * @param {Object} target Target node/window or custom object.
       * @param {String} names Name of the event to bind.
       * @param {function} callback Callback function to execute when the event occurs.
       * @param {Object} scope Scope to call the callback function on, defaults to target.
       * @return {function} Callback function that got bound.
       */</span>
      self.bind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, names, callback, scope</span>) </span>{
        <span class="hljs-keyword">var</span> id, callbackList, i, name, fakeName, nativeHandler, capture, win = <span class="hljs-built_in">window</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Native event handler function patches the event and executes the callbacks for the expando</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultNativeHandler</span>(<span class="hljs-params">evt</span>) </span>{
          executeHandlers(fix(evt || win.event), id);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Dont bind to text nodes or comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!target || target.nodeType === <span class="hljs-number">3</span> || target.nodeType === <span class="hljs-number">8</span>) {
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Create or get events id for the target</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!target[expando]) {
          id = count++;
          target[expando] = id;
          events[id] = {};
        } <span class="hljs-keyword">else</span> {
          id = target[expando];
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Setup the specified scope or use the target as a default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        scope = scope || target;</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Split names and bind each event, enables you to bind multiple events with one call</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        names = names.split(<span class="hljs-string">' '</span>);
        i = names.length;
        <span class="hljs-keyword">while</span> (i--) {
          name = names[i];
          nativeHandler = defaultNativeHandler;
          fakeName = capture = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Use ready instead of DOMContentLoaded</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (name === <span class="hljs-string">"DOMContentLoaded"</span>) {
            name = <span class="hljs-string">"ready"</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>DOM is already ready</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (self.domLoaded &amp;&amp; name === <span class="hljs-string">"ready"</span> &amp;&amp; target.readyState == <span class="hljs-string">'complete'</span>) {
            callback.call(scope, fix({ <span class="hljs-attr">type</span>: name }));
            <span class="hljs-keyword">continue</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Handle mouseenter/mouseleaver</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!hasMouseEnterLeave) {
            fakeName = mouseEnterLeave[name];

            <span class="hljs-keyword">if</span> (fakeName) {
              nativeHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>{
                <span class="hljs-keyword">var</span> current, related;

                current = evt.currentTarget;
                related = evt.relatedTarget;</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Check if related is inside the current target if its not then the event should
be ignored since its a mouseover/mouseout inside the element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (related &amp;&amp; current.contains) {</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Use contains for performance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  related = current.contains(related);
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">while</span> (related &amp;&amp; related !== current) {
                    related = related.parentNode;
                  }
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Fire fake event</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (!related) {
                  evt = fix(evt || win.event);
                  evt.type = evt.type === <span class="hljs-string">'mouseout'</span> ? <span class="hljs-string">'mouseleave'</span> : <span class="hljs-string">'mouseenter'</span>;
                  evt.target = current;
                  executeHandlers(evt, id);
                }
              };
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Fake bubbling of focusin/focusout</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!hasFocusIn &amp;&amp; (name === <span class="hljs-string">"focusin"</span> || name === <span class="hljs-string">"focusout"</span>)) {
            capture = <span class="hljs-literal">true</span>;
            fakeName = name === <span class="hljs-string">"focusin"</span> ? <span class="hljs-string">"focus"</span> : <span class="hljs-string">"blur"</span>;
            nativeHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>{
              evt = fix(evt || win.event);
              evt.type = evt.type === <span class="hljs-string">'focus'</span> ? <span class="hljs-string">'focusin'</span> : <span class="hljs-string">'focusout'</span>;
              executeHandlers(evt, id);
            };
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Setup callback list and bind native event</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          callbackList = events[id][name];
          <span class="hljs-keyword">if</span> (!callbackList) {
            events[id][name] = callbackList = [{ <span class="hljs-attr">func</span>: callback, <span class="hljs-attr">scope</span>: scope }];
            callbackList.fakeName = fakeName;
            callbackList.capture = capture;</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>callbackList.callback = callback;</p>

            </div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Add the nativeHandler to the callback list so that we can later unbind it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            callbackList.nativeHandler = nativeHandler;</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Check if the target has native events support</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">if</span> (name === <span class="hljs-string">"ready"</span>) {
              bindOnReady(target, nativeHandler, self);
            } <span class="hljs-keyword">else</span> {
              addEvent(target, fakeName || name, nativeHandler, capture);
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (name === <span class="hljs-string">"ready"</span> &amp;&amp; self.domLoaded) {
              callback({ <span class="hljs-attr">type</span>: name });
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>If it already has an native handler then just push the callback</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              callbackList.push({ <span class="hljs-attr">func</span>: callback, <span class="hljs-attr">scope</span>: scope });
            }
          }
        }

        target = callbackList = <span class="hljs-number">0</span>; <span class="hljs-comment">// Clean memory for IE</span>

        <span class="hljs-keyword">return</span> callback;
      };

      <span class="hljs-comment">/**
       * Unbinds the specified event by name, name and callback or all events on the target.
       *
       * @method unbind
       * @param {Object} target Target node/window or custom object.
       * @param {String} names Optional event name to unbind.
       * @param {function} callback Optional callback function to unbind.
       * @return {EventUtils} Event utils instance.
       */</span>
      self.unbind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, names, callback</span>) </span>{
        <span class="hljs-keyword">var</span> id, callbackList, i, ci, name, eventMap;</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Dont bind to text nodes or comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!target || target.nodeType === <span class="hljs-number">3</span> || target.nodeType === <span class="hljs-number">8</span>) {
          <span class="hljs-keyword">return</span> self;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Unbind event or events if the target has the expando</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        id = target[expando];
        <span class="hljs-keyword">if</span> (id) {
          eventMap = events[id];</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Specific callback</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (names) {
            names = names.split(<span class="hljs-string">' '</span>);
            i = names.length;
            <span class="hljs-keyword">while</span> (i--) {
              name = names[i];
              callbackList = eventMap[name];</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Unbind the event if it exists in the map</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (callbackList) {</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Remove specified callback</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (callback) {
                  ci = callbackList.length;
                  <span class="hljs-keyword">while</span> (ci--) {
                    <span class="hljs-keyword">if</span> (callbackList[ci].func === callback) {
                      <span class="hljs-keyword">var</span> nativeHandler = callbackList.nativeHandler;
                      <span class="hljs-keyword">var</span> fakeName = callbackList.fakeName, capture = callbackList.capture;</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Clone callbackList since unbind inside a callback would otherwise break the handlers loop</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                      callbackList = callbackList.slice(<span class="hljs-number">0</span>, ci).concat(callbackList.slice(ci + <span class="hljs-number">1</span>));
                      callbackList.nativeHandler = nativeHandler;
                      callbackList.fakeName = fakeName;
                      callbackList.capture = capture;

                      eventMap[name] = callbackList;
                    }
                  }
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>Remove all callbacks if there isnt a specified callback or there is no callbacks left</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (!callback || callbackList.length === <span class="hljs-number">0</span>) {
                  <span class="hljs-keyword">delete</span> eventMap[name];
                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
                }
              }
            }
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>All events for a specific element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> eventMap) {
              callbackList = eventMap[name];
              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
            }

            eventMap = {};
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>Check if object is empty, if it isnt then we wont remove the expando map</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> eventMap) {
            <span class="hljs-keyword">return</span> self;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>Delete event object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">delete</span> events[id];</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Remove expando from target</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>IE will fail here since it cant delete properties from window</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">delete</span> target[expando];
          } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>IE will set it to null</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            target[expando] = <span class="hljs-literal">null</span>;
          }
        }

        <span class="hljs-keyword">return</span> self;
      };

      <span class="hljs-comment">/**
       * Fires the specified event on the specified target.
       *
       * @method fire
       * @param {Object} target Target node/window or custom object.
       * @param {String} name Event name to fire.
       * @param {Object} args Optional arguments to send to the observers.
       * @return {EventUtils} Event utils instance.
       */</span>
      self.fire = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, name, args</span>) </span>{
        <span class="hljs-keyword">var</span> id;</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Dont bind to text nodes or comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!target || target.nodeType === <span class="hljs-number">3</span> || target.nodeType === <span class="hljs-number">8</span>) {
          <span class="hljs-keyword">return</span> self;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Build event object by patching the args</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        args = fix(<span class="hljs-literal">null</span>, args);
        args.type = name;
        args.target = target;

        <span class="hljs-keyword">do</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>Found an expando that means there is listeners to execute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          id = target[expando];
          <span class="hljs-keyword">if</span> (id) {
            executeHandlers(args, id);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>Walk up the DOM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
        } <span class="hljs-keyword">while</span> (target &amp;&amp; !args.isPropagationStopped());

        <span class="hljs-keyword">return</span> self;
      };

      <span class="hljs-comment">/**
       * Removes all bound event listeners for the specified target. This will also remove any bound
       * listeners to child nodes within that target.
       *
       * @method clean
       * @param {Object} target Target node/window object.
       * @return {EventUtils} Event utils instance.
       */</span>
      self.clean = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>{
        <span class="hljs-keyword">var</span> i, children, unbind = self.unbind;</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>Dont bind to text nodes or comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!target || target.nodeType === <span class="hljs-number">3</span> || target.nodeType === <span class="hljs-number">8</span>) {
          <span class="hljs-keyword">return</span> self;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>Unbind any element on the specified target</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (target[expando]) {
          unbind(target);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>Target doesnt have getElementsByTagName its probably a window object then use its document to find the children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!target.getElementsByTagName) {
          target = target.document;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>Remove events from each child element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (target &amp;&amp; target.getElementsByTagName) {
          unbind(target);

          children = target.getElementsByTagName(<span class="hljs-string">'*'</span>);
          i = children.length;
          <span class="hljs-keyword">while</span> (i--) {
            target = children[i];

            <span class="hljs-keyword">if</span> (target[expando]) {
              unbind(target);
            }
          }
        }

        <span class="hljs-keyword">return</span> self;
      };

      <span class="hljs-comment">/**
       * Destroys the event object. Call this on IE to remove memory leaks.
       */</span>
      self.destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        events = {};
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>Legacy function for canceling events</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      self.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (e) {
          e.preventDefault();
          e.stopImmediatePropagation();
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      };
    }

    EventUtils.Event = <span class="hljs-keyword">new</span> EventUtils();
    EventUtils.Event.bind(<span class="hljs-built_in">window</span>, <span class="hljs-string">'ready'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ });

    <span class="hljs-keyword">return</span> EventUtils;
  }
);

<span class="hljs-comment">/**
 * Sizzle.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 *
 * @ignore-file
 */</span>

<span class="hljs-comment">/*jshint bitwise:false, expr:true, noempty:false, sub:true, eqnull:true, latedef:false, maxlen:255 */</span>
<span class="hljs-comment">/*eslint-disable */</span>

<span class="hljs-comment">/**
 * Sizzle CSS Selector Engine v@VERSION
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: @DATE
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.Sizzle'</span>,
  [],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> i,
      support,
      Expr,
      getText,
      isXML,
      tokenize,
      compile,
      select,
      outermostContext,
      sortInput,
      hasDuplicate,</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Local document vars</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      setDocument,
      <span class="hljs-built_in">document</span>,
      docElem,
      documentIsHTML,
      rbuggyQSA,
      rbuggyMatches,
      matches,
      contains,</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Instance-specific data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      expando = <span class="hljs-string">"sizzle"</span> + -(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()),
      preferredDoc = <span class="hljs-built_in">window</span>.document,
      dirruns = <span class="hljs-number">0</span>,
      done = <span class="hljs-number">0</span>,
      classCache = createCache(),
      tokenCache = createCache(),
      compilerCache = createCache(),
      sortOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
        <span class="hljs-keyword">if</span> (a === b) {
          hasDuplicate = <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>General-purpose constants</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      strundefined = <span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>,
      MAX_NEGATIVE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>Instance methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      hasOwn = ({}).hasOwnProperty,
      arr = [],
      pop = arr.pop,
      push_native = arr.push,
      push = arr.push,
      slice = arr.slice,</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>Use a stripped-down indexOf if we cant use a native one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      indexOf = arr.indexOf || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
        <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
          len = <span class="hljs-keyword">this</span>.length;
        <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[i] === elem) {
            <span class="hljs-keyword">return</span> i;
          }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
      },

      booleans = <span class="hljs-string">"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Regular expressions</p>

            </div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p><a href="http://www.w3.org/TR/css3-selectors/#whitespace">http://www.w3.org/TR/css3-selectors/#whitespace</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      whitespace = <span class="hljs-string">"[\\x20\\t\\r\\n\\f]"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p><a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      identifier = <span class="hljs-string">"(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>Attribute selectors: <a href="http://www.w3.org/TR/selectors/#attribute-selectors">http://www.w3.org/TR/selectors/#attribute-selectors</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      attributes = <span class="hljs-string">"\\["</span> + whitespace + <span class="hljs-string">"*("</span> + identifier + <span class="hljs-string">")(?:"</span> + whitespace +</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>Operator (capture 2)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"*([*^$|!~]?=)"</span> + whitespace +</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("</span> + identifier + <span class="hljs-string">"))|)"</span> + whitespace +
        <span class="hljs-string">"*\\]"</span>,

      pseudos = <span class="hljs-string">":("</span> + identifier + <span class="hljs-string">")(?:\\(("</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:</p>
<ol>
<li>quoted (capture 3; capture 4 or capture 5)</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|"</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <ol>
<li>simple (capture 6)</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"((?:\\\\.|[^\\\\()[\\]]|"</span> + attributes + <span class="hljs-string">")*)|"</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <ol>
<li>anything else (capture 2)</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">".*"</span> +
        <span class="hljs-string">")\\)|)"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      rtrim = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^"</span> + whitespace + <span class="hljs-string">"+|((?:^|[^\\\\])(?:\\\\.)*)"</span> + whitespace + <span class="hljs-string">"+$"</span>, <span class="hljs-string">"g"</span>),

      rcomma = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^"</span> + whitespace + <span class="hljs-string">"*,"</span> + whitespace + <span class="hljs-string">"*"</span>),
      rcombinators = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^"</span> + whitespace + <span class="hljs-string">"*([&gt;+~]|"</span> + whitespace + <span class="hljs-string">")"</span> + whitespace + <span class="hljs-string">"*"</span>),

      rattributeQuotes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"="</span> + whitespace + <span class="hljs-string">"*([^\\]'\"]*?)"</span> + whitespace + <span class="hljs-string">"*\\]"</span>, <span class="hljs-string">"g"</span>),

      rpseudo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(pseudos),
      ridentifier = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^"</span> + identifier + <span class="hljs-string">"$"</span>),

      matchExpr = {
        <span class="hljs-string">"ID"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^#("</span> + identifier + <span class="hljs-string">")"</span>),
        <span class="hljs-string">"CLASS"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^\\.("</span> + identifier + <span class="hljs-string">")"</span>),
        <span class="hljs-string">"TAG"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^("</span> + identifier + <span class="hljs-string">"|[*])"</span>),
        <span class="hljs-string">"ATTR"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^"</span> + attributes),
        <span class="hljs-string">"PSEUDO"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^"</span> + pseudos),
        <span class="hljs-string">"CHILD"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("</span> + whitespace +
          <span class="hljs-string">"*(even|odd|(([+-]|)(\\d*)n|)"</span> + whitespace + <span class="hljs-string">"*(?:([+-]|)"</span> + whitespace +
          <span class="hljs-string">"*(\\d+)|))"</span> + whitespace + <span class="hljs-string">"*\\)|)"</span>, <span class="hljs-string">"i"</span>),
        <span class="hljs-string">"bool"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^(?:"</span> + booleans + <span class="hljs-string">")$"</span>, <span class="hljs-string">"i"</span>),</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>For use in libraries implementing .is()
We use this for POS matching in <code>select</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"needsContext"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^"</span> + whitespace + <span class="hljs-string">"*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("</span> +
          whitespace + <span class="hljs-string">"*((?:-\\d)?\\d*)"</span> + whitespace + <span class="hljs-string">"*\\)|)(?=[^-]|$)"</span>, <span class="hljs-string">"i"</span>)
      },

      rinputs = <span class="hljs-regexp">/^(?:input|select|textarea|button)$/i</span>,
      rheader = <span class="hljs-regexp">/^h\d$/i</span>,

      rnative = <span class="hljs-regexp">/^[^{]+\{\s*\[native \w/</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>Easily-parseable/retrievable ID or TAG or CLASS selectors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      rquickExpr = <span class="hljs-regexp">/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/</span>,

      rsibling = <span class="hljs-regexp">/[+~]/</span>,
      rescape = <span class="hljs-regexp">/'|\\/g</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>CSS escapes <a href="http://www.w3.org/TR/CSS21/syndata.html#escaped-characters">http://www.w3.org/TR/CSS21/syndata.html#escaped-characters</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      runescape = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"\\\\([\\da-f]{1,6}"</span> + whitespace + <span class="hljs-string">"?|("</span> + whitespace + <span class="hljs-string">")|.)"</span>, <span class="hljs-string">"ig"</span>),
      funescape = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_, escaped, escapedWhitespace</span>) </span>{
        <span class="hljs-keyword">var</span> high = <span class="hljs-string">"0x"</span> + escaped - <span class="hljs-number">0x10000</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>NaN means non-codepoint
Support: Firefox&lt;24
Workaround erroneous numeric interpretation of +0x</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> high !== high || escapedWhitespace ?
          escaped :
          high &lt; <span class="hljs-number">0</span> ?</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>BMP codepoint</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-built_in">String</span>.fromCharCode(high + <span class="hljs-number">0x10000</span>) :</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>Supplemental Plane codepoint (surrogate pair)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-built_in">String</span>.fromCharCode(high &gt;&gt; <span class="hljs-number">10</span> | <span class="hljs-number">0xD800</span>, high &amp; <span class="hljs-number">0x3FF</span> | <span class="hljs-number">0xDC00</span>);
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>Optimize for push.apply( _, NodeList )</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">try</span> {
      push.apply(
        (arr = slice.call(preferredDoc.childNodes)),
        preferredDoc.childNodes
      );</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>Support: Android&lt;4.0
Detect silently failing push.apply</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      arr[preferredDoc.childNodes.length].nodeType;
    } <span class="hljs-keyword">catch</span> (e) {
      push = {
        <span class="hljs-attr">apply</span>: arr.length ?</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>Leverage slice if possible</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, els</span>) </span>{
            push_native.apply(target, slice.call(els));
          } :</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>Support: IE&lt;9
Otherwise append directly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, els</span>) </span>{
            <span class="hljs-keyword">var</span> j = target.length,
              i = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>Cant trust NodeList.length</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">while</span> ((target[j++] = els[i++])) { }
            target.length = j - <span class="hljs-number">1</span>;
          }
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sizzle</span>(<span class="hljs-params">selector, context, results, seed</span>) </span>{
      <span class="hljs-keyword">var</span> match, elem, m, nodeType,</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>QSA vars</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        i, groups, old, nid, newContext, newSelector;

      <span class="hljs-keyword">if</span> ((context ? context.ownerDocument || context : preferredDoc) !== <span class="hljs-built_in">document</span>) {
        setDocument(context);
      }

      context = context || <span class="hljs-built_in">document</span>;
      results = results || [];

      <span class="hljs-keyword">if</span> (!selector || <span class="hljs-keyword">typeof</span> selector !== <span class="hljs-string">"string"</span>) {
        <span class="hljs-keyword">return</span> results;
      }

      <span class="hljs-keyword">if</span> ((nodeType = context.nodeType) !== <span class="hljs-number">1</span> &amp;&amp; nodeType !== <span class="hljs-number">9</span>) {
        <span class="hljs-keyword">return</span> [];
      }

      <span class="hljs-keyword">if</span> (documentIsHTML &amp;&amp; !seed) {</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>Shortcuts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((match = rquickExpr.exec(selector))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>Speed-up: Sizzle(#ID)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> ((m = match[<span class="hljs-number">1</span>])) {
            <span class="hljs-keyword">if</span> (nodeType === <span class="hljs-number">9</span>) {
              elem = context.getElementById(m);</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>Check parentNode to catch when Blackberry 4.6 returns
nodes that are no longer in the document (jQuery #6963)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (elem &amp;&amp; elem.parentNode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>Handle the case where IE, Opera, and Webkit return items
by name instead of ID</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (elem.id === m) {
                  results.push(elem);
                  <span class="hljs-keyword">return</span> results;
                }
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> results;
              }
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>Context is not a document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById(m)) &amp;&amp;
                contains(context, elem) &amp;&amp; elem.id === m) {
                results.push(elem);
                <span class="hljs-keyword">return</span> results;
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>Speed-up: Sizzle(TAG)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match[<span class="hljs-number">2</span>]) {
            push.apply(results, context.getElementsByTagName(selector));
            <span class="hljs-keyword">return</span> results;</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>Speed-up: Sizzle(.CLASS)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((m = match[<span class="hljs-number">3</span>]) &amp;&amp; support.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            <span class="hljs-keyword">return</span> results;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>QSA path</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (support.qsa &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType === <span class="hljs-number">9</span> &amp;&amp; selector;</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>qSA works strangely on Element-rooted queries
We can work around this by specifying an extra ID on the root
and working up from there (Thanks to Andrew Dupont for the technique)
IE 8 doesnt work on object elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (nodeType === <span class="hljs-number">1</span> &amp;&amp; context.nodeName.toLowerCase() !== <span class="hljs-string">"object"</span>) {
            groups = tokenize(selector);

            <span class="hljs-keyword">if</span> ((old = context.getAttribute(<span class="hljs-string">"id"</span>))) {
              nid = old.replace(rescape, <span class="hljs-string">"\\$&amp;"</span>);
            } <span class="hljs-keyword">else</span> {
              context.setAttribute(<span class="hljs-string">"id"</span>, nid);
            }
            nid = <span class="hljs-string">"[id='"</span> + nid + <span class="hljs-string">"'] "</span>;

            i = groups.length;
            <span class="hljs-keyword">while</span> (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) &amp;&amp; testContext(context.parentNode) || context;
            newSelector = groups.join(<span class="hljs-string">","</span>);
          }

          <span class="hljs-keyword">if</span> (newSelector) {
            <span class="hljs-keyword">try</span> {
              push.apply(results,
                newContext.querySelectorAll(newSelector)
              );
              <span class="hljs-keyword">return</span> results;
            } <span class="hljs-keyword">catch</span> (qsaError) {
            } <span class="hljs-keyword">finally</span> {
              <span class="hljs-keyword">if</span> (!old) {
                context.removeAttribute(<span class="hljs-string">"id"</span>);
              }
            }
          }
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>All others</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> select(selector.replace(rtrim, <span class="hljs-string">"$1"</span>), context, results, seed);
    }

    <span class="hljs-comment">/**
     * Create key-value caches of limited size
     * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
     * property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     * deleting the oldest entry
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCache</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> keys = [];

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cache</span>(<span class="hljs-params">key, value</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>Use (key +  ) to avoid collision with native prototype properties (see Issue #157)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (keys.push(key + <span class="hljs-string">" "</span>) &gt; Expr.cacheLength) {</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>Only keep the most recent entries</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">delete</span> cache[keys.shift()];
        }
        <span class="hljs-keyword">return</span> (cache[key + <span class="hljs-string">" "</span>] = value);
      }
      <span class="hljs-keyword">return</span> cache;
    }

    <span class="hljs-comment">/**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markFunction</span>(<span class="hljs-params">fn</span>) </span>{
      fn[expando] = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">return</span> fn;
    }

    <span class="hljs-comment">/**
     * Support testing using an element
     * @param {Function} fn Passed the created div and expects a boolean result
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assert</span>(<span class="hljs-params">fn</span>) </span>{
      <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>);

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> !!fn(div);
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      } <span class="hljs-keyword">finally</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>Remove from its parent by default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (div.parentNode) {
          div.parentNode.removeChild(div);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>release memory in IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        div = <span class="hljs-literal">null</span>;
      }
    }

    <span class="hljs-comment">/**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addHandle</span>(<span class="hljs-params">attrs, handler</span>) </span>{
      <span class="hljs-keyword">var</span> arr = attrs.split(<span class="hljs-string">"|"</span>),
        i = attrs.length;

      <span class="hljs-keyword">while</span> (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }

    <span class="hljs-comment">/**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">siblingCheck</span>(<span class="hljs-params">a, b</span>) </span>{
      <span class="hljs-keyword">var</span> cur = b &amp;&amp; a,
        diff = cur &amp;&amp; a.nodeType === <span class="hljs-number">1</span> &amp;&amp; b.nodeType === <span class="hljs-number">1</span> &amp;&amp;
          (~b.sourceIndex || MAX_NEGATIVE) -
          (~a.sourceIndex || MAX_NEGATIVE);</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>Use IE sourceIndex if available on both nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (diff) {
        <span class="hljs-keyword">return</span> diff;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>Check if b follows a</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (cur) {
        <span class="hljs-keyword">while</span> ((cur = cur.nextSibling)) {
          <span class="hljs-keyword">if</span> (cur === b) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
          }
        }
      }

      <span class="hljs-keyword">return</span> a ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
    }

    <span class="hljs-comment">/**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createInputPseudo</span>(<span class="hljs-params">type</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
        <span class="hljs-keyword">var</span> name = elem.nodeName.toLowerCase();
        <span class="hljs-keyword">return</span> name === <span class="hljs-string">"input"</span> &amp;&amp; elem.type === type;
      };
    }

    <span class="hljs-comment">/**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createButtonPseudo</span>(<span class="hljs-params">type</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
        <span class="hljs-keyword">var</span> name = elem.nodeName.toLowerCase();
        <span class="hljs-keyword">return</span> (name === <span class="hljs-string">"input"</span> || name === <span class="hljs-string">"button"</span>) &amp;&amp; elem.type === type;
      };
    }

    <span class="hljs-comment">/**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPositionalPseudo</span>(<span class="hljs-params">fn</span>) </span>{
      <span class="hljs-keyword">return</span> markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argument</span>) </span>{
        argument = +argument;
        <span class="hljs-keyword">return</span> markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">seed, matches</span>) </span>{
          <span class="hljs-keyword">var</span> j,
            matchIndexes = fn([], seed.length, argument),
            i = matchIndexes.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>Match elements found at the specified indexes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">while</span> (i--) {
            <span class="hljs-keyword">if</span> (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }

    <span class="hljs-comment">/**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testContext</span>(<span class="hljs-params">context</span>) </span>{
      <span class="hljs-keyword">return</span> context &amp;&amp; <span class="hljs-keyword">typeof</span> context.getElementsByTagName !== strundefined &amp;&amp; context;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>Expose support vars for convenience</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    support = Sizzle.support = {};

    <span class="hljs-comment">/**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */</span>
    isXML = Sizzle.isXML = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>documentElement is verified for cases where it doesnt yet exist
(such as loading iframes in IE - #4833)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
      <span class="hljs-keyword">return</span> documentElement ? documentElement.nodeName !== <span class="hljs-string">"HTML"</span> : <span class="hljs-literal">false</span>;
    };

    <span class="hljs-comment">/**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */</span>
    setDocument = Sizzle.setDocument = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">var</span> hasCompare,
        doc = node ? node.ownerDocument || node : preferredDoc,
        parent = doc.defaultView;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTop</span>(<span class="hljs-params">win</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>Edge throws a lovely Object expected if you try to get top on a detached reference see #2642</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> win.top;
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>Ignore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p>If no document and documentElement is available, return</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (doc === <span class="hljs-built_in">document</span> || doc.nodeType !== <span class="hljs-number">9</span> || !doc.documentElement) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>Set our document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-built_in">document</span> = doc;
      docElem = doc.documentElement;</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>Support tests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      documentIsHTML = !isXML(doc);</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>Support: IE&gt;8
If iframe document is assigned to document variable and if iframe has been reloaded,
IE will throw permission denied error when accessing document variable, see jQuery #13936
IE6-8 do not support the defaultView property so parent will be undefined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (parent &amp;&amp; parent !== getTop(parent)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>IE11 does not have attachEvent, so all must suffer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (parent.addEventListener) {
          parent.addEventListener(<span class="hljs-string">"unload"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            setDocument();
          }, <span class="hljs-literal">false</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent.attachEvent) {
          parent.attachEvent(<span class="hljs-string">"onunload"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            setDocument();
          });
        }
      }

      <span class="hljs-comment">/* Attributes
      ---------------------------------------------------------------------- */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>Support: IE&lt;8
Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      support.attributes = assert(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">div</span>) </span>{
        div.className = <span class="hljs-string">"i"</span>;
        <span class="hljs-keyword">return</span> !div.getAttribute(<span class="hljs-string">"className"</span>);
      });

      <span class="hljs-comment">/* getElement(s)By*
      ---------------------------------------------------------------------- */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>Check if getElementsByTagName(*) returns only elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      support.getElementsByTagName = assert(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">div</span>) </span>{
        div.appendChild(doc.createComment(<span class="hljs-string">""</span>));
        <span class="hljs-keyword">return</span> !div.getElementsByTagName(<span class="hljs-string">"*"</span>).length;
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>Support: IE&lt;9</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      support.getElementsByClassName = rnative.test(doc.getElementsByClassName);</pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p>Support: IE&lt;10
Check if getElementById returns elements by name
The broken getElementById methods dont pick up programatically-set names,
so use a roundabout getElementsByName test</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      support.getById = assert(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">div</span>) </span>{
        docElem.appendChild(div).id = expando;
        <span class="hljs-keyword">return</span> !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>ID find and filter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (support.getById) {
        Expr.find[<span class="hljs-string">"ID"</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, context</span>) </span>{
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> context.getElementById !== strundefined &amp;&amp; documentIsHTML) {
            <span class="hljs-keyword">var</span> m = context.getElementById(id);</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>Check parentNode to catch when Blackberry 4.6 returns
nodes that are no longer in the document #6963</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> m &amp;&amp; m.parentNode ? [m] : [];
          }
        };
        Expr.filter[<span class="hljs-string">"ID"</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
          <span class="hljs-keyword">var</span> attrId = id.replace(runescape, funescape);
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
            <span class="hljs-keyword">return</span> elem.getAttribute(<span class="hljs-string">"id"</span>) === attrId;
          };
        };
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>Support: IE6/7
getElementById is not reliable as a find shortcut</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">delete</span> Expr.find[<span class="hljs-string">"ID"</span>];

        Expr.filter[<span class="hljs-string">"ID"</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
          <span class="hljs-keyword">var</span> attrId = id.replace(runescape, funescape);
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
            <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">typeof</span> elem.getAttributeNode !== strundefined &amp;&amp; elem.getAttributeNode(<span class="hljs-string">"id"</span>);
            <span class="hljs-keyword">return</span> node &amp;&amp; node.value === attrId;
          };
        };
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>Tag</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      Expr.find[<span class="hljs-string">"TAG"</span>] = support.getElementsByTagName ?
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tag, context</span>) </span>{
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> context.getElementsByTagName !== strundefined) {
            <span class="hljs-keyword">return</span> context.getElementsByTagName(tag);
          }
        } :
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tag, context</span>) </span>{
          <span class="hljs-keyword">var</span> elem,
            tmp = [],
            i = <span class="hljs-number">0</span>,
            results = context.getElementsByTagName(tag);</pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>Filter out possible comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">"*"</span>) {
            <span class="hljs-keyword">while</span> ((elem = results[i++])) {
              <span class="hljs-keyword">if</span> (elem.nodeType === <span class="hljs-number">1</span>) {
                tmp.push(elem);
              }
            }

            <span class="hljs-keyword">return</span> tmp;
          }
          <span class="hljs-keyword">return</span> results;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>Class</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      Expr.find[<span class="hljs-string">"CLASS"</span>] = support.getElementsByClassName &amp;&amp; <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">className, context</span>) </span>{
        <span class="hljs-keyword">if</span> (documentIsHTML) {
          <span class="hljs-keyword">return</span> context.getElementsByClassName(className);
        }
      };

      <span class="hljs-comment">/* QSA/matchesSelector
      ---------------------------------------------------------------------- */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <p>QSA and matchesSelector support</p>

            </div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <p>matchesSelector(:active) reports false when true (IE9/Opera 11.5)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      rbuggyMatches = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <p>qSa(:focus) reports false when true (Chrome 21)
We allow this because of a bug in IE8/9 that throws an error
whenever <code>document.activeElement</code> is accessed on an iframe
So, we allow :focus to pass through QSA all the time to avoid the IE error
See <a href="http://bugs.jquery.com/ticket/13378">http://bugs.jquery.com/ticket/13378</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      rbuggyQSA = [];

      <span class="hljs-keyword">if</span> ((support.qsa = rnative.test(doc.querySelectorAll))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <p>Build QSA regex
Regex strategy adopted from Diego Perini</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        assert(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">div</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <p>Select is set to empty string on purpose
This is to test IEs treatment of not explicitly
setting a boolean content attribute,
since its presence should be enough
<a href="http://bugs.jquery.com/ticket/12359">http://bugs.jquery.com/ticket/12359</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          div.innerHTML = <span class="hljs-string">"&lt;select msallowcapture=''&gt;&lt;option selected=''&gt;&lt;/option&gt;&lt;/select&gt;"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              <p>Support: IE8, Opera 11-12.16
Nothing should be selected when empty strings follow ^= or $= or *=
The test attribute must be unknown in Opera but safe for WinRT
<a href="http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section">http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (div.querySelectorAll(<span class="hljs-string">"[msallowcapture^='']"</span>).length) {
            rbuggyQSA.push(<span class="hljs-string">"[*^$]="</span> + whitespace + <span class="hljs-string">"*(?:''|\"\")"</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              <p>Support: IE8
Boolean attributes and value are not treated correctly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!div.querySelectorAll(<span class="hljs-string">"[selected]"</span>).length) {
            rbuggyQSA.push(<span class="hljs-string">"\\["</span> + whitespace + <span class="hljs-string">"*(?:value|"</span> + booleans + <span class="hljs-string">")"</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <p>Webkit/Opera - :checked should return selected option elements
<a href="http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked">http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</a>
IE8 throws error here and will not see later tests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!div.querySelectorAll(<span class="hljs-string">":checked"</span>).length) {
            rbuggyQSA.push(<span class="hljs-string">":checked"</span>);
          }
        });

        assert(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">div</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <p>Support: Windows 8 Native Apps
The type and name attributes are restricted during .innerHTML assignment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> input = doc.createElement(<span class="hljs-string">"input"</span>);
          input.setAttribute(<span class="hljs-string">"type"</span>, <span class="hljs-string">"hidden"</span>);
          div.appendChild(input).setAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"D"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <p>Support: IE8
Enforce case-sensitivity of name attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (div.querySelectorAll(<span class="hljs-string">"[name=d]"</span>).length) {
            rbuggyQSA.push(<span class="hljs-string">"name"</span> + whitespace + <span class="hljs-string">"*[*^$|!~]?="</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <p>FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
IE8 throws error here and will not see later tests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!div.querySelectorAll(<span class="hljs-string">":enabled"</span>).length) {
            rbuggyQSA.push(<span class="hljs-string">":enabled"</span>, <span class="hljs-string">":disabled"</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              <p>Opera 10-11 does not throw on post-comma invalid pseudos</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          div.querySelectorAll(<span class="hljs-string">"*,:x"</span>);
          rbuggyQSA.push(<span class="hljs-string">",.*:"</span>);
        });
      }

      <span class="hljs-keyword">if</span> ((support.matchesSelector = rnative.test((matches = docElem.matches ||
        docElem.webkitMatchesSelector ||
        docElem.mozMatchesSelector ||
        docElem.oMatchesSelector ||
        docElem.msMatchesSelector)))) {

        assert(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">div</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <p>Check to see if its possible to do matchesSelector
on a disconnected node (IE 9)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          support.disconnectedMatch = matches.call(div, <span class="hljs-string">"div"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <p>This should fail with an exception
Gecko does not error, returns false instead</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          matches.call(div, <span class="hljs-string">"[s!='']:x"</span>);
          rbuggyMatches.push(<span class="hljs-string">"!="</span>, pseudos);
        });
      }

      rbuggyQSA = rbuggyQSA.length &amp;&amp; <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(rbuggyQSA.join(<span class="hljs-string">"|"</span>));
      rbuggyMatches = rbuggyMatches.length &amp;&amp; <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(rbuggyMatches.join(<span class="hljs-string">"|"</span>));

      <span class="hljs-comment">/* Contains
      ---------------------------------------------------------------------- */</span>
      hasCompare = rnative.test(docElem.compareDocumentPosition);</pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>
              <p>Element contains another
Purposefully does not implement inclusive descendent
As in, an element does not contain itself</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      contains = hasCompare || rnative.test(docElem.contains) ?
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
          <span class="hljs-keyword">var</span> adown = a.nodeType === <span class="hljs-number">9</span> ? a.documentElement : a,
            bup = b &amp;&amp; b.parentNode;
          <span class="hljs-keyword">return</span> a === bup || !!(bup &amp;&amp; bup.nodeType === <span class="hljs-number">1</span> &amp;&amp; (
            adown.contains ?
              adown.contains(bup) :
              a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition(bup) &amp; <span class="hljs-number">16</span>
          ));
        } :
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
          <span class="hljs-keyword">if</span> (b) {
            <span class="hljs-keyword">while</span> ((b = b.parentNode)) {
              <span class="hljs-keyword">if</span> (b === a) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              }
            }
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        };

      <span class="hljs-comment">/* Sorting
      ---------------------------------------------------------------------- */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <p>Document order sorting</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      sortOrder = hasCompare ?
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <p>Flag for duplicate removal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (a === b) {
            hasDuplicate = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>
              <p>Sort on method existence if only one input has compareDocumentPosition</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
          <span class="hljs-keyword">if</span> (compare) {
            <span class="hljs-keyword">return</span> compare;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>
              <p>Calculate position if both inputs belong to the same document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
            a.compareDocumentPosition(b) :</pre></div></div>
            
        </li>
        
        
        <li id="section-157">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-157">&#182;</a>
              </div>
              <p>Otherwise we know they are disconnected</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-158">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-158">&#182;</a>
              </div>
              <p>Disconnected nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (compare &amp; <span class="hljs-number">1</span> ||
            (!support.sortDetached &amp;&amp; b.compareDocumentPosition(a) === compare)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-159">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-159">&#182;</a>
              </div>
              <p>Choose the first element that is related to our preferred document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (a === doc || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, a)) {
              <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
            }
            <span class="hljs-keyword">if</span> (b === doc || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, b)) {
              <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-160">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-160">&#182;</a>
              </div>
              <p>Maintain original order</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> sortInput ?
              (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
              <span class="hljs-number">0</span>;
          }

          <span class="hljs-keyword">return</span> compare &amp; <span class="hljs-number">4</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;
        } :
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-161">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-161">&#182;</a>
              </div>
              <p>Exit early if the nodes are identical</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (a === b) {
            hasDuplicate = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
          }

          <span class="hljs-keyword">var</span> cur,
            i = <span class="hljs-number">0</span>,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b];</pre></div></div>
            
        </li>
        
        
        <li id="section-162">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-162">&#182;</a>
              </div>
              <p>Parentless nodes are either documents or disconnected</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!aup || !bup) {
            <span class="hljs-keyword">return</span> a === doc ? <span class="hljs-number">-1</span> :
              b === doc ? <span class="hljs-number">1</span> :
                aup ? <span class="hljs-number">-1</span> :
                  bup ? <span class="hljs-number">1</span> :
                    sortInput ?
                      (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
                      <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-163">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-163">&#182;</a>
              </div>
              <p>If the nodes are siblings, we can do a quick check</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aup === bup) {
            <span class="hljs-keyword">return</span> siblingCheck(a, b);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-164">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-164">&#182;</a>
              </div>
              <p>Otherwise we need full lists of their ancestors for comparison</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          cur = a;
          <span class="hljs-keyword">while</span> ((cur = cur.parentNode)) {
            ap.unshift(cur);
          }
          cur = b;
          <span class="hljs-keyword">while</span> ((cur = cur.parentNode)) {
            bp.unshift(cur);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-165">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-165">&#182;</a>
              </div>
              <p>Walk down the tree looking for a discrepancy</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">while</span> (ap[i] === bp[i]) {
            i++;
          }

          <span class="hljs-keyword">return</span> i ?</pre></div></div>
            
        </li>
        
        
        <li id="section-166">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-166">&#182;</a>
              </div>
              <p>Do a sibling check if the nodes have a common ancestor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            siblingCheck(ap[i], bp[i]) :</pre></div></div>
            
        </li>
        
        
        <li id="section-167">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-167">&#182;</a>
              </div>
              <p>Otherwise nodes in our document sort first</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            ap[i] === preferredDoc ? <span class="hljs-number">-1</span> :
              bp[i] === preferredDoc ? <span class="hljs-number">1</span> :
                <span class="hljs-number">0</span>;
        };

      <span class="hljs-keyword">return</span> doc;
    };

    Sizzle.matches = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">expr, elements</span>) </span>{
      <span class="hljs-keyword">return</span> Sizzle(expr, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, elements);
    };

    Sizzle.matchesSelector = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, expr</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-168">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-168">&#182;</a>
              </div>
              <p>Set document vars if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((elem.ownerDocument || elem) !== <span class="hljs-built_in">document</span>) {
        setDocument(elem);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-169">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-169">&#182;</a>
              </div>
              <p>Make sure that attribute selectors are quoted</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      expr = expr.replace(rattributeQuotes, <span class="hljs-string">"='$1']"</span>);

      <span class="hljs-keyword">if</span> (support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;
        (!rbuggyMatches || !rbuggyMatches.test(expr)) &amp;&amp;
        (!rbuggyQSA || !rbuggyQSA.test(expr))) {

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">var</span> ret = matches.call(elem, expr);</pre></div></div>
            
        </li>
        
        
        <li id="section-170">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-170">&#182;</a>
              </div>
              <p>IE 9s matchesSelector returns false on disconnected nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (ret || support.disconnectedMatch ||</pre></div></div>
            
        </li>
        
        
        <li id="section-171">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-171">&#182;</a>
              </div>
              <p>As well, disconnected nodes are said to be in a document
fragment in IE 9</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            elem.document &amp;&amp; elem.document.nodeType !== <span class="hljs-number">11</span>) {
            <span class="hljs-keyword">return</span> ret;
          }
        } <span class="hljs-keyword">catch</span> (e) { }
      }

      <span class="hljs-keyword">return</span> Sizzle(expr, <span class="hljs-built_in">document</span>, <span class="hljs-literal">null</span>, [elem]).length &gt; <span class="hljs-number">0</span>;
    };

    Sizzle.contains = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, elem</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-172">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-172">&#182;</a>
              </div>
              <p>Set document vars if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((context.ownerDocument || context) !== <span class="hljs-built_in">document</span>) {
        setDocument(context);
      }
      <span class="hljs-keyword">return</span> contains(context, elem);
    };

    Sizzle.attr = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, name</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-173">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-173">&#182;</a>
              </div>
              <p>Set document vars if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((elem.ownerDocument || elem) !== <span class="hljs-built_in">document</span>) {
        setDocument(elem);
      }

      <span class="hljs-keyword">var</span> fn = Expr.attrHandle[name.toLowerCase()],</pre></div></div>
            
        </li>
        
        
        <li id="section-174">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-174">&#182;</a>
              </div>
              <p>Dont get fooled by Object.prototype properties (jQuery #13807)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        val = fn &amp;&amp; hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
          fn(elem, name, !documentIsHTML) :
          <span class="hljs-literal">undefined</span>;

      <span class="hljs-keyword">return</span> val !== <span class="hljs-literal">undefined</span> ?
        val :
        support.attributes || !documentIsHTML ?
          elem.getAttribute(name) :
          (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
            val.value :
            <span class="hljs-literal">null</span>;
    };

    Sizzle.error = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>{
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Syntax error, unrecognized expression: "</span> + msg);
    };

    <span class="hljs-comment">/**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */</span>
    Sizzle.uniqueSort = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">results</span>) </span>{
      <span class="hljs-keyword">var</span> elem,
        duplicates = [],
        j = <span class="hljs-number">0</span>,
        i = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-175">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-175">&#182;</a>
              </div>
              <p>Unless we <em>know</em> we can detect duplicates, assume their presence</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable &amp;&amp; results.slice(<span class="hljs-number">0</span>);
      results.sort(sortOrder);

      <span class="hljs-keyword">if</span> (hasDuplicate) {
        <span class="hljs-keyword">while</span> ((elem = results[i++])) {
          <span class="hljs-keyword">if</span> (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        <span class="hljs-keyword">while</span> (j--) {
          results.splice(duplicates[j], <span class="hljs-number">1</span>);
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-176">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-176">&#182;</a>
              </div>
              <p>Clear input after sorting to release objects
See <a href="https://github.com/jquery/sizzle/pull/225">https://github.com/jquery/sizzle/pull/225</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      sortInput = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">return</span> results;
    };

    <span class="hljs-comment">/**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */</span>
    getText = Sizzle.getText = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
      <span class="hljs-keyword">var</span> node,
        ret = <span class="hljs-string">""</span>,
        i = <span class="hljs-number">0</span>,
        nodeType = elem.nodeType;

      <span class="hljs-keyword">if</span> (!nodeType) {</pre></div></div>
            
        </li>
        
        
        <li id="section-177">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-177">&#182;</a>
              </div>
              <p>If no nodeType, this is expected to be an array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">while</span> ((node = elem[i++])) {</pre></div></div>
            
        </li>
        
        
        <li id="section-178">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-178">&#182;</a>
              </div>
              <p>Do not traverse comment nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          ret += getText(node);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeType === <span class="hljs-number">1</span> || nodeType === <span class="hljs-number">9</span> || nodeType === <span class="hljs-number">11</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-179">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-179">&#182;</a>
              </div>
              <p>Use textContent for elements
innerText usage removed for consistency of new lines (jQuery #11153)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> elem.textContent === <span class="hljs-string">"string"</span>) {
          <span class="hljs-keyword">return</span> elem.textContent;
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-180">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-180">&#182;</a>
              </div>
              <p>Traverse its children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeType === <span class="hljs-number">3</span> || nodeType === <span class="hljs-number">4</span>) {
        <span class="hljs-keyword">return</span> elem.nodeValue;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-181">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-181">&#182;</a>
              </div>
              <p>Do not include comment or processing instruction nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">return</span> ret;
    };

    Expr = Sizzle.selectors = {</pre></div></div>
            
        </li>
        
        
        <li id="section-182">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-182">&#182;</a>
              </div>
              <p>Can be adjusted by the user</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      cacheLength: <span class="hljs-number">50</span>,

      <span class="hljs-attr">createPseudo</span>: markFunction,

      <span class="hljs-attr">match</span>: matchExpr,

      <span class="hljs-attr">attrHandle</span>: {},

      <span class="hljs-attr">find</span>: {},

      <span class="hljs-attr">relative</span>: {
        <span class="hljs-string">"&gt;"</span>: { <span class="hljs-attr">dir</span>: <span class="hljs-string">"parentNode"</span>, <span class="hljs-attr">first</span>: <span class="hljs-literal">true</span> },
        <span class="hljs-string">" "</span>: { <span class="hljs-attr">dir</span>: <span class="hljs-string">"parentNode"</span> },
        <span class="hljs-string">"+"</span>: { <span class="hljs-attr">dir</span>: <span class="hljs-string">"previousSibling"</span>, <span class="hljs-attr">first</span>: <span class="hljs-literal">true</span> },
        <span class="hljs-string">"~"</span>: { <span class="hljs-attr">dir</span>: <span class="hljs-string">"previousSibling"</span> }
      },

      <span class="hljs-attr">preFilter</span>: {
        <span class="hljs-string">"ATTR"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match</span>) </span>{
          match[<span class="hljs-number">1</span>] = match[<span class="hljs-number">1</span>].replace(runescape, funescape);</pre></div></div>
            
        </li>
        
        
        <li id="section-183">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-183">&#182;</a>
              </div>
              <p>Move the given value to match[3] whether quoted or unquoted</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          match[<span class="hljs-number">3</span>] = (match[<span class="hljs-number">3</span>] || match[<span class="hljs-number">4</span>] || match[<span class="hljs-number">5</span>] || <span class="hljs-string">""</span>).replace(runescape, funescape);

          <span class="hljs-keyword">if</span> (match[<span class="hljs-number">2</span>] === <span class="hljs-string">"~="</span>) {
            match[<span class="hljs-number">3</span>] = <span class="hljs-string">" "</span> + match[<span class="hljs-number">3</span>] + <span class="hljs-string">" "</span>;
          }

          <span class="hljs-keyword">return</span> match.slice(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>);
        },

        <span class="hljs-string">"CHILD"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match</span>) </span>{
          <span class="hljs-comment">/* matches from matchExpr["CHILD"]
            1 type (only|nth|...)
            2 what (child|of-type)
            3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
            4 xn-component of xn+y argument ([+-]?\d*n|)
            5 sign of xn-component
            6 x of xn-component
            7 sign of y-component
            8 y of y-component
          */</span>
          match[<span class="hljs-number">1</span>] = match[<span class="hljs-number">1</span>].toLowerCase();

          <span class="hljs-keyword">if</span> (match[<span class="hljs-number">1</span>].slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) === <span class="hljs-string">"nth"</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-184">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-184">&#182;</a>
              </div>
              <p>nth-* requires argument</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!match[<span class="hljs-number">3</span>]) {
              Sizzle.error(match[<span class="hljs-number">0</span>]);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-185">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-185">&#182;</a>
              </div>
              <p>numeric x and y parameters for Expr.filter.CHILD
remember that false/true cast respectively to 0/1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            match[<span class="hljs-number">4</span>] = +(match[<span class="hljs-number">4</span>] ? match[<span class="hljs-number">5</span>] + (match[<span class="hljs-number">6</span>] || <span class="hljs-number">1</span>) : <span class="hljs-number">2</span> * (match[<span class="hljs-number">3</span>] === <span class="hljs-string">"even"</span> || match[<span class="hljs-number">3</span>] === <span class="hljs-string">"odd"</span>));
            match[<span class="hljs-number">5</span>] = +((match[<span class="hljs-number">7</span>] + match[<span class="hljs-number">8</span>]) || match[<span class="hljs-number">3</span>] === <span class="hljs-string">"odd"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-186">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-186">&#182;</a>
              </div>
              <p>other types prohibit arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match[<span class="hljs-number">3</span>]) {
            Sizzle.error(match[<span class="hljs-number">0</span>]);
          }

          <span class="hljs-keyword">return</span> match;
        },

        <span class="hljs-string">"PSEUDO"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match</span>) </span>{
          <span class="hljs-keyword">var</span> excess,
            unquoted = !match[<span class="hljs-number">6</span>] &amp;&amp; match[<span class="hljs-number">2</span>];

          <span class="hljs-keyword">if</span> (matchExpr[<span class="hljs-string">"CHILD"</span>].test(match[<span class="hljs-number">0</span>])) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-187">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-187">&#182;</a>
              </div>
              <p>Accept quoted arguments as-is</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (match[<span class="hljs-number">3</span>]) {
            match[<span class="hljs-number">2</span>] = match[<span class="hljs-number">4</span>] || match[<span class="hljs-number">5</span>] || <span class="hljs-string">""</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-188">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-188">&#182;</a>
              </div>
              <p>Strip excess characters from unquoted arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unquoted &amp;&amp; rpseudo.test(unquoted) &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-189">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-189">&#182;</a>
              </div>
              <p>Get excess from tokenize (recursively)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            (excess = tokenize(unquoted, <span class="hljs-literal">true</span>)) &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-190">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-190">&#182;</a>
              </div>
              <p>advance to the next closing parenthesis</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            (excess = unquoted.indexOf(<span class="hljs-string">")"</span>, unquoted.length - excess) - unquoted.length)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-191">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-191">&#182;</a>
              </div>
              <p>excess is a negative index</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            match[<span class="hljs-number">0</span>] = match[<span class="hljs-number">0</span>].slice(<span class="hljs-number">0</span>, excess);
            match[<span class="hljs-number">2</span>] = unquoted.slice(<span class="hljs-number">0</span>, excess);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-192">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-192">&#182;</a>
              </div>
              <p>Return only captures needed by the pseudo filter method (type and argument)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> match.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
        }
      },

      <span class="hljs-attr">filter</span>: {

        <span class="hljs-string">"TAG"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodeNameSelector</span>) </span>{
          <span class="hljs-keyword">var</span> nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          <span class="hljs-keyword">return</span> nodeNameSelector === <span class="hljs-string">"*"</span> ?
            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; } :
            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
              <span class="hljs-keyword">return</span> elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
            };
        },

        <span class="hljs-string">"CLASS"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">className</span>) </span>{
          <span class="hljs-keyword">var</span> pattern = classCache[className + <span class="hljs-string">" "</span>];

          <span class="hljs-keyword">return</span> pattern ||
            (pattern = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"(^|"</span> + whitespace + <span class="hljs-string">")"</span> + className + <span class="hljs-string">"("</span> + whitespace + <span class="hljs-string">"|$)"</span>)) &amp;&amp;
            classCache(className, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
              <span class="hljs-keyword">return</span> pattern.test(<span class="hljs-keyword">typeof</span> elem.className === <span class="hljs-string">"string"</span> &amp;&amp; elem.className || <span class="hljs-keyword">typeof</span> elem.getAttribute !== strundefined &amp;&amp; elem.getAttribute(<span class="hljs-string">"class"</span>) || <span class="hljs-string">""</span>);
            });
        },

        <span class="hljs-string">"ATTR"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, operator, check</span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
            <span class="hljs-keyword">var</span> result = Sizzle.attr(elem, name);

            <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">return</span> operator === <span class="hljs-string">"!="</span>;
            }
            <span class="hljs-keyword">if</span> (!operator) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            result += <span class="hljs-string">""</span>;

            <span class="hljs-keyword">return</span> operator === <span class="hljs-string">"="</span> ? result === check :
              operator === <span class="hljs-string">"!="</span> ? result !== check :
                operator === <span class="hljs-string">"^="</span> ? check &amp;&amp; result.indexOf(check) === <span class="hljs-number">0</span> :
                  operator === <span class="hljs-string">"*="</span> ? check &amp;&amp; result.indexOf(check) &gt; <span class="hljs-number">-1</span> :
                    operator === <span class="hljs-string">"$="</span> ? check &amp;&amp; result.slice(-check.length) === check :
                      operator === <span class="hljs-string">"~="</span> ? (<span class="hljs-string">" "</span> + result + <span class="hljs-string">" "</span>).indexOf(check) &gt; <span class="hljs-number">-1</span> :
                        operator === <span class="hljs-string">"|="</span> ? result === check || result.slice(<span class="hljs-number">0</span>, check.length + <span class="hljs-number">1</span>) === check + <span class="hljs-string">"-"</span> :
                          <span class="hljs-literal">false</span>;
          };
        },

        <span class="hljs-string">"CHILD"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, what, argument, first, last</span>) </span>{
          <span class="hljs-keyword">var</span> simple = type.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) !== <span class="hljs-string">"nth"</span>,
            forward = type.slice(<span class="hljs-number">-4</span>) !== <span class="hljs-string">"last"</span>,
            ofType = what === <span class="hljs-string">"of-type"</span>;

          <span class="hljs-keyword">return</span> first === <span class="hljs-number">1</span> &amp;&amp; last === <span class="hljs-number">0</span> ?</pre></div></div>
            
        </li>
        
        
        <li id="section-193">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-193">&#182;</a>
              </div>
              <p>Shortcut for :nth-*(n)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
              <span class="hljs-keyword">return</span> !!elem.parentNode;
            } :

            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, context, xml</span>) </span>{
              <span class="hljs-keyword">var</span> cache, outerCache, node, diff, nodeIndex, start,
                dir = simple !== forward ? <span class="hljs-string">"nextSibling"</span> : <span class="hljs-string">"previousSibling"</span>,
                parent = elem.parentNode,
                name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
                useCache = !xml &amp;&amp; !ofType;

              <span class="hljs-keyword">if</span> (parent) {</pre></div></div>
            
        </li>
        
        
        <li id="section-194">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-194">&#182;</a>
              </div>
              <p>:(first|last|only)-(child|of-type)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (simple) {
                  <span class="hljs-keyword">while</span> (dir) {
                    node = elem;
                    <span class="hljs-keyword">while</span> ((node = node[dir])) {
                      <span class="hljs-keyword">if</span> (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === <span class="hljs-number">1</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                      }
                    }</pre></div></div>
            
        </li>
        
        
        <li id="section-195">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-195">&#182;</a>
              </div>
              <p>Reverse direction for :only-* (if we havent yet done so)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    start = dir = type === <span class="hljs-string">"only"</span> &amp;&amp; !start &amp;&amp; <span class="hljs-string">"nextSibling"</span>;
                  }
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }

                start = [forward ? parent.firstChild : parent.lastChild];</pre></div></div>
            
        </li>
        
        
        <li id="section-196">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-196">&#182;</a>
              </div>
              <p>non-xml :nth-child() stores cache data on <code>parent</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (forward &amp;&amp; useCache) {</pre></div></div>
            
        </li>
        
        
        <li id="section-197">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-197">&#182;</a>
              </div>
              <p>Seek <code>elem</code> from a previously-cached index</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  outerCache = parent[expando] || (parent[expando] = {});
                  cache = outerCache[type] || [];
                  nodeIndex = cache[<span class="hljs-number">0</span>] === dirruns &amp;&amp; cache[<span class="hljs-number">1</span>];
                  diff = cache[<span class="hljs-number">0</span>] === dirruns &amp;&amp; cache[<span class="hljs-number">2</span>];
                  node = nodeIndex &amp;&amp; parent.childNodes[nodeIndex];

                  <span class="hljs-keyword">while</span> ((node = ++nodeIndex &amp;&amp; node &amp;&amp; node[dir] ||</pre></div></div>
            
        </li>
        
        
        <li id="section-198">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-198">&#182;</a>
              </div>
              <p>Fallback to seeking <code>elem</code> from the start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    (diff = nodeIndex = <span class="hljs-number">0</span>) || start.pop())) {</pre></div></div>
            
        </li>
        
        
        <li id="section-199">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-199">&#182;</a>
              </div>
              <p>When found, cache indexes on <code>parent</code> and break</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span> &amp;&amp; ++diff &amp;&amp; node === elem) {
                      outerCache[type] = [dirruns, nodeIndex, diff];
                      <span class="hljs-keyword">break</span>;
                    }
                  }</pre></div></div>
            
        </li>
        
        
        <li id="section-200">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-200">&#182;</a>
              </div>
              <p>Use previously-cached element index if available</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (useCache &amp;&amp; (cache = (elem[expando] || (elem[expando] = {}))[type]) &amp;&amp; cache[<span class="hljs-number">0</span>] === dirruns) {
                  diff = cache[<span class="hljs-number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-201">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-201">&#182;</a>
              </div>
              <p>xml :nth-child() or :nth-last-child() or :nth(-last)?-of-type()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-202">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-202">&#182;</a>
              </div>
              <p>Use the same loop as above to seek <code>elem</code> from the start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">while</span> ((node = ++nodeIndex &amp;&amp; node &amp;&amp; node[dir] ||
                    (diff = nodeIndex = <span class="hljs-number">0</span>) || start.pop())) {

                    <span class="hljs-keyword">if</span> ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === <span class="hljs-number">1</span>) &amp;&amp; ++diff) {</pre></div></div>
            
        </li>
        
        
        <li id="section-203">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-203">&#182;</a>
              </div>
              <p>Cache the index of each encountered element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                      <span class="hljs-keyword">if</span> (useCache) {
                        (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                      }

                      <span class="hljs-keyword">if</span> (node === elem) {
                        <span class="hljs-keyword">break</span>;
                      }
                    }
                  }
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-204">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-204">&#182;</a>
              </div>
              <p>Incorporate the offset, then check against cycle size</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                diff -= last;
                <span class="hljs-keyword">return</span> diff === first || (diff % first === <span class="hljs-number">0</span> &amp;&amp; diff / first &gt;= <span class="hljs-number">0</span>);
              }
            };
        },

        <span class="hljs-string">"PSEUDO"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pseudo, argument</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-205">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-205">&#182;</a>
              </div>
              <p>pseudo-class names are case-insensitive
<a href="http://www.w3.org/TR/selectors/#pseudo-classes">http://www.w3.org/TR/selectors/#pseudo-classes</a>
Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
Remember that setFilters inherits from pseudos</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> args,
            fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
              Sizzle.error(<span class="hljs-string">"unsupported pseudo: "</span> + pseudo);</pre></div></div>
            
        </li>
        
        
        <li id="section-206">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-206">&#182;</a>
              </div>
              <p>The user may use createPseudo to indicate that
arguments are needed to create the filter function
just as Sizzle does</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (fn[expando]) {
            <span class="hljs-keyword">return</span> fn(argument);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-207">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-207">&#182;</a>
              </div>
              <p>But maintain support for old signatures</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (fn.length &gt; <span class="hljs-number">1</span>) {
            args = [pseudo, pseudo, <span class="hljs-string">""</span>, argument];
            <span class="hljs-keyword">return</span> Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
              markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">seed, matches</span>) </span>{
                <span class="hljs-keyword">var</span> idx,
                  matched = fn(seed, argument),
                  i = matched.length;
                <span class="hljs-keyword">while</span> (i--) {
                  idx = indexOf.call(seed, matched[i]);
                  seed[idx] = !(matches[idx] = matched[i]);
                }
              }) :
              <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
                <span class="hljs-keyword">return</span> fn(elem, <span class="hljs-number">0</span>, args);
              };
          }

          <span class="hljs-keyword">return</span> fn;
        }
      },

      <span class="hljs-attr">pseudos</span>: {</pre></div></div>
            
        </li>
        
        
        <li id="section-208">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-208">&#182;</a>
              </div>
              <p>Potentially complex pseudos</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"not"</span>: markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-209">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-209">&#182;</a>
              </div>
              <p>Trim the selector passed to compile
to avoid treating leading and trailing
spaces as combinators</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> input = [],
            results = [],
            matcher = compile(selector.replace(rtrim, <span class="hljs-string">"$1"</span>));

          <span class="hljs-keyword">return</span> matcher[expando] ?
            markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">seed, matches, context, xml</span>) </span>{
              <span class="hljs-keyword">var</span> elem,
                unmatched = matcher(seed, <span class="hljs-literal">null</span>, xml, []),
                i = seed.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-210">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-210">&#182;</a>
              </div>
              <p>Match elements unmatched by <code>matcher</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">while</span> (i--) {
                <span class="hljs-keyword">if</span> ((elem = unmatched[i])) {
                  seed[i] = !(matches[i] = elem);
                }
              }
            }) :
            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, context, xml</span>) </span>{
              input[<span class="hljs-number">0</span>] = elem;
              matcher(input, <span class="hljs-literal">null</span>, xml, results);
              <span class="hljs-keyword">return</span> !results.pop();
            };
        }),

        <span class="hljs-string">"has"</span>: markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
            <span class="hljs-keyword">return</span> Sizzle(selector, elem).length &gt; <span class="hljs-number">0</span>;
          };
        }),

        <span class="hljs-string">"contains"</span>: markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
          text = text.replace(runescape, funescape);
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
            <span class="hljs-keyword">return</span> (elem.textContent || elem.innerText || getText(elem)).indexOf(text) &gt; <span class="hljs-number">-1</span>;
          };
        }),</pre></div></div>
            
        </li>
        
        
        <li id="section-211">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-211">&#182;</a>
              </div>
              <p>Whether an element is represented by a :lang() selector
is based solely on the elements language value
being equal to the identifier C,
or beginning with the identifier C immediately followed by -.
The matching of C against the elements language value is performed case-insensitively.
The identifier C does not have to be a valid language name.
<a href="http://www.w3.org/TR/selectors/#lang-pseudo">http://www.w3.org/TR/selectors/#lang-pseudo</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"lang"</span>: markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">lang</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-212">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-212">&#182;</a>
              </div>
              <p>lang value must be a valid identifier</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!ridentifier.test(lang || <span class="hljs-string">""</span>)) {
            Sizzle.error(<span class="hljs-string">"unsupported lang: "</span> + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
            <span class="hljs-keyword">var</span> elemLang;
            <span class="hljs-keyword">do</span> {
              <span class="hljs-keyword">if</span> ((elemLang = documentIsHTML ?
                elem.lang :
                elem.getAttribute(<span class="hljs-string">"xml:lang"</span>) || elem.getAttribute(<span class="hljs-string">"lang"</span>))) {

                elemLang = elemLang.toLowerCase();
                <span class="hljs-keyword">return</span> elemLang === lang || elemLang.indexOf(lang + <span class="hljs-string">"-"</span>) === <span class="hljs-number">0</span>;
              }
            } <span class="hljs-keyword">while</span> ((elem = elem.parentNode) &amp;&amp; elem.nodeType === <span class="hljs-number">1</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          };
        }),</pre></div></div>
            
        </li>
        
        
        <li id="section-213">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-213">&#182;</a>
              </div>
              <p>Miscellaneous</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"target"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
          <span class="hljs-keyword">var</span> hash = <span class="hljs-built_in">window</span>.location &amp;&amp; <span class="hljs-built_in">window</span>.location.hash;
          <span class="hljs-keyword">return</span> hash &amp;&amp; hash.slice(<span class="hljs-number">1</span>) === elem.id;
        },

        <span class="hljs-string">"root"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
          <span class="hljs-keyword">return</span> elem === docElem;
        },

        <span class="hljs-string">"focus"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
          <span class="hljs-keyword">return</span> elem === <span class="hljs-built_in">document</span>.activeElement &amp;&amp; (!<span class="hljs-built_in">document</span>.hasFocus || <span class="hljs-built_in">document</span>.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-214">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-214">&#182;</a>
              </div>
              <p>Boolean properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"enabled"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
          <span class="hljs-keyword">return</span> elem.disabled === <span class="hljs-literal">false</span>;
        },

        <span class="hljs-string">"disabled"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
          <span class="hljs-keyword">return</span> elem.disabled === <span class="hljs-literal">true</span>;
        },

        <span class="hljs-string">"checked"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-215">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-215">&#182;</a>
              </div>
              <p>In CSS3, :checked should return both checked and selected elements
<a href="http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked">http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> nodeName = elem.nodeName.toLowerCase();
          <span class="hljs-keyword">return</span> (nodeName === <span class="hljs-string">"input"</span> &amp;&amp; !!elem.checked) || (nodeName === <span class="hljs-string">"option"</span> &amp;&amp; !!elem.selected);
        },

        <span class="hljs-string">"selected"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-216">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-216">&#182;</a>
              </div>
              <p>Accessing this property makes selected-by-default
options in Safari work properly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }

          <span class="hljs-keyword">return</span> elem.selected === <span class="hljs-literal">true</span>;
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-217">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-217">&#182;</a>
              </div>
              <p>Contents</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"empty"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-218">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-218">&#182;</a>
              </div>
              <p><a href="http://www.w3.org/TR/selectors/#empty-pseudo">http://www.w3.org/TR/selectors/#empty-pseudo</a>
:empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
  but not by others (comment: 8; processing instruction: 7; etc.)
nodeType &lt; 6 works because attributes (2) do not appear as children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            <span class="hljs-keyword">if</span> (elem.nodeType &lt; <span class="hljs-number">6</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        },

        <span class="hljs-string">"parent"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
          <span class="hljs-keyword">return</span> !Expr.pseudos[<span class="hljs-string">"empty"</span>](elem);
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-219">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-219">&#182;</a>
              </div>
              <p>Element/input types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"header"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
          <span class="hljs-keyword">return</span> rheader.test(elem.nodeName);
        },

        <span class="hljs-string">"input"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
          <span class="hljs-keyword">return</span> rinputs.test(elem.nodeName);
        },

        <span class="hljs-string">"button"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
          <span class="hljs-keyword">var</span> name = elem.nodeName.toLowerCase();
          <span class="hljs-keyword">return</span> name === <span class="hljs-string">"input"</span> &amp;&amp; elem.type === <span class="hljs-string">"button"</span> || name === <span class="hljs-string">"button"</span>;
        },

        <span class="hljs-string">"text"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
          <span class="hljs-keyword">var</span> attr;
          <span class="hljs-keyword">return</span> elem.nodeName.toLowerCase() === <span class="hljs-string">"input"</span> &amp;&amp;
            elem.type === <span class="hljs-string">"text"</span> &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-220">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-220">&#182;</a>
              </div>
              <p>Support: IE&lt;8
New HTML5 attribute values (e.g., search) appear with elem.type === text</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            ((attr = elem.getAttribute(<span class="hljs-string">"type"</span>)) == <span class="hljs-literal">null</span> || attr.toLowerCase() === <span class="hljs-string">"text"</span>);
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-221">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-221">&#182;</a>
              </div>
              <p>Position-in-collection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"first"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>];
        }),

        <span class="hljs-string">"last"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matchIndexes, length</span>) </span>{
          <span class="hljs-keyword">return</span> [length - <span class="hljs-number">1</span>];
        }),

        <span class="hljs-string">"eq"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matchIndexes, length, argument</span>) </span>{
          <span class="hljs-keyword">return</span> [argument &lt; <span class="hljs-number">0</span> ? argument + length : argument];
        }),

        <span class="hljs-string">"even"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matchIndexes, length</span>) </span>{
          <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">for</span> (; i &lt; length; i += <span class="hljs-number">2</span>) {
            matchIndexes.push(i);
          }
          <span class="hljs-keyword">return</span> matchIndexes;
        }),

        <span class="hljs-string">"odd"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matchIndexes, length</span>) </span>{
          <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;
          <span class="hljs-keyword">for</span> (; i &lt; length; i += <span class="hljs-number">2</span>) {
            matchIndexes.push(i);
          }
          <span class="hljs-keyword">return</span> matchIndexes;
        }),

        <span class="hljs-string">"lt"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matchIndexes, length, argument</span>) </span>{
          <span class="hljs-keyword">var</span> i = argument &lt; <span class="hljs-number">0</span> ? argument + length : argument;
          <span class="hljs-keyword">for</span> (; --i &gt;= <span class="hljs-number">0</span>;) {
            matchIndexes.push(i);
          }
          <span class="hljs-keyword">return</span> matchIndexes;
        }),

        <span class="hljs-string">"gt"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matchIndexes, length, argument</span>) </span>{
          <span class="hljs-keyword">var</span> i = argument &lt; <span class="hljs-number">0</span> ? argument + length : argument;
          <span class="hljs-keyword">for</span> (; ++i &lt; length;) {
            matchIndexes.push(i);
          }
          <span class="hljs-keyword">return</span> matchIndexes;
        })
      }
    };

    Expr.pseudos[<span class="hljs-string">"nth"</span>] = Expr.pseudos[<span class="hljs-string">"eq"</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-222">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-222">&#182;</a>
              </div>
              <p>Add button/input type pseudos</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> { <span class="hljs-attr">radio</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">checkbox</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">file</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">password</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">image</span>: <span class="hljs-literal">true</span> }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> { <span class="hljs-attr">submit</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">reset</span>: <span class="hljs-literal">true</span> }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-223">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-223">&#182;</a>
              </div>
              <p>Easy API for creating new setFilters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setFilters</span>(<span class="hljs-params"></span>) </span>{ }
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = <span class="hljs-keyword">new</span> setFilters();

    tokenize = Sizzle.tokenize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector, parseOnly</span>) </span>{
      <span class="hljs-keyword">var</span> matched, match, tokens, type,
        soFar, groups, preFilters,
        cached = tokenCache[selector + <span class="hljs-string">" "</span>];

      <span class="hljs-keyword">if</span> (cached) {
        <span class="hljs-keyword">return</span> parseOnly ? <span class="hljs-number">0</span> : cached.slice(<span class="hljs-number">0</span>);
      }

      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;

      <span class="hljs-keyword">while</span> (soFar) {</pre></div></div>
            
        </li>
        
        
        <li id="section-224">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-224">&#182;</a>
              </div>
              <p>Comma and first run</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!matched || (match = rcomma.exec(soFar))) {
          <span class="hljs-keyword">if</span> (match) {</pre></div></div>
            
        </li>
        
        
        <li id="section-225">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-225">&#182;</a>
              </div>
              <p>Dont consume trailing commas as valid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            soFar = soFar.slice(match[<span class="hljs-number">0</span>].length) || soFar;
          }
          groups.push((tokens = []));
        }

        matched = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-226">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-226">&#182;</a>
              </div>
              <p>Combinators</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            <span class="hljs-attr">value</span>: matched,</pre></div></div>
            
        </li>
        
        
        <li id="section-227">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-227">&#182;</a>
              </div>
              <p>Cast descendant combinators to space</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            type: match[<span class="hljs-number">0</span>].replace(rtrim, <span class="hljs-string">" "</span>)
          });
          soFar = soFar.slice(matched.length);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-228">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-228">&#182;</a>
              </div>
              <p>Filters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (type <span class="hljs-keyword">in</span> Expr.filter) {
          <span class="hljs-keyword">if</span> ((match = matchExpr[type].exec(soFar)) &amp;&amp; (!preFilters[type] ||
            (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              <span class="hljs-attr">value</span>: matched,
              <span class="hljs-attr">type</span>: type,
              <span class="hljs-attr">matches</span>: match
            });
            soFar = soFar.slice(matched.length);
          }
        }

        <span class="hljs-keyword">if</span> (!matched) {
          <span class="hljs-keyword">break</span>;
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-229">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-229">&#182;</a>
              </div>
              <p>Return the length of the invalid excess
if were just parsing
Otherwise, throw an error or return tokens</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> parseOnly ?
        soFar.length :
        soFar ?
          Sizzle.error(selector) :</pre></div></div>
            
        </li>
        
        
        <li id="section-230">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-230">&#182;</a>
              </div>
              <p>Cache the tokens</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          tokenCache(selector, groups).slice(<span class="hljs-number">0</span>);
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toSelector</span>(<span class="hljs-params">tokens</span>) </span>{
      <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
        len = tokens.length,
        selector = <span class="hljs-string">""</span>;
      <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
        selector += tokens[i].value;
      }
      <span class="hljs-keyword">return</span> selector;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCombinator</span>(<span class="hljs-params">matcher, combinator, base</span>) </span>{
      <span class="hljs-keyword">var</span> dir = combinator.dir,
        checkNonElements = base &amp;&amp; dir === <span class="hljs-string">"parentNode"</span>,
        doneName = done++;

      <span class="hljs-keyword">return</span> combinator.first ?</pre></div></div>
            
        </li>
        
        
        <li id="section-231">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-231">&#182;</a>
              </div>
              <p>Check against closest ancestor/preceding element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, context, xml</span>) </span>{
          <span class="hljs-keyword">while</span> ((elem = elem[dir])) {
            <span class="hljs-keyword">if</span> (elem.nodeType === <span class="hljs-number">1</span> || checkNonElements) {
              <span class="hljs-keyword">return</span> matcher(elem, context, xml);
            }
          }
        } :</pre></div></div>
            
        </li>
        
        
        <li id="section-232">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-232">&#182;</a>
              </div>
              <p>Check against all ancestor/preceding elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, context, xml</span>) </span>{
          <span class="hljs-keyword">var</span> oldCache, outerCache,
            newCache = [dirruns, doneName];</pre></div></div>
            
        </li>
        
        
        <li id="section-233">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-233">&#182;</a>
              </div>
              <p>We cant set arbitrary data on XML nodes, so they dont benefit from dir caching</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (xml) {
            <span class="hljs-keyword">while</span> ((elem = elem[dir])) {
              <span class="hljs-keyword">if</span> (elem.nodeType === <span class="hljs-number">1</span> || checkNonElements) {
                <span class="hljs-keyword">if</span> (matcher(elem, context, xml)) {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
              }
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">while</span> ((elem = elem[dir])) {
              <span class="hljs-keyword">if</span> (elem.nodeType === <span class="hljs-number">1</span> || checkNonElements) {
                outerCache = elem[expando] || (elem[expando] = {});
                <span class="hljs-keyword">if</span> ((oldCache = outerCache[dir]) &amp;&amp;
                  oldCache[<span class="hljs-number">0</span>] === dirruns &amp;&amp; oldCache[<span class="hljs-number">1</span>] === doneName) {</pre></div></div>
            
        </li>
        
        
        <li id="section-234">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-234">&#182;</a>
              </div>
              <p>Assign to newCache so results back-propagate to previous elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">return</span> (newCache[<span class="hljs-number">2</span>] = oldCache[<span class="hljs-number">2</span>]);
                } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-235">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-235">&#182;</a>
              </div>
              <p>Reuse newcache so results back-propagate to previous elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  outerCache[dir] = newCache;</pre></div></div>
            
        </li>
        
        
        <li id="section-236">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-236">&#182;</a>
              </div>
              <p>A match means were done; a fail means we have to keep checking</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">if</span> ((newCache[<span class="hljs-number">2</span>] = matcher(elem, context, xml))) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                  }
                }
              }
            }
          }
        };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">elementMatcher</span>(<span class="hljs-params">matchers</span>) </span>{
      <span class="hljs-keyword">return</span> matchers.length &gt; <span class="hljs-number">1</span> ?
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, context, xml</span>) </span>{
          <span class="hljs-keyword">var</span> i = matchers.length;
          <span class="hljs-keyword">while</span> (i--) {
            <span class="hljs-keyword">if</span> (!matchers[i](elem, context, xml)) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } :
        matchers[<span class="hljs-number">0</span>];
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multipleContexts</span>(<span class="hljs-params">selector, contexts, results</span>) </span>{
      <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
        len = contexts.length;
      <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      <span class="hljs-keyword">return</span> results;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">condense</span>(<span class="hljs-params">unmatched, map, filter, context, xml</span>) </span>{
      <span class="hljs-keyword">var</span> elem,
        newUnmatched = [],
        i = <span class="hljs-number">0</span>,
        len = unmatched.length,
        mapped = map != <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
        <span class="hljs-keyword">if</span> ((elem = unmatched[i])) {
          <span class="hljs-keyword">if</span> (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            <span class="hljs-keyword">if</span> (mapped) {
              map.push(i);
            }
          }
        }
      }

      <span class="hljs-keyword">return</span> newUnmatched;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setMatcher</span>(<span class="hljs-params">preFilter, selector, matcher, postFilter, postFinder, postSelector</span>) </span>{
      <span class="hljs-keyword">if</span> (postFilter &amp;&amp; !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      <span class="hljs-keyword">if</span> (postFinder &amp;&amp; !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      <span class="hljs-keyword">return</span> markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">seed, results, context, xml</span>) </span>{
        <span class="hljs-keyword">var</span> temp, i, elem,
          preMap = [],
          postMap = [],
          preexisting = results.length,</pre></div></div>
            
        </li>
        
        
        <li id="section-237">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-237">&#182;</a>
              </div>
              <p>Get initial elements from seed or context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          elems = seed || multipleContexts(selector || <span class="hljs-string">"*"</span>, context.nodeType ? [context] : context, []),</pre></div></div>
            
        </li>
        
        
        <li id="section-238">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-238">&#182;</a>
              </div>
              <p>Prefilter to get matcher input, preserving a map for seed-results synchronization</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          matcherIn = preFilter &amp;&amp; (seed || !selector) ?
            condense(elems, preMap, preFilter, context, xml) :
            elems,

          matcherOut = matcher ?</pre></div></div>
            
        </li>
        
        
        <li id="section-239">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-239">&#182;</a>
              </div>
              <p>If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            postFinder || (seed ? preFilter : preexisting || postFilter) ?</pre></div></div>
            
        </li>
        
        
        <li id="section-240">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-240">&#182;</a>
              </div>
              <p>intermediate processing is necessary</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              [] :</pre></div></div>
            
        </li>
        
        
        <li id="section-241">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-241">&#182;</a>
              </div>
              <p>otherwise use results directly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              results :
            matcherIn;</pre></div></div>
            
        </li>
        
        
        <li id="section-242">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-242">&#182;</a>
              </div>
              <p>Find primary matches</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-243">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-243">&#182;</a>
              </div>
              <p>Apply postFilter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);</pre></div></div>
            
        </li>
        
        
        <li id="section-244">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-244">&#182;</a>
              </div>
              <p>Un-match failing elements by moving them back to matcherIn</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          i = temp.length;
          <span class="hljs-keyword">while</span> (i--) {
            <span class="hljs-keyword">if</span> ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }

        <span class="hljs-keyword">if</span> (seed) {
          <span class="hljs-keyword">if</span> (postFinder || preFilter) {
            <span class="hljs-keyword">if</span> (postFinder) {</pre></div></div>
            
        </li>
        
        
        <li id="section-245">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-245">&#182;</a>
              </div>
              <p>Get the final matcherOut by condensing this intermediate into postFinder contexts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              temp = [];
              i = matcherOut.length;
              <span class="hljs-keyword">while</span> (i--) {
                <span class="hljs-keyword">if</span> ((elem = matcherOut[i])) {</pre></div></div>
            
        </li>
        
        
        <li id="section-246">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-246">&#182;</a>
              </div>
              <p>Restore matcherIn since elem is not yet a final match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(<span class="hljs-literal">null</span>, (matcherOut = []), temp, xml);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-247">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-247">&#182;</a>
              </div>
              <p>Move matched elements from seed to results to keep them synchronized</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            i = matcherOut.length;
            <span class="hljs-keyword">while</span> (i--) {
              <span class="hljs-keyword">if</span> ((elem = matcherOut[i]) &amp;&amp;
                (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) &gt; <span class="hljs-number">-1</span>) {

                seed[temp] = !(results[temp] = elem);
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-248">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-248">&#182;</a>
              </div>
              <p>Add elements to results, through postFinder if defined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        } <span class="hljs-keyword">else</span> {
          matcherOut = condense(
            matcherOut === results ?
              matcherOut.splice(preexisting, matcherOut.length) :
              matcherOut
          );
          <span class="hljs-keyword">if</span> (postFinder) {
            postFinder(<span class="hljs-literal">null</span>, results, matcherOut, xml);
          } <span class="hljs-keyword">else</span> {
            push.apply(results, matcherOut);
          }
        }
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matcherFromTokens</span>(<span class="hljs-params">tokens</span>) </span>{
      <span class="hljs-keyword">var</span> checkContext, matcher, j,
        len = tokens.length,
        leadingRelative = Expr.relative[tokens[<span class="hljs-number">0</span>].type],
        implicitRelative = leadingRelative || Expr.relative[<span class="hljs-string">" "</span>],
        i = leadingRelative ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-249">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-249">&#182;</a>
              </div>
              <p>The foundational matcher ensures that elements are reachable from top-level context(s)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        matchContext = addCombinator(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
          <span class="hljs-keyword">return</span> elem === checkContext;
        }, implicitRelative, <span class="hljs-literal">true</span>),
        matchAnyContext = addCombinator(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
          <span class="hljs-keyword">return</span> indexOf.call(checkContext, elem) &gt; <span class="hljs-number">-1</span>;
        }, implicitRelative, <span class="hljs-literal">true</span>),
        matchers = [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, context, xml</span>) </span>{
          <span class="hljs-keyword">return</span> (!leadingRelative &amp;&amp; (xml || context !== outermostContext)) || (
            (checkContext = context).nodeType ?
              matchContext(elem, context, xml) :
              matchAnyContext(elem, context, xml));
        }];

      <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
        <span class="hljs-keyword">if</span> ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } <span class="hljs-keyword">else</span> {
          matcher = Expr.filter[tokens[i].type].apply(<span class="hljs-literal">null</span>, tokens[i].matches);</pre></div></div>
            
        </li>
        
        
        <li id="section-250">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-250">&#182;</a>
              </div>
              <p>Return special upon seeing a positional matcher</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (matcher[expando]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-251">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-251">&#182;</a>
              </div>
              <p>Find the next relative operator (if any) for proper handling</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            j = ++i;
            <span class="hljs-keyword">for</span> (; j &lt; len; j++) {
              <span class="hljs-keyword">if</span> (Expr.relative[tokens[j].type]) {
                <span class="hljs-keyword">break</span>;
              }
            }
            <span class="hljs-keyword">return</span> setMatcher(
              i &gt; <span class="hljs-number">1</span> &amp;&amp; elementMatcher(matchers),
              i &gt; <span class="hljs-number">1</span> &amp;&amp; toSelector(</pre></div></div>
            
        </li>
        
        
        <li id="section-252">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-252">&#182;</a>
              </div>
              <p>If the preceding token was a descendant combinator, insert an implicit any-element <code>*</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                tokens.slice(<span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>).concat({ <span class="hljs-attr">value</span>: tokens[i - <span class="hljs-number">2</span>].type === <span class="hljs-string">" "</span> ? <span class="hljs-string">"*"</span> : <span class="hljs-string">""</span> })
              ).replace(rtrim, <span class="hljs-string">"$1"</span>),
              matcher,
              i &lt; j &amp;&amp; matcherFromTokens(tokens.slice(i, j)),
              j &lt; len &amp;&amp; matcherFromTokens((tokens = tokens.slice(j))),
              j &lt; len &amp;&amp; toSelector(tokens)
            );
          }
          matchers.push(matcher);
        }
      }

      <span class="hljs-keyword">return</span> elementMatcher(matchers);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matcherFromGroupMatchers</span>(<span class="hljs-params">elementMatchers, setMatchers</span>) </span>{
      <span class="hljs-keyword">var</span> bySet = setMatchers.length &gt; <span class="hljs-number">0</span>,
        byElement = elementMatchers.length &gt; <span class="hljs-number">0</span>,
        superMatcher = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">seed, context, xml, results, outermost</span>) </span>{
          <span class="hljs-keyword">var</span> elem, j, matcher,
            matchedCount = <span class="hljs-number">0</span>,
            i = <span class="hljs-string">"0"</span>,
            unmatched = seed &amp;&amp; [],
            setMatched = [],
            contextBackup = outermostContext,</pre></div></div>
            
        </li>
        
        
        <li id="section-253">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-253">&#182;</a>
              </div>
              <p>We must always have either seed elements or outermost context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            elems = seed || byElement &amp;&amp; Expr.find[<span class="hljs-string">"TAG"</span>](<span class="hljs-string">"*"</span>, outermost),</pre></div></div>
            
        </li>
        
        
        <li id="section-254">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-254">&#182;</a>
              </div>
              <p>Use integer dirruns iff this is the outermost matcher</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            dirrunsUnique = (dirruns += contextBackup == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : <span class="hljs-built_in">Math</span>.random() || <span class="hljs-number">0.1</span>),
            len = elems.length;

          <span class="hljs-keyword">if</span> (outermost) {
            outermostContext = context !== <span class="hljs-built_in">document</span> &amp;&amp; context;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-255">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-255">&#182;</a>
              </div>
              <p>Add elements passing elementMatchers directly to results
Keep <code>i</code> a string if there are no elements so <code>matchedCount</code> will be 00 below
Support: IE<9, Safari
Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (; i !== len &amp;&amp; (elem = elems[i]) != <span class="hljs-literal">null</span>; i++) {
            <span class="hljs-keyword">if</span> (byElement &amp;&amp; elem) {
              j = <span class="hljs-number">0</span>;
              <span class="hljs-keyword">while</span> ((matcher = elementMatchers[j++])) {
                <span class="hljs-keyword">if</span> (matcher(elem, context, xml)) {
                  results.push(elem);
                  <span class="hljs-keyword">break</span>;
                }
              }
              <span class="hljs-keyword">if</span> (outermost) {
                dirruns = dirrunsUnique;
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-256">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-256">&#182;</a>
              </div>
              <p>Track unmatched elements for set filters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (bySet) {</pre></div></div>
            
        </li>
        
        
        <li id="section-257">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-257">&#182;</a>
              </div>
              <p>They will have gone through all possible matchers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> ((elem = !matcher &amp;&amp; elem)) {
                matchedCount--;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-258">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-258">&#182;</a>
              </div>
              <p>Lengthen the array for every element, matched or not</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (seed) {
                unmatched.push(elem);
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-259">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-259">&#182;</a>
              </div>
              <p>Apply set filters to unmatched elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          matchedCount += i;
          <span class="hljs-keyword">if</span> (bySet &amp;&amp; i !== matchedCount) {
            j = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> ((matcher = setMatchers[j++])) {
              matcher(unmatched, setMatched, context, xml);
            }

            <span class="hljs-keyword">if</span> (seed) {</pre></div></div>
            
        </li>
        
        
        <li id="section-260">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-260">&#182;</a>
              </div>
              <p>Reintegrate element matches to eliminate the need for sorting</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (matchedCount &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">while</span> (i--) {
                  <span class="hljs-keyword">if</span> (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-261">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-261">&#182;</a>
              </div>
              <p>Discard index placeholder values to get only actual matches</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              setMatched = condense(setMatched);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-262">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-262">&#182;</a>
              </div>
              <p>Add matches to results</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            push.apply(results, setMatched);</pre></div></div>
            
        </li>
        
        
        <li id="section-263">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-263">&#182;</a>
              </div>
              <p>Seedless set matches succeeding multiple successful matchers stipulate sorting</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; <span class="hljs-number">0</span> &amp;&amp;
              (matchedCount + setMatchers.length) &gt; <span class="hljs-number">1</span>) {

              Sizzle.uniqueSort(results);
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-264">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-264">&#182;</a>
              </div>
              <p>Override manipulation of globals by nested matchers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }

          <span class="hljs-keyword">return</span> unmatched;
        };

      <span class="hljs-keyword">return</span> bySet ?
        markFunction(superMatcher) :
        superMatcher;
    }

    compile = Sizzle.compile = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector, match <span class="hljs-regexp">/* Internal Use Only */</span></span>) </span>{
      <span class="hljs-keyword">var</span> i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[selector + <span class="hljs-string">" "</span>];

      <span class="hljs-keyword">if</span> (!cached) {</pre></div></div>
            
        </li>
        
        
        <li id="section-265">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-265">&#182;</a>
              </div>
              <p>Generate a function of recursive functions that can be used to check each element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        <span class="hljs-keyword">while</span> (i--) {
          cached = matcherFromTokens(match[i]);
          <span class="hljs-keyword">if</span> (cached[expando]) {
            setMatchers.push(cached);
          } <span class="hljs-keyword">else</span> {
            elementMatchers.push(cached);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-266">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-266">&#182;</a>
              </div>
              <p>Cache the compiled function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));</pre></div></div>
            
        </li>
        
        
        <li id="section-267">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-267">&#182;</a>
              </div>
              <p>Save selector and tokenization</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        cached.selector = selector;
      }
      <span class="hljs-keyword">return</span> cached;
    };

    <span class="hljs-comment">/**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */</span>
    select = Sizzle.select = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector, context, results, seed</span>) </span>{
      <span class="hljs-keyword">var</span> i, tokens, token, type, find,
        compiled = <span class="hljs-keyword">typeof</span> selector === <span class="hljs-string">"function"</span> &amp;&amp; selector,
        match = !seed &amp;&amp; tokenize((selector = compiled.selector || selector));

      results = results || [];</pre></div></div>
            
        </li>
        
        
        <li id="section-268">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-268">&#182;</a>
              </div>
              <p>Try to minimize operations if there is no seed and only one group</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (match.length === <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-269">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-269">&#182;</a>
              </div>
              <p>Take a shortcut and set the context if the root selector is an ID</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        tokens = match[<span class="hljs-number">0</span>] = match[<span class="hljs-number">0</span>].slice(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (tokens.length &gt; <span class="hljs-number">2</span> &amp;&amp; (token = tokens[<span class="hljs-number">0</span>]).type === <span class="hljs-string">"ID"</span> &amp;&amp;
          support.getById &amp;&amp; context.nodeType === <span class="hljs-number">9</span> &amp;&amp; documentIsHTML &amp;&amp;
          Expr.relative[tokens[<span class="hljs-number">1</span>].type]) {

          context = (Expr.find[<span class="hljs-string">"ID"</span>](token.matches[<span class="hljs-number">0</span>].replace(runescape, funescape), context) || [])[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">if</span> (!context) {
            <span class="hljs-keyword">return</span> results;</pre></div></div>
            
        </li>
        
        
        <li id="section-270">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-270">&#182;</a>
              </div>
              <p>Precompiled matchers will still verify ancestry, so step up a level</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (compiled) {
            context = context.parentNode;
          }

          selector = selector.slice(tokens.shift().value.length);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-271">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-271">&#182;</a>
              </div>
              <p>Fetch a seed set for right-to-left matching</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        i = matchExpr[<span class="hljs-string">"needsContext"</span>].test(selector) ? <span class="hljs-number">0</span> : tokens.length;
        <span class="hljs-keyword">while</span> (i--) {
          token = tokens[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-272">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-272">&#182;</a>
              </div>
              <p>Abort if we hit a combinator</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (Expr.relative[(type = token.type)]) {
            <span class="hljs-keyword">break</span>;
          }
          <span class="hljs-keyword">if</span> ((find = Expr.find[type])) {</pre></div></div>
            
        </li>
        
        
        <li id="section-273">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-273">&#182;</a>
              </div>
              <p>Search, expanding context for leading sibling combinators</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ((seed = find(
              token.matches[<span class="hljs-number">0</span>].replace(runescape, funescape),
              rsibling.test(tokens[<span class="hljs-number">0</span>].type) &amp;&amp; testContext(context.parentNode) || context
            ))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-274">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-274">&#182;</a>
              </div>
              <p>If seed is empty or no tokens remain, we can return early</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              tokens.splice(i, <span class="hljs-number">1</span>);
              selector = seed.length &amp;&amp; toSelector(tokens);
              <span class="hljs-keyword">if</span> (!selector) {
                push.apply(results, seed);
                <span class="hljs-keyword">return</span> results;
              }

              <span class="hljs-keyword">break</span>;
            }
          }
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-275">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-275">&#182;</a>
              </div>
              <p>Compile and execute a filtering function if one is not provided
Provide <code>match</code> to avoid retokenization if we modified the selector above</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      (compiled || compile(selector, match))(
        seed,
        context,
        !documentIsHTML,
        results,
        rsibling.test(selector) &amp;&amp; testContext(context.parentNode) || context
      );
      <span class="hljs-keyword">return</span> results;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-276">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-276">&#182;</a>
              </div>
              <p>One-time assignments</p>

            </div>
            
        </li>
        
        
        <li id="section-277">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-277">&#182;</a>
              </div>
              <p>Sort stability</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    support.sortStable = expando.split(<span class="hljs-string">""</span>).sort(sortOrder).join(<span class="hljs-string">""</span>) === expando;</pre></div></div>
            
        </li>
        
        
        <li id="section-278">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-278">&#182;</a>
              </div>
              <p>Support: Chrome 14-35+
Always assume duplicates if they arent passed to the comparison function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    support.detectDuplicates = !!hasDuplicate;</pre></div></div>
            
        </li>
        
        
        <li id="section-279">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-279">&#182;</a>
              </div>
              <p>Initialize against the default document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    setDocument();</pre></div></div>
            
        </li>
        
        
        <li id="section-280">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-280">&#182;</a>
              </div>
              <p>Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
Detached nodes confoundingly follow <em>each other</em></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    support.sortDetached = assert(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">div1</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-281">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-281">&#182;</a>
              </div>
              <p>Should return 1, but returns 4 (following)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> div1.compareDocumentPosition(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>)) &amp; <span class="hljs-number">1</span>;
    }
    );</pre></div></div>
            
        </li>
        
        
        <li id="section-282">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-282">&#182;</a>
              </div>
              <p>Support: IE&lt;8
Prevent attribute/property interpolation
<a href="http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx">http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!assert(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">div</span>) </span>{
      div.innerHTML = <span class="hljs-string">"&lt;a href='#'&gt;&lt;/a&gt;"</span>;
      <span class="hljs-keyword">return</span> div.firstChild.getAttribute(<span class="hljs-string">"href"</span>) === <span class="hljs-string">"#"</span>;
    })) {
      addHandle(<span class="hljs-string">"type|href|height|width"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, name, isXML</span>) </span>{
        <span class="hljs-keyword">if</span> (!isXML) {
          <span class="hljs-keyword">return</span> elem.getAttribute(name, name.toLowerCase() === <span class="hljs-string">"type"</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>);
        }
      });
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-283">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-283">&#182;</a>
              </div>
              <p>Support: IE&lt;9
Use defaultValue in place of getAttribute(value)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!support.attributes || !assert(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">div</span>) </span>{
      div.innerHTML = <span class="hljs-string">"&lt;input/&gt;"</span>;
      div.firstChild.setAttribute(<span class="hljs-string">"value"</span>, <span class="hljs-string">""</span>);
      <span class="hljs-keyword">return</span> div.firstChild.getAttribute(<span class="hljs-string">"value"</span>) === <span class="hljs-string">""</span>;
    })) {
      addHandle(<span class="hljs-string">"value"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, name, isXML</span>) </span>{
        <span class="hljs-keyword">if</span> (!isXML &amp;&amp; elem.nodeName.toLowerCase() === <span class="hljs-string">"input"</span>) {
          <span class="hljs-keyword">return</span> elem.defaultValue;
        }
      });
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-284">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-284">&#182;</a>
              </div>
              <p>Support: IE&lt;9
Use getAttributeNode to fetch booleans when getAttribute lies</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!assert(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">div</span>) </span>{
      <span class="hljs-keyword">return</span> div.getAttribute(<span class="hljs-string">"disabled"</span>) == <span class="hljs-literal">null</span>;
    })) {
      addHandle(booleans, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, name, isXML</span>) </span>{
        <span class="hljs-keyword">var</span> val;
        <span class="hljs-keyword">if</span> (!isXML) {
          <span class="hljs-keyword">return</span> elem[name] === <span class="hljs-literal">true</span> ? name.toLowerCase() :
            (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
              val.value :
              <span class="hljs-literal">null</span>;
        }
      });
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-285">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-285">&#182;</a>
              </div>
              <p>EXPOSE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> Sizzle;
  }
);

<span class="hljs-comment">/*eslint-enable */</span>

<span class="hljs-comment">/**
 * Arr.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Array utility class.
 *
 * @private
 * @class tinymce.util.Arr
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.Arr'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> isArray = <span class="hljs-built_in">Array</span>.isArray || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">"[object Array]"</span>;
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArray</span>(<span class="hljs-params">obj</span>) </span>{
      <span class="hljs-keyword">var</span> array = obj, i, l;

      <span class="hljs-keyword">if</span> (!isArray(obj)) {
        array = [];
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = obj.length; i &lt; l; i++) {
          array[i] = obj[i];
        }
      }

      <span class="hljs-keyword">return</span> array;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">each</span>(<span class="hljs-params">o, cb, s</span>) </span>{
      <span class="hljs-keyword">var</span> n, l;

      <span class="hljs-keyword">if</span> (!o) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      }

      s = s || o;

      <span class="hljs-keyword">if</span> (o.length !== <span class="hljs-literal">undefined</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-286">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-286">&#182;</a>
              </div>
              <p>Indexed arrays, needed for Safari</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>, l = o.length; n &lt; l; n++) {
          <span class="hljs-keyword">if</span> (cb.call(s, o[n], n, o) === <span class="hljs-literal">false</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
          }
        }
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-287">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-287">&#182;</a>
              </div>
              <p>Hashtables</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> o) {
          <span class="hljs-keyword">if</span> (o.hasOwnProperty(n)) {
            <span class="hljs-keyword">if</span> (cb.call(s, o[n], n, o) === <span class="hljs-literal">false</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            }
          }
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">array, callback</span>) </span>{
      <span class="hljs-keyword">var</span> out = [];

      each(array, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index</span>) </span>{
        out.push(callback(item, index, array));
      });

      <span class="hljs-keyword">return</span> out;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span>(<span class="hljs-params">a, f</span>) </span>{
      <span class="hljs-keyword">var</span> o = [];

      each(a, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v, index</span>) </span>{
        <span class="hljs-keyword">if</span> (!f || f(v, index, a)) {
          o.push(v);
        }
      });

      <span class="hljs-keyword">return</span> o;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexOf</span>(<span class="hljs-params">a, v</span>) </span>{
      <span class="hljs-keyword">var</span> i, l;

      <span class="hljs-keyword">if</span> (a) {
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = a.length; i &lt; l; i++) {
          <span class="hljs-keyword">if</span> (a[i] === v) {
            <span class="hljs-keyword">return</span> i;
          }
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">collection, iteratee, accumulator, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">3</span>) {
        accumulator = collection[<span class="hljs-number">0</span>];
      }

      <span class="hljs-keyword">for</span> (; i &lt; collection.length; i++) {
        accumulator = iteratee.call(thisArg, accumulator, collection[i], i);
      }

      <span class="hljs-keyword">return</span> accumulator;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findIndex</span>(<span class="hljs-params">array, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> i, l;

      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = array.length; i &lt; l; i++) {
        <span class="hljs-keyword">if</span> (predicate.call(thisArg, array[i], i, array)) {
          <span class="hljs-keyword">return</span> i;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">array, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> idx = findIndex(array, predicate, thisArg);

      <span class="hljs-keyword">if</span> (idx !== <span class="hljs-number">-1</span>) {
        <span class="hljs-keyword">return</span> array[idx];
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">last</span>(<span class="hljs-params">collection</span>) </span>{
      <span class="hljs-keyword">return</span> collection[collection.length - <span class="hljs-number">1</span>];
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">isArray</span>: isArray,
      <span class="hljs-attr">toArray</span>: toArray,
      <span class="hljs-attr">each</span>: each,
      <span class="hljs-attr">map</span>: map,
      <span class="hljs-attr">filter</span>: filter,
      <span class="hljs-attr">indexOf</span>: indexOf,
      <span class="hljs-attr">reduce</span>: reduce,
      <span class="hljs-attr">findIndex</span>: findIndex,
      <span class="hljs-attr">find</span>: find,
      <span class="hljs-attr">last</span>: last
    };
  }
);
<span class="hljs-comment">/**
 * Tools.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class contains various utlity functions. These are also exposed
 * directly on the tinymce namespace.
 *
 * @class tinymce.util.Tools
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.Tools'</span>,
  [
    <span class="hljs-string">"tinymce.core.Env"</span>,
    <span class="hljs-string">"tinymce.core.util.Arr"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Env, Arr</span>) </span>{
    <span class="hljs-comment">/**
     * Removes whitespace from the beginning and end of a string.
     *
     * @method trim
     * @param {String} s String to remove whitespace from.
     * @return {String} New string with removed whitespace.
     */</span>
    <span class="hljs-keyword">var</span> whiteSpaceRegExp = <span class="hljs-regexp">/^\s*|\s*$/g</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trim</span>(<span class="hljs-params">str</span>) </span>{
      <span class="hljs-keyword">return</span> (str === <span class="hljs-literal">null</span> || str === <span class="hljs-literal">undefined</span>) ? <span class="hljs-string">''</span> : (<span class="hljs-string">""</span> + str).replace(whiteSpaceRegExp, <span class="hljs-string">''</span>);
    }

    <span class="hljs-comment">/**
     * Checks if a object is of a specific type for example an array.
     *
     * @method is
     * @param {Object} obj Object to check type of.
     * @param {string} type Optional type to check for.
     * @return {Boolean} true/false if the object is of the specified type.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is</span>(<span class="hljs-params">obj, type</span>) </span>{
      <span class="hljs-keyword">if</span> (!type) {
        <span class="hljs-keyword">return</span> obj !== <span class="hljs-literal">undefined</span>;
      }

      <span class="hljs-keyword">if</span> (type == <span class="hljs-string">'array'</span> &amp;&amp; Arr.isArray(obj)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj == type;
    }

    <span class="hljs-comment">/**
     * Makes a name/object map out of an array with names.
     *
     * @method makeMap
     * @param {Array/String} items Items to make map out of.
     * @param {String} delim Optional delimiter to split string by.
     * @param {Object} map Optional map to add items to.
     * @return {Object} Name/value map of items.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeMap</span>(<span class="hljs-params">items, delim, map</span>) </span>{
      <span class="hljs-keyword">var</span> i;

      items = items || [];
      delim = delim || <span class="hljs-string">','</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> items == <span class="hljs-string">"string"</span>) {
        items = items.split(delim);
      }

      map = map || {};

      i = items.length;
      <span class="hljs-keyword">while</span> (i--) {
        map[items[i]] = {};
      }

      <span class="hljs-keyword">return</span> map;
    }

    <span class="hljs-comment">/**
     * JavaScript does not protect hasOwnProperty method, so it is possible to overwrite it. This is
     * object independent version.
     *
     * @param {Object} obj
     * @param {String} prop
     * @returns {Boolean}
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasOwnProperty</span>(<span class="hljs-params">obj, prop</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, prop);
    }

    <span class="hljs-comment">/**
     * Creates a class, subclass or static singleton.
     * More details on this method can be found in the Wiki.
     *
     * @method create
     * @param {String} s Class name, inheritance and prefix.
     * @param {Object} p Collection of methods to add to the class.
     * @param {Object} root Optional root object defaults to the global window object.
     * @example
     * // Creates a basic class
     * tinymce.create('tinymce.somepackage.SomeClass', {
     *     SomeClass: function() {
     *         // Class constructor
     *     },
     *
     *     method: function() {
     *         // Some method
     *     }
     * });
     *
     * // Creates a basic subclass class
     * tinymce.create('tinymce.somepackage.SomeSubClass:tinymce.somepackage.SomeClass', {
     *     SomeSubClass: function() {
     *         // Class constructor
     *         this.parent(); // Call parent constructor
     *     },
     *
     *     method: function() {
     *         // Some method
     *         this.parent(); // Call parent method
     *     },
     *
     *     'static': {
     *         staticMethod: function() {
     *             // Static method
     *         }
     *     }
     * });
     *
     * // Creates a singleton/static class
     * tinymce.create('static tinymce.somepackage.SomeSingletonClass', {
     *     method: function() {
     *         // Some method
     *     }
     * });
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">s, p, root</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, sp, ns, cn, scn, c, de = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-288">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-288">&#182;</a>
              </div>
              <p>Parse : <prefix> <class>:<super class></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      s = <span class="hljs-regexp">/^((static) )?([\w.]+)(:([\w.]+))?/</span>.exec(s);
      cn = s[<span class="hljs-number">3</span>].match(<span class="hljs-regexp">/(^|\.)(\w+)$/i</span>)[<span class="hljs-number">2</span>]; <span class="hljs-comment">// Class name</span></pre></div></div>
            
        </li>
        
        
        <li id="section-289">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-289">&#182;</a>
              </div>
              <p>Create namespace for new class</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      ns = self.createNS(s[<span class="hljs-number">3</span>].replace(<span class="hljs-regexp">/\.\w+$/</span>, <span class="hljs-string">''</span>), root);</pre></div></div>
            
        </li>
        
        
        <li id="section-290">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-290">&#182;</a>
              </div>
              <p>Class already exists</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (ns[cn]) {
        <span class="hljs-keyword">return</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-291">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-291">&#182;</a>
              </div>
              <p>Make pure static class</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (s[<span class="hljs-number">2</span>] == <span class="hljs-string">'static'</span>) {
        ns[cn] = p;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.onCreate) {
          <span class="hljs-keyword">this</span>.onCreate(s[<span class="hljs-number">2</span>], s[<span class="hljs-number">3</span>], ns[cn]);
        }

        <span class="hljs-keyword">return</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-292">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-292">&#182;</a>
              </div>
              <p>Create default constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!p[cn]) {
        p[cn] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ };
        de = <span class="hljs-number">1</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-293">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-293">&#182;</a>
              </div>
              <p>Add constructor and methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      ns[cn] = p[cn];
      self.extend(ns[cn].prototype, p);</pre></div></div>
            
        </li>
        
        
        <li id="section-294">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-294">&#182;</a>
              </div>
              <p>Extend</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (s[<span class="hljs-number">5</span>]) {
        sp = self.resolve(s[<span class="hljs-number">5</span>]).prototype;
        scn = s[<span class="hljs-number">5</span>].match(<span class="hljs-regexp">/\.(\w+)$/i</span>)[<span class="hljs-number">1</span>]; <span class="hljs-comment">// Class name</span></pre></div></div>
            
        </li>
        
        
        <li id="section-295">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-295">&#182;</a>
              </div>
              <p>Extend constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        c = ns[cn];
        <span class="hljs-keyword">if</span> (de) {</pre></div></div>
            
        </li>
        
        
        <li id="section-296">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-296">&#182;</a>
              </div>
              <p>Add passthrough constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          ns[cn] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> sp[scn].apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
          };
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-297">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-297">&#182;</a>
              </div>
              <p>Add inherit constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          ns[cn] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>.parent = sp[scn];
            <span class="hljs-keyword">return</span> c.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
          };
        }
        ns[cn].prototype[cn] = ns[cn];</pre></div></div>
            
        </li>
        
        
        <li id="section-298">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-298">&#182;</a>
              </div>
              <p>Add super methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self.each(sp, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f, n</span>) </span>{
          ns[cn].prototype[n] = sp[n];
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-299">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-299">&#182;</a>
              </div>
              <p>Add overridden methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self.each(p, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f, n</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-300">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-300">&#182;</a>
              </div>
              <p>Extend methods if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (sp[n]) {
            ns[cn].prototype[n] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">this</span>.parent = sp[n];
              <span class="hljs-keyword">return</span> f.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
            };
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (n != cn) {
              ns[cn].prototype[n] = f;
            }
          }
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-301">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-301">&#182;</a>
              </div>
              <p>Add static methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/*jshint sub:true*/</span>
      <span class="hljs-comment">/*eslint dot-notation:0*/</span>
      self.each(p[<span class="hljs-string">'static'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f, n</span>) </span>{
        ns[cn][n] = f;
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>(<span class="hljs-params">obj, ext</span>) </span>{
      <span class="hljs-keyword">var</span> i, l, name, args = <span class="hljs-built_in">arguments</span>, value;

      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>, l = args.length; i &lt; l; i++) {
        ext = args[i];
        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> ext) {
          <span class="hljs-keyword">if</span> (ext.hasOwnProperty(name)) {
            value = ext[name];

            <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">undefined</span>) {
              obj[name] = value;
            }
          }
        }
      }

      <span class="hljs-keyword">return</span> obj;
    }

    <span class="hljs-comment">/**
     * Executed the specified function for each item in a object tree.
     *
     * @method walk
     * @param {Object} o Object tree to walk though.
     * @param {function} f Function to call for each item.
     * @param {String} n Optional name of collection inside the objects to walk for example childNodes.
     * @param {String} s Optional scope to execute the function in.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walk</span>(<span class="hljs-params">o, f, n, s</span>) </span>{
      s = s || <span class="hljs-keyword">this</span>;

      <span class="hljs-keyword">if</span> (o) {
        <span class="hljs-keyword">if</span> (n) {
          o = o[n];
        }

        Arr.each(o, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o, i</span>) </span>{
          <span class="hljs-keyword">if</span> (f.call(s, o, i, n) === <span class="hljs-literal">false</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

          walk(o, f, n, s);
        });
      }
    }

    <span class="hljs-comment">/**
     * Creates a namespace on a specific object.
     *
     * @method createNS
     * @param {String} n Namespace to create for example a.b.c.d.
     * @param {Object} o Optional object to add namespace to, defaults to window.
     * @return {Object} New namespace object the last item in path.
     * @example
     * // Create some namespace
     * tinymce.createNS('tinymce.somepackage.subpackage');
     *
     * // Add a singleton
     * var tinymce.somepackage.subpackage.SomeSingleton = {
     *     method: function() {
     *         // Some method
     *     }
     * };
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createNS</span>(<span class="hljs-params">n, o</span>) </span>{
      <span class="hljs-keyword">var</span> i, v;

      o = o || <span class="hljs-built_in">window</span>;

      n = n.split(<span class="hljs-string">'.'</span>);
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n.length; i++) {
        v = n[i];

        <span class="hljs-keyword">if</span> (!o[v]) {
          o[v] = {};
        }

        o = o[v];
      }

      <span class="hljs-keyword">return</span> o;
    }

    <span class="hljs-comment">/**
     * Resolves a string and returns the object from a specific structure.
     *
     * @method resolve
     * @param {String} n Path to resolve for example a.b.c.d.
     * @param {Object} o Optional object to search though, defaults to window.
     * @return {Object} Last object in path or null if it couldn't be resolved.
     * @example
     * // Resolve a path into an object reference
     * var obj = tinymce.resolve('a.b.c.d');
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">n, o</span>) </span>{
      <span class="hljs-keyword">var</span> i, l;

      o = o || <span class="hljs-built_in">window</span>;

      n = n.split(<span class="hljs-string">'.'</span>);
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = n.length; i &lt; l; i++) {
        o = o[n[i]];

        <span class="hljs-keyword">if</span> (!o) {
          <span class="hljs-keyword">break</span>;
        }
      }

      <span class="hljs-keyword">return</span> o;
    }

    <span class="hljs-comment">/**
     * Splits a string but removes the whitespace before and after each value.
     *
     * @method explode
     * @param {string} s String to split.
     * @param {string} d Delimiter to split by.
     * @example
     * // Split a string into an array with a,b,c
     * var arr = tinymce.explode('a, b,   c');
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">explode</span>(<span class="hljs-params">s, d</span>) </span>{
      <span class="hljs-keyword">if</span> (!s || is(s, <span class="hljs-string">'array'</span>)) {
        <span class="hljs-keyword">return</span> s;
      }

      <span class="hljs-keyword">return</span> Arr.map(s.split(d || <span class="hljs-string">','</span>), trim);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_addCacheSuffix</span>(<span class="hljs-params">url</span>) </span>{
      <span class="hljs-keyword">var</span> cacheSuffix = Env.cacheSuffix;

      <span class="hljs-keyword">if</span> (cacheSuffix) {
        url += (url.indexOf(<span class="hljs-string">'?'</span>) === <span class="hljs-number">-1</span> ? <span class="hljs-string">'?'</span> : <span class="hljs-string">'&amp;'</span>) + cacheSuffix;
      }

      <span class="hljs-keyword">return</span> url;
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">trim</span>: trim,

      <span class="hljs-comment">/**
       * Returns true/false if the object is an array or not.
       *
       * @method isArray
       * @param {Object} obj Object to check.
       * @return {boolean} true/false state if the object is an array or not.
       */</span>
      isArray: Arr.isArray,

      <span class="hljs-attr">is</span>: is,

      <span class="hljs-comment">/**
       * Converts the specified object into a real JavaScript array.
       *
       * @method toArray
       * @param {Object} obj Object to convert into array.
       * @return {Array} Array object based in input.
       */</span>
      toArray: Arr.toArray,
      <span class="hljs-attr">makeMap</span>: makeMap,

      <span class="hljs-comment">/**
       * Performs an iteration of all items in a collection such as an object or array. This method will execure the
       * callback function for each item in the collection, if the callback returns false the iteration will terminate.
       * The callback has the following format: cb(value, key_or_index).
       *
       * @method each
       * @param {Object} o Collection to iterate.
       * @param {function} cb Callback function to execute for each item.
       * @param {Object} s Optional scope to execute the callback in.
       * @example
       * // Iterate an array
       * tinymce.each([1,2,3], function(v, i) {
       *     console.debug("Value: " + v + ", Index: " + i);
       * });
       *
       * // Iterate an object
       * tinymce.each({a: 1, b: 2, c: 3], function(v, k) {
       *     console.debug("Value: " + v + ", Key: " + k);
       * });
       */</span>
      each: Arr.each,

      <span class="hljs-comment">/**
       * Creates a new array by the return value of each iteration function call. This enables you to convert
       * one array list into another.
       *
       * @method map
       * @param {Array} array Array of items to iterate.
       * @param {function} callback Function to call for each item. It's return value will be the new value.
       * @return {Array} Array with new values based on function return values.
       */</span>
      map: Arr.map,

      <span class="hljs-comment">/**
       * Filters out items from the input array by calling the specified function for each item.
       * If the function returns false the item will be excluded if it returns true it will be included.
       *
       * @method grep
       * @param {Array} a Array of items to loop though.
       * @param {function} f Function to call for each item. Include/exclude depends on it's return value.
       * @return {Array} New array with values imported and filtered based in input.
       * @example
       * // Filter out some items, this will return an array with 4 and 5
       * var items = tinymce.grep([1,2,3,4,5], function(v) {return v &gt; 3;});
       */</span>
      grep: Arr.filter,

      <span class="hljs-comment">/**
       * Returns an index of the item or -1 if item is not present in the array.
       *
       * @method inArray
       * @param {any} item Item to search for.
       * @param {Array} arr Array to search in.
       * @return {Number} index of the item or -1 if item was not found.
       */</span>
      inArray: Arr.indexOf,

      <span class="hljs-attr">hasOwn</span>: hasOwnProperty,

      <span class="hljs-attr">extend</span>: extend,
      <span class="hljs-attr">create</span>: create,
      <span class="hljs-attr">walk</span>: walk,
      <span class="hljs-attr">createNS</span>: createNS,
      <span class="hljs-attr">resolve</span>: resolve,
      <span class="hljs-attr">explode</span>: explode,
      <span class="hljs-attr">_addCacheSuffix</span>: _addCacheSuffix
    };
  }
);
<span class="hljs-comment">/**
 * DomQuery.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class mimics most of the jQuery API:
 *
 * This is whats currently implemented:
 * - Utility functions
 * - DOM traversial
 * - DOM manipulation
 * - Event binding
 *
 * This is not currently implemented:
 * - Dimension
 * - Ajax
 * - Animation
 * - Advanced chaining
 *
 * @example
 * var $ = tinymce.dom.DomQuery;
 * $('p').attr('attr', 'value').addClass('class');
 *
 * @class tinymce.dom.DomQuery
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.DomQuery'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.EventUtils"</span>,
    <span class="hljs-string">"tinymce.core.dom.Sizzle"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.Env"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">EventUtils, Sizzle, Tools, Env</span>) </span>{
    <span class="hljs-keyword">var</span> doc = <span class="hljs-built_in">document</span>, push = <span class="hljs-built_in">Array</span>.prototype.push, slice = <span class="hljs-built_in">Array</span>.prototype.slice;
    <span class="hljs-keyword">var</span> rquickExpr = <span class="hljs-regexp">/^(?:[^#&lt;]*(&lt;[\w\W]+&gt;)[^&gt;]*$|#([\w\-]*)$)/</span>;
    <span class="hljs-keyword">var</span> Event = EventUtils.Event, undef;
    <span class="hljs-keyword">var</span> skipUniques = Tools.makeMap(<span class="hljs-string">'children,contents,next,prev'</span>);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDefined</span>(<span class="hljs-params">obj</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">'undefined'</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isString</span>(<span class="hljs-params">obj</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'string'</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isWindow</span>(<span class="hljs-params">obj</span>) </span>{
      <span class="hljs-keyword">return</span> obj &amp;&amp; obj == obj.window;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFragment</span>(<span class="hljs-params">html, fragDoc</span>) </span>{
      <span class="hljs-keyword">var</span> frag, node, container;

      fragDoc = fragDoc || doc;
      container = fragDoc.createElement(<span class="hljs-string">'div'</span>);
      frag = fragDoc.createDocumentFragment();
      container.innerHTML = html;

      <span class="hljs-keyword">while</span> ((node = container.firstChild)) {
        frag.appendChild(node);
      }

      <span class="hljs-keyword">return</span> frag;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">domManipulate</span>(<span class="hljs-params">targetNodes, sourceItem, callback, reverse</span>) </span>{
      <span class="hljs-keyword">var</span> i;

      <span class="hljs-keyword">if</span> (isString(sourceItem)) {
        sourceItem = createFragment(sourceItem, getElementDocument(targetNodes[<span class="hljs-number">0</span>]));
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sourceItem.length &amp;&amp; !sourceItem.nodeType) {
        sourceItem = DomQuery.makeArray(sourceItem);

        <span class="hljs-keyword">if</span> (reverse) {
          <span class="hljs-keyword">for</span> (i = sourceItem.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            domManipulate(targetNodes, sourceItem[i], callback, reverse);
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; sourceItem.length; i++) {
            domManipulate(targetNodes, sourceItem[i], callback, reverse);
          }
        }

        <span class="hljs-keyword">return</span> targetNodes;
      }

      <span class="hljs-keyword">if</span> (sourceItem.nodeType) {
        i = targetNodes.length;
        <span class="hljs-keyword">while</span> (i--) {
          callback.call(targetNodes[i], sourceItem);
        }
      }

      <span class="hljs-keyword">return</span> targetNodes;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasClass</span>(<span class="hljs-params">node, className</span>) </span>{
      <span class="hljs-keyword">return</span> node &amp;&amp; className &amp;&amp; (<span class="hljs-string">' '</span> + node.className + <span class="hljs-string">' '</span>).indexOf(<span class="hljs-string">' '</span> + className + <span class="hljs-string">' '</span>) !== <span class="hljs-number">-1</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span>(<span class="hljs-params">elements, wrapper, all</span>) </span>{
      <span class="hljs-keyword">var</span> lastParent, newWrapper;

      wrapper = DomQuery(wrapper)[<span class="hljs-number">0</span>];

      elements.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (!all || lastParent != self.parentNode) {
          lastParent = self.parentNode;
          newWrapper = wrapper.cloneNode(<span class="hljs-literal">false</span>);
          self.parentNode.insertBefore(newWrapper, self);
          newWrapper.appendChild(self);
        } <span class="hljs-keyword">else</span> {
          newWrapper.appendChild(self);
        }
      });

      <span class="hljs-keyword">return</span> elements;
    }

    <span class="hljs-keyword">var</span> numericCssMap = Tools.makeMap(<span class="hljs-string">'fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom'</span>, <span class="hljs-string">' '</span>);
    <span class="hljs-keyword">var</span> booleanMap = Tools.makeMap(<span class="hljs-string">'checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected'</span>, <span class="hljs-string">' '</span>);
    <span class="hljs-keyword">var</span> propFix = {
      <span class="hljs-string">'for'</span>: <span class="hljs-string">'htmlFor'</span>,
      <span class="hljs-string">'class'</span>: <span class="hljs-string">'className'</span>,
      <span class="hljs-string">'readonly'</span>: <span class="hljs-string">'readOnly'</span>
    };
    <span class="hljs-keyword">var</span> cssFix = {
      <span class="hljs-string">'float'</span>: <span class="hljs-string">'cssFloat'</span>
    };

    <span class="hljs-keyword">var</span> attrHooks = {}, cssHooks = {};

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DomQuery</span>(<span class="hljs-params">selector, context</span>) </span>{
      <span class="hljs-comment">/*eslint new-cap:0 */</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DomQuery.fn.init(selector, context);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inArray</span>(<span class="hljs-params">item, array</span>) </span>{
      <span class="hljs-keyword">var</span> i;

      <span class="hljs-keyword">if</span> (array.indexOf) {
        <span class="hljs-keyword">return</span> array.indexOf(item);
      }

      i = array.length;
      <span class="hljs-keyword">while</span> (i--) {
        <span class="hljs-keyword">if</span> (array[i] === item) {
          <span class="hljs-keyword">return</span> i;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }

    <span class="hljs-keyword">var</span> whiteSpaceRegExp = <span class="hljs-regexp">/^\s*|\s*$/g</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trim</span>(<span class="hljs-params">str</span>) </span>{
      <span class="hljs-keyword">return</span> (str === <span class="hljs-literal">null</span> || str === undef) ? <span class="hljs-string">''</span> : (<span class="hljs-string">""</span> + str).replace(whiteSpaceRegExp, <span class="hljs-string">''</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">each</span>(<span class="hljs-params">obj, callback</span>) </span>{
      <span class="hljs-keyword">var</span> length, key, i, undef, value;

      <span class="hljs-keyword">if</span> (obj) {
        length = obj.length;

        <span class="hljs-keyword">if</span> (length === undef) {</pre></div></div>
            
        </li>
        
        
        <li id="section-302">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-302">&#182;</a>
              </div>
              <p>Loop object items</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> obj) {
            <span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) {
              value = obj[key];
              <span class="hljs-keyword">if</span> (callback.call(value, key, value) === <span class="hljs-literal">false</span>) {
                <span class="hljs-keyword">break</span>;
              }
            }
          }
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-303">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-303">&#182;</a>
              </div>
              <p>Loop array items</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) {
            value = obj[i];
            <span class="hljs-keyword">if</span> (callback.call(value, i, value) === <span class="hljs-literal">false</span>) {
              <span class="hljs-keyword">break</span>;
            }
          }
        }
      }

      <span class="hljs-keyword">return</span> obj;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grep</span>(<span class="hljs-params">array, callback</span>) </span>{
      <span class="hljs-keyword">var</span> out = [];

      each(array, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i, item</span>) </span>{
        <span class="hljs-keyword">if</span> (callback(item, i)) {
          out.push(item);
        }
      });

      <span class="hljs-keyword">return</span> out;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getElementDocument</span>(<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">if</span> (!element) {
        <span class="hljs-keyword">return</span> doc;
      }

      <span class="hljs-keyword">if</span> (element.nodeType == <span class="hljs-number">9</span>) {
        <span class="hljs-keyword">return</span> element;
      }

      <span class="hljs-keyword">return</span> element.ownerDocument;
    }

    DomQuery.fn = DomQuery.prototype = {
      <span class="hljs-attr">constructor</span>: DomQuery,

      <span class="hljs-comment">/**
       * Selector for the current set.
       *
       * @property selector
       * @type String
       */</span>
      selector: <span class="hljs-string">""</span>,

      <span class="hljs-comment">/**
       * Context used to create the set.
       *
       * @property context
       * @type Element
       */</span>
      context: <span class="hljs-literal">null</span>,

      <span class="hljs-comment">/**
       * Number of items in the current set.
       *
       * @property length
       * @type Number
       */</span>
      length: <span class="hljs-number">0</span>,

      <span class="hljs-comment">/**
       * Constructs a new DomQuery instance with the specified selector or context.
       *
       * @constructor
       * @method init
       * @param {String/Array/DomQuery} selector Optional CSS selector/Array or array like object or HTML string.
       * @param {Document/Element} context Optional context to search in.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector, context</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, match, node;

        <span class="hljs-keyword">if</span> (!selector) {
          <span class="hljs-keyword">return</span> self;
        }

        <span class="hljs-keyword">if</span> (selector.nodeType) {
          self.context = self[<span class="hljs-number">0</span>] = selector;
          self.length = <span class="hljs-number">1</span>;

          <span class="hljs-keyword">return</span> self;
        }

        <span class="hljs-keyword">if</span> (context &amp;&amp; context.nodeType) {
          self.context = context;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (context) {
            <span class="hljs-keyword">return</span> DomQuery(selector).attr(context);
          }

          self.context = context = <span class="hljs-built_in">document</span>;
        }

        <span class="hljs-keyword">if</span> (isString(selector)) {
          self.selector = selector;

          <span class="hljs-keyword">if</span> (selector.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">"&lt;"</span> &amp;&amp; selector.charAt(selector.length - <span class="hljs-number">1</span>) === <span class="hljs-string">"&gt;"</span> &amp;&amp; selector.length &gt;= <span class="hljs-number">3</span>) {
            match = [<span class="hljs-literal">null</span>, selector, <span class="hljs-literal">null</span>];
          } <span class="hljs-keyword">else</span> {
            match = rquickExpr.exec(selector);
          }

          <span class="hljs-keyword">if</span> (match) {
            <span class="hljs-keyword">if</span> (match[<span class="hljs-number">1</span>]) {
              node = createFragment(selector, getElementDocument(context)).firstChild;

              <span class="hljs-keyword">while</span> (node) {
                push.call(self, node);
                node = node.nextSibling;
              }
            } <span class="hljs-keyword">else</span> {
              node = getElementDocument(context).getElementById(match[<span class="hljs-number">2</span>]);

              <span class="hljs-keyword">if</span> (!node) {
                <span class="hljs-keyword">return</span> self;
              }

              <span class="hljs-keyword">if</span> (node.id !== match[<span class="hljs-number">2</span>]) {
                <span class="hljs-keyword">return</span> self.find(selector);
              }

              self.length = <span class="hljs-number">1</span>;
              self[<span class="hljs-number">0</span>] = node;
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> DomQuery(context).find(selector);
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">this</span>.add(selector, <span class="hljs-literal">false</span>);
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Converts the current set to an array.
       *
       * @method toArray
       * @return {Array} Array of all nodes in set.
       */</span>
      toArray: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> Tools.toArray(<span class="hljs-keyword">this</span>);
      },

      <span class="hljs-comment">/**
       * Adds new nodes to the set.
       *
       * @method add
       * @param {Array/tinymce.core.dom.DomQuery} items Array of all nodes to add to set.
       * @param {Boolean} sort Optional sort flag that enables sorting of elements.
       * @return {tinymce.dom.DomQuery} New instance with nodes added.
       */</span>
      add: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items, sort</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, nodes, i;

        <span class="hljs-keyword">if</span> (isString(items)) {
          <span class="hljs-keyword">return</span> self.add(DomQuery(items));
        }

        <span class="hljs-keyword">if</span> (sort !== <span class="hljs-literal">false</span>) {
          nodes = DomQuery.unique(self.toArray().concat(DomQuery.makeArray(items)));
          self.length = nodes.length;
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nodes.length; i++) {
            self[i] = nodes[i];
          }
        } <span class="hljs-keyword">else</span> {
          push.apply(self, DomQuery.makeArray(items));
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Sets/gets attributes on the elements in the current set.
       *
       * @method attr
       * @param {String/Object} name Name of attribute to get or an object with attributes to set.
       * @param {String} value Optional value to set.
       * @return {tinymce.dom.DomQuery/String} Current set or the specified attribute when only the name is specified.
       */</span>
      attr: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, hook;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">"object"</span>) {
          each(name, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
            self.attr(name, value);
          });
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isDefined(value)) {
          <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> hook;

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nodeType === <span class="hljs-number">1</span>) {
              hook = attrHooks[name];
              <span class="hljs-keyword">if</span> (hook &amp;&amp; hook.set) {
                hook.set(<span class="hljs-keyword">this</span>, value);
                <span class="hljs-keyword">return</span>;
              }

              <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">this</span>.removeAttribute(name, <span class="hljs-number">2</span>);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>.setAttribute(name, value, <span class="hljs-number">2</span>);
              }
            }
          });
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (self[<span class="hljs-number">0</span>] &amp;&amp; self[<span class="hljs-number">0</span>].nodeType === <span class="hljs-number">1</span>) {
            hook = attrHooks[name];
            <span class="hljs-keyword">if</span> (hook &amp;&amp; hook.get) {
              <span class="hljs-keyword">return</span> hook.get(self[<span class="hljs-number">0</span>], name);
            }

            <span class="hljs-keyword">if</span> (booleanMap[name]) {
              <span class="hljs-keyword">return</span> self.prop(name) ? name : undef;
            }

            value = self[<span class="hljs-number">0</span>].getAttribute(name, <span class="hljs-number">2</span>);

            <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
              value = undef;
            }
          }

          <span class="hljs-keyword">return</span> value;
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Removes attributse on the elements in the current set.
       *
       * @method removeAttr
       * @param {String/Object} name Name of attribute to remove.
       * @return {tinymce.dom.DomQuery/String} Current set.
       */</span>
      removeAttr: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.attr(name, <span class="hljs-literal">null</span>);
      },

      <span class="hljs-comment">/**
       * Sets/gets properties on the elements in the current set.
       *
       * @method attr
       * @param {String/Object} name Name of property to get or an object with properties to set.
       * @param {String} value Optional value to set.
       * @return {tinymce.dom.DomQuery/String} Current set or the specified property when only the name is specified.
       */</span>
      prop: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        name = propFix[name] || name;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">"object"</span>) {
          each(name, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
            self.prop(name, value);
          });
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isDefined(value)) {
          <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nodeType == <span class="hljs-number">1</span>) {
              <span class="hljs-keyword">this</span>[name] = value;
            }
          });
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (self[<span class="hljs-number">0</span>] &amp;&amp; self[<span class="hljs-number">0</span>].nodeType &amp;&amp; name <span class="hljs-keyword">in</span> self[<span class="hljs-number">0</span>]) {
            <span class="hljs-keyword">return</span> self[<span class="hljs-number">0</span>][name];
          }

          <span class="hljs-keyword">return</span> value;
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Sets/gets styles on the elements in the current set.
       *
       * @method css
       * @param {String/Object} name Name of style to get or an object with styles to set.
       * @param {String} value Optional value to set.
       * @return {tinymce.dom.DomQuery/String} Current set or the specified style when only the name is specified.
       */</span>
      css: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, elm, hook;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">camel</span>(<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">return</span> name.replace(<span class="hljs-regexp">/-(\D)/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
            <span class="hljs-keyword">return</span> b.toUpperCase();
          });
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dashed</span>(<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">return</span> name.replace(<span class="hljs-regexp">/[A-Z]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">'-'</span> + a;
          });
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">"object"</span>) {
          each(name, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
            self.css(name, value);
          });
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (isDefined(value)) {
            name = camel(name);</pre></div></div>
            
        </li>
        
        
        <li id="section-304">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-304">&#182;</a>
              </div>
              <p>Default px suffix on these</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'number'</span> &amp;&amp; !numericCssMap[name]) {
              value += <span class="hljs-string">'px'</span>;
            }

            self.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">var</span> style = <span class="hljs-keyword">this</span>.style;

              hook = cssHooks[name];
              <span class="hljs-keyword">if</span> (hook &amp;&amp; hook.set) {
                hook.set(<span class="hljs-keyword">this</span>, value);
                <span class="hljs-keyword">return</span>;
              }

              <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">this</span>.style[cssFix[name] || name] = value;
              } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-305">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-305">&#182;</a>
              </div>
              <p>Ignore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              }

              <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span> || value === <span class="hljs-string">''</span>) {
                <span class="hljs-keyword">if</span> (style.removeProperty) {
                  style.removeProperty(dashed(name));
                } <span class="hljs-keyword">else</span> {
                  style.removeAttribute(name);
                }
              }
            });
          } <span class="hljs-keyword">else</span> {
            elm = self[<span class="hljs-number">0</span>];

            hook = cssHooks[name];
            <span class="hljs-keyword">if</span> (hook &amp;&amp; hook.get) {
              <span class="hljs-keyword">return</span> hook.get(elm);
            }

            <span class="hljs-keyword">if</span> (elm.ownerDocument.defaultView) {
              <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> elm.ownerDocument.defaultView.getComputedStyle(elm, <span class="hljs-literal">null</span>).getPropertyValue(dashed(name));
              } <span class="hljs-keyword">catch</span> (ex) {
                <span class="hljs-keyword">return</span> undef;
              }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elm.currentStyle) {
              <span class="hljs-keyword">return</span> elm.currentStyle[camel(name)];
            }
          }
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Removes all nodes in set from the document.
       *
       * @method remove
       * @return {tinymce.dom.DomQuery} Current set with the removed nodes.
       */</span>
      remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, node, i = <span class="hljs-keyword">this</span>.length;

        <span class="hljs-keyword">while</span> (i--) {
          node = self[i];
          Event.clean(node);

          <span class="hljs-keyword">if</span> (node.parentNode) {
            node.parentNode.removeChild(node);
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Empties all elements in set.
       *
       * @method empty
       * @return {tinymce.dom.DomQuery} Current set with the empty nodes.
       */</span>
      empty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, node, i = <span class="hljs-keyword">this</span>.length;

        <span class="hljs-keyword">while</span> (i--) {
          node = self[i];
          <span class="hljs-keyword">while</span> (node.firstChild) {
            node.removeChild(node.firstChild);
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Sets or gets the HTML of the current set or first set node.
       *
       * @method html
       * @param {String} value Optional innerHTML value to set on each element.
       * @return {tinymce.dom.DomQuery/String} Current set or the innerHTML of the first element.
       */</span>
      html: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, i;

        <span class="hljs-keyword">if</span> (isDefined(value)) {
          i = self.length;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">while</span> (i--) {
              self[i].innerHTML = value;
            }
          } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-306">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-306">&#182;</a>
              </div>
              <p>Workaround for Unknown runtime error when DIV is added to P on IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            DomQuery(self[i]).empty().append(value);
          }

          <span class="hljs-keyword">return</span> self;
        }

        <span class="hljs-keyword">return</span> self[<span class="hljs-number">0</span>] ? self[<span class="hljs-number">0</span>].innerHTML : <span class="hljs-string">''</span>;
      },

      <span class="hljs-comment">/**
       * Sets or gets the text of the current set or first set node.
       *
       * @method text
       * @param {String} value Optional innerText value to set on each element.
       * @return {tinymce.dom.DomQuery/String} Current set or the innerText of the first element.
       */</span>
      text: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, i;

        <span class="hljs-keyword">if</span> (isDefined(value)) {
          i = self.length;
          <span class="hljs-keyword">while</span> (i--) {
            <span class="hljs-keyword">if</span> (<span class="hljs-string">"innerText"</span> <span class="hljs-keyword">in</span> self[i]) {
              self[i].innerText = value;
            } <span class="hljs-keyword">else</span> {
              self[<span class="hljs-number">0</span>].textContent = value;
            }
          }

          <span class="hljs-keyword">return</span> self;
        }

        <span class="hljs-keyword">return</span> self[<span class="hljs-number">0</span>] ? (self[<span class="hljs-number">0</span>].innerText || self[<span class="hljs-number">0</span>].textContent) : <span class="hljs-string">''</span>;
      },

      <span class="hljs-comment">/**
       * Appends the specified node/html or node set to the current set nodes.
       *
       * @method append
       * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to append to each element in set.
       * @return {tinymce.dom.DomQuery} Current set.
       */</span>
      append: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> domManipulate(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-307">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-307">&#182;</a>
              </div>
              <p>Either element or Shadow Root</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nodeType === <span class="hljs-number">1</span> || (<span class="hljs-keyword">this</span>.host &amp;&amp; <span class="hljs-keyword">this</span>.host.nodeType === <span class="hljs-number">1</span>)) {
            <span class="hljs-keyword">this</span>.appendChild(node);
          }
        });
      },

      <span class="hljs-comment">/**
       * Prepends the specified node/html or node set to the current set nodes.
       *
       * @method prepend
       * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to prepend to each element in set.
       * @return {tinymce.dom.DomQuery} Current set.
       */</span>
      prepend: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> domManipulate(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-308">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-308">&#182;</a>
              </div>
              <p>Either element or Shadow Root</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nodeType === <span class="hljs-number">1</span> || (<span class="hljs-keyword">this</span>.host &amp;&amp; <span class="hljs-keyword">this</span>.host.nodeType === <span class="hljs-number">1</span>)) {
            <span class="hljs-keyword">this</span>.insertBefore(node, <span class="hljs-keyword">this</span>.firstChild);
          }
        }, <span class="hljs-literal">true</span>);
      },

      <span class="hljs-comment">/**
       * Adds the specified elements before current set nodes.
       *
       * @method before
       * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to add before to each element in set.
       * @return {tinymce.dom.DomQuery} Current set.
       */</span>
      before: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (self[<span class="hljs-number">0</span>] &amp;&amp; self[<span class="hljs-number">0</span>].parentNode) {
          <span class="hljs-keyword">return</span> domManipulate(self, <span class="hljs-built_in">arguments</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">this</span>.parentNode.insertBefore(node, <span class="hljs-keyword">this</span>);
          });
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Adds the specified elements after current set nodes.
       *
       * @method after
       * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to add after to each element in set.
       * @return {tinymce.dom.DomQuery} Current set.
       */</span>
      after: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (self[<span class="hljs-number">0</span>] &amp;&amp; self[<span class="hljs-number">0</span>].parentNode) {
          <span class="hljs-keyword">return</span> domManipulate(self, <span class="hljs-built_in">arguments</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">this</span>.parentNode.insertBefore(node, <span class="hljs-keyword">this</span>.nextSibling);
          }, <span class="hljs-literal">true</span>);
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Appends the specified set nodes to the specified selector/instance.
       *
       * @method appendTo
       * @param {String/Element/Array/tinymce.dom.DomQuery} val Item to append the current set to.
       * @return {tinymce.dom.DomQuery} Current set with the appended nodes.
       */</span>
      appendTo: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{
        DomQuery(val).append(<span class="hljs-keyword">this</span>);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Prepends the specified set nodes to the specified selector/instance.
       *
       * @method prependTo
       * @param {String/Element/Array/tinymce.dom.DomQuery} val Item to prepend the current set to.
       * @return {tinymce.dom.DomQuery} Current set with the prepended nodes.
       */</span>
      prependTo: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{
        DomQuery(val).prepend(<span class="hljs-keyword">this</span>);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Replaces the nodes in set with the specified content.
       *
       * @method replaceWith
       * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to replace nodes with.
       * @return {tinymce.dom.DomQuery} Set with replaced nodes.
       */</span>
      replaceWith: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">content</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.before(content).remove();
      },

      <span class="hljs-comment">/**
       * Wraps all elements in set with the specified wrapper.
       *
       * @method wrap
       * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to wrap nodes with.
       * @return {tinymce.dom.DomQuery} Set with wrapped nodes.
       */</span>
      wrap: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">content</span>) </span>{
        <span class="hljs-keyword">return</span> wrap(<span class="hljs-keyword">this</span>, content);
      },

      <span class="hljs-comment">/**
       * Wraps all nodes in set with the specified wrapper. If the nodes are siblings all of them
       * will be wrapped in the same wrapper.
       *
       * @method wrapAll
       * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to wrap nodes with.
       * @return {tinymce.dom.DomQuery} Set with wrapped nodes.
       */</span>
      wrapAll: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">content</span>) </span>{
        <span class="hljs-keyword">return</span> wrap(<span class="hljs-keyword">this</span>, content, <span class="hljs-literal">true</span>);
      },

      <span class="hljs-comment">/**
       * Wraps all elements inner contents in set with the specified wrapper.
       *
       * @method wrapInner
       * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to wrap nodes with.
       * @return {tinymce.dom.DomQuery} Set with wrapped nodes.
       */</span>
      wrapInner: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">content</span>) </span>{
        <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          DomQuery(<span class="hljs-keyword">this</span>).contents().wrapAll(content);
        });

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Unwraps all elements by removing the parent element of each item in set.
       *
       * @method unwrap
       * @return {tinymce.dom.DomQuery} Set with unwrapped nodes.
       */</span>
      unwrap: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parent().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          DomQuery(<span class="hljs-keyword">this</span>).replaceWith(<span class="hljs-keyword">this</span>.childNodes);
        });
      },

      <span class="hljs-comment">/**
       * Clones all nodes in set.
       *
       * @method clone
       * @return {tinymce.dom.DomQuery} Set with cloned nodes.
       */</span>
      clone: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> result = [];

        <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          result.push(<span class="hljs-keyword">this</span>.cloneNode(<span class="hljs-literal">true</span>));
        });

        <span class="hljs-keyword">return</span> DomQuery(result);
      },

      <span class="hljs-comment">/**
       * Adds the specified class name to the current set elements.
       *
       * @method addClass
       * @param {String} className Class name to add.
       * @return {tinymce.dom.DomQuery} Current set.
       */</span>
      addClass: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">className</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toggleClass(className, <span class="hljs-literal">true</span>);
      },

      <span class="hljs-comment">/**
       * Removes the specified class name to the current set elements.
       *
       * @method removeClass
       * @param {String} className Class name to remove.
       * @return {tinymce.dom.DomQuery} Current set.
       */</span>
      removeClass: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">className</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toggleClass(className, <span class="hljs-literal">false</span>);
      },

      <span class="hljs-comment">/**
       * Toggles the specified class name on the current set elements.
       *
       * @method toggleClass
       * @param {String} className Class name to add/remove.
       * @param {Boolean} state Optional state to toggle on/off.
       * @return {tinymce.dom.DomQuery} Current set.
       */</span>
      toggleClass: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">className, state</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-309">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-309">&#182;</a>
              </div>
              <p>Functions are not supported</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> className != <span class="hljs-string">'string'</span>) {
          <span class="hljs-keyword">return</span> self;
        }

        <span class="hljs-keyword">if</span> (className.indexOf(<span class="hljs-string">' '</span>) !== <span class="hljs-number">-1</span>) {
          each(className.split(<span class="hljs-string">' '</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            self.toggleClass(<span class="hljs-keyword">this</span>, state);
          });
        } <span class="hljs-keyword">else</span> {
          self.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index, node</span>) </span>{
            <span class="hljs-keyword">var</span> existingClassName, classState;

            classState = hasClass(node, className);
            <span class="hljs-keyword">if</span> (classState !== state) {
              existingClassName = node.className;

              <span class="hljs-keyword">if</span> (classState) {
                node.className = trim((<span class="hljs-string">" "</span> + existingClassName + <span class="hljs-string">" "</span>).replace(<span class="hljs-string">' '</span> + className + <span class="hljs-string">' '</span>, <span class="hljs-string">' '</span>));
              } <span class="hljs-keyword">else</span> {
                node.className += existingClassName ? <span class="hljs-string">' '</span> + className : className;
              }
            }
          });
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Returns true/false if the first item in set has the specified class.
       *
       * @method hasClass
       * @param {String} className Class name to check for.
       * @return {Boolean} True/false if the set has the specified class.
       */</span>
      hasClass: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">className</span>) </span>{
        <span class="hljs-keyword">return</span> hasClass(<span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>], className);
      },

      <span class="hljs-comment">/**
       * Executes the callback function for each item DomQuery collection. If you return false in the
       * callback it will break the loop.
       *
       * @method each
       * @param {function} callback Callback function to execute for each item.
       * @return {tinymce.dom.DomQuery} Current set.
       */</span>
      each: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
        <span class="hljs-keyword">return</span> each(<span class="hljs-keyword">this</span>, callback);
      },

      <span class="hljs-comment">/**
       * Binds an event with callback function to the elements in set.
       *
       * @method on
       * @param {String} name Name of the event to bind.
       * @param {function} callback Callback function to execute when the event occurs.
       * @return {tinymce.dom.DomQuery} Current set.
       */</span>
      on: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, callback</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          Event.bind(<span class="hljs-keyword">this</span>, name, callback);
        });
      },

      <span class="hljs-comment">/**
       * Unbinds an event with callback function to the elements in set.
       *
       * @method off
       * @param {String} name Optional name of the event to bind.
       * @param {function} callback Optional callback function to execute when the event occurs.
       * @return {tinymce.dom.DomQuery} Current set.
       */</span>
      off: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, callback</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          Event.unbind(<span class="hljs-keyword">this</span>, name, callback);
        });
      },

      <span class="hljs-comment">/**
       * Triggers the specified event by name or event object.
       *
       * @method trigger
       * @param {String/Object} name Name of the event to trigger or event object.
       * @return {tinymce.dom.DomQuery} Current set.
       */</span>
      trigger: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name == <span class="hljs-string">'object'</span>) {
            Event.fire(<span class="hljs-keyword">this</span>, name.type, name);
          } <span class="hljs-keyword">else</span> {
            Event.fire(<span class="hljs-keyword">this</span>, name);
          }
        });
      },

      <span class="hljs-comment">/**
       * Shows all elements in set.
       *
       * @method show
       * @return {tinymce.dom.DomQuery} Current set.
       */</span>
      show: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.css(<span class="hljs-string">'display'</span>, <span class="hljs-string">''</span>);
      },

      <span class="hljs-comment">/**
       * Hides all elements in set.
       *
       * @method hide
       * @return {tinymce.dom.DomQuery} Current set.
       */</span>
      hide: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.css(<span class="hljs-string">'display'</span>, <span class="hljs-string">'none'</span>);
      },

      <span class="hljs-comment">/**
       * Slices the current set.
       *
       * @method slice
       * @param {Number} start Start index to slice at.
       * @param {Number} end Optional end index to end slice at.
       * @return {tinymce.dom.DomQuery} Sliced set.
       */</span>
      slice: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DomQuery(slice.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>));
      },

      <span class="hljs-comment">/**
       * Makes the set equal to the specified index.
       *
       * @method eq
       * @param {Number} index Index to set it equal to.
       * @return {tinymce.dom.DomQuery} Single item set.
       */</span>
      eq: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>{
        <span class="hljs-keyword">return</span> index === <span class="hljs-number">-1</span> ? <span class="hljs-keyword">this</span>.slice(index) : <span class="hljs-keyword">this</span>.slice(index, +index + <span class="hljs-number">1</span>);
      },

      <span class="hljs-comment">/**
       * Makes the set equal to first element in set.
       *
       * @method first
       * @return {tinymce.dom.DomQuery} Single item set.
       */</span>
      first: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.eq(<span class="hljs-number">0</span>);
      },

      <span class="hljs-comment">/**
       * Makes the set equal to last element in set.
       *
       * @method last
       * @return {tinymce.dom.DomQuery} Single item set.
       */</span>
      last: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.eq(<span class="hljs-number">-1</span>);
      },

      <span class="hljs-comment">/**
       * Finds elements by the specified selector for each element in set.
       *
       * @method find
       * @param {String} selector Selector to find elements by.
       * @return {tinymce.dom.DomQuery} Set with matches elements.
       */</span>
      find: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
        <span class="hljs-keyword">var</span> i, l, ret = [];

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = <span class="hljs-keyword">this</span>.length; i &lt; l; i++) {
          DomQuery.find(selector, <span class="hljs-keyword">this</span>[i], ret);
        }

        <span class="hljs-keyword">return</span> DomQuery(ret);
      },

      <span class="hljs-comment">/**
       * Filters the current set with the specified selector.
       *
       * @method filter
       * @param {String/function} selector Selector to filter elements by.
       * @return {tinymce.dom.DomQuery} Set with filtered elements.
       */</span>
      filter: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> selector == <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">return</span> DomQuery(grep(<span class="hljs-keyword">this</span>.toArray(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, i</span>) </span>{
            <span class="hljs-keyword">return</span> selector(i, item);
          }));
        }

        <span class="hljs-keyword">return</span> DomQuery(DomQuery.filter(selector, <span class="hljs-keyword">this</span>.toArray()));
      },

      <span class="hljs-comment">/**
       * Gets the current node or any parent matching the specified selector.
       *
       * @method closest
       * @param {String/Element/tinymce.dom.DomQuery} selector Selector or element to find.
       * @return {tinymce.dom.DomQuery} Set with closest elements.
       */</span>
      closest: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
        <span class="hljs-keyword">var</span> result = [];

        <span class="hljs-keyword">if</span> (selector <span class="hljs-keyword">instanceof</span> DomQuery) {
          selector = selector[<span class="hljs-number">0</span>];
        }

        <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i, node</span>) </span>{
          <span class="hljs-keyword">while</span> (node) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> selector == <span class="hljs-string">'string'</span> &amp;&amp; DomQuery(node).is(selector)) {
              result.push(node);
              <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == selector) {
              result.push(node);
              <span class="hljs-keyword">break</span>;
            }

            node = node.parentNode;
          }
        });

        <span class="hljs-keyword">return</span> DomQuery(result);
      },

      <span class="hljs-comment">/**
       * Returns the offset of the first element in set or sets the top/left css properties of all elements in set.
       *
       * @method offset
       * @param {Object} offset Optional offset object to set on each item.
       * @return {Object/tinymce.dom.DomQuery} Returns the first element offset or the current set if you specified an offset.
       */</span>
      offset: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">offset</span>) </span>{
        <span class="hljs-keyword">var</span> elm, doc, docElm;
        <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, pos;

        <span class="hljs-keyword">if</span> (!offset) {
          elm = <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>];

          <span class="hljs-keyword">if</span> (elm) {
            doc = elm.ownerDocument;
            docElm = doc.documentElement;

            <span class="hljs-keyword">if</span> (elm.getBoundingClientRect) {
              pos = elm.getBoundingClientRect();
              x = pos.left + (docElm.scrollLeft || doc.body.scrollLeft) - docElm.clientLeft;
              y = pos.top + (docElm.scrollTop || doc.body.scrollTop) - docElm.clientTop;
            }
          }

          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">left</span>: x,
            <span class="hljs-attr">top</span>: y
          };
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.css(offset);
      },

      <span class="hljs-attr">push</span>: push,
      <span class="hljs-attr">sort</span>: [].sort,
      <span class="hljs-attr">splice</span>: [].splice
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-310">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-310">&#182;</a>
              </div>
              <p>Static members</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tools.extend(DomQuery, {
      <span class="hljs-comment">/**
       * Extends the specified object with one or more objects.
       *
       * @static
       * @method extend
       * @param {Object} target Target object to extend with new items.
       * @param {Object..} object Object to extend the target with.
       * @return {Object} Extended input object.
       */</span>
      extend: Tools.extend,

      <span class="hljs-comment">/**
       * Creates an array out of an array like object.
       *
       * @static
       * @method makeArray
       * @param {Object} object Object to convert to array.
       * @return {Array} Array produced from object.
       */</span>
      makeArray: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">object</span>) </span>{
        <span class="hljs-keyword">if</span> (isWindow(object) || object.nodeType) {
          <span class="hljs-keyword">return</span> [object];
        }

        <span class="hljs-keyword">return</span> Tools.toArray(object);
      },

      <span class="hljs-comment">/**
       * Returns the index of the specified item inside the array.
       *
       * @static
       * @method inArray
       * @param {Object} item Item to look for.
       * @param {Array} array Array to look for item in.
       * @return {Number} Index of the item or -1.
       */</span>
      inArray: inArray,

      <span class="hljs-comment">/**
       * Returns true/false if the specified object is an array or not.
       *
       * @static
       * @method isArray
       * @param {Object} array Object to check if it's an array or not.
       * @return {Boolean} True/false if the object is an array.
       */</span>
      isArray: Tools.isArray,

      <span class="hljs-comment">/**
       * Executes the callback function for each item in array/object. If you return false in the
       * callback it will break the loop.
       *
       * @static
       * @method each
       * @param {Object} obj Object to iterate.
       * @param {function} callback Callback function to execute for each item.
       */</span>
      each: each,

      <span class="hljs-comment">/**
       * Removes whitespace from the beginning and end of a string.
       *
       * @static
       * @method trim
       * @param {String} str String to remove whitespace from.
       * @return {String} New string with removed whitespace.
       */</span>
      trim: trim,

      <span class="hljs-comment">/**
       * Filters out items from the input array by calling the specified function for each item.
       * If the function returns false the item will be excluded if it returns true it will be included.
       *
       * @static
       * @method grep
       * @param {Array} array Array of items to loop though.
       * @param {function} callback Function to call for each item. Include/exclude depends on it's return value.
       * @return {Array} New array with values imported and filtered based in input.
       * @example
       * // Filter out some items, this will return an array with 4 and 5
       * var items = DomQuery.grep([1, 2, 3, 4, 5], function(v) {return v &gt; 3;});
       */</span>
      grep: grep,</pre></div></div>
            
        </li>
        
        
        <li id="section-311">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-311">&#182;</a>
              </div>
              <p>Sizzle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      find: Sizzle,
      <span class="hljs-attr">expr</span>: Sizzle.selectors,
      <span class="hljs-attr">unique</span>: Sizzle.uniqueSort,
      <span class="hljs-attr">text</span>: Sizzle.getText,
      <span class="hljs-attr">contains</span>: Sizzle.contains,
      <span class="hljs-attr">filter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">expr, elems, not</span>) </span>{
        <span class="hljs-keyword">var</span> i = elems.length;

        <span class="hljs-keyword">if</span> (not) {
          expr = <span class="hljs-string">":not("</span> + expr + <span class="hljs-string">")"</span>;
        }

        <span class="hljs-keyword">while</span> (i--) {
          <span class="hljs-keyword">if</span> (elems[i].nodeType != <span class="hljs-number">1</span>) {
            elems.splice(i, <span class="hljs-number">1</span>);
          }
        }

        <span class="hljs-keyword">if</span> (elems.length === <span class="hljs-number">1</span>) {
          elems = DomQuery.find.matchesSelector(elems[<span class="hljs-number">0</span>], expr) ? [elems[<span class="hljs-number">0</span>]] : [];
        } <span class="hljs-keyword">else</span> {
          elems = DomQuery.find.matches(expr, elems);
        }

        <span class="hljs-keyword">return</span> elems;
      }
    });

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dir</span>(<span class="hljs-params">el, prop, until</span>) </span>{
      <span class="hljs-keyword">var</span> matched = [], cur = el[prop];

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> until != <span class="hljs-string">'string'</span> &amp;&amp; until <span class="hljs-keyword">instanceof</span> DomQuery) {
        until = until[<span class="hljs-number">0</span>];
      }

      <span class="hljs-keyword">while</span> (cur &amp;&amp; cur.nodeType !== <span class="hljs-number">9</span>) {
        <span class="hljs-keyword">if</span> (until !== <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">if</span> (cur === until) {
            <span class="hljs-keyword">break</span>;
          }

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> until == <span class="hljs-string">'string'</span> &amp;&amp; DomQuery(cur).is(until)) {
            <span class="hljs-keyword">break</span>;
          }
        }

        <span class="hljs-keyword">if</span> (cur.nodeType === <span class="hljs-number">1</span>) {
          matched.push(cur);
        }

        cur = cur[prop];
      }

      <span class="hljs-keyword">return</span> matched;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sibling</span>(<span class="hljs-params">node, siblingName, nodeType, until</span>) </span>{
      <span class="hljs-keyword">var</span> result = [];

      <span class="hljs-keyword">if</span> (until <span class="hljs-keyword">instanceof</span> DomQuery) {
        until = until[<span class="hljs-number">0</span>];
      }

      <span class="hljs-keyword">for</span> (; node; node = node[siblingName]) {
        <span class="hljs-keyword">if</span> (nodeType &amp;&amp; node.nodeType !== nodeType) {
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (until !== <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">if</span> (node === until) {
            <span class="hljs-keyword">break</span>;
          }

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> until == <span class="hljs-string">'string'</span> &amp;&amp; DomQuery(node).is(until)) {
            <span class="hljs-keyword">break</span>;
          }
        }

        result.push(node);
      }

      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">firstSibling</span>(<span class="hljs-params">node, siblingName, nodeType</span>) </span>{
      <span class="hljs-keyword">for</span> (node = node[siblingName]; node; node = node[siblingName]) {
        <span class="hljs-keyword">if</span> (node.nodeType == nodeType) {
          <span class="hljs-keyword">return</span> node;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    each({
      <span class="hljs-comment">/**
       * Returns a new collection with the parent of each item in current collection matching the optional selector.
       *
       * @method parent
       * @param {Element/tinymce.dom.DomQuery} node Node to match parents against.
       * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching parents.
       */</span>
      parent: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> parent = node.parentNode;

        <span class="hljs-keyword">return</span> parent &amp;&amp; parent.nodeType !== <span class="hljs-number">11</span> ? parent : <span class="hljs-literal">null</span>;
      },

      <span class="hljs-comment">/**
       * Returns a new collection with the all the parents of each item in current collection matching the optional selector.
       *
       * @method parents
       * @param {Element/tinymce.dom.DomQuery} node Node to match parents against.
       * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching parents.
       */</span>
      parents: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> dir(node, <span class="hljs-string">"parentNode"</span>);
      },

      <span class="hljs-comment">/**
       * Returns a new collection with next sibling of each item in current collection matching the optional selector.
       *
       * @method next
       * @param {Element/tinymce.dom.DomQuery} node Node to match the next element against.
       * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
       */</span>
      next: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> firstSibling(node, <span class="hljs-string">'nextSibling'</span>, <span class="hljs-number">1</span>);
      },

      <span class="hljs-comment">/**
       * Returns a new collection with previous sibling of each item in current collection matching the optional selector.
       *
       * @method prev
       * @param {Element/tinymce.dom.DomQuery} node Node to match the previous element against.
       * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
       */</span>
      prev: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> firstSibling(node, <span class="hljs-string">'previousSibling'</span>, <span class="hljs-number">1</span>);
      },

      <span class="hljs-comment">/**
       * Returns all child elements matching the optional selector.
       *
       * @method children
       * @param {Element/tinymce.dom.DomQuery} node Node to match the elements against.
       * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
       */</span>
      children: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> sibling(node.firstChild, <span class="hljs-string">'nextSibling'</span>, <span class="hljs-number">1</span>);
      },

      <span class="hljs-comment">/**
       * Returns all child nodes matching the optional selector.
       *
       * @method contents
       * @param {Element/tinymce.dom.DomQuery} node Node to get the contents of.
       * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
       */</span>
      contents: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> Tools.toArray((node.nodeName === <span class="hljs-string">"iframe"</span> ? node.contentDocument || node.contentWindow.document : node).childNodes);
      }
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, fn</span>) </span>{
      DomQuery.fn[name] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, result = [];

        self.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> nodes = fn.call(result, <span class="hljs-keyword">this</span>, selector, result);

          <span class="hljs-keyword">if</span> (nodes) {
            <span class="hljs-keyword">if</span> (DomQuery.isArray(nodes)) {
              result.push.apply(result, nodes);
            } <span class="hljs-keyword">else</span> {
              result.push(nodes);
            }
          }
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-312">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-312">&#182;</a>
              </div>
              <p>If traversing on multiple elements we might get the same elements twice</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.length &gt; <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">if</span> (!skipUniques[name]) {
            result = DomQuery.unique(result);
          }

          <span class="hljs-keyword">if</span> (name.indexOf(<span class="hljs-string">'parents'</span>) === <span class="hljs-number">0</span>) {
            result = result.reverse();
          }
        }

        result = DomQuery(result);

        <span class="hljs-keyword">if</span> (selector) {
          <span class="hljs-keyword">return</span> result.filter(selector);
        }

        <span class="hljs-keyword">return</span> result;
      };
    });

    each({
      <span class="hljs-comment">/**
       * Returns a new collection with the all the parents until the matching selector/element
       * of each item in current collection matching the optional selector.
       *
       * @method parentsUntil
       * @param {Element/tinymce.dom.DomQuery} node Node to find parent of.
       * @param {String/Element/tinymce.dom.DomQuery} until Until the matching selector or element.
       * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching parents.
       */</span>
      parentsUntil: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, until</span>) </span>{
        <span class="hljs-keyword">return</span> dir(node, <span class="hljs-string">"parentNode"</span>, until);
      },

      <span class="hljs-comment">/**
       * Returns a new collection with all next siblings of each item in current collection matching the optional selector.
       *
       * @method nextUntil
       * @param {Element/tinymce.dom.DomQuery} node Node to find next siblings on.
       * @param {String/Element/tinymce.dom.DomQuery} until Until the matching selector or element.
       * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
       */</span>
      nextUntil: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, until</span>) </span>{
        <span class="hljs-keyword">return</span> sibling(node, <span class="hljs-string">'nextSibling'</span>, <span class="hljs-number">1</span>, until).slice(<span class="hljs-number">1</span>);
      },

      <span class="hljs-comment">/**
       * Returns a new collection with all previous siblings of each item in current collection matching the optional selector.
       *
       * @method prevUntil
       * @param {Element/tinymce.dom.DomQuery} node Node to find previous siblings on.
       * @param {String/Element/tinymce.dom.DomQuery} until Until the matching selector or element.
       * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
       */</span>
      prevUntil: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, until</span>) </span>{
        <span class="hljs-keyword">return</span> sibling(node, <span class="hljs-string">'previousSibling'</span>, <span class="hljs-number">1</span>, until).slice(<span class="hljs-number">1</span>);
      }
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, fn</span>) </span>{
      DomQuery.fn[name] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector, filter</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, result = [];

        self.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> nodes = fn.call(result, <span class="hljs-keyword">this</span>, selector, result);

          <span class="hljs-keyword">if</span> (nodes) {
            <span class="hljs-keyword">if</span> (DomQuery.isArray(nodes)) {
              result.push.apply(result, nodes);
            } <span class="hljs-keyword">else</span> {
              result.push(nodes);
            }
          }
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-313">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-313">&#182;</a>
              </div>
              <p>If traversing on multiple elements we might get the same elements twice</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.length &gt; <span class="hljs-number">1</span>) {
          result = DomQuery.unique(result);

          <span class="hljs-keyword">if</span> (name.indexOf(<span class="hljs-string">'parents'</span>) === <span class="hljs-number">0</span> || name === <span class="hljs-string">'prevUntil'</span>) {
            result = result.reverse();
          }
        }

        result = DomQuery(result);

        <span class="hljs-keyword">if</span> (filter) {
          <span class="hljs-keyword">return</span> result.filter(filter);
        }

        <span class="hljs-keyword">return</span> result;
      };
    });

    <span class="hljs-comment">/**
     * Returns true/false if the current set items matches the selector.
     *
     * @method is
     * @param {String} selector Selector to match the elements against.
     * @return {Boolean} True/false if the current set matches the selector.
     */</span>
    DomQuery.fn.is = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
      <span class="hljs-keyword">return</span> !!selector &amp;&amp; <span class="hljs-keyword">this</span>.filter(selector).length &gt; <span class="hljs-number">0</span>;
    };

    DomQuery.fn.init.prototype = DomQuery.fn;

    DomQuery.overrideDefaults = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
      <span class="hljs-keyword">var</span> defaults;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sub</span>(<span class="hljs-params">selector, context</span>) </span>{
        defaults = defaults || callback();

        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">0</span>) {
          selector = defaults.element;
        }

        <span class="hljs-keyword">if</span> (!context) {
          context = defaults.context;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> sub.fn.init(selector, context);
      }

      DomQuery.extend(sub, <span class="hljs-keyword">this</span>);

      <span class="hljs-keyword">return</span> sub;
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendHooks</span>(<span class="hljs-params">targetHooks, prop, hooks</span>) </span>{
      each(hooks, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, func</span>) </span>{
        targetHooks[name] = targetHooks[name] || {};
        targetHooks[name][prop] = func;
      });
    }

    <span class="hljs-keyword">if</span> (Env.ie &amp;&amp; Env.ie &lt; <span class="hljs-number">8</span>) {
      appendHooks(attrHooks, <span class="hljs-string">'get'</span>, {
        <span class="hljs-attr">maxlength</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
          <span class="hljs-keyword">var</span> value = elm.maxLength;

          <span class="hljs-keyword">if</span> (value === <span class="hljs-number">0x7fffffff</span>) {
            <span class="hljs-keyword">return</span> undef;
          }

          <span class="hljs-keyword">return</span> value;
        },

        <span class="hljs-attr">size</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
          <span class="hljs-keyword">var</span> value = elm.size;

          <span class="hljs-keyword">if</span> (value === <span class="hljs-number">20</span>) {
            <span class="hljs-keyword">return</span> undef;
          }

          <span class="hljs-keyword">return</span> value;
        },

        <span class="hljs-string">'class'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
          <span class="hljs-keyword">return</span> elm.className;
        },

        <span class="hljs-attr">style</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
          <span class="hljs-keyword">var</span> value = elm.style.cssText;

          <span class="hljs-keyword">if</span> (value.length === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> undef;
          }

          <span class="hljs-keyword">return</span> value;
        }
      });

      appendHooks(attrHooks, <span class="hljs-string">'set'</span>, {
        <span class="hljs-string">'class'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, value</span>) </span>{
          elm.className = value;
        },

        <span class="hljs-attr">style</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, value</span>) </span>{
          elm.style.cssText = value;
        }
      });
    }

    <span class="hljs-keyword">if</span> (Env.ie &amp;&amp; Env.ie &lt; <span class="hljs-number">9</span>) {
      <span class="hljs-comment">/*jshint sub:true */</span>
      <span class="hljs-comment">/*eslint dot-notation: 0*/</span>
      cssFix[<span class="hljs-string">'float'</span>] = <span class="hljs-string">'styleFloat'</span>;

      appendHooks(cssHooks, <span class="hljs-string">'set'</span>, {
        <span class="hljs-attr">opacity</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, value</span>) </span>{
          <span class="hljs-keyword">var</span> style = elm.style;

          <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span> || value === <span class="hljs-string">''</span>) {
            style.removeAttribute(<span class="hljs-string">'filter'</span>);
          } <span class="hljs-keyword">else</span> {
            style.zoom = <span class="hljs-number">1</span>;
            style.filter = <span class="hljs-string">'alpha(opacity='</span> + (value * <span class="hljs-number">100</span>) + <span class="hljs-string">')'</span>;
          }
        }
      });
    }

    DomQuery.attrHooks = attrHooks;
    DomQuery.cssHooks = cssHooks;

    <span class="hljs-keyword">return</span> DomQuery;
  }
);

<span class="hljs-comment">/**
 * Styles.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class is used to parse CSS styles it also compresses styles to reduce the output size.
 *
 * @example
 * var Styles = new tinymce.html.Styles({
 *    url_converter: function(url) {
 *       return url;
 *    }
 * });
 *
 * styles = Styles.parse('border: 1px solid red');
 * styles.color = 'red';
 *
 * console.log(new tinymce.html.StyleSerializer().serialize(styles));
 *
 * @class tinymce.html.Styles
 * @version 3.4
 */</span>
define(
  <span class="hljs-string">'tinymce.core.html.Styles'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings, schema</span>) </span>{
      <span class="hljs-comment">/*jshint maxlen:255 */</span>
      <span class="hljs-comment">/*eslint max-len:0 */</span>
      <span class="hljs-keyword">var</span> rgbRegExp = <span class="hljs-regexp">/rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi</span>,
        urlOrStrRegExp = <span class="hljs-regexp">/(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi</span>,
        styleRegExp = <span class="hljs-regexp">/\s*([^:]+):\s*([^;]+);?/g</span>,
        trimRightRegExp = <span class="hljs-regexp">/\s+$/</span>,
        i, encodingLookup = {}, encodingItems, validStyles, invalidStyles, invisibleChar = <span class="hljs-string">'\uFEFF'</span>;

      settings = settings || {};

      <span class="hljs-keyword">if</span> (schema) {
        validStyles = schema.getValidStyles();
        invalidStyles = schema.getInvalidStyles();
      }

      encodingItems = (<span class="hljs-string">'\\" \\\' \\; \\: ; : '</span> + invisibleChar).split(<span class="hljs-string">' '</span>);
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; encodingItems.length; i++) {
        encodingLookup[encodingItems[i]] = invisibleChar + i;
        encodingLookup[invisibleChar + i] = encodingItems[i];
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toHex</span>(<span class="hljs-params">match, r, g, b</span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hex</span>(<span class="hljs-params">val</span>) </span>{
          val = <span class="hljs-built_in">parseInt</span>(val, <span class="hljs-number">10</span>).toString(<span class="hljs-number">16</span>);

          <span class="hljs-keyword">return</span> val.length &gt; <span class="hljs-number">1</span> ? val : <span class="hljs-string">'0'</span> + val; <span class="hljs-comment">// 0 -&gt; 00</span>
        }

        <span class="hljs-keyword">return</span> <span class="hljs-string">'#'</span> + hex(r) + hex(g) + hex(b);
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">/**
         * Parses the specified RGB color value and returns a hex version of that color.
         *
         * @method toHex
         * @param {String} color RGB string value like rgb(1,2,3)
         * @return {String} Hex version of that RGB value like #FF00FF.
         */</span>
        toHex: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">color</span>) </span>{
          <span class="hljs-keyword">return</span> color.replace(rgbRegExp, toHex);
        },

        <span class="hljs-comment">/**
         * Parses the specified style value into an object collection. This parser will also
         * merge and remove any redundant items that browsers might have added. It will also convert non hex
         * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.
         *
         * @method parse
         * @param {String} css Style value to parse for example: border:1px solid red;.
         * @return {Object} Object representation of that style like {border: '1px solid red'}
         */</span>
        parse: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">css</span>) </span>{
          <span class="hljs-keyword">var</span> styles = {}, matches, name, value, isEncoded, urlConverter = settings.url_converter;
          <span class="hljs-keyword">var</span> urlConverterScope = settings.url_converter_scope || <span class="hljs-keyword">this</span>;

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compress</span>(<span class="hljs-params">prefix, suffix, noJoin</span>) </span>{
            <span class="hljs-keyword">var</span> top, right, bottom, left;

            top = styles[prefix + <span class="hljs-string">'-top'</span> + suffix];
            <span class="hljs-keyword">if</span> (!top) {
              <span class="hljs-keyword">return</span>;
            }

            right = styles[prefix + <span class="hljs-string">'-right'</span> + suffix];
            <span class="hljs-keyword">if</span> (!right) {
              <span class="hljs-keyword">return</span>;
            }

            bottom = styles[prefix + <span class="hljs-string">'-bottom'</span> + suffix];
            <span class="hljs-keyword">if</span> (!bottom) {
              <span class="hljs-keyword">return</span>;
            }

            left = styles[prefix + <span class="hljs-string">'-left'</span> + suffix];
            <span class="hljs-keyword">if</span> (!left) {
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">var</span> box = [top, right, bottom, left];
            i = box.length - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (i--) {
              <span class="hljs-keyword">if</span> (box[i] !== box[i + <span class="hljs-number">1</span>]) {
                <span class="hljs-keyword">break</span>;
              }
            }

            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">-1</span> &amp;&amp; noJoin) {
              <span class="hljs-keyword">return</span>;
            }

            styles[prefix + suffix] = i == <span class="hljs-number">-1</span> ? box[<span class="hljs-number">0</span>] : box.join(<span class="hljs-string">' '</span>);
            <span class="hljs-keyword">delete</span> styles[prefix + <span class="hljs-string">'-top'</span> + suffix];
            <span class="hljs-keyword">delete</span> styles[prefix + <span class="hljs-string">'-right'</span> + suffix];
            <span class="hljs-keyword">delete</span> styles[prefix + <span class="hljs-string">'-bottom'</span> + suffix];
            <span class="hljs-keyword">delete</span> styles[prefix + <span class="hljs-string">'-left'</span> + suffix];
          }

          <span class="hljs-comment">/**
           * Checks if the specific style can be compressed in other words if all border-width are equal.
           */</span>
          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canCompress</span>(<span class="hljs-params">key</span>) </span>{
            <span class="hljs-keyword">var</span> value = styles[key], i;

            <span class="hljs-keyword">if</span> (!value) {
              <span class="hljs-keyword">return</span>;
            }

            value = value.split(<span class="hljs-string">' '</span>);
            i = value.length;
            <span class="hljs-keyword">while</span> (i--) {
              <span class="hljs-keyword">if</span> (value[i] !== value[<span class="hljs-number">0</span>]) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
            }

            styles[key] = value[<span class="hljs-number">0</span>];

            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }

          <span class="hljs-comment">/**
           * Compresses multiple styles into one style.
           */</span>
          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compress2</span>(<span class="hljs-params">target, a, b, c</span>) </span>{
            <span class="hljs-keyword">if</span> (!canCompress(a)) {
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (!canCompress(b)) {
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (!canCompress(c)) {
              <span class="hljs-keyword">return</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-314">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-314">&#182;</a>
              </div>
              <p>Compress</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            styles[target] = styles[a] + <span class="hljs-string">' '</span> + styles[b] + <span class="hljs-string">' '</span> + styles[c];
            <span class="hljs-keyword">delete</span> styles[a];
            <span class="hljs-keyword">delete</span> styles[b];
            <span class="hljs-keyword">delete</span> styles[c];
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-315">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-315">&#182;</a>
              </div>
              <p>Encodes the specified string by replacing all \ \ ; : with _<num></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encode</span>(<span class="hljs-params">str</span>) </span>{
            isEncoded = <span class="hljs-literal">true</span>;

            <span class="hljs-keyword">return</span> encodingLookup[str];
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-316">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-316">&#182;</a>
              </div>
              <p>Decodes the specified string by replacing all _<num> with its original value \ \ etc
It will also decode the \ \ if keepSlashes is set to fale or omitted</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decode</span>(<span class="hljs-params">str, keepSlashes</span>) </span>{
            <span class="hljs-keyword">if</span> (isEncoded) {
              str = str.replace(<span class="hljs-regexp">/\uFEFF[0-9]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
                <span class="hljs-keyword">return</span> encodingLookup[str];
              });
            }

            <span class="hljs-keyword">if</span> (!keepSlashes) {
              str = str.replace(<span class="hljs-regexp">/\\([\'\";:])/g</span>, <span class="hljs-string">"$1"</span>);
            }

            <span class="hljs-keyword">return</span> str;
          }

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decodeSingleHexSequence</span>(<span class="hljs-params">escSeq</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-built_in">parseInt</span>(escSeq.slice(<span class="hljs-number">1</span>), <span class="hljs-number">16</span>));
          }

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decodeHexSequences</span>(<span class="hljs-params">value</span>) </span>{
            <span class="hljs-keyword">return</span> value.replace(<span class="hljs-regexp">/\\[0-9a-f]+/gi</span>, decodeSingleHexSequence);
          }

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processUrl</span>(<span class="hljs-params">match, url, url2, url3, str, str2</span>) </span>{
            str = str || str2;

            <span class="hljs-keyword">if</span> (str) {
              str = decode(str);</pre></div></div>
            
        </li>
        
        
        <li id="section-317">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-317">&#182;</a>
              </div>
              <p>Force strings into single quote format</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">return</span> <span class="hljs-string">"'"</span> + str.replace(<span class="hljs-regexp">/\'/g</span>, <span class="hljs-string">"\\'"</span>) + <span class="hljs-string">"'"</span>;
            }

            url = decode(url || url2 || url3);

            <span class="hljs-keyword">if</span> (!settings.allow_script_urls) {
              <span class="hljs-keyword">var</span> scriptUrl = url.replace(<span class="hljs-regexp">/[\s\r\n]+/g</span>, <span class="hljs-string">''</span>);

              <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/(java|vb)script:/i</span>.test(scriptUrl)) {
                <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
              }

              <span class="hljs-keyword">if</span> (!settings.allow_svg_data_urls &amp;&amp; <span class="hljs-regexp">/^data:image\/svg/i</span>.test(scriptUrl)) {
                <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-318">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-318">&#182;</a>
              </div>
              <p>Convert the URL to relative/absolute depending on config</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (urlConverter) {
              url = urlConverter.call(urlConverterScope, url, <span class="hljs-string">'style'</span>);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-319">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-319">&#182;</a>
              </div>
              <p>Output new URL format</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> <span class="hljs-string">"url('"</span> + url.replace(<span class="hljs-regexp">/\'/g</span>, <span class="hljs-string">"\\'"</span>) + <span class="hljs-string">"')"</span>;
          }

          <span class="hljs-keyword">if</span> (css) {
            css = css.replace(<span class="hljs-regexp">/[\u0000-\u001F]/g</span>, <span class="hljs-string">''</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-320">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-320">&#182;</a>
              </div>
              <p>Encode \ \ % and ; and : inside strings so they dont interfere with the style parsing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            css = css.replace(<span class="hljs-regexp">/\\[\"\';:\uFEFF]/g</span>, encode).replace(<span class="hljs-regexp">/\"[^\"]+\"|\'[^\']+\'/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
              <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/[;:]/g</span>, encode);
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-321">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-321">&#182;</a>
              </div>
              <p>Parse styles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">while</span> ((matches = styleRegExp.exec(css))) {
              styleRegExp.lastIndex = matches.index + matches[<span class="hljs-number">0</span>].length;
              name = matches[<span class="hljs-number">1</span>].replace(trimRightRegExp, <span class="hljs-string">''</span>).toLowerCase();
              value = matches[<span class="hljs-number">2</span>].replace(trimRightRegExp, <span class="hljs-string">''</span>);

              <span class="hljs-keyword">if</span> (name &amp;&amp; value) {</pre></div></div>
            
        </li>
        
        
        <li id="section-322">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-322">&#182;</a>
              </div>
              <p>Decode escaped sequences like \65 -&gt; e</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                name = decodeHexSequences(name);
                value = decodeHexSequences(value);</pre></div></div>
            
        </li>
        
        
        <li id="section-323">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-323">&#182;</a>
              </div>
              <p>Skip properties with double quotes and sequences like \ \ in their names
See mXSS Attacks: Attacking well-secured Web-Applications by using innerHTML Mutations
<a href="https://cure53.de/fp170.pdf">https://cure53.de/fp170.pdf</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (name.indexOf(invisibleChar) !== <span class="hljs-number">-1</span> || name.indexOf(<span class="hljs-string">'"'</span>) !== <span class="hljs-number">-1</span>) {
                  <span class="hljs-keyword">continue</span>;
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-324">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-324">&#182;</a>
              </div>
              <p>Dont allow behavior name or expression/comments within the values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (!settings.allow_script_urls &amp;&amp; (name == <span class="hljs-string">"behavior"</span> || <span class="hljs-regexp">/expression\s*\(|\/\*|\*\//</span>.test(value))) {
                  <span class="hljs-keyword">continue</span>;
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-325">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-325">&#182;</a>
              </div>
              <p>Opera will produce 700 instead of bold in their style values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'font-weight'</span> &amp;&amp; value === <span class="hljs-string">'700'</span>) {
                  value = <span class="hljs-string">'bold'</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'color'</span> || name === <span class="hljs-string">'background-color'</span>) { <span class="hljs-comment">// Lowercase colors like RED</span>
                  value = value.toLowerCase();
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-326">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-326">&#182;</a>
              </div>
              <p>Convert RGB colors to HEX</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                value = value.replace(rgbRegExp, toHex);</pre></div></div>
            
        </li>
        
        
        <li id="section-327">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-327">&#182;</a>
              </div>
              <p>Convert URLs and force them into url(value) format</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                value = value.replace(urlOrStrRegExp, processUrl);
                styles[name] = isEncoded ? decode(value, <span class="hljs-literal">true</span>) : value;
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-328">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-328">&#182;</a>
              </div>
              <p>Compress the styles to reduce its size for example IE will expand styles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            compress(<span class="hljs-string">"border"</span>, <span class="hljs-string">""</span>, <span class="hljs-literal">true</span>);
            compress(<span class="hljs-string">"border"</span>, <span class="hljs-string">"-width"</span>);
            compress(<span class="hljs-string">"border"</span>, <span class="hljs-string">"-color"</span>);
            compress(<span class="hljs-string">"border"</span>, <span class="hljs-string">"-style"</span>);
            compress(<span class="hljs-string">"padding"</span>, <span class="hljs-string">""</span>);
            compress(<span class="hljs-string">"margin"</span>, <span class="hljs-string">""</span>);
            compress2(<span class="hljs-string">'border'</span>, <span class="hljs-string">'border-width'</span>, <span class="hljs-string">'border-style'</span>, <span class="hljs-string">'border-color'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-329">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-329">&#182;</a>
              </div>
              <p>Remove pointless border, IE produces these</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (styles.border === <span class="hljs-string">'medium none'</span>) {
              <span class="hljs-keyword">delete</span> styles.border;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-330">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-330">&#182;</a>
              </div>
              <p>IE 11 will produce a border-image: none when getting the style attribute from <p style="border: 1px solid red"></p>
So let us assume it shouldnt be there</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (styles[<span class="hljs-string">'border-image'</span>] === <span class="hljs-string">'none'</span>) {
              <span class="hljs-keyword">delete</span> styles[<span class="hljs-string">'border-image'</span>];
            }
          }

          <span class="hljs-keyword">return</span> styles;
        },

        <span class="hljs-comment">/**
         * Serializes the specified style object into a string.
         *
         * @method serialize
         * @param {Object} styles Object to serialize as string for example: {border: '1px solid red'}
         * @param {String} elementName Optional element name, if specified only the styles that matches the schema will be serialized.
         * @return {String} String representation of the style object for example: border: 1px solid red.
         */</span>
        serialize: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">styles, elementName</span>) </span>{
          <span class="hljs-keyword">var</span> css = <span class="hljs-string">''</span>, name, value;

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serializeStyles</span>(<span class="hljs-params">name</span>) </span>{
            <span class="hljs-keyword">var</span> styleList, i, l, value;

            styleList = validStyles[name];
            <span class="hljs-keyword">if</span> (styleList) {
              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = styleList.length; i &lt; l; i++) {
                name = styleList[i];
                value = styles[name];

                <span class="hljs-keyword">if</span> (value) {
                  css += (css.length &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">' '</span> : <span class="hljs-string">''</span>) + name + <span class="hljs-string">': '</span> + value + <span class="hljs-string">';'</span>;
                }
              }
            }
          }

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">name, elementName</span>) </span>{
            <span class="hljs-keyword">var</span> styleMap;

            styleMap = invalidStyles[<span class="hljs-string">'*'</span>];
            <span class="hljs-keyword">if</span> (styleMap &amp;&amp; styleMap[name]) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            styleMap = invalidStyles[elementName];
            <span class="hljs-keyword">if</span> (styleMap &amp;&amp; styleMap[name]) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-331">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-331">&#182;</a>
              </div>
              <p>Serialize styles according to schema</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (elementName &amp;&amp; validStyles) {</pre></div></div>
            
        </li>
        
        
        <li id="section-332">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-332">&#182;</a>
              </div>
              <p>Serialize global styles and element specific styles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            serializeStyles(<span class="hljs-string">'*'</span>);
            serializeStyles(elementName);
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-333">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-333">&#182;</a>
              </div>
              <p>Output the styles in the order they are inside the object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> styles) {
              value = styles[name];

              <span class="hljs-keyword">if</span> (value &amp;&amp; (!invalidStyles || isValid(name, elementName))) {
                css += (css.length &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">' '</span> : <span class="hljs-string">''</span>) + name + <span class="hljs-string">': '</span> + value + <span class="hljs-string">';'</span>;
              }
            }
          }

          <span class="hljs-keyword">return</span> css;
        }
      };
    };
  }
);

<span class="hljs-comment">/**
 * TreeWalker.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * TreeWalker class enables you to walk the DOM in a linear manner.
 *
 * @class tinymce.dom.TreeWalker
 * @example
 * var walker = new tinymce.dom.TreeWalker(startNode);
 *
 * do {
 *     console.log(walker.current());
 * } while (walker.next());
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.TreeWalker'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">/**
     * Constructs a new TreeWalker instance.
     *
     * @constructor
     * @method TreeWalker
     * @param {Node} startNode Node to start walking from.
     * @param {node} rootNode Optional root node to never walk out of.
     */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">startNode, rootNode</span>) </span>{
      <span class="hljs-keyword">var</span> node = startNode;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSibling</span>(<span class="hljs-params">node, startName, siblingName, shallow</span>) </span>{
        <span class="hljs-keyword">var</span> sibling, parent;

        <span class="hljs-keyword">if</span> (node) {</pre></div></div>
            
        </li>
        
        
        <li id="section-334">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-334">&#182;</a>
              </div>
              <p>Walk into nodes if it has a start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!shallow &amp;&amp; node[startName]) {
            <span class="hljs-keyword">return</span> node[startName];
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-335">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-335">&#182;</a>
              </div>
              <p>Return the sibling if it has one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (node != rootNode) {
            sibling = node[siblingName];
            <span class="hljs-keyword">if</span> (sibling) {
              <span class="hljs-keyword">return</span> sibling;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-336">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-336">&#182;</a>
              </div>
              <p>Walk up the parents to look for siblings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">for</span> (parent = node.parentNode; parent &amp;&amp; parent != rootNode; parent = parent.parentNode) {
              sibling = parent[siblingName];
              <span class="hljs-keyword">if</span> (sibling) {
                <span class="hljs-keyword">return</span> sibling;
              }
            }
          }
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findPreviousNode</span>(<span class="hljs-params">node, startName, siblingName, shallow</span>) </span>{
        <span class="hljs-keyword">var</span> sibling, parent, child;

        <span class="hljs-keyword">if</span> (node) {
          sibling = node[siblingName];
          <span class="hljs-keyword">if</span> (rootNode &amp;&amp; sibling === rootNode) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (sibling) {
            <span class="hljs-keyword">if</span> (!shallow) {</pre></div></div>
            
        </li>
        
        
        <li id="section-337">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-337">&#182;</a>
              </div>
              <p>Walk up the parents to look for siblings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">for</span> (child = sibling[startName]; child; child = child[startName]) {
                <span class="hljs-keyword">if</span> (!child[startName]) {
                  <span class="hljs-keyword">return</span> child;
                }
              }
            }

            <span class="hljs-keyword">return</span> sibling;
          }

          parent = node.parentNode;
          <span class="hljs-keyword">if</span> (parent &amp;&amp; parent !== rootNode) {
            <span class="hljs-keyword">return</span> parent;
          }
        }
      }

      <span class="hljs-comment">/**
       * Returns the current node.
       *
       * @method current
       * @return {Node} Current node where the walker is.
       */</span>
      <span class="hljs-keyword">this</span>.current = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> node;
      };

      <span class="hljs-comment">/**
       * Walks to the next node in tree.
       *
       * @method next
       * @return {Node} Current node where the walker is after moving to the next node.
       */</span>
      <span class="hljs-keyword">this</span>.next = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">shallow</span>) </span>{
        node = findSibling(node, <span class="hljs-string">'firstChild'</span>, <span class="hljs-string">'nextSibling'</span>, shallow);
        <span class="hljs-keyword">return</span> node;
      };

      <span class="hljs-comment">/**
       * Walks to the previous node in tree.
       *
       * @method prev
       * @return {Node} Current node where the walker is after moving to the previous node.
       */</span>
      <span class="hljs-keyword">this</span>.prev = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">shallow</span>) </span>{
        node = findSibling(node, <span class="hljs-string">'lastChild'</span>, <span class="hljs-string">'previousSibling'</span>, shallow);
        <span class="hljs-keyword">return</span> node;
      };

      <span class="hljs-keyword">this</span>.prev2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">shallow</span>) </span>{
        node = findPreviousNode(node, <span class="hljs-string">'lastChild'</span>, <span class="hljs-string">'previousSibling'</span>, shallow);
        <span class="hljs-keyword">return</span> node;
      };
    };
  }
);

<span class="hljs-comment">/**
 * Entities.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/*jshint bitwise:false */</span>
<span class="hljs-comment">/*eslint no-bitwise:0 */</span>

<span class="hljs-comment">/**
 * Entity encoder class.
 *
 * @class tinymce.html.Entities
 * @static
 * @version 3.4
 */</span>
define(
  <span class="hljs-string">'tinymce.core.html.Entities'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Tools</span>) </span>{
    <span class="hljs-keyword">var</span> makeMap = Tools.makeMap;

    <span class="hljs-keyword">var</span> namedEntities, baseEntities, reverseEntities,
      attrsCharsRegExp = <span class="hljs-regexp">/[&amp;&lt;&gt;\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g</span>,
      textCharsRegExp = <span class="hljs-regexp">/[&lt;&gt;&amp;\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g</span>,
      rawCharsRegExp = <span class="hljs-regexp">/[&lt;&gt;&amp;\"\']/g</span>,
      entityRegExp = <span class="hljs-regexp">/&amp;#([a-z0-9]+);?|&amp;([a-z0-9]+);/gi</span>,
      asciiMap = {
        <span class="hljs-number">128</span>: <span class="hljs-string">"\u20AC"</span>, <span class="hljs-number">130</span>: <span class="hljs-string">"\u201A"</span>, <span class="hljs-number">131</span>: <span class="hljs-string">"\u0192"</span>, <span class="hljs-number">132</span>: <span class="hljs-string">"\u201E"</span>, <span class="hljs-number">133</span>: <span class="hljs-string">"\u2026"</span>, <span class="hljs-number">134</span>: <span class="hljs-string">"\u2020"</span>,
        <span class="hljs-number">135</span>: <span class="hljs-string">"\u2021"</span>, <span class="hljs-number">136</span>: <span class="hljs-string">"\u02C6"</span>, <span class="hljs-number">137</span>: <span class="hljs-string">"\u2030"</span>, <span class="hljs-number">138</span>: <span class="hljs-string">"\u0160"</span>, <span class="hljs-number">139</span>: <span class="hljs-string">"\u2039"</span>, <span class="hljs-number">140</span>: <span class="hljs-string">"\u0152"</span>,
        <span class="hljs-number">142</span>: <span class="hljs-string">"\u017D"</span>, <span class="hljs-number">145</span>: <span class="hljs-string">"\u2018"</span>, <span class="hljs-number">146</span>: <span class="hljs-string">"\u2019"</span>, <span class="hljs-number">147</span>: <span class="hljs-string">"\u201C"</span>, <span class="hljs-number">148</span>: <span class="hljs-string">"\u201D"</span>, <span class="hljs-number">149</span>: <span class="hljs-string">"\u2022"</span>,
        <span class="hljs-number">150</span>: <span class="hljs-string">"\u2013"</span>, <span class="hljs-number">151</span>: <span class="hljs-string">"\u2014"</span>, <span class="hljs-number">152</span>: <span class="hljs-string">"\u02DC"</span>, <span class="hljs-number">153</span>: <span class="hljs-string">"\u2122"</span>, <span class="hljs-number">154</span>: <span class="hljs-string">"\u0161"</span>, <span class="hljs-number">155</span>: <span class="hljs-string">"\u203A"</span>,
        <span class="hljs-number">156</span>: <span class="hljs-string">"\u0153"</span>, <span class="hljs-number">158</span>: <span class="hljs-string">"\u017E"</span>, <span class="hljs-number">159</span>: <span class="hljs-string">"\u0178"</span>
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-338">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-338">&#182;</a>
              </div>
              <p>Raw entities</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    baseEntities = {
      <span class="hljs-string">'\"'</span>: <span class="hljs-string">'&amp;quot;'</span>, <span class="hljs-comment">// Needs to be escaped since the YUI compressor would otherwise break the code</span>
      <span class="hljs-string">"'"</span>: <span class="hljs-string">'&amp;#39;'</span>,
      <span class="hljs-string">'&lt;'</span>: <span class="hljs-string">'&amp;lt;'</span>,
      <span class="hljs-string">'&gt;'</span>: <span class="hljs-string">'&amp;gt;'</span>,
      <span class="hljs-string">'&amp;'</span>: <span class="hljs-string">'&amp;amp;'</span>,
      <span class="hljs-string">'\u0060'</span>: <span class="hljs-string">'&amp;#96;'</span>
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-339">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-339">&#182;</a>
              </div>
              <p>Reverse lookup table for raw entities</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    reverseEntities = {
      <span class="hljs-string">'&amp;lt;'</span>: <span class="hljs-string">'&lt;'</span>,
      <span class="hljs-string">'&amp;gt;'</span>: <span class="hljs-string">'&gt;'</span>,
      <span class="hljs-string">'&amp;amp;'</span>: <span class="hljs-string">'&amp;'</span>,
      <span class="hljs-string">'&amp;quot;'</span>: <span class="hljs-string">'"'</span>,
      <span class="hljs-string">'&amp;apos;'</span>: <span class="hljs-string">"'"</span>
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-340">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-340">&#182;</a>
              </div>
              <p>Decodes text by using the browser</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nativeDecode</span>(<span class="hljs-params">text</span>) </span>{
      <span class="hljs-keyword">var</span> elm;

      elm = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>);
      elm.innerHTML = text;

      <span class="hljs-keyword">return</span> elm.textContent || elm.innerText || text;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-341">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-341">&#182;</a>
              </div>
              <p>Build a two way lookup table for the entities</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildEntitiesLookup</span>(<span class="hljs-params">items, radix</span>) </span>{
      <span class="hljs-keyword">var</span> i, chr, entity, lookup = {};

      <span class="hljs-keyword">if</span> (items) {
        items = items.split(<span class="hljs-string">','</span>);
        radix = radix || <span class="hljs-number">10</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-342">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-342">&#182;</a>
              </div>
              <p>Build entities lookup table</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; items.length; i += <span class="hljs-number">2</span>) {
          chr = <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-built_in">parseInt</span>(items[i], radix));</pre></div></div>
            
        </li>
        
        
        <li id="section-343">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-343">&#182;</a>
              </div>
              <p>Only add non base entities</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!baseEntities[chr]) {
            entity = <span class="hljs-string">'&amp;'</span> + items[i + <span class="hljs-number">1</span>] + <span class="hljs-string">';'</span>;
            lookup[chr] = entity;
            lookup[entity] = chr;
          }
        }

        <span class="hljs-keyword">return</span> lookup;
      }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-344">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-344">&#182;</a>
              </div>
              <p>Unpack entities lookup where the numbers are in radix 32 to reduce the size</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    namedEntities = buildEntitiesLookup(
      <span class="hljs-string">'50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,'</span> +
      <span class="hljs-string">'5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,'</span> +
      <span class="hljs-string">'5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,'</span> +
      <span class="hljs-string">'5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,'</span> +
      <span class="hljs-string">'68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,'</span> +
      <span class="hljs-string">'6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,'</span> +
      <span class="hljs-string">'6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,'</span> +
      <span class="hljs-string">'75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,'</span> +
      <span class="hljs-string">'7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,'</span> +
      <span class="hljs-string">'7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,'</span> +
      <span class="hljs-string">'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,'</span> +
      <span class="hljs-string">'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,'</span> +
      <span class="hljs-string">'t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,'</span> +
      <span class="hljs-string">'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,'</span> +
      <span class="hljs-string">'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,'</span> +
      <span class="hljs-string">'81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,'</span> +
      <span class="hljs-string">'8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,'</span> +
      <span class="hljs-string">'8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,'</span> +
      <span class="hljs-string">'8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,'</span> +
      <span class="hljs-string">'8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,'</span> +
      <span class="hljs-string">'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,'</span> +
      <span class="hljs-string">'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,'</span> +
      <span class="hljs-string">'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,'</span> +
      <span class="hljs-string">'80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,'</span> +
      <span class="hljs-string">'811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro'</span>, <span class="hljs-number">32</span>);

    <span class="hljs-keyword">var</span> Entities = {
      <span class="hljs-comment">/**
       * Encodes the specified string using raw entities. This means only the required XML base entities will be encoded.
       *
       * @method encodeRaw
       * @param {String} text Text to encode.
       * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
       * @return {String} Entity encoded text.
       */</span>
      encodeRaw: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, attr</span>) </span>{
        <span class="hljs-keyword">return</span> text.replace(attr ? attrsCharsRegExp : textCharsRegExp, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chr</span>) </span>{
          <span class="hljs-keyword">return</span> baseEntities[chr] || chr;
        });
      },

      <span class="hljs-comment">/**
       * Encoded the specified text with both the attributes and text entities. This function will produce larger text contents
       * since it doesn't know if the context is within a attribute or text node. This was added for compatibility
       * and is exposed as the DOMUtils.encode function.
       *
       * @method encodeAllRaw
       * @param {String} text Text to encode.
       * @return {String} Entity encoded text.
       */</span>
      encodeAllRaw: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
        <span class="hljs-keyword">return</span> (<span class="hljs-string">''</span> + text).replace(rawCharsRegExp, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chr</span>) </span>{
          <span class="hljs-keyword">return</span> baseEntities[chr] || chr;
        });
      },

      <span class="hljs-comment">/**
       * Encodes the specified string using numeric entities. The core entities will be
       * encoded as named ones but all non lower ascii characters will be encoded into numeric entities.
       *
       * @method encodeNumeric
       * @param {String} text Text to encode.
       * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
       * @return {String} Entity encoded text.
       */</span>
      encodeNumeric: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, attr</span>) </span>{
        <span class="hljs-keyword">return</span> text.replace(attr ? attrsCharsRegExp : textCharsRegExp, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chr</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-345">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-345">&#182;</a>
              </div>
              <p>Multi byte sequence convert it to a single entity</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (chr.length &gt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'&amp;#'</span> + (((chr.charCodeAt(<span class="hljs-number">0</span>) - <span class="hljs-number">0xD800</span>) * <span class="hljs-number">0x400</span>) + (chr.charCodeAt(<span class="hljs-number">1</span>) - <span class="hljs-number">0xDC00</span>) + <span class="hljs-number">0x10000</span>) + <span class="hljs-string">';'</span>;
          }

          <span class="hljs-keyword">return</span> baseEntities[chr] || <span class="hljs-string">'&amp;#'</span> + chr.charCodeAt(<span class="hljs-number">0</span>) + <span class="hljs-string">';'</span>;
        });
      },

      <span class="hljs-comment">/**
       * Encodes the specified string using named entities. The core entities will be encoded
       * as named ones but all non lower ascii characters will be encoded into named entities.
       *
       * @method encodeNamed
       * @param {String} text Text to encode.
       * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
       * @param {Object} entities Optional parameter with entities to use.
       * @return {String} Entity encoded text.
       */</span>
      encodeNamed: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, attr, entities</span>) </span>{
        entities = entities || namedEntities;

        <span class="hljs-keyword">return</span> text.replace(attr ? attrsCharsRegExp : textCharsRegExp, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chr</span>) </span>{
          <span class="hljs-keyword">return</span> baseEntities[chr] || entities[chr] || chr;
        });
      },

      <span class="hljs-comment">/**
       * Returns an encode function based on the name(s) and it's optional entities.
       *
       * @method getEncodeFunc
       * @param {String} name Comma separated list of encoders for example named,numeric.
       * @param {String} entities Optional parameter with entities to use instead of the built in set.
       * @return {function} Encode function to be used.
       */</span>
      getEncodeFunc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, entities</span>) </span>{
        entities = buildEntitiesLookup(entities) || namedEntities;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encodeNamedAndNumeric</span>(<span class="hljs-params">text, attr</span>) </span>{
          <span class="hljs-keyword">return</span> text.replace(attr ? attrsCharsRegExp : textCharsRegExp, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chr</span>) </span>{
            <span class="hljs-keyword">if</span> (baseEntities[chr] !== <span class="hljs-literal">undefined</span>) {
              <span class="hljs-keyword">return</span> baseEntities[chr];
            }

            <span class="hljs-keyword">if</span> (entities[chr] !== <span class="hljs-literal">undefined</span>) {
              <span class="hljs-keyword">return</span> entities[chr];
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-346">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-346">&#182;</a>
              </div>
              <p>Convert multi-byte sequences to a single entity.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (chr.length &gt; <span class="hljs-number">1</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-string">'&amp;#'</span> + (((chr.charCodeAt(<span class="hljs-number">0</span>) - <span class="hljs-number">0xD800</span>) * <span class="hljs-number">0x400</span>) + (chr.charCodeAt(<span class="hljs-number">1</span>) - <span class="hljs-number">0xDC00</span>) + <span class="hljs-number">0x10000</span>) + <span class="hljs-string">';'</span>;
            }

            <span class="hljs-keyword">return</span> <span class="hljs-string">'&amp;#'</span> + chr.charCodeAt(<span class="hljs-number">0</span>) + <span class="hljs-string">';'</span>;
          });
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encodeCustomNamed</span>(<span class="hljs-params">text, attr</span>) </span>{
          <span class="hljs-keyword">return</span> Entities.encodeNamed(text, attr, entities);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-347">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-347">&#182;</a>
              </div>
              <p>Replace + with , to be compatible with previous TinyMCE versions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        name = makeMap(name.replace(<span class="hljs-regexp">/\+/g</span>, <span class="hljs-string">','</span>));</pre></div></div>
            
        </li>
        
        
        <li id="section-348">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-348">&#182;</a>
              </div>
              <p>Named and numeric encoder</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (name.named &amp;&amp; name.numeric) {
          <span class="hljs-keyword">return</span> encodeNamedAndNumeric;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-349">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-349">&#182;</a>
              </div>
              <p>Named encoder</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (name.named) {</pre></div></div>
            
        </li>
        
        
        <li id="section-350">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-350">&#182;</a>
              </div>
              <p>Custom names</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (entities) {
            <span class="hljs-keyword">return</span> encodeCustomNamed;
          }

          <span class="hljs-keyword">return</span> Entities.encodeNamed;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-351">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-351">&#182;</a>
              </div>
              <p>Numeric</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (name.numeric) {
          <span class="hljs-keyword">return</span> Entities.encodeNumeric;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-352">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-352">&#182;</a>
              </div>
              <p>Raw encoder</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> Entities.encodeRaw;
      },

      <span class="hljs-comment">/**
       * Decodes the specified string, this will replace entities with raw UTF characters.
       *
       * @method decode
       * @param {String} text Text to entity decode.
       * @return {String} Entity decoded string.
       */</span>
      decode: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
        <span class="hljs-keyword">return</span> text.replace(entityRegExp, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">all, numeric</span>) </span>{
          <span class="hljs-keyword">if</span> (numeric) {
            <span class="hljs-keyword">if</span> (numeric.charAt(<span class="hljs-number">0</span>).toLowerCase() === <span class="hljs-string">'x'</span>) {
              numeric = <span class="hljs-built_in">parseInt</span>(numeric.substr(<span class="hljs-number">1</span>), <span class="hljs-number">16</span>);
            } <span class="hljs-keyword">else</span> {
              numeric = <span class="hljs-built_in">parseInt</span>(numeric, <span class="hljs-number">10</span>);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-353">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-353">&#182;</a>
              </div>
              <p>Support upper UTF</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (numeric &gt; <span class="hljs-number">0xFFFF</span>) {
              numeric -= <span class="hljs-number">0x10000</span>;

              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0xD800</span> + (numeric &gt;&gt; <span class="hljs-number">10</span>), <span class="hljs-number">0xDC00</span> + (numeric &amp; <span class="hljs-number">0x3FF</span>));
            }

            <span class="hljs-keyword">return</span> asciiMap[numeric] || <span class="hljs-built_in">String</span>.fromCharCode(numeric);
          }

          <span class="hljs-keyword">return</span> reverseEntities[all] || namedEntities[all] || nativeDecode(all);
        });
      }
    };

    <span class="hljs-keyword">return</span> Entities;
  }
);

<span class="hljs-comment">/**
 * Range.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Old IE Range.
 *
 * @private
 * @class tinymce.dom.Range
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.Range'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Tools</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-354">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-354">&#182;</a>
              </div>
              <p>Range constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Range</span>(<span class="hljs-params">dom</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>,
        doc = dom.doc,
        EXTRACT = <span class="hljs-number">0</span>,
        CLONE = <span class="hljs-number">1</span>,
        DELETE = <span class="hljs-number">2</span>,
        TRUE = <span class="hljs-literal">true</span>,
        FALSE = <span class="hljs-literal">false</span>,
        START_OFFSET = <span class="hljs-string">'startOffset'</span>,
        START_CONTAINER = <span class="hljs-string">'startContainer'</span>,
        END_CONTAINER = <span class="hljs-string">'endContainer'</span>,
        END_OFFSET = <span class="hljs-string">'endOffset'</span>,
        extend = Tools.extend,
        nodeIndex = dom.nodeIndex;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createDocumentFragment</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> doc.createDocumentFragment();
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setStart</span>(<span class="hljs-params">n, o</span>) </span>{
        _setEndPoint(TRUE, n, o);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setEnd</span>(<span class="hljs-params">n, o</span>) </span>{
        _setEndPoint(FALSE, n, o);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setStartBefore</span>(<span class="hljs-params">n</span>) </span>{
        setStart(n.parentNode, nodeIndex(n));
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setStartAfter</span>(<span class="hljs-params">n</span>) </span>{
        setStart(n.parentNode, nodeIndex(n) + <span class="hljs-number">1</span>);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setEndBefore</span>(<span class="hljs-params">n</span>) </span>{
        setEnd(n.parentNode, nodeIndex(n));
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setEndAfter</span>(<span class="hljs-params">n</span>) </span>{
        setEnd(n.parentNode, nodeIndex(n) + <span class="hljs-number">1</span>);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collapse</span>(<span class="hljs-params">ts</span>) </span>{
        <span class="hljs-keyword">if</span> (ts) {
          self[END_CONTAINER] = self[START_CONTAINER];
          self[END_OFFSET] = self[START_OFFSET];
        } <span class="hljs-keyword">else</span> {
          self[START_CONTAINER] = self[END_CONTAINER];
          self[START_OFFSET] = self[END_OFFSET];
        }

        self.collapsed = TRUE;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectNode</span>(<span class="hljs-params">n</span>) </span>{
        setStartBefore(n);
        setEndAfter(n);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectNodeContents</span>(<span class="hljs-params">n</span>) </span>{
        setStart(n, <span class="hljs-number">0</span>);
        setEnd(n, n.nodeType === <span class="hljs-number">1</span> ? n.childNodes.length : n.nodeValue.length);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareBoundaryPoints</span>(<span class="hljs-params">h, r</span>) </span>{
        <span class="hljs-keyword">var</span> sc = self[START_CONTAINER], so = self[START_OFFSET], ec = self[END_CONTAINER], eo = self[END_OFFSET],
          rsc = r.startContainer, rso = r.startOffset, rec = r.endContainer, reo = r.endOffset;</pre></div></div>
            
        </li>
        
        
        <li id="section-355">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-355">&#182;</a>
              </div>
              <p>Check START_TO_START</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (h === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> _compareBoundaryPoints(sc, so, rsc, rso);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-356">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-356">&#182;</a>
              </div>
              <p>Check START_TO_END</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (h === <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">return</span> _compareBoundaryPoints(ec, eo, rsc, rso);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-357">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-357">&#182;</a>
              </div>
              <p>Check END_TO_END</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (h === <span class="hljs-number">2</span>) {
          <span class="hljs-keyword">return</span> _compareBoundaryPoints(ec, eo, rec, reo);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-358">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-358">&#182;</a>
              </div>
              <p>Check END_TO_START</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (h === <span class="hljs-number">3</span>) {
          <span class="hljs-keyword">return</span> _compareBoundaryPoints(sc, so, rec, reo);
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteContents</span>(<span class="hljs-params"></span>) </span>{
        _traverse(DELETE);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extractContents</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> _traverse(EXTRACT);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneContents</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> _traverse(CLONE);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertNode</span>(<span class="hljs-params">n</span>) </span>{
        <span class="hljs-keyword">var</span> startContainer = <span class="hljs-keyword">this</span>[START_CONTAINER],
          startOffset = <span class="hljs-keyword">this</span>[START_OFFSET], nn, o;</pre></div></div>
            
        </li>
        
        
        <li id="section-359">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-359">&#182;</a>
              </div>
              <p>Node is TEXT_NODE or CDATA</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((startContainer.nodeType === <span class="hljs-number">3</span> || startContainer.nodeType === <span class="hljs-number">4</span>) &amp;&amp; startContainer.nodeValue) {
          <span class="hljs-keyword">if</span> (!startOffset) {</pre></div></div>
            
        </li>
        
        
        <li id="section-360">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-360">&#182;</a>
              </div>
              <p>At the start of text</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            startContainer.parentNode.insertBefore(n, startContainer);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (startOffset &gt;= startContainer.nodeValue.length) {</pre></div></div>
            
        </li>
        
        
        <li id="section-361">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-361">&#182;</a>
              </div>
              <p>At the end of text</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            dom.insertAfter(n, startContainer);
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-362">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-362">&#182;</a>
              </div>
              <p>Middle, need to split</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            nn = startContainer.splitText(startOffset);
            startContainer.parentNode.insertBefore(n, nn);
          }
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-363">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-363">&#182;</a>
              </div>
              <p>Insert element node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (startContainer.childNodes.length &gt; <span class="hljs-number">0</span>) {
            o = startContainer.childNodes[startOffset];
          }

          <span class="hljs-keyword">if</span> (o) {
            startContainer.insertBefore(n, o);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (startContainer.nodeType == <span class="hljs-number">3</span>) {
              dom.insertAfter(n, startContainer);
            } <span class="hljs-keyword">else</span> {
              startContainer.appendChild(n);
            }
          }
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">surroundContents</span>(<span class="hljs-params">n</span>) </span>{
        <span class="hljs-keyword">var</span> f = self.extractContents();

        self.insertNode(n);
        n.appendChild(f);
        self.selectNode(n);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneRange</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> extend(<span class="hljs-keyword">new</span> Range(dom), {
          <span class="hljs-attr">startContainer</span>: self[START_CONTAINER],
          <span class="hljs-attr">startOffset</span>: self[START_OFFSET],
          <span class="hljs-attr">endContainer</span>: self[END_CONTAINER],
          <span class="hljs-attr">endOffset</span>: self[END_OFFSET],
          <span class="hljs-attr">collapsed</span>: self.collapsed,
          <span class="hljs-attr">commonAncestorContainer</span>: self.commonAncestorContainer
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-364">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-364">&#182;</a>
              </div>
              <p>Private methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_getSelectedNode</span>(<span class="hljs-params">container, offset</span>) </span>{
        <span class="hljs-keyword">var</span> child;</pre></div></div>
            
        </li>
        
        
        <li id="section-365">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-365">&#182;</a>
              </div>
              <p>TEXT_NODE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">3</span>) {
          <span class="hljs-keyword">return</span> container;
        }

        <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> container;
        }

        child = container.firstChild;
        <span class="hljs-keyword">while</span> (child &amp;&amp; offset &gt; <span class="hljs-number">0</span>) {
          --offset;
          child = child.nextSibling;
        }

        <span class="hljs-keyword">if</span> (child) {
          <span class="hljs-keyword">return</span> child;
        }

        <span class="hljs-keyword">return</span> container;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isCollapsed</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> (self[START_CONTAINER] == self[END_CONTAINER] &amp;&amp; self[START_OFFSET] == self[END_OFFSET]);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_compareBoundaryPoints</span>(<span class="hljs-params">containerA, offsetA, containerB, offsetB</span>) </span>{
        <span class="hljs-keyword">var</span> c, offsetC, n, cmnRoot, childA, childB;</pre></div></div>
            
        </li>
        
        
        <li id="section-366">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-366">&#182;</a>
              </div>
              <p>In the first case the boundary-points have the same container. A is before B
if its offset is less than the offset of B, A is equal to B if its offset is
equal to the offset of B, and A is after B if its offset is greater than the
offset of B.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (containerA == containerB) {
          <span class="hljs-keyword">if</span> (offsetA == offsetB) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// equal</span>
          }

          <span class="hljs-keyword">if</span> (offsetA &lt; offsetB) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// before</span>
          }

          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// after</span>
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-367">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-367">&#182;</a>
              </div>
              <p>In the second case a child node C of the container of A is an ancestor
container of B. In this case, A is before B if the offset of A is less than or
equal to the index of the child node C and A is after B otherwise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        c = containerB;
        <span class="hljs-keyword">while</span> (c &amp;&amp; c.parentNode != containerA) {
          c = c.parentNode;
        }

        <span class="hljs-keyword">if</span> (c) {
          offsetC = <span class="hljs-number">0</span>;
          n = containerA.firstChild;

          <span class="hljs-keyword">while</span> (n != c &amp;&amp; offsetC &lt; offsetA) {
            offsetC++;
            n = n.nextSibling;
          }

          <span class="hljs-keyword">if</span> (offsetA &lt;= offsetC) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// before</span>
          }

          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// after</span>
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-368">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-368">&#182;</a>
              </div>
              <p>In the third case a child node C of the container of B is an ancestor container
of A. In this case, A is before B if the index of the child node C is less than
the offset of B and A is after B otherwise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        c = containerA;
        <span class="hljs-keyword">while</span> (c &amp;&amp; c.parentNode != containerB) {
          c = c.parentNode;
        }

        <span class="hljs-keyword">if</span> (c) {
          offsetC = <span class="hljs-number">0</span>;
          n = containerB.firstChild;

          <span class="hljs-keyword">while</span> (n != c &amp;&amp; offsetC &lt; offsetB) {
            offsetC++;
            n = n.nextSibling;
          }

          <span class="hljs-keyword">if</span> (offsetC &lt; offsetB) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// before</span>
          }

          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// after</span>
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-369">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-369">&#182;</a>
              </div>
              <p>In the fourth case, none of three other cases hold: the containers of A and B
are siblings or descendants of sibling nodes. In this case, A is before B if
the container of A is before the container of B in a pre-order traversal of the
Ranges context tree and A is after B otherwise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        cmnRoot = dom.findCommonAncestor(containerA, containerB);
        childA = containerA;

        <span class="hljs-keyword">while</span> (childA &amp;&amp; childA.parentNode != cmnRoot) {
          childA = childA.parentNode;
        }

        <span class="hljs-keyword">if</span> (!childA) {
          childA = cmnRoot;
        }

        childB = containerB;
        <span class="hljs-keyword">while</span> (childB &amp;&amp; childB.parentNode != cmnRoot) {
          childB = childB.parentNode;
        }

        <span class="hljs-keyword">if</span> (!childB) {
          childB = cmnRoot;
        }

        <span class="hljs-keyword">if</span> (childA == childB) {
          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// equal</span>
        }

        n = cmnRoot.firstChild;
        <span class="hljs-keyword">while</span> (n) {
          <span class="hljs-keyword">if</span> (n == childA) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// before</span>
          }

          <span class="hljs-keyword">if</span> (n == childB) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// after</span>
          }

          n = n.nextSibling;
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_setEndPoint</span>(<span class="hljs-params">st, n, o</span>) </span>{
        <span class="hljs-keyword">var</span> ec, sc;

        <span class="hljs-keyword">if</span> (st) {
          self[START_CONTAINER] = n;
          self[START_OFFSET] = o;
        } <span class="hljs-keyword">else</span> {
          self[END_CONTAINER] = n;
          self[END_OFFSET] = o;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-370">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-370">&#182;</a>
              </div>
              <p>If one boundary-point of a Range is set to have a root container
other than the current one for the Range, the Range is collapsed to
the new position. This enforces the restriction that both boundary-
points of a Range must have the same root container.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        ec = self[END_CONTAINER];
        <span class="hljs-keyword">while</span> (ec.parentNode) {
          ec = ec.parentNode;
        }

        sc = self[START_CONTAINER];
        <span class="hljs-keyword">while</span> (sc.parentNode) {
          sc = sc.parentNode;
        }

        <span class="hljs-keyword">if</span> (sc == ec) {</pre></div></div>
            
        </li>
        
        
        <li id="section-371">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-371">&#182;</a>
              </div>
              <p>The start position of a Range is guaranteed to never be after the
end position. To enforce this restriction, if the start is set to
be at a position after the end, the Range is collapsed to that
position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (_compareBoundaryPoints(self[START_CONTAINER], self[START_OFFSET], self[END_CONTAINER], self[END_OFFSET]) &gt; <span class="hljs-number">0</span>) {
            self.collapse(st);
          }
        } <span class="hljs-keyword">else</span> {
          self.collapse(st);
        }

        self.collapsed = _isCollapsed();
        self.commonAncestorContainer = dom.findCommonAncestor(self[START_CONTAINER], self[END_CONTAINER]);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_traverse</span>(<span class="hljs-params">how</span>) </span>{
        <span class="hljs-keyword">var</span> c, endContainerDepth = <span class="hljs-number">0</span>, startContainerDepth = <span class="hljs-number">0</span>, p, depthDiff, startNode, endNode, sp, ep;

        <span class="hljs-keyword">if</span> (self[START_CONTAINER] == self[END_CONTAINER]) {
          <span class="hljs-keyword">return</span> _traverseSameContainer(how);
        }

        <span class="hljs-keyword">for</span> (c = self[END_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {
          <span class="hljs-keyword">if</span> (p == self[START_CONTAINER]) {
            <span class="hljs-keyword">return</span> _traverseCommonStartContainer(c, how);
          }

          ++endContainerDepth;
        }

        <span class="hljs-keyword">for</span> (c = self[START_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {
          <span class="hljs-keyword">if</span> (p == self[END_CONTAINER]) {
            <span class="hljs-keyword">return</span> _traverseCommonEndContainer(c, how);
          }

          ++startContainerDepth;
        }

        depthDiff = startContainerDepth - endContainerDepth;

        startNode = self[START_CONTAINER];
        <span class="hljs-keyword">while</span> (depthDiff &gt; <span class="hljs-number">0</span>) {
          startNode = startNode.parentNode;
          depthDiff--;
        }

        endNode = self[END_CONTAINER];
        <span class="hljs-keyword">while</span> (depthDiff &lt; <span class="hljs-number">0</span>) {
          endNode = endNode.parentNode;
          depthDiff++;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-372">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-372">&#182;</a>
              </div>
              <p>ascend the ancestor hierarchy until we have a common parent.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (sp = startNode.parentNode, ep = endNode.parentNode; sp != ep; sp = sp.parentNode, ep = ep.parentNode) {
          startNode = sp;
          endNode = ep;
        }

        <span class="hljs-keyword">return</span> _traverseCommonAncestors(startNode, endNode, how);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_traverseSameContainer</span>(<span class="hljs-params">how</span>) </span>{
        <span class="hljs-keyword">var</span> frag, s, sub, n, cnt, sibling, xferNode, start, len;

        <span class="hljs-keyword">if</span> (how != DELETE) {
          frag = createDocumentFragment();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-373">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-373">&#182;</a>
              </div>
              <p>If selection is empty, just return the fragment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self[START_OFFSET] == self[END_OFFSET]) {
          <span class="hljs-keyword">return</span> frag;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-374">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-374">&#182;</a>
              </div>
              <p>Text node needs special case handling</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self[START_CONTAINER].nodeType == <span class="hljs-number">3</span>) { <span class="hljs-comment">// TEXT_NODE</span></pre></div></div>
            
        </li>
        
        
        <li id="section-375">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-375">&#182;</a>
              </div>
              <p>get the substring</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          s = self[START_CONTAINER].nodeValue;
          sub = s.substring(self[START_OFFSET], self[END_OFFSET]);</pre></div></div>
            
        </li>
        
        
        <li id="section-376">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-376">&#182;</a>
              </div>
              <p>set the original text node to its new value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (how != CLONE) {
            n = self[START_CONTAINER];
            start = self[START_OFFSET];
            len = self[END_OFFSET] - self[START_OFFSET];

            <span class="hljs-keyword">if</span> (start === <span class="hljs-number">0</span> &amp;&amp; len &gt;= n.nodeValue.length - <span class="hljs-number">1</span>) {
              n.parentNode.removeChild(n);
            } <span class="hljs-keyword">else</span> {
              n.deleteData(start, len);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-377">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-377">&#182;</a>
              </div>
              <p>Nothing is partially selected, so collapse to start point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            self.collapse(TRUE);
          }

          <span class="hljs-keyword">if</span> (how == DELETE) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (sub.length &gt; <span class="hljs-number">0</span>) {
            frag.appendChild(doc.createTextNode(sub));
          }

          <span class="hljs-keyword">return</span> frag;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-378">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-378">&#182;</a>
              </div>
              <p>Copy nodes between the start/end offsets.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        n = _getSelectedNode(self[START_CONTAINER], self[START_OFFSET]);
        cnt = self[END_OFFSET] - self[START_OFFSET];

        <span class="hljs-keyword">while</span> (n &amp;&amp; cnt &gt; <span class="hljs-number">0</span>) {
          sibling = n.nextSibling;
          xferNode = _traverseFullySelected(n, how);

          <span class="hljs-keyword">if</span> (frag) {
            frag.appendChild(xferNode);
          }

          --cnt;
          n = sibling;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-379">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-379">&#182;</a>
              </div>
              <p>Nothing is partially selected, so collapse to start point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (how != CLONE) {
          self.collapse(TRUE);
        }

        <span class="hljs-keyword">return</span> frag;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_traverseCommonStartContainer</span>(<span class="hljs-params">endAncestor, how</span>) </span>{
        <span class="hljs-keyword">var</span> frag, n, endIdx, cnt, sibling, xferNode;

        <span class="hljs-keyword">if</span> (how != DELETE) {
          frag = createDocumentFragment();
        }

        n = _traverseRightBoundary(endAncestor, how);

        <span class="hljs-keyword">if</span> (frag) {
          frag.appendChild(n);
        }

        endIdx = nodeIndex(endAncestor);
        cnt = endIdx - self[START_OFFSET];

        <span class="hljs-keyword">if</span> (cnt &lt;= <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-380">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-380">&#182;</a>
              </div>
              <p>Collapse to just before the endAncestor, which
is partially selected.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (how != CLONE) {
            self.setEndBefore(endAncestor);
            self.collapse(FALSE);
          }

          <span class="hljs-keyword">return</span> frag;
        }

        n = endAncestor.previousSibling;
        <span class="hljs-keyword">while</span> (cnt &gt; <span class="hljs-number">0</span>) {
          sibling = n.previousSibling;
          xferNode = _traverseFullySelected(n, how);

          <span class="hljs-keyword">if</span> (frag) {
            frag.insertBefore(xferNode, frag.firstChild);
          }

          --cnt;
          n = sibling;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-381">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-381">&#182;</a>
              </div>
              <p>Collapse to just before the endAncestor, which
is partially selected.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (how != CLONE) {
          self.setEndBefore(endAncestor);
          self.collapse(FALSE);
        }

        <span class="hljs-keyword">return</span> frag;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_traverseCommonEndContainer</span>(<span class="hljs-params">startAncestor, how</span>) </span>{
        <span class="hljs-keyword">var</span> frag, startIdx, n, cnt, sibling, xferNode;

        <span class="hljs-keyword">if</span> (how != DELETE) {
          frag = createDocumentFragment();
        }

        n = _traverseLeftBoundary(startAncestor, how);
        <span class="hljs-keyword">if</span> (frag) {
          frag.appendChild(n);
        }

        startIdx = nodeIndex(startAncestor);
        ++startIdx; <span class="hljs-comment">// Because we already traversed it</span>

        cnt = self[END_OFFSET] - startIdx;
        n = startAncestor.nextSibling;
        <span class="hljs-keyword">while</span> (n &amp;&amp; cnt &gt; <span class="hljs-number">0</span>) {
          sibling = n.nextSibling;
          xferNode = _traverseFullySelected(n, how);

          <span class="hljs-keyword">if</span> (frag) {
            frag.appendChild(xferNode);
          }

          --cnt;
          n = sibling;
        }

        <span class="hljs-keyword">if</span> (how != CLONE) {
          self.setStartAfter(startAncestor);
          self.collapse(TRUE);
        }

        <span class="hljs-keyword">return</span> frag;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_traverseCommonAncestors</span>(<span class="hljs-params">startAncestor, endAncestor, how</span>) </span>{
        <span class="hljs-keyword">var</span> n, frag, startOffset, endOffset, cnt, sibling, nextSibling;

        <span class="hljs-keyword">if</span> (how != DELETE) {
          frag = createDocumentFragment();
        }

        n = _traverseLeftBoundary(startAncestor, how);
        <span class="hljs-keyword">if</span> (frag) {
          frag.appendChild(n);
        }

        startOffset = nodeIndex(startAncestor);
        endOffset = nodeIndex(endAncestor);
        ++startOffset;

        cnt = endOffset - startOffset;
        sibling = startAncestor.nextSibling;

        <span class="hljs-keyword">while</span> (cnt &gt; <span class="hljs-number">0</span>) {
          nextSibling = sibling.nextSibling;
          n = _traverseFullySelected(sibling, how);

          <span class="hljs-keyword">if</span> (frag) {
            frag.appendChild(n);
          }

          sibling = nextSibling;
          --cnt;
        }

        n = _traverseRightBoundary(endAncestor, how);

        <span class="hljs-keyword">if</span> (frag) {
          frag.appendChild(n);
        }

        <span class="hljs-keyword">if</span> (how != CLONE) {
          self.setStartAfter(startAncestor);
          self.collapse(TRUE);
        }

        <span class="hljs-keyword">return</span> frag;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_traverseRightBoundary</span>(<span class="hljs-params">root, how</span>) </span>{
        <span class="hljs-keyword">var</span> next = _getSelectedNode(self[END_CONTAINER], self[END_OFFSET] - <span class="hljs-number">1</span>), parent, clonedParent;
        <span class="hljs-keyword">var</span> prevSibling, clonedChild, clonedGrandParent, isFullySelected = next != self[END_CONTAINER];

        <span class="hljs-keyword">if</span> (next == root) {
          <span class="hljs-keyword">return</span> _traverseNode(next, isFullySelected, FALSE, how);
        }

        parent = next.parentNode;
        clonedParent = _traverseNode(parent, FALSE, FALSE, how);

        <span class="hljs-keyword">while</span> (parent) {
          <span class="hljs-keyword">while</span> (next) {
            prevSibling = next.previousSibling;
            clonedChild = _traverseNode(next, isFullySelected, FALSE, how);

            <span class="hljs-keyword">if</span> (how != DELETE) {
              clonedParent.insertBefore(clonedChild, clonedParent.firstChild);
            }

            isFullySelected = TRUE;
            next = prevSibling;
          }

          <span class="hljs-keyword">if</span> (parent == root) {
            <span class="hljs-keyword">return</span> clonedParent;
          }

          next = parent.previousSibling;
          parent = parent.parentNode;

          clonedGrandParent = _traverseNode(parent, FALSE, FALSE, how);

          <span class="hljs-keyword">if</span> (how != DELETE) {
            clonedGrandParent.appendChild(clonedParent);
          }

          clonedParent = clonedGrandParent;
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_traverseLeftBoundary</span>(<span class="hljs-params">root, how</span>) </span>{
        <span class="hljs-keyword">var</span> next = _getSelectedNode(self[START_CONTAINER], self[START_OFFSET]), isFullySelected = next != self[START_CONTAINER];
        <span class="hljs-keyword">var</span> parent, clonedParent, nextSibling, clonedChild, clonedGrandParent;

        <span class="hljs-keyword">if</span> (next == root) {
          <span class="hljs-keyword">return</span> _traverseNode(next, isFullySelected, TRUE, how);
        }

        parent = next.parentNode;
        clonedParent = _traverseNode(parent, FALSE, TRUE, how);

        <span class="hljs-keyword">while</span> (parent) {
          <span class="hljs-keyword">while</span> (next) {
            nextSibling = next.nextSibling;
            clonedChild = _traverseNode(next, isFullySelected, TRUE, how);

            <span class="hljs-keyword">if</span> (how != DELETE) {
              clonedParent.appendChild(clonedChild);
            }

            isFullySelected = TRUE;
            next = nextSibling;
          }

          <span class="hljs-keyword">if</span> (parent == root) {
            <span class="hljs-keyword">return</span> clonedParent;
          }

          next = parent.nextSibling;
          parent = parent.parentNode;

          clonedGrandParent = _traverseNode(parent, FALSE, TRUE, how);

          <span class="hljs-keyword">if</span> (how != DELETE) {
            clonedGrandParent.appendChild(clonedParent);
          }

          clonedParent = clonedGrandParent;
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_traverseNode</span>(<span class="hljs-params">n, isFullySelected, isLeft, how</span>) </span>{
        <span class="hljs-keyword">var</span> txtValue, newNodeValue, oldNodeValue, offset, newNode;

        <span class="hljs-keyword">if</span> (isFullySelected) {
          <span class="hljs-keyword">return</span> _traverseFullySelected(n, how);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-382">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-382">&#182;</a>
              </div>
              <p>TEXT_NODE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (n.nodeType == <span class="hljs-number">3</span>) {
          txtValue = n.nodeValue;

          <span class="hljs-keyword">if</span> (isLeft) {
            offset = self[START_OFFSET];
            newNodeValue = txtValue.substring(offset);
            oldNodeValue = txtValue.substring(<span class="hljs-number">0</span>, offset);
          } <span class="hljs-keyword">else</span> {
            offset = self[END_OFFSET];
            newNodeValue = txtValue.substring(<span class="hljs-number">0</span>, offset);
            oldNodeValue = txtValue.substring(offset);
          }

          <span class="hljs-keyword">if</span> (how != CLONE) {
            n.nodeValue = oldNodeValue;
          }

          <span class="hljs-keyword">if</span> (how == DELETE) {
            <span class="hljs-keyword">return</span>;
          }

          newNode = dom.clone(n, FALSE);
          newNode.nodeValue = newNodeValue;

          <span class="hljs-keyword">return</span> newNode;
        }

        <span class="hljs-keyword">if</span> (how == DELETE) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">return</span> dom.clone(n, FALSE);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_traverseFullySelected</span>(<span class="hljs-params">n, how</span>) </span>{
        <span class="hljs-keyword">if</span> (how != DELETE) {
          <span class="hljs-keyword">return</span> how == CLONE ? dom.clone(n, TRUE) : n;
        }

        n.parentNode.removeChild(n);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toStringIE</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> dom.create(<span class="hljs-string">'body'</span>, <span class="hljs-literal">null</span>, cloneContents()).outerText;
      }

      extend(self, {</pre></div></div>
            
        </li>
        
        
        <li id="section-383">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-383">&#182;</a>
              </div>
              <p>Initial states</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        startContainer: doc,
        <span class="hljs-attr">startOffset</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">endContainer</span>: doc,
        <span class="hljs-attr">endOffset</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">collapsed</span>: TRUE,
        <span class="hljs-attr">commonAncestorContainer</span>: doc,</pre></div></div>
            
        </li>
        
        
        <li id="section-384">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-384">&#182;</a>
              </div>
              <p>Range constants</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        START_TO_START: <span class="hljs-number">0</span>,
        <span class="hljs-attr">START_TO_END</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">END_TO_END</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">END_TO_START</span>: <span class="hljs-number">3</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-385">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-385">&#182;</a>
              </div>
              <p>Public methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        setStart: setStart,
        <span class="hljs-attr">setEnd</span>: setEnd,
        <span class="hljs-attr">setStartBefore</span>: setStartBefore,
        <span class="hljs-attr">setStartAfter</span>: setStartAfter,
        <span class="hljs-attr">setEndBefore</span>: setEndBefore,
        <span class="hljs-attr">setEndAfter</span>: setEndAfter,
        <span class="hljs-attr">collapse</span>: collapse,
        <span class="hljs-attr">selectNode</span>: selectNode,
        <span class="hljs-attr">selectNodeContents</span>: selectNodeContents,
        <span class="hljs-attr">compareBoundaryPoints</span>: compareBoundaryPoints,
        <span class="hljs-attr">deleteContents</span>: deleteContents,
        <span class="hljs-attr">extractContents</span>: extractContents,
        <span class="hljs-attr">cloneContents</span>: cloneContents,
        <span class="hljs-attr">insertNode</span>: insertNode,
        <span class="hljs-attr">surroundContents</span>: surroundContents,
        <span class="hljs-attr">cloneRange</span>: cloneRange,
        <span class="hljs-attr">toStringIE</span>: toStringIE
      });

      <span class="hljs-keyword">return</span> self;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-386">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-386">&#182;</a>
              </div>
              <p>Older IE versions doesnt let you override toString by its constructor so we have to stick it in the prototype</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Range.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toStringIE();
    };

    <span class="hljs-keyword">return</span> Range;
  }
);

defineGlobal(<span class="hljs-string">"global!Array"</span>, <span class="hljs-built_in">Array</span>);
defineGlobal(<span class="hljs-string">"global!Error"</span>, <span class="hljs-built_in">Error</span>);
define(
  <span class="hljs-string">'ephox.katamari.api.Fun'</span>,

  [
    <span class="hljs-string">'global!Array'</span>,
    <span class="hljs-string">'global!Error'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Array, Error</span>) </span>{

    <span class="hljs-keyword">var</span> noop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ };

    <span class="hljs-keyword">var</span> compose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fa, fb</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> fa(fb.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>));
      };
    };

    <span class="hljs-keyword">var</span> constant = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> value;
      };
    };

    <span class="hljs-keyword">var</span> identity = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
      <span class="hljs-keyword">return</span> x;
    };

    <span class="hljs-keyword">var</span> tripleEquals = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
      <span class="hljs-keyword">return</span> a === b;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-387">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-387">&#182;</a>
              </div>
              <p>Dont use array slice(arguments), makes the whole function unoptimisable on Chrome</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> curry = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-388">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-388">&#182;</a>
              </div>
              <p>equivalent to arguments.slice(1)
starting at 1 because 0 is the f, makes things tricky.
Pay attention to what variable is where, and the -1 magic.
thankfully, we have tests for this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) args[i<span class="hljs-number">-1</span>] = <span class="hljs-built_in">arguments</span>[i];

      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> newArgs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">arguments</span>.length);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; newArgs.length; j++) newArgs[j] = <span class="hljs-built_in">arguments</span>[j];

        <span class="hljs-keyword">var</span> all = args.concat(newArgs);
        <span class="hljs-keyword">return</span> f.apply(<span class="hljs-literal">null</span>, all);
      };
    };

    <span class="hljs-keyword">var</span> not = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> !f.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>);
      };
    };

    <span class="hljs-keyword">var</span> die = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(msg);
      };
    };

    <span class="hljs-keyword">var</span> apply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
      <span class="hljs-keyword">return</span> f();
    };

    <span class="hljs-keyword">var</span> call = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f</span>) </span>{
      f();
    };

    <span class="hljs-keyword">var</span> never = constant(<span class="hljs-literal">false</span>);
    <span class="hljs-keyword">var</span> always = constant(<span class="hljs-literal">true</span>);
    

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">noop</span>: noop,
      <span class="hljs-attr">compose</span>: compose,
      <span class="hljs-attr">constant</span>: constant,
      <span class="hljs-attr">identity</span>: identity,
      <span class="hljs-attr">tripleEquals</span>: tripleEquals,
      <span class="hljs-attr">curry</span>: curry,
      <span class="hljs-attr">not</span>: not,
      <span class="hljs-attr">die</span>: die,
      <span class="hljs-attr">apply</span>: apply,
      <span class="hljs-attr">call</span>: call,
      <span class="hljs-attr">never</span>: never,
      <span class="hljs-attr">always</span>: always
    };
  }
);

defineGlobal(<span class="hljs-string">"global!Object"</span>, <span class="hljs-built_in">Object</span>);
define(
  <span class="hljs-string">'ephox.katamari.api.Option'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'global!Object'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, Object</span>) </span>{

    <span class="hljs-keyword">var</span> never = Fun.never;
    <span class="hljs-keyword">var</span> always = Fun.always;

    <span class="hljs-comment">/**
      Option objects support the following methods:

      fold :: this Option a -&gt; ((() -&gt; b, a -&gt; b)) -&gt; Option b

      is :: this Option a -&gt; a -&gt; Boolean

      isSome :: this Option a -&gt; () -&gt; Boolean

      isNone :: this Option a -&gt; () -&gt; Boolean

      getOr :: this Option a -&gt; a -&gt; a

      getOrThunk :: this Option a -&gt; (() -&gt; a) -&gt; a

      getOrDie :: this Option a -&gt; String -&gt; a

      or :: this Option a -&gt; Option a -&gt; Option a
        - if some: return self
        - if none: return opt

      orThunk :: this Option a -&gt; (() -&gt; Option a) -&gt; Option a
        - Same as "or", but uses a thunk instead of a value

      map :: this Option a -&gt; (a -&gt; b) -&gt; Option b
        - "fmap" operation on the Option Functor.
        - same as 'each'

      ap :: this Option a -&gt; Option (a -&gt; b) -&gt; Option b
        - "apply" operation on the Option Apply/Applicative.
        - Equivalent to &lt;*&gt; in Haskell/PureScript.

      each :: this Option a -&gt; (a -&gt; b) -&gt; Option b
        - same as 'map'

      bind :: this Option a -&gt; (a -&gt; Option b) -&gt; Option b
        - "bind"/"flatMap" operation on the Option Bind/Monad.
        - Equivalent to &gt;&gt;= in Haskell/PureScript; flatMap in Scala.

      flatten :: {this Option (Option a))} -&gt; () -&gt; Option a
        - "flatten"/"join" operation on the Option Monad.

      exists :: this Option a -&gt; (a -&gt; Boolean) -&gt; Boolean

      forall :: this Option a -&gt; (a -&gt; Boolean) -&gt; Boolean

      filter :: this Option a -&gt; (a -&gt; Boolean) -&gt; Option a

      equals :: this Option a -&gt; Option a -&gt; Boolean

      equals_ :: this Option a -&gt; (Option a, a -&gt; Boolean) -&gt; Boolean

      toArray :: this Option a -&gt; () -&gt; [a]

    */</span>

    <span class="hljs-keyword">var</span> none = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> NONE; };

    <span class="hljs-keyword">var</span> NONE = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> eq = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>{
        <span class="hljs-keyword">return</span> o.isNone();
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-389">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-389">&#182;</a>
              </div>
              <p>inlined from peanut, maybe a micro-optimisation?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> call = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">thunk</span>) </span>{ <span class="hljs-keyword">return</span> thunk(); };
      <span class="hljs-keyword">var</span> id = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>{ <span class="hljs-keyword">return</span> n; };
      <span class="hljs-keyword">var</span> noop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ };

      <span class="hljs-keyword">var</span> me = {
        <span class="hljs-attr">fold</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n, s</span>) </span>{ <span class="hljs-keyword">return</span> n(); },
        <span class="hljs-attr">is</span>: never,
        <span class="hljs-attr">isSome</span>: never,
        <span class="hljs-attr">isNone</span>: always,
        <span class="hljs-attr">getOr</span>: id,
        <span class="hljs-attr">getOrThunk</span>: call,
        <span class="hljs-attr">getOrDie</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>{
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(msg || <span class="hljs-string">'error: getOrDie called on none.'</span>);
        },
        <span class="hljs-attr">or</span>: id,
        <span class="hljs-attr">orThunk</span>: call,
        <span class="hljs-attr">map</span>: none,
        <span class="hljs-attr">ap</span>: none,
        <span class="hljs-attr">each</span>: noop,
        <span class="hljs-attr">bind</span>: none,
        <span class="hljs-attr">flatten</span>: none,
        <span class="hljs-attr">exists</span>: never,
        <span class="hljs-attr">forall</span>: always,
        <span class="hljs-attr">filter</span>: none,
        <span class="hljs-attr">equals</span>: eq,
        <span class="hljs-attr">equals_</span>: eq,
        <span class="hljs-attr">toArray</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> []; },
        <span class="hljs-attr">toString</span>: Fun.constant(<span class="hljs-string">"none()"</span>)
      };
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.freeze) <span class="hljs-built_in">Object</span>.freeze(me);
      <span class="hljs-keyword">return</span> me;
    })();


    <span class="hljs-comment">/** some :: a -&gt; Option a */</span>
    <span class="hljs-keyword">var</span> some = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-390">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-390">&#182;</a>
              </div>
              <p>inlined from peanut, maybe a micro-optimisation?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> constant_a = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> a; };

      <span class="hljs-keyword">var</span> self = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-391">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-391">&#182;</a>
              </div>
              <p>cant Fun.constant this one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> me;
      };

      <span class="hljs-keyword">var</span> map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
        <span class="hljs-keyword">return</span> some(f(a));
      };

      <span class="hljs-keyword">var</span> bind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
        <span class="hljs-keyword">return</span> f(a);
      };

      <span class="hljs-keyword">var</span> me = {
        <span class="hljs-attr">fold</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n, s</span>) </span>{ <span class="hljs-keyword">return</span> s(a); },
        <span class="hljs-attr">is</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{ <span class="hljs-keyword">return</span> a === v; },
        <span class="hljs-attr">isSome</span>: always,
        <span class="hljs-attr">isNone</span>: never,
        <span class="hljs-attr">getOr</span>: constant_a,
        <span class="hljs-attr">getOrThunk</span>: constant_a,
        <span class="hljs-attr">getOrDie</span>: constant_a,
        <span class="hljs-attr">or</span>: self,
        <span class="hljs-attr">orThunk</span>: self,
        <span class="hljs-attr">map</span>: map,
        <span class="hljs-attr">ap</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">optfab</span>) </span>{
          <span class="hljs-keyword">return</span> optfab.fold(none, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fab</span>) </span>{
            <span class="hljs-keyword">return</span> some(fab(a));
          });
        },
        <span class="hljs-attr">each</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
          f(a);
        },
        <span class="hljs-attr">bind</span>: bind,
        <span class="hljs-attr">flatten</span>: constant_a,
        <span class="hljs-attr">exists</span>: bind,
        <span class="hljs-attr">forall</span>: bind,
        <span class="hljs-attr">filter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
          <span class="hljs-keyword">return</span> f(a) ? me : NONE;
        },
        <span class="hljs-attr">equals</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>{
          <span class="hljs-keyword">return</span> o.is(a);
        },
        <span class="hljs-attr">equals_</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o, elementEq</span>) </span>{
          <span class="hljs-keyword">return</span> o.fold(
            never,
            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">b</span>) </span>{ <span class="hljs-keyword">return</span> elementEq(a, b); }
          );
        },
        <span class="hljs-attr">toArray</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> [a];
        },
        <span class="hljs-attr">toString</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-string">'some('</span> + a + <span class="hljs-string">')'</span>;
        }
      };
      <span class="hljs-keyword">return</span> me;
    };

    <span class="hljs-comment">/** from :: undefined|null|a -&gt; Option a */</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">from</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> value === <span class="hljs-literal">null</span> || value === <span class="hljs-literal">undefined</span> ? NONE : some(value);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">some</span>: some,
      <span class="hljs-attr">none</span>: none,
      <span class="hljs-attr">from</span>: <span class="hljs-keyword">from</span>
    };
  }
);

defineGlobal(<span class="hljs-string">"global!String"</span>, <span class="hljs-built_in">String</span>);
define(
  <span class="hljs-string">'ephox.katamari.api.Arr'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'global!Array'</span>,
    <span class="hljs-string">'global!Error'</span>,
    <span class="hljs-string">'global!String'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Option, Array, Error, String</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-392">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-392">&#182;</a>
              </div>
              <p>Use the native Array.indexOf if it is available (IE9+) otherwise fall back to manual iteration
<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> rawIndexOf = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> pIndexOf = <span class="hljs-built_in">Array</span>.prototype.indexOf;

      <span class="hljs-keyword">var</span> fastIndex = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs, x</span>) </span>{ <span class="hljs-keyword">return</span>  pIndexOf.call(xs, x); };

      <span class="hljs-keyword">var</span> slowIndex = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xs, x</span>) </span>{ <span class="hljs-keyword">return</span> slowIndexOf(xs, x); };

      <span class="hljs-keyword">return</span> pIndexOf === <span class="hljs-literal">undefined</span> ? slowIndex : fastIndex;
    })();

    <span class="hljs-keyword">var</span> indexOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs, x</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-393">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-393">&#182;</a>
              </div>
              <p>The rawIndexOf method does not wrap up in an option. This is for performance reasons.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> r = rawIndexOf(xs, x);
      <span class="hljs-keyword">return</span> r === <span class="hljs-number">-1</span> ? Option.none() : Option.some(r);
    };

    <span class="hljs-keyword">var</span> contains = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs, x</span>) </span>{
      <span class="hljs-keyword">return</span> rawIndexOf(xs, x) &gt; <span class="hljs-number">-1</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-394">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-394">&#182;</a>
              </div>
              <p>Using findIndex is likely less optimal in Chrome (dynamic return type instead of bool)
but if we need that micro-optimisation we can inline it later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> exists = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs, pred</span>) </span>{
      <span class="hljs-keyword">return</span> findIndex(xs, pred).isSome();
    };

    <span class="hljs-keyword">var</span> range = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num, f</span>) </span>{
      <span class="hljs-keyword">var</span> r = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) {
        r.push(f(i));
      }
      <span class="hljs-keyword">return</span> r;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-395">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-395">&#182;</a>
              </div>
              <p>Its a total micro optimisation, but these do make some difference.
Particularly for browsers other than Chrome.</p>
<ul>
<li>length caching
<a href="http://jsperf.com/browser-diet-jquery-each-vs-for-loop/69">http://jsperf.com/browser-diet-jquery-each-vs-for-loop/69</a></li>
<li>not using push
<a href="http://jsperf.com/array-direct-assignment-vs-push/2">http://jsperf.com/array-direct-assignment-vs-push/2</a></li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> chunk = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">array, size</span>) </span>{
      <span class="hljs-keyword">var</span> r = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i += size) {
        <span class="hljs-keyword">var</span> s = array.slice(i, i + size);
        r.push(s);
      }
      <span class="hljs-keyword">return</span> r;
    };

    <span class="hljs-keyword">var</span> map = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xs, f</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-396">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-396">&#182;</a>
              </div>
              <p>pre-allocating array size when its guaranteed to be known
<a href="http://jsperf.com/push-allocated-vs-dynamic/22">http://jsperf.com/push-allocated-vs-dynamic/22</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> len = xs.length;
      <span class="hljs-keyword">var</span> r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
        <span class="hljs-keyword">var</span> x = xs[i];
        r[i] = f(x, i, xs);
      }
      <span class="hljs-keyword">return</span> r;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-397">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-397">&#182;</a>
              </div>
              <p>Unwound implementing other functions in terms of each.
The code size is roughly the same, and it should allow for better optimisation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> each = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xs, f</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = xs.length; i &lt; len; i++) {
        <span class="hljs-keyword">var</span> x = xs[i];
        f(x, i, xs);
      }
    };

    <span class="hljs-keyword">var</span> eachr = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs, f</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = xs.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        <span class="hljs-keyword">var</span> x = xs[i];
        f(x, i, xs);
      }
    };

    <span class="hljs-keyword">var</span> partition = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xs, pred</span>) </span>{
      <span class="hljs-keyword">var</span> pass = [];
      <span class="hljs-keyword">var</span> fail = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = xs.length; i &lt; len; i++) {
        <span class="hljs-keyword">var</span> x = xs[i];
        <span class="hljs-keyword">var</span> arr = pred(x, i, xs) ? pass : fail;
        arr.push(x);
      }
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">pass</span>: pass, <span class="hljs-attr">fail</span>: fail };
    };

    <span class="hljs-keyword">var</span> filter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xs, pred</span>) </span>{
      <span class="hljs-keyword">var</span> r = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = xs.length; i &lt; len; i++) {
        <span class="hljs-keyword">var</span> x = xs[i];
        <span class="hljs-keyword">if</span> (pred(x, i, xs)) {
          r.push(x);
        }
      }
      <span class="hljs-keyword">return</span> r;
    };

    <span class="hljs-comment">/*
     * Groups an array into contiguous arrays of like elements. Whether an element is like or not depends on f.
     *
     * f is a function that derives a value from an element - e.g. true or false, or a string.
     * Elements are like if this function generates the same value for them (according to ===).
     *
     *
     * Order of the elements is preserved. Arr.flatten() on the result will return the original list, as with Haskell groupBy function.
     *  For a good explanation, see the group function (which is a special case of groupBy)
     *  http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-List.html#v:group
     */</span>
    <span class="hljs-keyword">var</span> groupBy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs, f</span>) </span>{
      <span class="hljs-keyword">if</span> (xs.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> [];
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> wasType = f(xs[<span class="hljs-number">0</span>]); <span class="hljs-comment">// initial case for matching</span>
        <span class="hljs-keyword">var</span> r = [];
        <span class="hljs-keyword">var</span> group = [];

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = xs.length; i &lt; len; i++) {
          <span class="hljs-keyword">var</span> x = xs[i];
          <span class="hljs-keyword">var</span> type = f(x);
          <span class="hljs-keyword">if</span> (type !== wasType) {
            r.push(group);
            group = [];
          }
          wasType = type;
          group.push(x);
        }
        <span class="hljs-keyword">if</span> (group.length !== <span class="hljs-number">0</span>) {
          r.push(group);
        }
        <span class="hljs-keyword">return</span> r;
      }
    };

    <span class="hljs-keyword">var</span> foldr = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs, f, acc</span>) </span>{
      eachr(xs, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
        acc = f(acc, x);
      });
      <span class="hljs-keyword">return</span> acc;
    };

    <span class="hljs-keyword">var</span> foldl = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs, f, acc</span>) </span>{
      each(xs, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
        acc = f(acc, x);
      });
      <span class="hljs-keyword">return</span> acc;
    };

    <span class="hljs-keyword">var</span> find = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs, pred</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = xs.length; i &lt; len; i++) {
        <span class="hljs-keyword">var</span> x = xs[i];
        <span class="hljs-keyword">if</span> (pred(x, i, xs)) {
          <span class="hljs-keyword">return</span> Option.some(x);
        }
      }
      <span class="hljs-keyword">return</span> Option.none();
    };

    <span class="hljs-keyword">var</span> findIndex = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs, pred</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = xs.length; i &lt; len; i++) {
        <span class="hljs-keyword">var</span> x = xs[i];
        <span class="hljs-keyword">if</span> (pred(x, i, xs)) {
          <span class="hljs-keyword">return</span> Option.some(i);
        }
      }

      <span class="hljs-keyword">return</span> Option.none();
    };

    <span class="hljs-keyword">var</span> slowIndexOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs, x</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = xs.length; i &lt; len; ++i) {
        <span class="hljs-keyword">if</span> (xs[i] === x) {
          <span class="hljs-keyword">return</span> i;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    };

    <span class="hljs-keyword">var</span> push = <span class="hljs-built_in">Array</span>.prototype.push;
    <span class="hljs-keyword">var</span> flatten = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-398">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-398">&#182;</a>
              </div>
              <p>Note, this is possible because push supports multiple arguments:
<a href="http://jsperf.com/concat-push/6">http://jsperf.com/concat-push/6</a>
Note that in the past, concat() would silently work (very slowly) for array-like objects.
With this change it will throw an error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> r = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = xs.length; i &lt; len; ++i) {</pre></div></div>
            
        </li>
        
        
        <li id="section-399">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-399">&#182;</a>
              </div>
              <p>Ensure that each value is an array itself</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">Array</span>.prototype.isPrototypeOf(xs[i])) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Arr.flatten item '</span> + i + <span class="hljs-string">' was not an array, input: '</span> + xs);
        push.apply(r, xs[i]);
      }
      <span class="hljs-keyword">return</span> r;
    };

    <span class="hljs-keyword">var</span> bind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs, f</span>) </span>{
      <span class="hljs-keyword">var</span> output = map(xs, f);
      <span class="hljs-keyword">return</span> flatten(output);
    };

    <span class="hljs-keyword">var</span> forall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs, pred</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = xs.length; i &lt; len; ++i) {
        <span class="hljs-keyword">var</span> x = xs[i];
        <span class="hljs-keyword">if</span> (pred(x, i, xs) !== <span class="hljs-literal">true</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    };

    <span class="hljs-keyword">var</span> equal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a1, a2</span>) </span>{
      <span class="hljs-keyword">return</span> a1.length === a2.length &amp;&amp; forall(a1, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, i</span>) </span>{
        <span class="hljs-keyword">return</span> x === a2[i];
      });
    };

    <span class="hljs-keyword">var</span> slice = <span class="hljs-built_in">Array</span>.prototype.slice;
    <span class="hljs-keyword">var</span> reverse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs</span>) </span>{
      <span class="hljs-keyword">var</span> r = slice.call(xs, <span class="hljs-number">0</span>);
      r.reverse();
      <span class="hljs-keyword">return</span> r;
    };

    <span class="hljs-keyword">var</span> difference = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a1, a2</span>) </span>{
      <span class="hljs-keyword">return</span> filter(a1, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
        <span class="hljs-keyword">return</span> !contains(a2, x);
      });
    };

    <span class="hljs-keyword">var</span> mapToObject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xs, f</span>) </span>{
      <span class="hljs-keyword">var</span> r = {};
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = xs.length; i &lt; len; i++) {
        <span class="hljs-keyword">var</span> x = xs[i];
        r[<span class="hljs-built_in">String</span>(x)] = f(x, i);
      }
      <span class="hljs-keyword">return</span> r;
    };

    <span class="hljs-keyword">var</span> pure = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
      <span class="hljs-keyword">return</span> [x];
    };

    <span class="hljs-keyword">var</span> sort = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs, comparator</span>) </span>{
      <span class="hljs-keyword">var</span> copy = slice.call(xs, <span class="hljs-number">0</span>);
      copy.sort(comparator);
      <span class="hljs-keyword">return</span> copy;
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">map</span>: map,
      <span class="hljs-attr">each</span>: each,
      <span class="hljs-attr">eachr</span>: eachr,
      <span class="hljs-attr">partition</span>: partition,
      <span class="hljs-attr">filter</span>: filter,
      <span class="hljs-attr">groupBy</span>: groupBy,
      <span class="hljs-attr">indexOf</span>: indexOf,
      <span class="hljs-attr">foldr</span>: foldr,
      <span class="hljs-attr">foldl</span>: foldl,
      <span class="hljs-attr">find</span>: find,
      <span class="hljs-attr">findIndex</span>: findIndex,
      <span class="hljs-attr">flatten</span>: flatten,
      <span class="hljs-attr">bind</span>: bind,
      <span class="hljs-attr">forall</span>: forall,
      <span class="hljs-attr">exists</span>: exists,
      <span class="hljs-attr">contains</span>: contains,
      <span class="hljs-attr">equal</span>: equal,
      <span class="hljs-attr">reverse</span>: reverse,
      <span class="hljs-attr">chunk</span>: chunk,
      <span class="hljs-attr">difference</span>: difference,
      <span class="hljs-attr">mapToObject</span>: mapToObject,
      <span class="hljs-attr">pure</span>: pure,
      <span class="hljs-attr">sort</span>: sort,
      <span class="hljs-attr">range</span>: range
    };
  }
);
defineGlobal(<span class="hljs-string">"global!setTimeout"</span>, setTimeout);
define(
  <span class="hljs-string">'ephox.katamari.api.LazyValue'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'global!setTimeout'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Option, setTimeout</span>) </span>{
    <span class="hljs-keyword">var</span> nu = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">baseFn</span>) </span>{
      <span class="hljs-keyword">var</span> data = Option.none();
      <span class="hljs-keyword">var</span> callbacks = [];

      <span class="hljs-comment">/** map :: this LazyValue a -&gt; (a -&gt; b) -&gt; LazyValue b */</span>
      <span class="hljs-keyword">var</span> map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
        <span class="hljs-keyword">return</span> nu(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nCallback</span>) </span>{
          get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
            nCallback(f(data));
          });
        });
      };

      <span class="hljs-keyword">var</span> get = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nCallback</span>) </span>{
        <span class="hljs-keyword">if</span> (isReady()) call(nCallback);
        <span class="hljs-keyword">else</span> callbacks.push(nCallback);
      };

      <span class="hljs-keyword">var</span> set = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
        data = Option.some(x);
        run(callbacks);
        callbacks = [];
      };

      <span class="hljs-keyword">var</span> isReady = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> data.isSome();
      };

      <span class="hljs-keyword">var</span> run = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cbs</span>) </span>{
        Arr.each(cbs, call);
      };

      <span class="hljs-keyword">var</span> call = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>) </span>{
        data.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
          setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            cb(x);
          }, <span class="hljs-number">0</span>);
        });
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-400">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-400">&#182;</a>
              </div>
              <p>Lazy values cache the value and kick off immediately</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      baseFn(set);

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">get</span>: get,
        <span class="hljs-attr">map</span>: map,
        <span class="hljs-attr">isReady</span>: isReady
      };
    };

    <span class="hljs-keyword">var</span> pure = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
      <span class="hljs-keyword">return</span> nu(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
        callback(a);
      });
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">nu</span>: nu,
      <span class="hljs-attr">pure</span>: pure
    };
  }
);
define(
  <span class="hljs-string">'ephox.katamari.async.Bounce'</span>,

  [
    <span class="hljs-string">'global!Array'</span>,
    <span class="hljs-string">'global!setTimeout'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Array, setTimeout</span>) </span>{

    <span class="hljs-keyword">var</span> bounce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">var</span> me = <span class="hljs-keyword">this</span>;
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          f.apply(me, args);
        }, <span class="hljs-number">0</span>);
      };
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">bounce</span>: bounce
    };
  }
);

define(
  <span class="hljs-string">'ephox.katamari.api.Future'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.LazyValue'</span>,
    <span class="hljs-string">'ephox.katamari.async.Bounce'</span>
  ],

  <span class="hljs-comment">/** A future value that is evaluated on demand. The base function is re-evaluated each time 'get' is called. */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">LazyValue, Bounce</span>) </span>{
    <span class="hljs-keyword">var</span> nu = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">baseFn</span>) </span>{
      <span class="hljs-keyword">var</span> get = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
        baseFn(Bounce.bounce(callback));
      };

      <span class="hljs-comment">/** map :: this Future a -&gt; (a -&gt; b) -&gt; Future b */</span>
      <span class="hljs-keyword">var</span> map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fab</span>) </span>{
        <span class="hljs-keyword">return</span> nu(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
          get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
            <span class="hljs-keyword">var</span> value = fab(a);
            callback(value);
          });
        });
      };

      <span class="hljs-comment">/** bind :: this Future a -&gt; (a -&gt; Future b) -&gt; Future b */</span>
      <span class="hljs-keyword">var</span> bind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">aFutureB</span>) </span>{
        <span class="hljs-keyword">return</span> nu(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
          get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
            aFutureB(a).get(callback);
          });
        });
      };

      <span class="hljs-comment">/** anonBind :: this Future a -&gt; Future b -&gt; Future b
       *  Returns a future, which evaluates the first future, ignores the result, then evaluates the second.
       */</span>
      <span class="hljs-keyword">var</span> anonBind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">futureB</span>) </span>{
        <span class="hljs-keyword">return</span> nu(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
          get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
            futureB.get(callback);
          });
        });
      };

      <span class="hljs-keyword">var</span> toLazy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> LazyValue.nu(get);
      };

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">map</span>: map,
        <span class="hljs-attr">bind</span>: bind,
        <span class="hljs-attr">anonBind</span>: anonBind,
        <span class="hljs-attr">toLazy</span>: toLazy,
        <span class="hljs-attr">get</span>: get
      };

    };

    <span class="hljs-comment">/** a -&gt; Future a */</span>
    <span class="hljs-keyword">var</span> pure = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
      <span class="hljs-keyword">return</span> nu(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
        callback(a);
      });
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">nu</span>: nu,
      <span class="hljs-attr">pure</span>: pure
    };
  }
);

define(
  <span class="hljs-string">'ephox.katamari.async.AsyncValues'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr</span>) </span>{
    <span class="hljs-comment">/* 
     * <span class="hljs-doctag">NOTE:</span> an `asyncValue` must have a `get` function which gets given a callback and calls 
     * that callback with a value once it is ready
     *
     * e.g 
     * {
     *   get: function (callback) { callback(10); }
     * }
     */</span>
    <span class="hljs-keyword">var</span> par = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">asyncValues, nu</span>) </span>{
      <span class="hljs-keyword">return</span> nu(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
        <span class="hljs-keyword">var</span> r = [];
        <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">var</span> cb = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
            r[i] = value;
            count++;
            <span class="hljs-keyword">if</span> (count &gt;= asyncValues.length) {
              callback(r);
            }
          };
        };

        <span class="hljs-keyword">if</span> (asyncValues.length === <span class="hljs-number">0</span>) {
          callback([]);
        } <span class="hljs-keyword">else</span> {
          Arr.each(asyncValues, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">asyncValue, i</span>) </span>{
            asyncValue.get(cb(i));
          });
        }
      });
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">par</span>: par
    };
  }
);
define(
  <span class="hljs-string">'ephox.katamari.api.Futures'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Future'</span>,
    <span class="hljs-string">'ephox.katamari.async.AsyncValues'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Future, AsyncValues</span>) </span>{
    <span class="hljs-comment">/** par :: [Future a] -&gt; Future [a] */</span>
    <span class="hljs-keyword">var</span> par = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">futures</span>) </span>{
      <span class="hljs-keyword">return</span> AsyncValues.par(futures, Future.nu);
    };

    <span class="hljs-comment">/** mapM :: [a] -&gt; (a -&gt; Future b) -&gt; Future [b] */</span>
    <span class="hljs-keyword">var</span> mapM = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">array, fn</span>) </span>{
      <span class="hljs-keyword">var</span> futures = Arr.map(array, fn);
      <span class="hljs-keyword">return</span> par(futures);
    };

    <span class="hljs-comment">/** Kleisli composition of two functions: a -&gt; Future b.
     *  Note the order of arguments: g is invoked first, then the result passed to f.
     *  This is in line with f . g = \x -&gt; f (g a)
     *
     *  compose :: ((b -&gt; Future c), (a -&gt; Future b)) -&gt; a -&gt; Future c
     */</span>
    <span class="hljs-keyword">var</span> compose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f, g</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
        <span class="hljs-keyword">return</span> g(a).bind(f);
      };
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">par</span>: par,
      <span class="hljs-attr">mapM</span>: mapM,
      <span class="hljs-attr">compose</span>: compose
    };
  }
);
define(
  <span class="hljs-string">'ephox.katamari.api.Result'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, Option</span>) </span>{
    <span class="hljs-comment">/* The type signatures for Result 
     * is :: this Result a -&gt; a -&gt; Bool
     * or :: this Result a -&gt; Result a -&gt; Result a
     * orThunk :: this Result a -&gt; (_ -&gt; Result a) -&gt; Result a
     * map :: this Result a -&gt; (a -&gt; b) -&gt; Result b
     * each :: this Result a -&gt; (a -&gt; _) -&gt; _ 
     * bind :: this Result a -&gt; (a -&gt; Result b) -&gt; Result b
     * fold :: this Result a -&gt; (_ -&gt; b, a -&gt; b) -&gt; b
     * exists :: this Result a -&gt; (a -&gt; Bool) -&gt; Bool
     * forall :: this Result a -&gt; (a -&gt; Bool) -&gt; Bool
     * toOption :: this Result a -&gt; Option a
     * isValue :: this Result a -&gt; Bool
     * isError :: this Result a -&gt; Bool
     * getOr :: this Result a -&gt; a -&gt; a
     * getOrThunk :: this Result a -&gt; (_ -&gt; a) -&gt; a
     * getOrDie :: this Result a -&gt; a (or throws error)
    */</span>

    <span class="hljs-keyword">var</span> value = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>{
      <span class="hljs-keyword">var</span> is = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
        <span class="hljs-keyword">return</span> o === v;      
      };

      <span class="hljs-keyword">var</span> or = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">opt</span>) </span>{
        <span class="hljs-keyword">return</span> value(o);
      };

      <span class="hljs-keyword">var</span> orThunk = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
        <span class="hljs-keyword">return</span> value(o);
      };

      <span class="hljs-keyword">var</span> map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
        <span class="hljs-keyword">return</span> value(f(o));
      };

      <span class="hljs-keyword">var</span> each = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
        f(o);
      };

      <span class="hljs-keyword">var</span> bind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
        <span class="hljs-keyword">return</span> f(o);
      };

      <span class="hljs-keyword">var</span> fold = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_, onValue</span>) </span>{
        <span class="hljs-keyword">return</span> onValue(o);
      };

      <span class="hljs-keyword">var</span> exists = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
        <span class="hljs-keyword">return</span> f(o);
      };

      <span class="hljs-keyword">var</span> forall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
        <span class="hljs-keyword">return</span> f(o);
      };

      <span class="hljs-keyword">var</span> toOption = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> Option.some(o);
      };
     
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">is</span>: is,
        <span class="hljs-attr">isValue</span>: Fun.constant(<span class="hljs-literal">true</span>),
        <span class="hljs-attr">isError</span>: Fun.constant(<span class="hljs-literal">false</span>),
        <span class="hljs-attr">getOr</span>: Fun.constant(o),
        <span class="hljs-attr">getOrThunk</span>: Fun.constant(o),
        <span class="hljs-attr">getOrDie</span>: Fun.constant(o),
        <span class="hljs-attr">or</span>: or,
        <span class="hljs-attr">orThunk</span>: orThunk,
        <span class="hljs-attr">fold</span>: fold,
        <span class="hljs-attr">map</span>: map,
        <span class="hljs-attr">each</span>: each,
        <span class="hljs-attr">bind</span>: bind,
        <span class="hljs-attr">exists</span>: exists,
        <span class="hljs-attr">forall</span>: forall,
        <span class="hljs-attr">toOption</span>: toOption
      };
    };

    <span class="hljs-keyword">var</span> error = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>{
      <span class="hljs-keyword">var</span> getOrThunk = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
        <span class="hljs-keyword">return</span> f();
      };

      <span class="hljs-keyword">var</span> getOrDie = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> Fun.die(message)();
      };

      <span class="hljs-keyword">var</span> or = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">opt</span>) </span>{
        <span class="hljs-keyword">return</span> opt;
      };

      <span class="hljs-keyword">var</span> orThunk = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
        <span class="hljs-keyword">return</span> f();
      };

      <span class="hljs-keyword">var</span> map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
        <span class="hljs-keyword">return</span> error(message);
      };

      <span class="hljs-keyword">var</span> bind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
        <span class="hljs-keyword">return</span> error(message);
      };

      <span class="hljs-keyword">var</span> fold = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onError, _</span>) </span>{
        <span class="hljs-keyword">return</span> onError(message);
      };

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">is</span>: Fun.constant(<span class="hljs-literal">false</span>),
        <span class="hljs-attr">isValue</span>: Fun.constant(<span class="hljs-literal">false</span>),
        <span class="hljs-attr">isError</span>: Fun.constant(<span class="hljs-literal">true</span>),
        <span class="hljs-attr">getOr</span>: Fun.identity,
        <span class="hljs-attr">getOrThunk</span>: getOrThunk,
        <span class="hljs-attr">getOrDie</span>: getOrDie,
        <span class="hljs-attr">or</span>: or,
        <span class="hljs-attr">orThunk</span>: orThunk,
        <span class="hljs-attr">fold</span>: fold,
        <span class="hljs-attr">map</span>: map,
        <span class="hljs-attr">each</span>: Fun.noop,
        <span class="hljs-attr">bind</span>: bind,
        <span class="hljs-attr">exists</span>: Fun.constant(<span class="hljs-literal">false</span>),
        <span class="hljs-attr">forall</span>: Fun.constant(<span class="hljs-literal">true</span>),
        <span class="hljs-attr">toOption</span>: Option.none
      };
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">value</span>: value,
      <span class="hljs-attr">error</span>: error
    };
  }
);

<span class="hljs-comment">/**
 * StyleSheetLoader.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class handles loading of external stylesheets and fires events when these are loaded.
 *
 * @class tinymce.dom.StyleSheetLoader
 * @private
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.StyleSheetLoader'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.katamari.api.Future'</span>,
    <span class="hljs-string">'ephox.katamari.api.Futures'</span>,
    <span class="hljs-string">'ephox.katamari.api.Result'</span>,
    <span class="hljs-string">'tinymce.core.util.Delay'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Fun, Future, Futures, Result, Delay, Tools</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">document, settings</span>) </span>{
      <span class="hljs-keyword">var</span> idCount = <span class="hljs-number">0</span>, loadedStates = {}, maxLoadTime;

      settings = settings || {};
      maxLoadTime = settings.maxLoadTime || <span class="hljs-number">5000</span>;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendToHead</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'head'</span>)[<span class="hljs-number">0</span>].appendChild(node);
      }

      <span class="hljs-comment">/**
       * Loads the specified css style sheet file and call the loadedCallback once it's finished loading.
       *
       * @method load
       * @param {String} url Url to be loaded.
       * @param {Function} loadedCallback Callback to be executed when loaded.
       * @param {Function} errorCallback Callback to be executed when failed loading.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params">url, loadedCallback, errorCallback</span>) </span>{
        <span class="hljs-keyword">var</span> link, style, startTime, state;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">passed</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> callbacks = state.passed, i = callbacks.length;

          <span class="hljs-keyword">while</span> (i--) {
            callbacks[i]();
          }

          state.status = <span class="hljs-number">2</span>;
          state.passed = [];
          state.failed = [];
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">failed</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> callbacks = state.failed, i = callbacks.length;

          <span class="hljs-keyword">while</span> (i--) {
            callbacks[i]();
          }

          state.status = <span class="hljs-number">3</span>;
          state.passed = [];
          state.failed = [];
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-401">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-401">&#182;</a>
              </div>
              <p>Sniffs for older WebKit versions that have the link.onload but a broken one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isOldWebKit</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> webKitChunks = navigator.userAgent.match(<span class="hljs-regexp">/WebKit\/(\d*)/</span>);
          <span class="hljs-keyword">return</span> !!(webKitChunks &amp;&amp; webKitChunks[<span class="hljs-number">1</span>] &lt; <span class="hljs-number">536</span>);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-402">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-402">&#182;</a>
              </div>
              <p>Calls the waitCallback until the test returns true or the timeout occurs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">testCallback, waitCallback</span>) </span>{
          <span class="hljs-keyword">if</span> (!testCallback()) {</pre></div></div>
            
        </li>
        
        
        <li id="section-403">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-403">&#182;</a>
              </div>
              <p>Wait for timeout</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()) - startTime &lt; maxLoadTime) {
              Delay.setTimeout(waitCallback);
            } <span class="hljs-keyword">else</span> {
              failed();
            }
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-404">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-404">&#182;</a>
              </div>
              <p>Workaround for WebKit that doesnt properly support the onload event for link elements
Or WebKit that fires the onload event before the StyleSheet is added to the document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitForWebKitLinkLoaded</span>(<span class="hljs-params"></span>) </span>{
          wait(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> styleSheets = <span class="hljs-built_in">document</span>.styleSheets, styleSheet, i = styleSheets.length, owner;

            <span class="hljs-keyword">while</span> (i--) {
              styleSheet = styleSheets[i];
              owner = styleSheet.ownerNode ? styleSheet.ownerNode : styleSheet.owningElement;
              <span class="hljs-keyword">if</span> (owner &amp;&amp; owner.id === link.id) {
                passed();
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              }
            }
          }, waitForWebKitLinkLoaded);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-405">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-405">&#182;</a>
              </div>
              <p>Workaround for older Geckos that doesnt have any onload event for StyleSheets</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitForGeckoLinkLoaded</span>(<span class="hljs-params"></span>) </span>{
          wait(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-406">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-406">&#182;</a>
              </div>
              <p>Accessing the cssRules will throw an exception until the CSS file is loaded</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> cssRules = style.sheet.cssRules;
              passed();
              <span class="hljs-keyword">return</span> !!cssRules;
            } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-407">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-407">&#182;</a>
              </div>
              <p>Ignore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            }
          }, waitForGeckoLinkLoaded);
        }

        url = Tools._addCacheSuffix(url);

        <span class="hljs-keyword">if</span> (!loadedStates[url]) {
          state = {
            <span class="hljs-attr">passed</span>: [],
            <span class="hljs-attr">failed</span>: []
          };

          loadedStates[url] = state;
        } <span class="hljs-keyword">else</span> {
          state = loadedStates[url];
        }

        <span class="hljs-keyword">if</span> (loadedCallback) {
          state.passed.push(loadedCallback);
        }

        <span class="hljs-keyword">if</span> (errorCallback) {
          state.failed.push(errorCallback);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-408">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-408">&#182;</a>
              </div>
              <p>Is loading wait for it to pass</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (state.status == <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-409">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-409">&#182;</a>
              </div>
              <p>Has finished loading and was success</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (state.status == <span class="hljs-number">2</span>) {
          passed();
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-410">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-410">&#182;</a>
              </div>
              <p>Has finished loading and was a failure</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (state.status == <span class="hljs-number">3</span>) {
          failed();
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-411">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-411">&#182;</a>
              </div>
              <p>Start loading</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        state.status = <span class="hljs-number">1</span>;
        link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'link'</span>);
        link.rel = <span class="hljs-string">'stylesheet'</span>;
        link.type = <span class="hljs-string">'text/css'</span>;
        link.id = <span class="hljs-string">'u'</span> + (idCount++);
        link.async = <span class="hljs-literal">false</span>;
        link.defer = <span class="hljs-literal">false</span>;
        startTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();</pre></div></div>
            
        </li>
        
        
        <li id="section-412">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-412">&#182;</a>
              </div>
              <p>Feature detect onload on link element and sniff older webkits since it has an broken onload event</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-string">"onload"</span> <span class="hljs-keyword">in</span> link &amp;&amp; !isOldWebKit()) {
          link.onload = waitForWebKitLinkLoaded;
          link.onerror = failed;
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-413">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-413">&#182;</a>
              </div>
              <p>Sniff for old Firefox that doesnt support the onload event on link elements
TODO: Remove this in the future when everyone uses modern browsers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (navigator.userAgent.indexOf(<span class="hljs-string">"Firefox"</span>) &gt; <span class="hljs-number">0</span>) {
            style = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'style'</span>);
            style.textContent = <span class="hljs-string">'@import "'</span> + url + <span class="hljs-string">'"'</span>;
            waitForGeckoLinkLoaded();
            appendToHead(style);
            <span class="hljs-keyword">return</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-414">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-414">&#182;</a>
              </div>
              <p>Use the id owner on older webkits</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          waitForWebKitLinkLoaded();
        }

        appendToHead(link);
        link.href = url;
      }

      <span class="hljs-keyword">var</span> loadF = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
        <span class="hljs-keyword">return</span> Future.nu(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
          load(
            url,
            Fun.compose(resolve, Fun.constant(Result.value(url))),
            Fun.compose(resolve, Fun.constant(Result.error(url)))
          );
        });
      };

      <span class="hljs-keyword">var</span> unbox = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
        <span class="hljs-keyword">return</span> result.fold(Fun.identity, Fun.identity);
      };

      <span class="hljs-keyword">var</span> loadAll = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">urls, success, failure</span>) </span>{
        Futures.par(Arr.map(urls, loadF)).get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
          <span class="hljs-keyword">var</span> parts = Arr.partition(result, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">r</span>) </span>{
            <span class="hljs-keyword">return</span> r.isValue();
          });

          <span class="hljs-keyword">if</span> (parts.fail.length &gt; <span class="hljs-number">0</span>) {
            failure(parts.fail.map(unbox));
          } <span class="hljs-keyword">else</span> {
            success(parts.pass.map(unbox));
          }
        });
      };

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">load</span>: load,
        <span class="hljs-attr">loadAll</span>: loadAll
      };
    };
  }
);

<span class="hljs-comment">/**
 * Schema.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Schema validator class.
 *
 * @class tinymce.html.Schema
 * @example
 *  if (tinymce.activeEditor.schema.isValidChild('p', 'span'))
 *    alert('span is valid child of p.');
 *
 *  if (tinymce.activeEditor.schema.getElementRule('p'))
 *    alert('P is a valid element.');
 *
 * @class tinymce.html.Schema
 * @version 3.4
 */</span>
define(
  <span class="hljs-string">'tinymce.core.html.Schema'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Tools</span>) </span>{
    <span class="hljs-keyword">var</span> mapCache = {}, dummyObj = {};
    <span class="hljs-keyword">var</span> makeMap = Tools.makeMap, each = Tools.each, extend = Tools.extend, explode = Tools.explode, inArray = Tools.inArray;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">split</span>(<span class="hljs-params">items, delim</span>) </span>{
      items = Tools.trim(items);
      <span class="hljs-keyword">return</span> items ? items.split(delim || <span class="hljs-string">' '</span>) : [];
    }

    <span class="hljs-comment">/**
     * Builds a schema lookup table
     *
     * @private
     * @param {String} type html4, html5 or html5-strict schema type.
     * @return {Object} Schema lookup table.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileSchema</span>(<span class="hljs-params">type</span>) </span>{
      <span class="hljs-keyword">var</span> schema = {}, globalAttributes, blockContent;
      <span class="hljs-keyword">var</span> phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">name, attributes, children</span>) </span>{
        <span class="hljs-keyword">var</span> ni, attributesOrder, element;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arrayToMap</span>(<span class="hljs-params">array, obj</span>) </span>{
          <span class="hljs-keyword">var</span> map = {}, i, l;

          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = array.length; i &lt; l; i++) {
            map[array[i]] = obj || {};
          }

          <span class="hljs-keyword">return</span> map;
        }

        children = children || [];
        attributes = attributes || <span class="hljs-string">""</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> children === <span class="hljs-string">"string"</span>) {
          children = split(children);
        }

        name = split(name);
        ni = name.length;
        <span class="hljs-keyword">while</span> (ni--) {
          attributesOrder = split([globalAttributes, attributes].join(<span class="hljs-string">' '</span>));

          element = {
            <span class="hljs-attr">attributes</span>: arrayToMap(attributesOrder),
            <span class="hljs-attr">attributesOrder</span>: attributesOrder,
            <span class="hljs-attr">children</span>: arrayToMap(children, dummyObj)
          };

          schema[name[ni]] = element;
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAttrs</span>(<span class="hljs-params">name, attributes</span>) </span>{
        <span class="hljs-keyword">var</span> ni, schemaItem, i, l;

        name = split(name);
        ni = name.length;
        attributes = split(attributes);
        <span class="hljs-keyword">while</span> (ni--) {
          schemaItem = schema[name[ni]];
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = attributes.length; i &lt; l; i++) {
            schemaItem.attributes[attributes[i]] = {};
            schemaItem.attributesOrder.push(attributes[i]);
          }
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-415">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-415">&#182;</a>
              </div>
              <p>Use cached schema</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (mapCache[type]) {
        <span class="hljs-keyword">return</span> mapCache[type];
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-416">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-416">&#182;</a>
              </div>
              <p>Attributes present on all elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      globalAttributes = <span class="hljs-string">"id accesskey class dir lang style tabindex title role"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-417">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-417">&#182;</a>
              </div>
              <p>Event attributes can be opt-in/opt-out</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/*eventAttributes = split("onabort onblur oncancel oncanplay oncanplaythrough onchange onclick onclose oncontextmenu oncuechange " +
       "ondblclick ondrag ondragend ondragenter ondragleave ondragover ondragstart ondrop ondurationchange onemptied onended " +
       "onerror onfocus oninput oninvalid onkeydown onkeypress onkeyup onload onloadeddata onloadedmetadata onloadstart " +
       "onmousedown onmousemove onmouseout onmouseover onmouseup onmousewheel onpause onplay onplaying onprogress onratechange " +
       "onreset onscroll onseeked onseeking onseeking onselect onshow onstalled onsubmit onsuspend ontimeupdate onvolumechange " +
       "onwaiting"
       );*/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-418">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-418">&#182;</a>
              </div>
              <p>Block content elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      blockContent =
        <span class="hljs-string">"address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-419">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-419">&#182;</a>
              </div>
              <p>Phrasing content elements from the HTML5 spec (inline)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      phrasingContent =
        <span class="hljs-string">"a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd "</span> +
        <span class="hljs-string">"label map noscript object q s samp script select small span strong sub sup "</span> +
        <span class="hljs-string">"textarea u var #text #comment"</span>
        ;</pre></div></div>
            
        </li>
        
        
        <li id="section-420">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-420">&#182;</a>
              </div>
              <p>Add HTML5 items to globalAttributes, blockContent, phrasingContent</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (type != <span class="hljs-string">"html4"</span>) {
        globalAttributes += <span class="hljs-string">" contenteditable contextmenu draggable dropzone "</span> +
          <span class="hljs-string">"hidden spellcheck translate"</span>;
        blockContent += <span class="hljs-string">" article aside details dialog figure header footer hgroup section nav"</span>;
        phrasingContent += <span class="hljs-string">" audio canvas command datalist mark meter output picture "</span> +
          <span class="hljs-string">"progress time wbr video ruby bdi keygen"</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-421">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-421">&#182;</a>
              </div>
              <p>Add HTML4 elements unless its html5-strict</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (type != <span class="hljs-string">"html5-strict"</span>) {
        globalAttributes += <span class="hljs-string">" xml:lang"</span>;

        html4PhrasingContent = <span class="hljs-string">"acronym applet basefont big font strike tt"</span>;
        phrasingContent = [phrasingContent, html4PhrasingContent].join(<span class="hljs-string">' '</span>);

        each(split(html4PhrasingContent), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          add(name, <span class="hljs-string">""</span>, phrasingContent);
        });

        html4BlockContent = <span class="hljs-string">"center dir isindex noframes"</span>;
        blockContent = [blockContent, html4BlockContent].join(<span class="hljs-string">' '</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-422">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-422">&#182;</a>
              </div>
              <p>Flow content elements from the HTML5 spec (block+inline)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        flowContent = [blockContent, phrasingContent].join(<span class="hljs-string">' '</span>);

        each(split(html4BlockContent), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          add(name, <span class="hljs-string">""</span>, flowContent);
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-423">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-423">&#182;</a>
              </div>
              <p>Flow content elements from the HTML5 spec (block+inline)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      flowContent = flowContent || [blockContent, phrasingContent].join(<span class="hljs-string">" "</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-424">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-424">&#182;</a>
              </div>
              <p>HTML4 base schema TODO: Move HTML5 specific attributes to HTML5 specific if statement
Schema items <element name>, <specific attributes>, <children ..></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      add(<span class="hljs-string">"html"</span>, <span class="hljs-string">"manifest"</span>, <span class="hljs-string">"head body"</span>);
      add(<span class="hljs-string">"head"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"base command link meta noscript script style title"</span>);
      add(<span class="hljs-string">"title hr noscript br"</span>);
      add(<span class="hljs-string">"base"</span>, <span class="hljs-string">"href target"</span>);
      add(<span class="hljs-string">"link"</span>, <span class="hljs-string">"href rel media hreflang type sizes hreflang"</span>);
      add(<span class="hljs-string">"meta"</span>, <span class="hljs-string">"name http-equiv content charset"</span>);
      add(<span class="hljs-string">"style"</span>, <span class="hljs-string">"media type scoped"</span>);
      add(<span class="hljs-string">"script"</span>, <span class="hljs-string">"src async defer type charset"</span>);
      add(<span class="hljs-string">"body"</span>, <span class="hljs-string">"onafterprint onbeforeprint onbeforeunload onblur onerror onfocus "</span> +
        <span class="hljs-string">"onhashchange onload onmessage onoffline ononline onpagehide onpageshow "</span> +
        <span class="hljs-string">"onpopstate onresize onscroll onstorage onunload"</span>, flowContent);
      add(<span class="hljs-string">"address dt dd div caption"</span>, <span class="hljs-string">""</span>, flowContent);
      add(<span class="hljs-string">"h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn"</span>, <span class="hljs-string">""</span>, phrasingContent);
      add(<span class="hljs-string">"blockquote"</span>, <span class="hljs-string">"cite"</span>, flowContent);
      add(<span class="hljs-string">"ol"</span>, <span class="hljs-string">"reversed start type"</span>, <span class="hljs-string">"li"</span>);
      add(<span class="hljs-string">"ul"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"li"</span>);
      add(<span class="hljs-string">"li"</span>, <span class="hljs-string">"value"</span>, flowContent);
      add(<span class="hljs-string">"dl"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"dt dd"</span>);
      add(<span class="hljs-string">"a"</span>, <span class="hljs-string">"href target rel media hreflang type"</span>, phrasingContent);
      add(<span class="hljs-string">"q"</span>, <span class="hljs-string">"cite"</span>, phrasingContent);
      add(<span class="hljs-string">"ins del"</span>, <span class="hljs-string">"cite datetime"</span>, flowContent);
      add(<span class="hljs-string">"img"</span>, <span class="hljs-string">"src sizes srcset alt usemap ismap width height"</span>);
      add(<span class="hljs-string">"iframe"</span>, <span class="hljs-string">"src name width height"</span>, flowContent);
      add(<span class="hljs-string">"embed"</span>, <span class="hljs-string">"src type width height"</span>);
      add(<span class="hljs-string">"object"</span>, <span class="hljs-string">"data type typemustmatch name usemap form width height"</span>, [flowContent, <span class="hljs-string">"param"</span>].join(<span class="hljs-string">' '</span>));
      add(<span class="hljs-string">"param"</span>, <span class="hljs-string">"name value"</span>);
      add(<span class="hljs-string">"map"</span>, <span class="hljs-string">"name"</span>, [flowContent, <span class="hljs-string">"area"</span>].join(<span class="hljs-string">' '</span>));
      add(<span class="hljs-string">"area"</span>, <span class="hljs-string">"alt coords shape href target rel media hreflang type"</span>);
      add(<span class="hljs-string">"table"</span>, <span class="hljs-string">"border"</span>, <span class="hljs-string">"caption colgroup thead tfoot tbody tr"</span> + (type == <span class="hljs-string">"html4"</span> ? <span class="hljs-string">" col"</span> : <span class="hljs-string">""</span>));
      add(<span class="hljs-string">"colgroup"</span>, <span class="hljs-string">"span"</span>, <span class="hljs-string">"col"</span>);
      add(<span class="hljs-string">"col"</span>, <span class="hljs-string">"span"</span>);
      add(<span class="hljs-string">"tbody thead tfoot"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"tr"</span>);
      add(<span class="hljs-string">"tr"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"td th"</span>);
      add(<span class="hljs-string">"td"</span>, <span class="hljs-string">"colspan rowspan headers"</span>, flowContent);
      add(<span class="hljs-string">"th"</span>, <span class="hljs-string">"colspan rowspan headers scope abbr"</span>, flowContent);
      add(<span class="hljs-string">"form"</span>, <span class="hljs-string">"accept-charset action autocomplete enctype method name novalidate target"</span>, flowContent);
      add(<span class="hljs-string">"fieldset"</span>, <span class="hljs-string">"disabled form name"</span>, [flowContent, <span class="hljs-string">"legend"</span>].join(<span class="hljs-string">' '</span>));
      add(<span class="hljs-string">"label"</span>, <span class="hljs-string">"form for"</span>, phrasingContent);
      add(<span class="hljs-string">"input"</span>, <span class="hljs-string">"accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate "</span> +
        <span class="hljs-string">"formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"</span>
      );
      add(<span class="hljs-string">"button"</span>, <span class="hljs-string">"disabled form formaction formenctype formmethod formnovalidate formtarget name type value"</span>,
        type == <span class="hljs-string">"html4"</span> ? flowContent : phrasingContent);
      add(<span class="hljs-string">"select"</span>, <span class="hljs-string">"disabled form multiple name required size"</span>, <span class="hljs-string">"option optgroup"</span>);
      add(<span class="hljs-string">"optgroup"</span>, <span class="hljs-string">"disabled label"</span>, <span class="hljs-string">"option"</span>);
      add(<span class="hljs-string">"option"</span>, <span class="hljs-string">"disabled label selected value"</span>);
      add(<span class="hljs-string">"textarea"</span>, <span class="hljs-string">"cols dirname disabled form maxlength name readonly required rows wrap"</span>);
      add(<span class="hljs-string">"menu"</span>, <span class="hljs-string">"type label"</span>, [flowContent, <span class="hljs-string">"li"</span>].join(<span class="hljs-string">' '</span>));
      add(<span class="hljs-string">"noscript"</span>, <span class="hljs-string">""</span>, flowContent);</pre></div></div>
            
        </li>
        
        
        <li id="section-425">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-425">&#182;</a>
              </div>
              <p>Extend with HTML5 elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (type != <span class="hljs-string">"html4"</span>) {
        add(<span class="hljs-string">"wbr"</span>);
        add(<span class="hljs-string">"ruby"</span>, <span class="hljs-string">""</span>, [phrasingContent, <span class="hljs-string">"rt rp"</span>].join(<span class="hljs-string">' '</span>));
        add(<span class="hljs-string">"figcaption"</span>, <span class="hljs-string">""</span>, flowContent);
        add(<span class="hljs-string">"mark rt rp summary bdi"</span>, <span class="hljs-string">""</span>, phrasingContent);
        add(<span class="hljs-string">"canvas"</span>, <span class="hljs-string">"width height"</span>, flowContent);
        add(<span class="hljs-string">"video"</span>, <span class="hljs-string">"src crossorigin poster preload autoplay mediagroup loop "</span> +
          <span class="hljs-string">"muted controls width height buffered"</span>, [flowContent, <span class="hljs-string">"track source"</span>].join(<span class="hljs-string">' '</span>));
        add(<span class="hljs-string">"audio"</span>, <span class="hljs-string">"src crossorigin preload autoplay mediagroup loop muted controls "</span> +
          <span class="hljs-string">"buffered volume"</span>, [flowContent, <span class="hljs-string">"track source"</span>].join(<span class="hljs-string">' '</span>));
        add(<span class="hljs-string">"picture"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"img source"</span>);
        add(<span class="hljs-string">"source"</span>, <span class="hljs-string">"src srcset type media sizes"</span>);
        add(<span class="hljs-string">"track"</span>, <span class="hljs-string">"kind src srclang label default"</span>);
        add(<span class="hljs-string">"datalist"</span>, <span class="hljs-string">""</span>, [phrasingContent, <span class="hljs-string">"option"</span>].join(<span class="hljs-string">' '</span>));
        add(<span class="hljs-string">"article section nav aside header footer"</span>, <span class="hljs-string">""</span>, flowContent);
        add(<span class="hljs-string">"hgroup"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"h1 h2 h3 h4 h5 h6"</span>);
        add(<span class="hljs-string">"figure"</span>, <span class="hljs-string">""</span>, [flowContent, <span class="hljs-string">"figcaption"</span>].join(<span class="hljs-string">' '</span>));
        add(<span class="hljs-string">"time"</span>, <span class="hljs-string">"datetime"</span>, phrasingContent);
        add(<span class="hljs-string">"dialog"</span>, <span class="hljs-string">"open"</span>, flowContent);
        add(<span class="hljs-string">"command"</span>, <span class="hljs-string">"type label icon disabled checked radiogroup command"</span>);
        add(<span class="hljs-string">"output"</span>, <span class="hljs-string">"for form name"</span>, phrasingContent);
        add(<span class="hljs-string">"progress"</span>, <span class="hljs-string">"value max"</span>, phrasingContent);
        add(<span class="hljs-string">"meter"</span>, <span class="hljs-string">"value min max low high optimum"</span>, phrasingContent);
        add(<span class="hljs-string">"details"</span>, <span class="hljs-string">"open"</span>, [flowContent, <span class="hljs-string">"summary"</span>].join(<span class="hljs-string">' '</span>));
        add(<span class="hljs-string">"keygen"</span>, <span class="hljs-string">"autofocus challenge disabled form keytype name"</span>);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-426">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-426">&#182;</a>
              </div>
              <p>Extend with HTML4 attributes unless its html5-strict</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (type != <span class="hljs-string">"html5-strict"</span>) {
        addAttrs(<span class="hljs-string">"script"</span>, <span class="hljs-string">"language xml:space"</span>);
        addAttrs(<span class="hljs-string">"style"</span>, <span class="hljs-string">"xml:space"</span>);
        addAttrs(<span class="hljs-string">"object"</span>, <span class="hljs-string">"declare classid code codebase codetype archive standby align border hspace vspace"</span>);
        addAttrs(<span class="hljs-string">"embed"</span>, <span class="hljs-string">"align name hspace vspace"</span>);
        addAttrs(<span class="hljs-string">"param"</span>, <span class="hljs-string">"valuetype type"</span>);
        addAttrs(<span class="hljs-string">"a"</span>, <span class="hljs-string">"charset name rev shape coords"</span>);
        addAttrs(<span class="hljs-string">"br"</span>, <span class="hljs-string">"clear"</span>);
        addAttrs(<span class="hljs-string">"applet"</span>, <span class="hljs-string">"codebase archive code object alt name width height align hspace vspace"</span>);
        addAttrs(<span class="hljs-string">"img"</span>, <span class="hljs-string">"name longdesc align border hspace vspace"</span>);
        addAttrs(<span class="hljs-string">"iframe"</span>, <span class="hljs-string">"longdesc frameborder marginwidth marginheight scrolling align"</span>);
        addAttrs(<span class="hljs-string">"font basefont"</span>, <span class="hljs-string">"size color face"</span>);
        addAttrs(<span class="hljs-string">"input"</span>, <span class="hljs-string">"usemap align"</span>);
        addAttrs(<span class="hljs-string">"select"</span>, <span class="hljs-string">"onchange"</span>);
        addAttrs(<span class="hljs-string">"textarea"</span>);
        addAttrs(<span class="hljs-string">"h1 h2 h3 h4 h5 h6 div p legend caption"</span>, <span class="hljs-string">"align"</span>);
        addAttrs(<span class="hljs-string">"ul"</span>, <span class="hljs-string">"type compact"</span>);
        addAttrs(<span class="hljs-string">"li"</span>, <span class="hljs-string">"type"</span>);
        addAttrs(<span class="hljs-string">"ol dl menu dir"</span>, <span class="hljs-string">"compact"</span>);
        addAttrs(<span class="hljs-string">"pre"</span>, <span class="hljs-string">"width xml:space"</span>);
        addAttrs(<span class="hljs-string">"hr"</span>, <span class="hljs-string">"align noshade size width"</span>);
        addAttrs(<span class="hljs-string">"isindex"</span>, <span class="hljs-string">"prompt"</span>);
        addAttrs(<span class="hljs-string">"table"</span>, <span class="hljs-string">"summary width frame rules cellspacing cellpadding align bgcolor"</span>);
        addAttrs(<span class="hljs-string">"col"</span>, <span class="hljs-string">"width align char charoff valign"</span>);
        addAttrs(<span class="hljs-string">"colgroup"</span>, <span class="hljs-string">"width align char charoff valign"</span>);
        addAttrs(<span class="hljs-string">"thead"</span>, <span class="hljs-string">"align char charoff valign"</span>);
        addAttrs(<span class="hljs-string">"tr"</span>, <span class="hljs-string">"align char charoff valign bgcolor"</span>);
        addAttrs(<span class="hljs-string">"th"</span>, <span class="hljs-string">"axis align char charoff valign nowrap bgcolor width height"</span>);
        addAttrs(<span class="hljs-string">"form"</span>, <span class="hljs-string">"accept"</span>);
        addAttrs(<span class="hljs-string">"td"</span>, <span class="hljs-string">"abbr axis scope align char charoff valign nowrap bgcolor width height"</span>);
        addAttrs(<span class="hljs-string">"tfoot"</span>, <span class="hljs-string">"align char charoff valign"</span>);
        addAttrs(<span class="hljs-string">"tbody"</span>, <span class="hljs-string">"align char charoff valign"</span>);
        addAttrs(<span class="hljs-string">"area"</span>, <span class="hljs-string">"nohref"</span>);
        addAttrs(<span class="hljs-string">"body"</span>, <span class="hljs-string">"background bgcolor text link vlink alink"</span>);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-427">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-427">&#182;</a>
              </div>
              <p>Extend with HTML5 attributes unless its html4</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (type != <span class="hljs-string">"html4"</span>) {
        addAttrs(<span class="hljs-string">"input button select textarea"</span>, <span class="hljs-string">"autofocus"</span>);
        addAttrs(<span class="hljs-string">"input textarea"</span>, <span class="hljs-string">"placeholder"</span>);
        addAttrs(<span class="hljs-string">"a"</span>, <span class="hljs-string">"download"</span>);
        addAttrs(<span class="hljs-string">"link script img"</span>, <span class="hljs-string">"crossorigin"</span>);
        addAttrs(<span class="hljs-string">"iframe"</span>, <span class="hljs-string">"sandbox seamless allowfullscreen"</span>); <span class="hljs-comment">// Excluded: srcdoc</span>
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-428">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-428">&#182;</a>
              </div>
              <p>Special: iframe, ruby, video, audio, label</p>

            </div>
            
        </li>
        
        
        <li id="section-429">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-429">&#182;</a>
              </div>
              <p>Delete children of the same name from its parent
For example: form cant have a child of the name form</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      each(split(<span class="hljs-string">'a form meter progress dfn'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">if</span> (schema[name]) {
          <span class="hljs-keyword">delete</span> schema[name].children[name];
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-430">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-430">&#182;</a>
              </div>
              <p>Delete header, footer, sectioning and heading content descendants</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-comment">/*each('dt th address', function(name) {
       delete schema[name].children[name];
       });*/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-431">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-431">&#182;</a>
              </div>
              <p>Caption cant have tables</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">delete</span> schema.caption.children.table;</pre></div></div>
            
        </li>
        
        
        <li id="section-432">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-432">&#182;</a>
              </div>
              <p>Delete scripts by default due to possible XSS</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">delete</span> schema.script;</pre></div></div>
            
        </li>
        
        
        <li id="section-433">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-433">&#182;</a>
              </div>
              <p>TODO: LI:s can only have value if parent is OL</p>

            </div>
            
        </li>
        
        
        <li id="section-434">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-434">&#182;</a>
              </div>
              <p>TODO: Handle transparent elements
a ins del canvas map</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      mapCache[type] = schema;

      <span class="hljs-keyword">return</span> schema;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileElementMap</span>(<span class="hljs-params">value, mode</span>) </span>{
      <span class="hljs-keyword">var</span> styles;

      <span class="hljs-keyword">if</span> (value) {
        styles = {};

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'string'</span>) {
          value = {
            <span class="hljs-string">'*'</span>: value
          };
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-435">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-435">&#182;</a>
              </div>
              <p>Convert styles into a rule list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        each(value, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, key</span>) </span>{
          styles[key] = styles[key.toUpperCase()] = mode == <span class="hljs-string">'map'</span> ? makeMap(value, /[, ]/) : explode(value, /[, ]/);
        });
      }

      <span class="hljs-keyword">return</span> styles;
    }

    <span class="hljs-comment">/**
     * Constructs a new Schema instance.
     *
     * @constructor
     * @method Schema
     * @param {Object} settings Name/value settings object.
     */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, elements = {}, children = {}, patternElements = [], validStyles, invalidStyles, schemaItems;
      <span class="hljs-keyword">var</span> whiteSpaceElementsMap, selfClosingElementsMap, shortEndedElementsMap, boolAttrMap, validClasses;
      <span class="hljs-keyword">var</span> blockElementsMap, nonEmptyElementsMap, moveCaretBeforeOnEnterElementsMap, textBlockElementsMap, textInlineElementsMap;
      <span class="hljs-keyword">var</span> customElementsMap = {}, specialElements = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-436">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-436">&#182;</a>
              </div>
              <p>Creates an lookup table map object for the specified option or the default value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createLookupTable</span>(<span class="hljs-params">option, defaultValue, extendWith</span>) </span>{
        <span class="hljs-keyword">var</span> value = settings[option];

        <span class="hljs-keyword">if</span> (!value) {</pre></div></div>
            
        </li>
        
        
        <li id="section-437">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-437">&#182;</a>
              </div>
              <p>Get cached default map or make it if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          value = mapCache[option];

          <span class="hljs-keyword">if</span> (!value) {
            value = makeMap(defaultValue, <span class="hljs-string">' '</span>, makeMap(defaultValue.toUpperCase(), <span class="hljs-string">' '</span>));
            value = extend(value, extendWith);

            mapCache[option] = value;
          }
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-438">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-438">&#182;</a>
              </div>
              <p>Create custom map</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          value = makeMap(value, /[, ]/, makeMap(value.toUpperCase(), /[, ]/));
        }

        <span class="hljs-keyword">return</span> value;
      }

      settings = settings || {};
      schemaItems = compileSchema(settings.schema);</pre></div></div>
            
        </li>
        
        
        <li id="section-439">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-439">&#182;</a>
              </div>
              <p>Allow all elements and attributes if verify_html is set to false</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (settings.verify_html === <span class="hljs-literal">false</span>) {
        settings.valid_elements = <span class="hljs-string">'*[*]'</span>;
      }

      validStyles = compileElementMap(settings.valid_styles);
      invalidStyles = compileElementMap(settings.invalid_styles, <span class="hljs-string">'map'</span>);
      validClasses = compileElementMap(settings.valid_classes, <span class="hljs-string">'map'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-440">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-440">&#182;</a>
              </div>
              <p>Setup map objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      whiteSpaceElementsMap = createLookupTable(
        <span class="hljs-string">'whitespace_elements'</span>,
        <span class="hljs-string">'pre script noscript style textarea video audio iframe object code'</span>
      );
      selfClosingElementsMap = createLookupTable(<span class="hljs-string">'self_closing_elements'</span>, <span class="hljs-string">'colgroup dd dt li option p td tfoot th thead tr'</span>);
      shortEndedElementsMap = createLookupTable(<span class="hljs-string">'short_ended_elements'</span>, <span class="hljs-string">'area base basefont br col frame hr img input isindex link '</span> +
        <span class="hljs-string">'meta param embed source wbr track'</span>);
      boolAttrMap = createLookupTable(<span class="hljs-string">'boolean_attributes'</span>, <span class="hljs-string">'checked compact declare defer disabled ismap multiple nohref noresize '</span> +
        <span class="hljs-string">'noshade nowrap readonly selected autoplay loop controls'</span>);
      nonEmptyElementsMap = createLookupTable(<span class="hljs-string">'non_empty_elements'</span>, <span class="hljs-string">'td th iframe video audio object '</span> +
        <span class="hljs-string">'script pre code'</span>, shortEndedElementsMap);
      moveCaretBeforeOnEnterElementsMap = createLookupTable(<span class="hljs-string">'move_caret_before_on_enter_elements'</span>, <span class="hljs-string">'table'</span>, nonEmptyElementsMap);
      textBlockElementsMap = createLookupTable(<span class="hljs-string">'text_block_elements'</span>, <span class="hljs-string">'h1 h2 h3 h4 h5 h6 p div address pre form '</span> +
        <span class="hljs-string">'blockquote center dir fieldset header footer article section hgroup aside nav figure'</span>);
      blockElementsMap = createLookupTable(<span class="hljs-string">'block_elements'</span>, <span class="hljs-string">'hr table tbody thead tfoot '</span> +
        <span class="hljs-string">'th tr td li ol ul caption dl dt dd noscript menu isindex option '</span> +
        <span class="hljs-string">'datalist select optgroup figcaption'</span>, textBlockElementsMap);
      textInlineElementsMap = createLookupTable(<span class="hljs-string">'text_inline_elements'</span>, <span class="hljs-string">'span strong b em i font strike u var cite '</span> +
        <span class="hljs-string">'dfn code mark q sup sub samp'</span>);

      each((settings.special || <span class="hljs-string">'script noscript style textarea'</span>).split(<span class="hljs-string">' '</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        specialElements[name] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'&lt;\/'</span> + name + <span class="hljs-string">'[^&gt;]*&gt;'</span>, <span class="hljs-string">'gi'</span>);
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-441">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-441">&#182;</a>
              </div>
              <p>Converts a wildcard expression string to a regexp for example <em>a will become /.</em>a/.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">patternToRegExp</span>(<span class="hljs-params">str</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^'</span> + str.replace(<span class="hljs-regexp">/([?+*])/g</span>, <span class="hljs-string">'.$1'</span>) + <span class="hljs-string">'$'</span>);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-442">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-442">&#182;</a>
              </div>
              <p>Parses the specified valid_elements string and adds to the current rules
This function is a bit hard to read since its heavily optimized for speed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addValidElements</span>(<span class="hljs-params">validElements</span>) </span>{
        <span class="hljs-keyword">var</span> ei, el, ai, al, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder,
          prefix, outputName, globalAttributes, globalAttributesOrder, key, value,
          elementRuleRegExp = <span class="hljs-regexp">/^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)\])?$/</span>,
          attrRuleRegExp = <span class="hljs-regexp">/^([!\-])?(\w+::\w+|[^=:&lt;]+)?(?:([=:&lt;])(.*))?$/</span>,
          hasPatternsRegExp = <span class="hljs-regexp">/[*?+]/</span>;

        <span class="hljs-keyword">if</span> (validElements) {</pre></div></div>
            
        </li>
        
        
        <li id="section-443">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-443">&#182;</a>
              </div>
              <p>Split valid elements into an array with rules</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          validElements = split(validElements, <span class="hljs-string">','</span>);

          <span class="hljs-keyword">if</span> (elements[<span class="hljs-string">'@'</span>]) {
            globalAttributes = elements[<span class="hljs-string">'@'</span>].attributes;
            globalAttributesOrder = elements[<span class="hljs-string">'@'</span>].attributesOrder;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-444">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-444">&#182;</a>
              </div>
              <p>Loop all rules</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (ei = <span class="hljs-number">0</span>, el = validElements.length; ei &lt; el; ei++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-445">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-445">&#182;</a>
              </div>
              <p>Parse element rule</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            matches = elementRuleRegExp.exec(validElements[ei]);
            <span class="hljs-keyword">if</span> (matches) {</pre></div></div>
            
        </li>
        
        
        <li id="section-446">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-446">&#182;</a>
              </div>
              <p>Setup local names for matches</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              prefix = matches[<span class="hljs-number">1</span>];
              elementName = matches[<span class="hljs-number">2</span>];
              outputName = matches[<span class="hljs-number">3</span>];
              attrData = matches[<span class="hljs-number">5</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-447">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-447">&#182;</a>
              </div>
              <p>Create new attributes and attributesOrder</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              attributes = {};
              attributesOrder = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-448">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-448">&#182;</a>
              </div>
              <p>Create the new element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              element = {
                <span class="hljs-attr">attributes</span>: attributes,
                <span class="hljs-attr">attributesOrder</span>: attributesOrder
              };</pre></div></div>
            
        </li>
        
        
        <li id="section-449">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-449">&#182;</a>
              </div>
              <p>Padd empty elements prefix</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (prefix === <span class="hljs-string">'#'</span>) {
                element.paddEmpty = <span class="hljs-literal">true</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-450">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-450">&#182;</a>
              </div>
              <p>Remove empty elements prefix</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (prefix === <span class="hljs-string">'-'</span>) {
                element.removeEmpty = <span class="hljs-literal">true</span>;
              }

              <span class="hljs-keyword">if</span> (matches[<span class="hljs-number">4</span>] === <span class="hljs-string">'!'</span>) {
                element.removeEmptyAttrs = <span class="hljs-literal">true</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-451">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-451">&#182;</a>
              </div>
              <p>Copy attributes from global rule into current rule</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (globalAttributes) {
                <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> globalAttributes) {
                  attributes[key] = globalAttributes[key];
                }

                attributesOrder.push.apply(attributesOrder, globalAttributesOrder);
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-452">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-452">&#182;</a>
              </div>
              <p>Attributes defined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (attrData) {
                attrData = split(attrData, <span class="hljs-string">'|'</span>);
                <span class="hljs-keyword">for</span> (ai = <span class="hljs-number">0</span>, al = attrData.length; ai &lt; al; ai++) {
                  matches = attrRuleRegExp.exec(attrData[ai]);
                  <span class="hljs-keyword">if</span> (matches) {
                    attr = {};
                    attrType = matches[<span class="hljs-number">1</span>];
                    attrName = matches[<span class="hljs-number">2</span>].replace(<span class="hljs-regexp">/::/g</span>, <span class="hljs-string">':'</span>);
                    prefix = matches[<span class="hljs-number">3</span>];
                    value = matches[<span class="hljs-number">4</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-453">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-453">&#182;</a>
              </div>
              <p>Required</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> (attrType === <span class="hljs-string">'!'</span>) {
                      element.attributesRequired = element.attributesRequired || [];
                      element.attributesRequired.push(attrName);
                      attr.required = <span class="hljs-literal">true</span>;
                    }</pre></div></div>
            
        </li>
        
        
        <li id="section-454">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-454">&#182;</a>
              </div>
              <p>Denied from global</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> (attrType === <span class="hljs-string">'-'</span>) {
                      <span class="hljs-keyword">delete</span> attributes[attrName];
                      attributesOrder.splice(inArray(attributesOrder, attrName), <span class="hljs-number">1</span>);
                      <span class="hljs-keyword">continue</span>;
                    }</pre></div></div>
            
        </li>
        
        
        <li id="section-455">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-455">&#182;</a>
              </div>
              <p>Default value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> (prefix) {</pre></div></div>
            
        </li>
        
        
        <li id="section-456">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-456">&#182;</a>
              </div>
              <p>Default value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                      <span class="hljs-keyword">if</span> (prefix === <span class="hljs-string">'='</span>) {
                        element.attributesDefault = element.attributesDefault || [];
                        element.attributesDefault.push({ <span class="hljs-attr">name</span>: attrName, <span class="hljs-attr">value</span>: value });
                        attr.defaultValue = value;
                      }</pre></div></div>
            
        </li>
        
        
        <li id="section-457">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-457">&#182;</a>
              </div>
              <p>Forced value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                      <span class="hljs-keyword">if</span> (prefix === <span class="hljs-string">':'</span>) {
                        element.attributesForced = element.attributesForced || [];
                        element.attributesForced.push({ <span class="hljs-attr">name</span>: attrName, <span class="hljs-attr">value</span>: value });
                        attr.forcedValue = value;
                      }</pre></div></div>
            
        </li>
        
        
        <li id="section-458">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-458">&#182;</a>
              </div>
              <p>Required values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                      <span class="hljs-keyword">if</span> (prefix === <span class="hljs-string">'&lt;'</span>) {
                        attr.validValues = makeMap(value, <span class="hljs-string">'?'</span>);
                      }
                    }</pre></div></div>
            
        </li>
        
        
        <li id="section-459">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-459">&#182;</a>
              </div>
              <p>Check for attribute patterns</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> (hasPatternsRegExp.test(attrName)) {
                      element.attributePatterns = element.attributePatterns || [];
                      attr.pattern = patternToRegExp(attrName);
                      element.attributePatterns.push(attr);
                    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-460">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-460">&#182;</a>
              </div>
              <p>Add attribute to order list if it doesnt already exist</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                      <span class="hljs-keyword">if</span> (!attributes[attrName]) {
                        attributesOrder.push(attrName);
                      }

                      attributes[attrName] = attr;
                    }
                  }
                }
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-461">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-461">&#182;</a>
              </div>
              <p>Global rule, store away these for later usage</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (!globalAttributes &amp;&amp; elementName == <span class="hljs-string">'@'</span>) {
                globalAttributes = attributes;
                globalAttributesOrder = attributesOrder;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-462">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-462">&#182;</a>
              </div>
              <p>Handle substitute elements such as b/strong</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (outputName) {
                element.outputName = elementName;
                elements[outputName] = element;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-463">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-463">&#182;</a>
              </div>
              <p>Add pattern or exact element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (hasPatternsRegExp.test(elementName)) {
                element.pattern = patternToRegExp(elementName);
                patternElements.push(element);
              } <span class="hljs-keyword">else</span> {
                elements[elementName] = element;
              }
            }
          }
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setValidElements</span>(<span class="hljs-params">validElements</span>) </span>{
        elements = {};
        patternElements = [];

        addValidElements(validElements);

        each(schemaItems, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, name</span>) </span>{
          children[name] = element.children;
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-464">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-464">&#182;</a>
              </div>
              <p>Adds custom non HTML elements to the schema</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCustomElements</span>(<span class="hljs-params">customElements</span>) </span>{
        <span class="hljs-keyword">var</span> customElementRegExp = <span class="hljs-regexp">/^(~)?(.+)$/</span>;

        <span class="hljs-keyword">if</span> (customElements) {</pre></div></div>
            
        </li>
        
        
        <li id="section-465">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-465">&#182;</a>
              </div>
              <p>Flush cached items since we are altering the default maps</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          mapCache.text_block_elements = mapCache.block_elements = <span class="hljs-literal">null</span>;

          each(split(customElements, <span class="hljs-string">','</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rule</span>) </span>{
            <span class="hljs-keyword">var</span> matches = customElementRegExp.exec(rule),
              inline = matches[<span class="hljs-number">1</span>] === <span class="hljs-string">'~'</span>,
              cloneName = inline ? <span class="hljs-string">'span'</span> : <span class="hljs-string">'div'</span>,
              name = matches[<span class="hljs-number">2</span>];

            children[name] = children[cloneName];
            customElementsMap[name] = cloneName;</pre></div></div>
            
        </li>
        
        
        <li id="section-466">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-466">&#182;</a>
              </div>
              <p>If its not marked as inline then add it to valid block elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!inline) {
              blockElementsMap[name.toUpperCase()] = {};
              blockElementsMap[name] = {};
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-467">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-467">&#182;</a>
              </div>
              <p>Add elements clone if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!elements[name]) {
              <span class="hljs-keyword">var</span> customRule = elements[cloneName];

              customRule = extend({}, customRule);
              <span class="hljs-keyword">delete</span> customRule.removeEmptyAttrs;
              <span class="hljs-keyword">delete</span> customRule.removeEmpty;

              elements[name] = customRule;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-468">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-468">&#182;</a>
              </div>
              <p>Add custom elements at span/div positions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            each(children, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, elmName</span>) </span>{
              <span class="hljs-keyword">if</span> (element[cloneName]) {
                children[elmName] = element = extend({}, children[elmName]);
                element[name] = element[cloneName];
              }
            });
          });
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-469">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-469">&#182;</a>
              </div>
              <p>Adds valid children to the schema object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addValidChildren</span>(<span class="hljs-params">validChildren</span>) </span>{
        <span class="hljs-keyword">var</span> childRuleRegExp = <span class="hljs-regexp">/^([+\-]?)(\w+)\[([^\]]+)\]$/</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-470">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-470">&#182;</a>
              </div>
              <p>Invalidate the schema cache if the schema is mutated</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        mapCache[settings.schema] = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (validChildren) {
          each(split(validChildren, <span class="hljs-string">','</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rule</span>) </span>{
            <span class="hljs-keyword">var</span> matches = childRuleRegExp.exec(rule), parent, prefix;

            <span class="hljs-keyword">if</span> (matches) {
              prefix = matches[<span class="hljs-number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-471">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-471">&#182;</a>
              </div>
              <p>Add/remove items from default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (prefix) {
                parent = children[matches[<span class="hljs-number">2</span>]];
              } <span class="hljs-keyword">else</span> {
                parent = children[matches[<span class="hljs-number">2</span>]] = { <span class="hljs-string">'#comment'</span>: {} };
              }

              parent = children[matches[<span class="hljs-number">2</span>]];

              each(split(matches[<span class="hljs-number">3</span>], <span class="hljs-string">'|'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) </span>{
                <span class="hljs-keyword">if</span> (prefix === <span class="hljs-string">'-'</span>) {
                  <span class="hljs-keyword">delete</span> parent[child];
                } <span class="hljs-keyword">else</span> {
                  parent[child] = {};
                }
              });
            }
          });
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getElementRule</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">var</span> element = elements[name], i;</pre></div></div>
            
        </li>
        
        
        <li id="section-472">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-472">&#182;</a>
              </div>
              <p>Exact match found</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (element) {
          <span class="hljs-keyword">return</span> element;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-473">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-473">&#182;</a>
              </div>
              <p>No exact match then try the patterns</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        i = patternElements.length;
        <span class="hljs-keyword">while</span> (i--) {
          element = patternElements[i];

          <span class="hljs-keyword">if</span> (element.pattern.test(name)) {
            <span class="hljs-keyword">return</span> element;
          }
        }
      }

      <span class="hljs-keyword">if</span> (!settings.valid_elements) {</pre></div></div>
            
        </li>
        
        
        <li id="section-474">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-474">&#182;</a>
              </div>
              <p>No valid elements defined then clone the elements from the schema spec</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        each(schemaItems, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, name</span>) </span>{
          elements[name] = {
            <span class="hljs-attr">attributes</span>: element.attributes,
            <span class="hljs-attr">attributesOrder</span>: element.attributesOrder
          };

          children[name] = element.children;
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-475">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-475">&#182;</a>
              </div>
              <p>Switch these on HTML4</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (settings.schema != <span class="hljs-string">"html5"</span>) {
          each(split(<span class="hljs-string">'strong/b em/i'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
            item = split(item, <span class="hljs-string">'/'</span>);
            elements[item[<span class="hljs-number">1</span>]].outputName = item[<span class="hljs-number">0</span>];
          });
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-476">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-476">&#182;</a>
              </div>
              <p>Add default alt attribute for images, removed since alt= is treated as presentational.
elements.img.attributesDefault = [{name: alt, value: }];</p>

            </div>
            
        </li>
        
        
        <li id="section-477">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-477">&#182;</a>
              </div>
              <p>Remove these if they are empty by default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        each(split(<span class="hljs-string">'ol ul sub sup blockquote span font a table tbody tr strong em b i'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">if</span> (elements[name]) {
            elements[name].removeEmpty = <span class="hljs-literal">true</span>;
          }
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-478">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-478">&#182;</a>
              </div>
              <p>Padd these by default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        each(split(<span class="hljs-string">'p h1 h2 h3 h4 h5 h6 th td pre div address caption'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          elements[name].paddEmpty = <span class="hljs-literal">true</span>;
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-479">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-479">&#182;</a>
              </div>
              <p>Remove these if they have no attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        each(split(<span class="hljs-string">'span'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          elements[name].removeEmptyAttrs = <span class="hljs-literal">true</span>;
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-480">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-480">&#182;</a>
              </div>
              <p>Remove these by default
TODO: Reenable in 4.1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/*each(split('script style'), function(name) {
         delete elements[name];
         });*/</span>
      } <span class="hljs-keyword">else</span> {
        setValidElements(settings.valid_elements);
      }

      addCustomElements(settings.custom_elements);
      addValidChildren(settings.valid_children);
      addValidElements(settings.extended_valid_elements);</pre></div></div>
            
        </li>
        
        
        <li id="section-481">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-481">&#182;</a>
              </div>
              <p>Todo: Remove this when we fix list handling to be valid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      addValidChildren(<span class="hljs-string">'+ol[ul|ol],+ul[ul|ol]'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-482">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-482">&#182;</a>
              </div>
              <p>Some elements are not valid by themselves - require parents</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      each({
        <span class="hljs-attr">dd</span>: <span class="hljs-string">'dl'</span>,
        <span class="hljs-attr">dt</span>: <span class="hljs-string">'dl'</span>,
        <span class="hljs-attr">li</span>: <span class="hljs-string">'ul ol'</span>,
        <span class="hljs-attr">td</span>: <span class="hljs-string">'tr'</span>,
        <span class="hljs-attr">th</span>: <span class="hljs-string">'tr'</span>,
        <span class="hljs-attr">tr</span>: <span class="hljs-string">'tbody thead tfoot'</span>,
        <span class="hljs-attr">tbody</span>: <span class="hljs-string">'table'</span>,
        <span class="hljs-attr">thead</span>: <span class="hljs-string">'table'</span>,
        <span class="hljs-attr">tfoot</span>: <span class="hljs-string">'table'</span>,
        <span class="hljs-attr">legend</span>: <span class="hljs-string">'fieldset'</span>,
        <span class="hljs-attr">area</span>: <span class="hljs-string">'map'</span>,
        <span class="hljs-attr">param</span>: <span class="hljs-string">'video audio object'</span>
      }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parents, item</span>) </span>{
        <span class="hljs-keyword">if</span> (elements[item]) {
          elements[item].parentsRequired = split(parents);
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-483">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-483">&#182;</a>
              </div>
              <p>Delete invalid elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (settings.invalid_elements) {
        each(explode(settings.invalid_elements), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          <span class="hljs-keyword">if</span> (elements[item]) {
            <span class="hljs-keyword">delete</span> elements[item];
          }
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-484">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-484">&#182;</a>
              </div>
              <p>If the user didnt allow span only allow internal spans</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!getElementRule(<span class="hljs-string">'span'</span>)) {
        addValidElements(<span class="hljs-string">'span[!data-mce-type|*]'</span>);
      }

      <span class="hljs-comment">/**
       * Name/value map object with valid parents and children to those parents.
       *
       * @example
       * children = {
       *    div:{p:{}, h1:{}}
       * };
       * @field children
       * @type Object
       */</span>
      self.children = children;

      <span class="hljs-comment">/**
       * Name/value map object with valid styles for each element.
       *
       * @method getValidStyles
       * @type Object
       */</span>
      self.getValidStyles = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> validStyles;
      };

      <span class="hljs-comment">/**
       * Name/value map object with valid styles for each element.
       *
       * @method getInvalidStyles
       * @type Object
       */</span>
      self.getInvalidStyles = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> invalidStyles;
      };

      <span class="hljs-comment">/**
       * Name/value map object with valid classes for each element.
       *
       * @method getValidClasses
       * @type Object
       */</span>
      self.getValidClasses = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> validClasses;
      };

      <span class="hljs-comment">/**
       * Returns a map with boolean attributes.
       *
       * @method getBoolAttrs
       * @return {Object} Name/value lookup map for boolean attributes.
       */</span>
      self.getBoolAttrs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> boolAttrMap;
      };

      <span class="hljs-comment">/**
       * Returns a map with block elements.
       *
       * @method getBlockElements
       * @return {Object} Name/value lookup map for block elements.
       */</span>
      self.getBlockElements = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> blockElementsMap;
      };

      <span class="hljs-comment">/**
       * Returns a map with text block elements. Such as: p,h1-h6,div,address
       *
       * @method getTextBlockElements
       * @return {Object} Name/value lookup map for block elements.
       */</span>
      self.getTextBlockElements = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> textBlockElementsMap;
      };

      <span class="hljs-comment">/**
       * Returns a map of inline text format nodes for example strong/span or ins.
       *
       * @method getTextInlineElements
       * @return {Object} Name/value lookup map for text format elements.
       */</span>
      self.getTextInlineElements = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> textInlineElementsMap;
      };

      <span class="hljs-comment">/**
       * Returns a map with short ended elements such as BR or IMG.
       *
       * @method getShortEndedElements
       * @return {Object} Name/value lookup map for short ended elements.
       */</span>
      self.getShortEndedElements = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> shortEndedElementsMap;
      };

      <span class="hljs-comment">/**
       * Returns a map with self closing tags such as &lt;li&gt;.
       *
       * @method getSelfClosingElements
       * @return {Object} Name/value lookup map for self closing tags elements.
       */</span>
      self.getSelfClosingElements = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> selfClosingElementsMap;
      };

      <span class="hljs-comment">/**
       * Returns a map with elements that should be treated as contents regardless if it has text
       * content in them or not such as TD, VIDEO or IMG.
       *
       * @method getNonEmptyElements
       * @return {Object} Name/value lookup map for non empty elements.
       */</span>
      self.getNonEmptyElements = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> nonEmptyElementsMap;
      };

      <span class="hljs-comment">/**
       * Returns a map with elements that the caret should be moved in front of after enter is
       * pressed
       *
       * @method getMoveCaretBeforeOnEnterElements
       * @return {Object} Name/value lookup map for elements to place the caret in front of.
       */</span>
      self.getMoveCaretBeforeOnEnterElements = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> moveCaretBeforeOnEnterElementsMap;
      };

      <span class="hljs-comment">/**
       * Returns a map with elements where white space is to be preserved like PRE or SCRIPT.
       *
       * @method getWhiteSpaceElements
       * @return {Object} Name/value lookup map for white space elements.
       */</span>
      self.getWhiteSpaceElements = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> whiteSpaceElementsMap;
      };

      <span class="hljs-comment">/**
       * Returns a map with special elements. These are elements that needs to be parsed
       * in a special way such as script, style, textarea etc. The map object values
       * are regexps used to find the end of the element.
       *
       * @method getSpecialElements
       * @return {Object} Name/value lookup map for special elements.
       */</span>
      self.getSpecialElements = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> specialElements;
      };

      <span class="hljs-comment">/**
       * Returns true/false if the specified element and it's child is valid or not
       * according to the schema.
       *
       * @method isValidChild
       * @param {String} name Element name to check for.
       * @param {String} child Element child to verify.
       * @return {Boolean} True/false if the element is a valid child of the specified parent.
       */</span>
      self.isValidChild = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, child</span>) </span>{
        <span class="hljs-keyword">var</span> parent = children[name.toLowerCase()];

        <span class="hljs-keyword">return</span> !!(parent &amp;&amp; parent[child.toLowerCase()]);
      };

      <span class="hljs-comment">/**
       * Returns true/false if the specified element name and optional attribute is
       * valid according to the schema.
       *
       * @method isValid
       * @param {String} name Name of element to check.
       * @param {String} attr Optional attribute name to check for.
       * @return {Boolean} True/false if the element and attribute is valid.
       */</span>
      self.isValid = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, attr</span>) </span>{
        <span class="hljs-keyword">var</span> attrPatterns, i, rule = getElementRule(name);</pre></div></div>
            
        </li>
        
        
        <li id="section-485">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-485">&#182;</a>
              </div>
              <p>Check if its a valid element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (rule) {
          <span class="hljs-keyword">if</span> (attr) {</pre></div></div>
            
        </li>
        
        
        <li id="section-486">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-486">&#182;</a>
              </div>
              <p>Check if attribute name exists</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (rule.attributes[attr]) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-487">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-487">&#182;</a>
              </div>
              <p>Check if attribute matches a regexp pattern</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            attrPatterns = rule.attributePatterns;
            <span class="hljs-keyword">if</span> (attrPatterns) {
              i = attrPatterns.length;
              <span class="hljs-keyword">while</span> (i--) {
                <span class="hljs-keyword">if</span> (attrPatterns[i].pattern.test(name)) {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
              }
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-488">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-488">&#182;</a>
              </div>
              <p>No match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      };

      <span class="hljs-comment">/**
       * Returns true/false if the specified element is valid or not
       * according to the schema.
       *
       * @method getElementRule
       * @param {String} name Element name to check for.
       * @return {Object} Element object or undefined if the element isn't valid.
       */</span>
      self.getElementRule = getElementRule;

      <span class="hljs-comment">/**
       * Returns an map object of all custom elements.
       *
       * @method getCustomElements
       * @return {Object} Name/value map object of all custom elements.
       */</span>
      self.getCustomElements = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> customElementsMap;
      };

      <span class="hljs-comment">/**
       * Parses a valid elements string and adds it to the schema. The valid elements
       * format is for example "element[attr=default|otherattr]".
       * Existing rules will be replaced with the ones specified, so this extends the schema.
       *
       * @method addValidElements
       * @param {String} valid_elements String in the valid elements format to be parsed.
       */</span>
      self.addValidElements = addValidElements;

      <span class="hljs-comment">/**
       * Parses a valid elements string and sets it to the schema. The valid elements
       * format is for example "element[attr=default|otherattr]".
       * Existing rules will be replaced with the ones specified, so this extends the schema.
       *
       * @method setValidElements
       * @param {String} valid_elements String in the valid elements format to be parsed.
       */</span>
      self.setValidElements = setValidElements;

      <span class="hljs-comment">/**
       * Adds custom non HTML elements to the schema.
       *
       * @method addCustomElements
       * @param {String} custom_elements Comma separated list of custom elements to add.
       */</span>
      self.addCustomElements = addCustomElements;

      <span class="hljs-comment">/**
       * Parses a valid children string and adds them to the schema structure. The valid children
       * format is for example: "element[child1|child2]".
       *
       * @method addValidChildren
       * @param {String} valid_children Valid children elements string to parse
       */</span>
      self.addValidChildren = addValidChildren;

      self.elements = elements;
    };
  }
);

<span class="hljs-comment">/**
 * DOMUtils.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Utility class for various DOM manipulation and retrieval functions.
 *
 * @class tinymce.dom.DOMUtils
 * @example
 * // Add a class to an element by id in the page
 * tinymce.DOM.addClass('someid', 'someclass');
 *
 * // Add a class to an element by id inside the editor
 * tinymce.activeEditor.dom.addClass('someid', 'someclass');
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.DOMUtils'</span>,
  [
    <span class="hljs-string">'tinymce.core.dom.DomQuery'</span>,
    <span class="hljs-string">'tinymce.core.dom.EventUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.Range'</span>,
    <span class="hljs-string">'tinymce.core.dom.Sizzle'</span>,
    <span class="hljs-string">'tinymce.core.dom.StyleSheetLoader'</span>,
    <span class="hljs-string">'tinymce.core.dom.TreeWalker'</span>,
    <span class="hljs-string">'tinymce.core.Env'</span>,
    <span class="hljs-string">'tinymce.core.html.Entities'</span>,
    <span class="hljs-string">'tinymce.core.html.Schema'</span>,
    <span class="hljs-string">'tinymce.core.html.Styles'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">DomQuery, EventUtils, Range, Sizzle, StyleSheetLoader, TreeWalker, Env, Entities, Schema, Styles, Tools</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-489">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-489">&#182;</a>
              </div>
              <p>Shorten names</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> each = Tools.each, is = Tools.is, grep = Tools.grep, trim = Tools.trim;
    <span class="hljs-keyword">var</span> isIE = Env.ie;
    <span class="hljs-keyword">var</span> simpleSelectorRe = <span class="hljs-regexp">/^([a-z0-9],?)+$/i</span>;
    <span class="hljs-keyword">var</span> whiteSpaceRegExp = <span class="hljs-regexp">/^[ \t\r\n]*$/</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setupAttrHooks</span>(<span class="hljs-params">domUtils, settings</span>) </span>{
      <span class="hljs-keyword">var</span> attrHooks = {}, keepValues = settings.keep_values, keepUrlHook;

      keepUrlHook = {
        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$elm, value, name</span>) </span>{
          <span class="hljs-keyword">if</span> (settings.url_converter) {
            value = settings.url_converter.call(settings.url_converter_scope || domUtils, value, name, $elm[<span class="hljs-number">0</span>]);
          }

          $elm.attr(<span class="hljs-string">'data-mce-'</span> + name, value).attr(name, value);
        },

        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$elm, name</span>) </span>{
          <span class="hljs-keyword">return</span> $elm.attr(<span class="hljs-string">'data-mce-'</span> + name) || $elm.attr(name);
        }
      };

      attrHooks = {
        <span class="hljs-attr">style</span>: {
          <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$elm, value</span>) </span>{
            <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span>) {
              $elm.css(value);
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (keepValues) {
              $elm.attr(<span class="hljs-string">'data-mce-style'</span>, value);
            }

            $elm.attr(<span class="hljs-string">'style'</span>, value);
          },

          <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$elm</span>) </span>{
            <span class="hljs-keyword">var</span> value = $elm.attr(<span class="hljs-string">'data-mce-style'</span>) || $elm.attr(<span class="hljs-string">'style'</span>);

            value = domUtils.serializeStyle(domUtils.parseStyle(value), $elm[<span class="hljs-number">0</span>].nodeName);

            <span class="hljs-keyword">return</span> value;
          }
        }
      };

      <span class="hljs-keyword">if</span> (keepValues) {
        attrHooks.href = attrHooks.src = keepUrlHook;
      }

      <span class="hljs-keyword">return</span> attrHooks;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateInternalStyleAttr</span>(<span class="hljs-params">domUtils, $elm</span>) </span>{
      <span class="hljs-keyword">var</span> value = $elm.attr(<span class="hljs-string">'style'</span>);

      value = domUtils.serializeStyle(domUtils.parseStyle(value), $elm[<span class="hljs-number">0</span>].nodeName);

      <span class="hljs-keyword">if</span> (!value) {
        value = <span class="hljs-literal">null</span>;
      }

      $elm.attr(<span class="hljs-string">'data-mce-style'</span>, value);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nodeIndex</span>(<span class="hljs-params">node, normalized</span>) </span>{
      <span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>, lastNodeType, nodeType;

      <span class="hljs-keyword">if</span> (node) {
        <span class="hljs-keyword">for</span> (lastNodeType = node.nodeType, node = node.previousSibling; node; node = node.previousSibling) {
          nodeType = node.nodeType;</pre></div></div>
            
        </li>
        
        
        <li id="section-490">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-490">&#182;</a>
              </div>
              <p>Normalize text nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (normalized &amp;&amp; nodeType == <span class="hljs-number">3</span>) {
            <span class="hljs-keyword">if</span> (nodeType == lastNodeType || !node.nodeValue.length) {
              <span class="hljs-keyword">continue</span>;
            }
          }
          idx++;
          lastNodeType = nodeType;
        }
      }

      <span class="hljs-keyword">return</span> idx;
    }

    <span class="hljs-comment">/**
     * Constructs a new DOMUtils instance. Consult the Wiki for more details on settings etc for this class.
     *
     * @constructor
     * @method DOMUtils
     * @param {Document} doc Document reference to bind the utility class to.
     * @param {settings} settings Optional settings collection.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DOMUtils</span>(<span class="hljs-params">doc, settings</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, blockElementsMap;

      self.doc = doc;
      self.win = <span class="hljs-built_in">window</span>;
      self.files = {};
      self.counter = <span class="hljs-number">0</span>;
      self.stdMode = !isIE || doc.documentMode &gt;= <span class="hljs-number">8</span>;
      self.boxModel = !isIE || doc.compatMode == <span class="hljs-string">"CSS1Compat"</span> || self.stdMode;
      self.styleSheetLoader = <span class="hljs-keyword">new</span> StyleSheetLoader(doc);
      self.boundEvents = [];
      self.settings = settings = settings || {};
      self.schema = settings.schema ? settings.schema : <span class="hljs-keyword">new</span> Schema({});
      self.styles = <span class="hljs-keyword">new</span> Styles({
        <span class="hljs-attr">url_converter</span>: settings.url_converter,
        <span class="hljs-attr">url_converter_scope</span>: settings.url_converter_scope
      }, settings.schema);

      self.fixDoc(doc);
      self.events = settings.ownEvents ? <span class="hljs-keyword">new</span> EventUtils(settings.proxy) : EventUtils.Event;
      self.attrHooks = setupAttrHooks(self, settings);
      blockElementsMap = settings.schema ? settings.schema.getBlockElements() : {};
      self.$ = DomQuery.overrideDefaults(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">context</span>: doc,
          <span class="hljs-attr">element</span>: self.getRoot()
        };
      });

      <span class="hljs-comment">/**
       * Returns true/false if the specified element is a block element or not.
       *
       * @method isBlock
       * @param {Node/String} node Element/Node to check.
       * @return {Boolean} True/False state if the node is a block element or not.
       */</span>
      self.isBlock = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-491">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-491">&#182;</a>
              </div>
              <p>Fix for #5446</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!node) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-492">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-492">&#182;</a>
              </div>
              <p>This function is called in module pattern style since it might be executed with the wrong this scope</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> type = node.nodeType;</pre></div></div>
            
        </li>
        
        
        <li id="section-493">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-493">&#182;</a>
              </div>
              <p>If its a node then check the type and use the nodeName</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (type) {
          <span class="hljs-keyword">return</span> !!(type === <span class="hljs-number">1</span> &amp;&amp; blockElementsMap[node.nodeName]);
        }

        <span class="hljs-keyword">return</span> !!blockElementsMap[node];
      };
    }

    DOMUtils.prototype = {
      <span class="hljs-attr">$$</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> elm == <span class="hljs-string">'string'</span>) {
          elm = <span class="hljs-keyword">this</span>.get(elm);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$(elm);
      },

      <span class="hljs-attr">root</span>: <span class="hljs-literal">null</span>,

      <span class="hljs-attr">fixDoc</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
        <span class="hljs-keyword">var</span> settings = <span class="hljs-keyword">this</span>.settings, name;

        <span class="hljs-keyword">if</span> (isIE &amp;&amp; settings.schema) {</pre></div></div>
            
        </li>
        
        
        <li id="section-494">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-494">&#182;</a>
              </div>
              <p>Add missing HTML 4/5 elements to IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          (<span class="hljs-string">'abbr article aside audio canvas '</span> +
            <span class="hljs-string">'details figcaption figure footer '</span> +
            <span class="hljs-string">'header hgroup mark menu meter nav '</span> +
            <span class="hljs-string">'output progress section summary '</span> +
            <span class="hljs-string">'time video'</span>).replace(<span class="hljs-regexp">/\w+/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
              doc.createElement(name);
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-495">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-495">&#182;</a>
              </div>
              <p>Create all custom elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> settings.schema.getCustomElements()) {
            doc.createElement(name);
          }
        }
      },

      <span class="hljs-attr">clone</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, deep</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, clone, doc;</pre></div></div>
            
        </li>
        
        
        <li id="section-496">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-496">&#182;</a>
              </div>
              <p>TODO: Add feature detection here in the future</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!isIE || node.nodeType !== <span class="hljs-number">1</span> || deep) {
          <span class="hljs-keyword">return</span> node.cloneNode(deep);
        }

        doc = self.doc;</pre></div></div>
            
        </li>
        
        
        <li id="section-497">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-497">&#182;</a>
              </div>
              <p>Make a HTML5 safe shallow copy</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!deep) {
          clone = doc.createElement(node.nodeName);</pre></div></div>
            
        </li>
        
        
        <li id="section-498">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-498">&#182;</a>
              </div>
              <p>Copy attribs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          each(self.getAttribs(node), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">attr</span>) </span>{
            self.setAttrib(clone, attr.nodeName, self.getAttrib(node, attr.nodeName));
          });

          <span class="hljs-keyword">return</span> clone;
        }

        <span class="hljs-keyword">return</span> clone.firstChild;
      },

      <span class="hljs-comment">/**
       * Returns the root node of the document. This is normally the body but might be a DIV. Parents like getParent will not
       * go above the point of this root node.
       *
       * @method getRoot
       * @return {Element} Root element for the utility class.
       */</span>
      getRoot: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">return</span> self.settings.root_element || self.doc.body;
      },

      <span class="hljs-comment">/**
       * Returns the viewport of the window.
       *
       * @method getViewPort
       * @param {Window} win Optional window to get viewport of.
       * @return {Object} Viewport object with fields x, y, w and h.
       */</span>
      getViewPort: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">win</span>) </span>{
        <span class="hljs-keyword">var</span> doc, rootElm;

        win = !win ? <span class="hljs-keyword">this</span>.win : win;
        doc = win.document;
        rootElm = <span class="hljs-keyword">this</span>.boxModel ? doc.documentElement : doc.body;</pre></div></div>
            
        </li>
        
        
        <li id="section-499">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-499">&#182;</a>
              </div>
              <p>Returns viewport size excluding scrollbars</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">x</span>: win.pageXOffset || rootElm.scrollLeft,
          <span class="hljs-attr">y</span>: win.pageYOffset || rootElm.scrollTop,
          <span class="hljs-attr">w</span>: win.innerWidth || rootElm.clientWidth,
          <span class="hljs-attr">h</span>: win.innerHeight || rootElm.clientHeight
        };
      },

      <span class="hljs-comment">/**
       * Returns the rectangle for a specific element.
       *
       * @method getRect
       * @param {Element/String} elm Element object or element ID to get rectangle from.
       * @return {object} Rectangle for specified element object with x, y, w, h fields.
       */</span>
      getRect: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, pos, size;

        elm = self.get(elm);
        pos = self.getPos(elm);
        size = self.getSize(elm);

        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">x</span>: pos.x, <span class="hljs-attr">y</span>: pos.y,
          <span class="hljs-attr">w</span>: size.w, <span class="hljs-attr">h</span>: size.h
        };
      },

      <span class="hljs-comment">/**
       * Returns the size dimensions of the specified element.
       *
       * @method getSize
       * @param {Element/String} elm Element object or element ID to get rectangle from.
       * @return {object} Rectangle for specified element object with w, h fields.
       */</span>
      getSize: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, w, h;

        elm = self.get(elm);
        w = self.getStyle(elm, <span class="hljs-string">'width'</span>);
        h = self.getStyle(elm, <span class="hljs-string">'height'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-500">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-500">&#182;</a>
              </div>
              <p>Non pixel value, then force offset/clientWidth</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (w.indexOf(<span class="hljs-string">'px'</span>) === <span class="hljs-number">-1</span>) {
          w = <span class="hljs-number">0</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-501">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-501">&#182;</a>
              </div>
              <p>Non pixel value, then force offset/clientWidth</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (h.indexOf(<span class="hljs-string">'px'</span>) === <span class="hljs-number">-1</span>) {
          h = <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">w</span>: <span class="hljs-built_in">parseInt</span>(w, <span class="hljs-number">10</span>) || elm.offsetWidth || elm.clientWidth,
          <span class="hljs-attr">h</span>: <span class="hljs-built_in">parseInt</span>(h, <span class="hljs-number">10</span>) || elm.offsetHeight || elm.clientHeight
        };
      },

      <span class="hljs-comment">/**
       * Returns a node by the specified selector function. This function will
       * loop through all parent nodes and call the specified function for each node.
       * If the function then returns true indicating that it has found what it was looking for, the loop execution will then end
       * and the node it found will be returned.
       *
       * @method getParent
       * @param {Node/String} node DOM node to search parents on or ID string.
       * @param {function} selector Selection function or CSS selector to execute on each node.
       * @param {Node} root Optional root element, never go beyond this point.
       * @return {Node} DOM Node or null if it wasn't found.
       */</span>
      getParent: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, selector, root</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getParents(node, selector, root, <span class="hljs-literal">false</span>);
      },

      <span class="hljs-comment">/**
       * Returns a node list of all parents matching the specified selector function or pattern.
       * If the function then returns true indicating that it has found what it was looking for and that node will be collected.
       *
       * @method getParents
       * @param {Node/String} node DOM node to search parents on or ID string.
       * @param {function} selector Selection function to execute on each node or CSS pattern.
       * @param {Node} root Optional root element, never go beyond this point.
       * @return {Array} Array of nodes or null if it wasn't found.
       */</span>
      getParents: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, selector, root, collect</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, selectorVal, result = [];

        node = self.get(node);
        collect = collect === <span class="hljs-literal">undefined</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-502">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-502">&#182;</a>
              </div>
              <p>Default root on inline mode</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        root = root || (self.getRoot().nodeName != <span class="hljs-string">'BODY'</span> ? self.getRoot().parentNode : <span class="hljs-literal">null</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-503">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-503">&#182;</a>
              </div>
              <p>Wrap node name as func</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (is(selector, <span class="hljs-string">'string'</span>)) {
          selectorVal = selector;

          <span class="hljs-keyword">if</span> (selector === <span class="hljs-string">'*'</span>) {
            selector = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
              <span class="hljs-keyword">return</span> node.nodeType == <span class="hljs-number">1</span>;
            };
          } <span class="hljs-keyword">else</span> {
            selector = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
              <span class="hljs-keyword">return</span> self.is(node, selectorVal);
            };
          }
        }

        <span class="hljs-keyword">while</span> (node) {
          <span class="hljs-keyword">if</span> (node == root || !node.nodeType || node.nodeType === <span class="hljs-number">9</span>) {
            <span class="hljs-keyword">break</span>;
          }

          <span class="hljs-keyword">if</span> (!selector || selector(node)) {
            <span class="hljs-keyword">if</span> (collect) {
              result.push(node);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> node;
            }
          }

          node = node.parentNode;
        }

        <span class="hljs-keyword">return</span> collect ? result : <span class="hljs-literal">null</span>;
      },

      <span class="hljs-comment">/**
       * Returns the specified element by ID or the input element if it isn't a string.
       *
       * @method get
       * @param {String/Element} n Element id to look for or element to just pass though.
       * @return {Element} Element matching the specified id or null if it wasn't found.
       */</span>
      get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">var</span> name;

        <span class="hljs-keyword">if</span> (elm &amp;&amp; <span class="hljs-keyword">this</span>.doc &amp;&amp; <span class="hljs-keyword">typeof</span> elm == <span class="hljs-string">'string'</span>) {
          name = elm;
          elm = <span class="hljs-keyword">this</span>.doc.getElementById(elm);</pre></div></div>
            
        </li>
        
        
        <li id="section-504">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-504">&#182;</a>
              </div>
              <p>IE and Opera returns meta elements when they match the specified input ID, but getElementsByName seems to do the trick</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (elm &amp;&amp; elm.id !== name) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.doc.getElementsByName(name)[<span class="hljs-number">1</span>];
          }
        }

        <span class="hljs-keyword">return</span> elm;
      },

      <span class="hljs-comment">/**
       * Returns the next node that matches selector or function
       *
       * @method getNext
       * @param {Node} node Node to find siblings from.
       * @param {String/function} selector Selector CSS expression or function.
       * @return {Node} Next node item matching the selector or null if it wasn't found.
       */</span>
      getNext: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, selector</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._findSib(node, selector, <span class="hljs-string">'nextSibling'</span>);
      },

      <span class="hljs-comment">/**
       * Returns the previous node that matches selector or function
       *
       * @method getPrev
       * @param {Node} node Node to find siblings from.
       * @param {String/function} selector Selector CSS expression or function.
       * @return {Node} Previous node item matching the selector or null if it wasn't found.
       */</span>
      getPrev: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, selector</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._findSib(node, selector, <span class="hljs-string">'previousSibling'</span>);
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-505">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-505">&#182;</a>
              </div>
              <p>#ifndef jquery</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Selects specific elements by a CSS level 3 pattern. For example "div#a1 p.test".
       * This function is optimized for the most common patterns needed in TinyMCE but it also performs well enough
       * on more complex patterns.
       *
       * @method select
       * @param {String} selector CSS level 3 pattern to select/find elements by.
       * @param {Object} scope Optional root element/scope element to search in.
       * @return {Array} Array with all matched elements.
       * @example
       * // Adds a class to all paragraphs in the currently active editor
       * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'someclass');
       *
       * // Adds a class to all spans that have the test class in the currently active editor
       * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('span.test'), 'someclass')
       */</span>
      select: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector, scope</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-comment">/*eslint new-cap:0 */</span>
        <span class="hljs-keyword">return</span> Sizzle(selector, self.get(scope) || self.settings.root_element || self.doc, []);
      },

      <span class="hljs-comment">/**
       * Returns true/false if the specified element matches the specified css pattern.
       *
       * @method is
       * @param {Node/NodeList} elm DOM node to match or an array of nodes to match.
       * @param {String} selector CSS pattern to match the element against.
       */</span>
      is: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, selector</span>) </span>{
        <span class="hljs-keyword">var</span> i;

        <span class="hljs-keyword">if</span> (!elm) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-506">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-506">&#182;</a>
              </div>
              <p>If it isnt an array then try to do some simple selectors instead of Sizzle for to boost performance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (elm.length === <span class="hljs-literal">undefined</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-507">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-507">&#182;</a>
              </div>
              <p>Simple all selector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (selector === <span class="hljs-string">'*'</span>) {
            <span class="hljs-keyword">return</span> elm.nodeType == <span class="hljs-number">1</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-508">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-508">&#182;</a>
              </div>
              <p>Simple selector just elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (simpleSelectorRe.test(selector)) {
            selector = selector.toLowerCase().split(<span class="hljs-regexp">/,/</span>);
            elm = elm.nodeName.toLowerCase();

            <span class="hljs-keyword">for</span> (i = selector.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
              <span class="hljs-keyword">if</span> (selector[i] == elm) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              }
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-509">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-509">&#182;</a>
              </div>
              <p>Is non element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (elm.nodeType &amp;&amp; elm.nodeType != <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">var</span> elms = elm.nodeType ? [elm] : elm;

        <span class="hljs-comment">/*eslint new-cap:0 */</span>
        <span class="hljs-keyword">return</span> Sizzle(selector, elms[<span class="hljs-number">0</span>].ownerDocument || elms[<span class="hljs-number">0</span>], <span class="hljs-literal">null</span>, elms).length &gt; <span class="hljs-number">0</span>;
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-510">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-510">&#182;</a>
              </div>
              <p>#endif</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Adds the specified element to another element or elements.
       *
       * @method add
       * @param {String/Element/Array} parentElm Element id string, DOM node element or array of ids or elements to add to.
       * @param {String/Element} name Name of new element to add or existing element to add.
       * @param {Object} attrs Optional object collection with arguments to add to the new element(s).
       * @param {String} html Optional inner HTML contents to add for each element.
       * @param {Boolean} create Optional flag if the element should be created or added.
       * @return {Element/Array} Element that got created, or an array of created elements if multiple input elements
       * were passed in.
       * @example
       * // Adds a new paragraph to the end of the active editor
       * tinymce.activeEditor.dom.add(tinymce.activeEditor.getBody(), 'p', {title: 'my title'}, 'Some content');
       */</span>
      add: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parentElm, name, attrs, html, create</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.run(parentElm, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parentElm</span>) </span>{
          <span class="hljs-keyword">var</span> newElm;

          newElm = is(name, <span class="hljs-string">'string'</span>) ? self.doc.createElement(name) : name;
          self.setAttribs(newElm, attrs);

          <span class="hljs-keyword">if</span> (html) {
            <span class="hljs-keyword">if</span> (html.nodeType) {
              newElm.appendChild(html);
            } <span class="hljs-keyword">else</span> {
              self.setHTML(newElm, html);
            }
          }

          <span class="hljs-keyword">return</span> !create ? parentElm.appendChild(newElm) : newElm;
        });
      },

      <span class="hljs-comment">/**
       * Creates a new element.
       *
       * @method create
       * @param {String} name Name of new element.
       * @param {Object} attrs Optional object name/value collection with element attributes.
       * @param {String} html Optional HTML string to set as inner HTML of the element.
       * @return {Element} HTML DOM node element that got created.
       * @example
       * // Adds an element where the caret/selection is in the active editor
       * var el = tinymce.activeEditor.dom.create('div', {id: 'test', 'class': 'myclass'}, 'some content');
       * tinymce.activeEditor.selection.setNode(el);
       */</span>
      create: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, attrs, html</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.add(<span class="hljs-keyword">this</span>.doc.createElement(name), name, attrs, html, <span class="hljs-number">1</span>);
      },

      <span class="hljs-comment">/**
       * Creates HTML string for element. The element will be closed unless an empty inner HTML string is passed in.
       *
       * @method createHTML
       * @param {String} name Name of new element.
       * @param {Object} attrs Optional object name/value collection with element attributes.
       * @param {String} html Optional HTML string to set as inner HTML of the element.
       * @return {String} String with new HTML element, for example: &lt;a href="#"&gt;test&lt;/a&gt;.
       * @example
       * // Creates a html chunk and inserts it at the current selection/caret location
       * tinymce.activeEditor.selection.setContent(tinymce.activeEditor.dom.createHTML('a', {href: 'test.html'}, 'some line'));
       */</span>
      createHTML: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, attrs, html</span>) </span>{
        <span class="hljs-keyword">var</span> outHtml = <span class="hljs-string">''</span>, key;

        outHtml += <span class="hljs-string">'&lt;'</span> + name;

        <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> attrs) {
          <span class="hljs-keyword">if</span> (attrs.hasOwnProperty(key) &amp;&amp; attrs[key] !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> attrs[key] != <span class="hljs-string">'undefined'</span>) {
            outHtml += <span class="hljs-string">' '</span> + key + <span class="hljs-string">'="'</span> + <span class="hljs-keyword">this</span>.encode(attrs[key]) + <span class="hljs-string">'"'</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-511">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-511">&#182;</a>
              </div>
              <p>A call to tinymce.is doesnt work for some odd reason on IE9 possible bug inside their JS runtime</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> html != <span class="hljs-string">"undefined"</span>) {
          <span class="hljs-keyword">return</span> outHtml + <span class="hljs-string">'&gt;'</span> + html + <span class="hljs-string">'&lt;/'</span> + name + <span class="hljs-string">'&gt;'</span>;
        }

        <span class="hljs-keyword">return</span> outHtml + <span class="hljs-string">' /&gt;'</span>;
      },

      <span class="hljs-comment">/**
       * Creates a document fragment out of the specified HTML string.
       *
       * @method createFragment
       * @param {String} html Html string to create fragment from.
       * @return {DocumentFragment} Document fragment node.
       */</span>
      createFragment: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">html</span>) </span>{
        <span class="hljs-keyword">var</span> frag, node, doc = <span class="hljs-keyword">this</span>.doc, container;

        container = doc.createElement(<span class="hljs-string">"div"</span>);
        frag = doc.createDocumentFragment();

        <span class="hljs-keyword">if</span> (html) {
          container.innerHTML = html;
        }

        <span class="hljs-keyword">while</span> ((node = container.firstChild)) {
          frag.appendChild(node);
        }

        <span class="hljs-keyword">return</span> frag;
      },

      <span class="hljs-comment">/**
       * Removes/deletes the specified element(s) from the DOM.
       *
       * @method remove
       * @param {String/Element/Array} node ID of element or DOM element object or array containing multiple elements/ids.
       * @param {Boolean} keepChildren Optional state to keep children or not. If set to true all children will be
       * placed at the location of the removed element.
       * @return {Element/Array} HTML DOM element that got removed, or an array of removed elements if multiple input elements
       * were passed in.
       * @example
       * // Removes all paragraphs in the active editor
       * tinymce.activeEditor.dom.remove(tinymce.activeEditor.dom.select('p'));
       *
       * // Removes an element by id in the document
       * tinymce.DOM.remove('mydiv');
       */</span>
      remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, keepChildren</span>) </span>{
        node = <span class="hljs-keyword">this</span>.$$(node);

        <span class="hljs-keyword">if</span> (keepChildren) {
          node.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> child;

            <span class="hljs-keyword">while</span> ((child = <span class="hljs-keyword">this</span>.firstChild)) {
              <span class="hljs-keyword">if</span> (child.nodeType == <span class="hljs-number">3</span> &amp;&amp; child.data.length === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">this</span>.removeChild(child);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>.parentNode.insertBefore(child, <span class="hljs-keyword">this</span>);
              }
            }
          }).remove();
        } <span class="hljs-keyword">else</span> {
          node.remove();
        }

        <span class="hljs-keyword">return</span> node.length &gt; <span class="hljs-number">1</span> ? node.toArray() : node[<span class="hljs-number">0</span>];
      },

      <span class="hljs-comment">/**
       * Sets the CSS style value on a HTML element. The name can be a camelcase string
       * or the CSS style name like background-color.
       *
       * @method setStyle
       * @param {String/Element/Array} elm HTML element/Array of elements to set CSS style value on.
       * @param {String} name Name of the style value to set.
       * @param {String} value Value to set on the style.
       * @example
       * // Sets a style value on all paragraphs in the currently active editor
       * tinymce.activeEditor.dom.setStyle(tinymce.activeEditor.dom.select('p'), 'background-color', 'red');
       *
       * // Sets a style value to an element by id in the current document
       * tinymce.DOM.setStyle('mydiv', 'background-color', 'red');
       */</span>
      setStyle: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, name, value</span>) </span>{
        elm = <span class="hljs-keyword">this</span>.$$(elm).css(name, value);

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.settings.update_styles) {
          updateInternalStyleAttr(<span class="hljs-keyword">this</span>, elm);
        }
      },

      <span class="hljs-comment">/**
       * Returns the current style or runtime/computed value of an element.
       *
       * @method getStyle
       * @param {String/Element} elm HTML element or element id string to get style from.
       * @param {String} name Style name to return.
       * @param {Boolean} computed Computed style.
       * @return {String} Current style or computed style value of an element.
       */</span>
      getStyle: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, name, computed</span>) </span>{
        elm = <span class="hljs-keyword">this</span>.$$(elm);

        <span class="hljs-keyword">if</span> (computed) {
          <span class="hljs-keyword">return</span> elm.css(name);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-512">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-512">&#182;</a>
              </div>
              <p>Camelcase it, if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        name = name.replace(<span class="hljs-regexp">/-(\D)/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
          <span class="hljs-keyword">return</span> b.toUpperCase();
        });

        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">'float'</span>) {
          name = Env.ie &amp;&amp; Env.ie &lt; <span class="hljs-number">12</span> ? <span class="hljs-string">'styleFloat'</span> : <span class="hljs-string">'cssFloat'</span>;
        }

        <span class="hljs-keyword">return</span> elm[<span class="hljs-number">0</span>] &amp;&amp; elm[<span class="hljs-number">0</span>].style ? elm[<span class="hljs-number">0</span>].style[name] : <span class="hljs-literal">undefined</span>;
      },

      <span class="hljs-comment">/**
       * Sets multiple styles on the specified element(s).
       *
       * @method setStyles
       * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set styles on.
       * @param {Object} styles Name/Value collection of style items to add to the element(s).
       * @example
       * // Sets styles on all paragraphs in the currently active editor
       * tinymce.activeEditor.dom.setStyles(tinymce.activeEditor.dom.select('p'), {'background-color': 'red', 'color': 'green'});
       *
       * // Sets styles to an element by id in the current document
       * tinymce.DOM.setStyles('mydiv', {'background-color': 'red', 'color': 'green'});
       */</span>
      setStyles: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, styles</span>) </span>{
        elm = <span class="hljs-keyword">this</span>.$$(elm).css(styles);

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.settings.update_styles) {
          updateInternalStyleAttr(<span class="hljs-keyword">this</span>, elm);
        }
      },

      <span class="hljs-comment">/**
       * Removes all attributes from an element or elements.
       *
       * @method removeAllAttribs
       * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to remove attributes from.
       */</span>
      removeAllAttribs: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.run(e, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> i, attrs = e.attributes;
          <span class="hljs-keyword">for</span> (i = attrs.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            e.removeAttributeNode(attrs.item(i));
          }
        });
      },

      <span class="hljs-comment">/**
       * Sets the specified attribute of an element or elements.
       *
       * @method setAttrib
       * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set attribute on.
       * @param {String} name Name of attribute to set.
       * @param {String} value Value to set on the attribute - if this value is falsy like null, 0 or '' it will remove
       * the attribute instead.
       * @example
       * // Sets class attribute on all paragraphs in the active editor
       * tinymce.activeEditor.dom.setAttrib(tinymce.activeEditor.dom.select('p'), 'class', 'myclass');
       *
       * // Sets class attribute on a specific element in the current page
       * tinymce.dom.setAttrib('mydiv', 'class', 'myclass');
       */</span>
      setAttrib: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, name, value</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, originalValue, hook, settings = self.settings;

        <span class="hljs-keyword">if</span> (value === <span class="hljs-string">''</span>) {
          value = <span class="hljs-literal">null</span>;
        }

        elm = self.$$(elm);
        originalValue = elm.attr(name);

        <span class="hljs-keyword">if</span> (!elm.length) {
          <span class="hljs-keyword">return</span>;
        }

        hook = self.attrHooks[name];
        <span class="hljs-keyword">if</span> (hook &amp;&amp; hook.set) {
          hook.set(elm, value, name);
        } <span class="hljs-keyword">else</span> {
          elm.attr(name, value);
        }

        <span class="hljs-keyword">if</span> (originalValue != value &amp;&amp; settings.onSetAttrib) {
          settings.onSetAttrib({
            <span class="hljs-attr">attrElm</span>: elm,
            <span class="hljs-attr">attrName</span>: name,
            <span class="hljs-attr">attrValue</span>: value
          });
        }
      },

      <span class="hljs-comment">/**
       * Sets two or more specified attributes of an element or elements.
       *
       * @method setAttribs
       * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set attributes on.
       * @param {Object} attrs Name/Value collection of attribute items to add to the element(s).
       * @example
       * // Sets class and title attributes on all paragraphs in the active editor
       * tinymce.activeEditor.dom.setAttribs(tinymce.activeEditor.dom.select('p'), {'class': 'myclass', title: 'some title'});
       *
       * // Sets class and title attributes on a specific element in the current page
       * tinymce.DOM.setAttribs('mydiv', {'class': 'myclass', title: 'some title'});
       */</span>
      setAttribs: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, attrs</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.$$(elm).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i, node</span>) </span>{
          each(attrs, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, name</span>) </span>{
            self.setAttrib(node, name, value);
          });
        });
      },

      <span class="hljs-comment">/**
       * Returns the specified attribute by name.
       *
       * @method getAttrib
       * @param {String/Element} elm Element string id or DOM element to get attribute from.
       * @param {String} name Name of attribute to get.
       * @param {String} defaultVal Optional default value to return if the attribute didn't exist.
       * @return {String} Attribute value string, default value or null if the attribute wasn't found.
       */</span>
      getAttrib: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, name, defaultVal</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, hook, value;

        elm = self.$$(elm);

        <span class="hljs-keyword">if</span> (elm.length) {
          hook = self.attrHooks[name];

          <span class="hljs-keyword">if</span> (hook &amp;&amp; hook.get) {
            value = hook.get(elm, name);
          } <span class="hljs-keyword">else</span> {
            value = elm.attr(name);
          }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'undefined'</span>) {
          value = defaultVal || <span class="hljs-string">''</span>;
        }

        <span class="hljs-keyword">return</span> value;
      },

      <span class="hljs-comment">/**
       * Returns the absolute x, y position of a node. The position will be returned in an object with x, y fields.
       *
       * @method getPos
       * @param {Element/String} elm HTML element or element id to get x, y position from.
       * @param {Element} rootElm Optional root element to stop calculations at.
       * @return {object} Absolute position of the specified element object with x, y fields.
       */</span>
      getPos: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, rootElm</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, offsetParent, doc = self.doc, body = doc.body, pos;

        elm = self.get(elm);
        rootElm = rootElm || body;

        <span class="hljs-keyword">if</span> (elm) {</pre></div></div>
            
        </li>
        
        
        <li id="section-513">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-513">&#182;</a>
              </div>
              <p>Use getBoundingClientRect if it exists since its faster than looping offset nodes
Fallback to offsetParent calculations if the body isnt static better since it stops at the body root</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (rootElm === body &amp;&amp; elm.getBoundingClientRect &amp;&amp; DomQuery(body).css(<span class="hljs-string">'position'</span>) === <span class="hljs-string">'static'</span>) {
            pos = elm.getBoundingClientRect();
            rootElm = self.boxModel ? doc.documentElement : body;</pre></div></div>
            
        </li>
        
        
        <li id="section-514">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-514">&#182;</a>
              </div>
              <p>Add scroll offsets from documentElement or body since IE with the wrong box model will use d.body and so do WebKit
Also remove the body/documentelement clientTop/clientLeft on IE 6, 7 since they offset the position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - rootElm.clientLeft;
            y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - rootElm.clientTop;

            <span class="hljs-keyword">return</span> { <span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y };
          }

          offsetParent = elm;
          <span class="hljs-keyword">while</span> (offsetParent &amp;&amp; offsetParent != rootElm &amp;&amp; offsetParent.nodeType) {
            x += offsetParent.offsetLeft || <span class="hljs-number">0</span>;
            y += offsetParent.offsetTop || <span class="hljs-number">0</span>;
            offsetParent = offsetParent.offsetParent;
          }

          offsetParent = elm.parentNode;
          <span class="hljs-keyword">while</span> (offsetParent &amp;&amp; offsetParent != rootElm &amp;&amp; offsetParent.nodeType) {
            x -= offsetParent.scrollLeft || <span class="hljs-number">0</span>;
            y -= offsetParent.scrollTop || <span class="hljs-number">0</span>;
            offsetParent = offsetParent.parentNode;
          }
        }

        <span class="hljs-keyword">return</span> { <span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y };
      },

      <span class="hljs-comment">/**
       * Parses the specified style value into an object collection. This parser will also
       * merge and remove any redundant items that browsers might have added. It will also convert non-hex
       * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.
       *
       * @method parseStyle
       * @param {String} cssText Style value to parse, for example: border:1px solid red;.
       * @return {Object} Object representation of that style, for example: {border: '1px solid red'}
       */</span>
      parseStyle: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cssText</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.styles.parse(cssText);
      },

      <span class="hljs-comment">/**
       * Serializes the specified style object into a string.
       *
       * @method serializeStyle
       * @param {Object} styles Object to serialize as string, for example: {border: '1px solid red'}
       * @param {String} name Optional element name.
       * @return {String} String representation of the style object, for example: border: 1px solid red.
       */</span>
      serializeStyle: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">styles, name</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.styles.serialize(styles, name);
      },

      <span class="hljs-comment">/**
       * Adds a style element at the top of the document with the specified cssText content.
       *
       * @method addStyle
       * @param {String} cssText CSS Text style to add to top of head of document.
       */</span>
      addStyle: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cssText</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, doc = self.doc, head, styleElm;</pre></div></div>
            
        </li>
        
        
        <li id="section-515">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-515">&#182;</a>
              </div>
              <p>Prevent inline from loading the same styles twice</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self !== DOMUtils.DOM &amp;&amp; doc === <span class="hljs-built_in">document</span>) {
          <span class="hljs-keyword">var</span> addedStyles = DOMUtils.DOM.addedStyles;

          addedStyles = addedStyles || [];
          <span class="hljs-keyword">if</span> (addedStyles[cssText]) {
            <span class="hljs-keyword">return</span>;
          }

          addedStyles[cssText] = <span class="hljs-literal">true</span>;
          DOMUtils.DOM.addedStyles = addedStyles;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-516">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-516">&#182;</a>
              </div>
              <p>Create style element if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        styleElm = doc.getElementById(<span class="hljs-string">'mceDefaultStyles'</span>);
        <span class="hljs-keyword">if</span> (!styleElm) {
          styleElm = doc.createElement(<span class="hljs-string">'style'</span>);
          styleElm.id = <span class="hljs-string">'mceDefaultStyles'</span>;
          styleElm.type = <span class="hljs-string">'text/css'</span>;

          head = doc.getElementsByTagName(<span class="hljs-string">'head'</span>)[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">if</span> (head.firstChild) {
            head.insertBefore(styleElm, head.firstChild);
          } <span class="hljs-keyword">else</span> {
            head.appendChild(styleElm);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-517">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-517">&#182;</a>
              </div>
              <p>Append style data to old or new style element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (styleElm.styleSheet) {
          styleElm.styleSheet.cssText += cssText;
        } <span class="hljs-keyword">else</span> {
          styleElm.appendChild(doc.createTextNode(cssText));
        }
      },

      <span class="hljs-comment">/**
       * Imports/loads the specified CSS file into the document bound to the class.
       *
       * @method loadCSS
       * @param {String} url URL to CSS file to load.
       * @example
       * // Loads a CSS file dynamically into the current document
       * tinymce.DOM.loadCSS('somepath/some.css');
       *
       * // Loads a CSS file into the currently active editor instance
       * tinymce.activeEditor.dom.loadCSS('somepath/some.css');
       *
       * // Loads a CSS file into an editor instance by id
       * tinymce.get('someid').dom.loadCSS('somepath/some.css');
       *
       * // Loads multiple CSS files into the current document
       * tinymce.DOM.loadCSS('somepath/some.css,somepath/someother.css');
       */</span>
      loadCSS: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, doc = self.doc, head;</pre></div></div>
            
        </li>
        
        
        <li id="section-518">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-518">&#182;</a>
              </div>
              <p>Prevent inline from loading the same CSS file twice</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self !== DOMUtils.DOM &amp;&amp; doc === <span class="hljs-built_in">document</span>) {
          DOMUtils.DOM.loadCSS(url);
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (!url) {
          url = <span class="hljs-string">''</span>;
        }

        head = doc.getElementsByTagName(<span class="hljs-string">'head'</span>)[<span class="hljs-number">0</span>];

        each(url.split(<span class="hljs-string">','</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
          <span class="hljs-keyword">var</span> link;

          url = Tools._addCacheSuffix(url);

          <span class="hljs-keyword">if</span> (self.files[url]) {
            <span class="hljs-keyword">return</span>;
          }

          self.files[url] = <span class="hljs-literal">true</span>;
          link = self.create(<span class="hljs-string">'link'</span>, { <span class="hljs-attr">rel</span>: <span class="hljs-string">'stylesheet'</span>, <span class="hljs-attr">href</span>: url });</pre></div></div>
            
        </li>
        
        
        <li id="section-519">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-519">&#182;</a>
              </div>
              <p>IE 8 has a bug where dynamically loading stylesheets would produce a 1 item remaining bug
This fix seems to resolve that issue by recalcing the document once a stylesheet finishes loading
Its ugly but it seems to work fine.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (isIE &amp;&amp; doc.documentMode &amp;&amp; doc.recalc) {
            link.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">if</span> (doc.recalc) {
                doc.recalc();
              }

              link.onload = <span class="hljs-literal">null</span>;
            };
          }

          head.appendChild(link);
        });
      },

      <span class="hljs-comment">/**
       * Adds a class to the specified element or elements.
       *
       * @method addClass
       * @param {String/Element/Array} elm Element ID string or DOM element or array with elements or IDs.
       * @param {String} cls Class name to add to each element.
       * @return {String/Array} String with new class value or array with new class values for all elements.
       * @example
       * // Adds a class to all paragraphs in the active editor
       * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'myclass');
       *
       * // Adds a class to a specific element in the current page
       * tinymce.DOM.addClass('mydiv', 'myclass');
       */</span>
      addClass: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, cls</span>) </span>{
        <span class="hljs-keyword">this</span>.$$(elm).addClass(cls);
      },

      <span class="hljs-comment">/**
       * Removes a class from the specified element or elements.
       *
       * @method removeClass
       * @param {String/Element/Array} elm Element ID string or DOM element or array with elements or IDs.
       * @param {String} cls Class name to remove from each element.
       * @return {String/Array} String of remaining class name(s), or an array of strings if multiple input elements
       * were passed in.
       * @example
       * // Removes a class from all paragraphs in the active editor
       * tinymce.activeEditor.dom.removeClass(tinymce.activeEditor.dom.select('p'), 'myclass');
       *
       * // Removes a class from a specific element in the current page
       * tinymce.DOM.removeClass('mydiv', 'myclass');
       */</span>
      removeClass: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, cls</span>) </span>{
        <span class="hljs-keyword">this</span>.toggleClass(elm, cls, <span class="hljs-literal">false</span>);
      },

      <span class="hljs-comment">/**
       * Returns true if the specified element has the specified class.
       *
       * @method hasClass
       * @param {String/Element} elm HTML element or element id string to check CSS class on.
       * @param {String} cls CSS class to check for.
       * @return {Boolean} true/false if the specified element has the specified class.
       */</span>
      hasClass: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, cls</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$$(elm).hasClass(cls);
      },

      <span class="hljs-comment">/**
       * Toggles the specified class on/off.
       *
       * @method toggleClass
       * @param {Element} elm Element to toggle class on.
       * @param {[type]} cls Class to toggle on/off.
       * @param {[type]} state Optional state to set.
       */</span>
      toggleClass: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, cls, state</span>) </span>{
        <span class="hljs-keyword">this</span>.$$(elm).toggleClass(cls, state).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.className === <span class="hljs-string">''</span>) {
            DomQuery(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'class'</span>, <span class="hljs-literal">null</span>);
          }
        });
      },

      <span class="hljs-comment">/**
       * Shows the specified element(s) by ID by setting the "display" style.
       *
       * @method show
       * @param {String/Element/Array} elm ID of DOM element or DOM element or array with elements or IDs to show.
       */</span>
      show: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">this</span>.$$(elm).show();
      },

      <span class="hljs-comment">/**
       * Hides the specified element(s) by ID by setting the "display" style.
       *
       * @method hide
       * @param {String/Element/Array} elm ID of DOM element or DOM element or array with elements or IDs to hide.
       * @example
       * // Hides an element by id in the document
       * tinymce.DOM.hide('myid');
       */</span>
      hide: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">this</span>.$$(elm).hide();
      },

      <span class="hljs-comment">/**
       * Returns true/false if the element is hidden or not by checking the "display" style.
       *
       * @method isHidden
       * @param {String/Element} elm Id or element to check display state on.
       * @return {Boolean} true/false if the element is hidden or not.
       */</span>
      isHidden: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$$(elm).css(<span class="hljs-string">'display'</span>) == <span class="hljs-string">'none'</span>;
      },

      <span class="hljs-comment">/**
       * Returns a unique id. This can be useful when generating elements on the fly.
       * This method will not check if the element already exists.
       *
       * @method uniqueId
       * @param {String} prefix Optional prefix to add in front of all ids - defaults to "mce_".
       * @return {String} Unique id.
       */</span>
      uniqueId: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prefix</span>) </span>{
        <span class="hljs-keyword">return</span> (!prefix ? <span class="hljs-string">'mce_'</span> : prefix) + (<span class="hljs-keyword">this</span>.counter++);
      },

      <span class="hljs-comment">/**
       * Sets the specified HTML content inside the element or elements. The HTML will first be processed. This means
       * URLs will get converted, hex color values fixed etc. Check processHTML for details.
       *
       * @method setHTML
       * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set HTML inside of.
       * @param {String} html HTML content to set as inner HTML of the element.
       * @example
       * // Sets the inner HTML of all paragraphs in the active editor
       * tinymce.activeEditor.dom.setHTML(tinymce.activeEditor.dom.select('p'), 'some inner html');
       *
       * // Sets the inner HTML of an element by id in the document
       * tinymce.DOM.setHTML('mydiv', 'some inner html');
       */</span>
      setHTML: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, html</span>) </span>{
        elm = <span class="hljs-keyword">this</span>.$$(elm);

        <span class="hljs-keyword">if</span> (isIE) {
          elm.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i, target</span>) </span>{
            <span class="hljs-keyword">if</span> (target.canHaveHTML === <span class="hljs-literal">false</span>) {
              <span class="hljs-keyword">return</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-520">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-520">&#182;</a>
              </div>
              <p>Remove all child nodes, IE keeps empty text nodes in DOM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">while</span> (target.firstChild) {
              target.removeChild(target.firstChild);
            }

            <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-521">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-521">&#182;</a>
              </div>
              <p>IE will remove comments from the beginning
unless you padd the contents with something</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              target.innerHTML = <span class="hljs-string">'&lt;br&gt;'</span> + html;
              target.removeChild(target.firstChild);
            } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-522">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-522">&#182;</a>
              </div>
              <p>IE sometimes produces an unknown runtime error on innerHTML if its a div inside a p</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              DomQuery(<span class="hljs-string">'&lt;div&gt;&lt;/div&gt;'</span>).html(<span class="hljs-string">'&lt;br&gt;'</span> + html).contents().slice(<span class="hljs-number">1</span>).appendTo(target);
            }

            <span class="hljs-keyword">return</span> html;
          });
        } <span class="hljs-keyword">else</span> {
          elm.html(html);
        }
      },

      <span class="hljs-comment">/**
       * Returns the outer HTML of an element.
       *
       * @method getOuterHTML
       * @param {String/Element} elm Element ID or element object to get outer HTML from.
       * @return {String} Outer HTML string.
       * @example
       * tinymce.DOM.getOuterHTML(editorElement);
       * tinymce.activeEditor.getOuterHTML(tinymce.activeEditor.getBody());
       */</span>
      getOuterHTML: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        elm = <span class="hljs-keyword">this</span>.get(elm);</pre></div></div>
            
        </li>
        
        
        <li id="section-523">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-523">&#182;</a>
              </div>
              <p>Older FF doesnt have outerHTML 3.6 is still used by some orgaizations</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> elm.nodeType == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-string">"outerHTML"</span> <span class="hljs-keyword">in</span> elm ? elm.outerHTML : DomQuery(<span class="hljs-string">'&lt;div&gt;&lt;/div&gt;'</span>).append(DomQuery(elm).clone()).html();
      },

      <span class="hljs-comment">/**
       * Sets the specified outer HTML on an element or elements.
       *
       * @method setOuterHTML
       * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set outer HTML on.
       * @param {Object} html HTML code to set as outer value for the element.
       * @example
       * // Sets the outer HTML of all paragraphs in the active editor
       * tinymce.activeEditor.dom.setOuterHTML(tinymce.activeEditor.dom.select('p'), '&lt;div&gt;some html&lt;/div&gt;');
       *
       * // Sets the outer HTML of an element by id in the document
       * tinymce.DOM.setOuterHTML('mydiv', '&lt;div&gt;some html&lt;/div&gt;');
       */</span>
      setOuterHTML: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, html</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.$$(elm).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-524">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-524">&#182;</a>
              </div>
              <p>Older FF doesnt have outerHTML 3.6 is still used by some organizations</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-string">"outerHTML"</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) {
              <span class="hljs-keyword">this</span>.outerHTML = html;
              <span class="hljs-keyword">return</span>;
            }
          } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-525">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-525">&#182;</a>
              </div>
              <p>Ignore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          }</pre></div></div>
            
        </li>
        
        
        <li id="section-526">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-526">&#182;</a>
              </div>
              <p>OuterHTML for IE it sometimes produces an unknown runtime error</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          self.remove(DomQuery(<span class="hljs-keyword">this</span>).html(html), <span class="hljs-literal">true</span>);
        });
      },

      <span class="hljs-comment">/**
       * Entity decodes a string. This method decodes any HTML entities, such as &amp;aring;.
       *
       * @method decode
       * @param {String} s String to decode entities on.
       * @return {String} Entity decoded string.
       */</span>
      decode: Entities.decode,

      <span class="hljs-comment">/**
       * Entity encodes a string. This method encodes the most common entities, such as &lt;&gt;"&amp;.
       *
       * @method encode
       * @param {String} text String to encode with entities.
       * @return {String} Entity encoded string.
       */</span>
      encode: Entities.encodeAllRaw,

      <span class="hljs-comment">/**
       * Inserts an element after the reference element.
       *
       * @method insertAfter
       * @param {Element} node Element to insert after the reference.
       * @param {Element/String/Array} referenceNode Reference element, element id or array of elements to insert after.
       * @return {Element/Array} Element that got added or an array with elements.
       */</span>
      insertAfter: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, referenceNode</span>) </span>{
        referenceNode = <span class="hljs-keyword">this</span>.get(referenceNode);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.run(node, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> parent, nextSibling;

          parent = referenceNode.parentNode;
          nextSibling = referenceNode.nextSibling;

          <span class="hljs-keyword">if</span> (nextSibling) {
            parent.insertBefore(node, nextSibling);
          } <span class="hljs-keyword">else</span> {
            parent.appendChild(node);
          }

          <span class="hljs-keyword">return</span> node;
        });
      },

      <span class="hljs-comment">/**
       * Replaces the specified element or elements with the new element specified. The new element will
       * be cloned if multiple input elements are passed in.
       *
       * @method replace
       * @param {Element} newElm New element to replace old ones with.
       * @param {Element/String/Array} oldElm Element DOM node, element id or array of elements or ids to replace.
       * @param {Boolean} keepChildren Optional keep children state, if set to true child nodes from the old object will be added
       * to new ones.
       */</span>
      replace: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newElm, oldElm, keepChildren</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">return</span> self.run(oldElm, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">oldElm</span>) </span>{
          <span class="hljs-keyword">if</span> (is(oldElm, <span class="hljs-string">'array'</span>)) {
            newElm = newElm.cloneNode(<span class="hljs-literal">true</span>);
          }

          <span class="hljs-keyword">if</span> (keepChildren) {
            each(grep(oldElm.childNodes), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
              newElm.appendChild(node);
            });
          }

          <span class="hljs-keyword">return</span> oldElm.parentNode.replaceChild(newElm, oldElm);
        });
      },

      <span class="hljs-comment">/**
       * Renames the specified element and keeps its attributes and children.
       *
       * @method rename
       * @param {Element} elm Element to rename.
       * @param {String} name Name of the new element.
       * @return {Element} New element or the old element if it needed renaming.
       */</span>
      rename: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, name</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, newElm;

        <span class="hljs-keyword">if</span> (elm.nodeName != name.toUpperCase()) {</pre></div></div>
            
        </li>
        
        
        <li id="section-527">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-527">&#182;</a>
              </div>
              <p>Rename block element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          newElm = self.create(name);</pre></div></div>
            
        </li>
        
        
        <li id="section-528">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-528">&#182;</a>
              </div>
              <p>Copy attribs to new block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          each(self.getAttribs(elm), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">attrNode</span>) </span>{
            self.setAttrib(newElm, attrNode.nodeName, self.getAttrib(elm, attrNode.nodeName));
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-529">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-529">&#182;</a>
              </div>
              <p>Replace block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          self.replace(newElm, elm, <span class="hljs-number">1</span>);
        }

        <span class="hljs-keyword">return</span> newElm || elm;
      },

      <span class="hljs-comment">/**
       * Find the common ancestor of two elements. This is a shorter method than using the DOM Range logic.
       *
       * @method findCommonAncestor
       * @param {Element} a Element to find common ancestor of.
       * @param {Element} b Element to find common ancestor of.
       * @return {Element} Common ancestor element of the two input elements.
       */</span>
      findCommonAncestor: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
        <span class="hljs-keyword">var</span> ps = a, pe;

        <span class="hljs-keyword">while</span> (ps) {
          pe = b;

          <span class="hljs-keyword">while</span> (pe &amp;&amp; ps != pe) {
            pe = pe.parentNode;
          }

          <span class="hljs-keyword">if</span> (ps == pe) {
            <span class="hljs-keyword">break</span>;
          }

          ps = ps.parentNode;
        }

        <span class="hljs-keyword">if</span> (!ps &amp;&amp; a.ownerDocument) {
          <span class="hljs-keyword">return</span> a.ownerDocument.documentElement;
        }

        <span class="hljs-keyword">return</span> ps;
      },

      <span class="hljs-comment">/**
       * Parses the specified RGB color value and returns a hex version of that color.
       *
       * @method toHex
       * @param {String} rgbVal RGB string value like rgb(1,2,3)
       * @return {String} Hex version of that RGB value like #FF00FF.
       */</span>
      toHex: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rgbVal</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.styles.toHex(Tools.trim(rgbVal));
      },

      <span class="hljs-comment">/**
       * Executes the specified function on the element by id or dom element node or array of elements/id.
       *
       * @method run
       * @param {String/Element/Array} elm ID or DOM element object or array with ids or elements.
       * @param {function} func Function to execute for each item.
       * @param {Object} scope Optional scope to execute the function in.
       * @return {Object/Array} Single object, or an array of objects if multiple input elements were passed in.
       */</span>
      run: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, func, scope</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, result;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> elm === <span class="hljs-string">'string'</span>) {
          elm = self.get(elm);
        }

        <span class="hljs-keyword">if</span> (!elm) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        scope = scope || <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">if</span> (!elm.nodeType &amp;&amp; (elm.length || elm.length === <span class="hljs-number">0</span>)) {
          result = [];

          each(elm, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, i</span>) </span>{
            <span class="hljs-keyword">if</span> (elm) {
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> elm == <span class="hljs-string">'string'</span>) {
                elm = self.get(elm);
              }

              result.push(func.call(scope, elm, i));
            }
          });

          <span class="hljs-keyword">return</span> result;
        }

        <span class="hljs-keyword">return</span> func.call(scope, elm);
      },

      <span class="hljs-comment">/**
       * Returns a NodeList with attributes for the element.
       *
       * @method getAttribs
       * @param {HTMLElement/string} elm Element node or string id to get attributes from.
       * @return {NodeList} NodeList with attributes.
       */</span>
      getAttribs: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">var</span> attrs;

        elm = <span class="hljs-keyword">this</span>.get(elm);

        <span class="hljs-keyword">if</span> (!elm) {
          <span class="hljs-keyword">return</span> [];
        }

        <span class="hljs-keyword">if</span> (isIE) {
          attrs = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-530">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-530">&#182;</a>
              </div>
              <p>Object will throw exception in IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (elm.nodeName == <span class="hljs-string">'OBJECT'</span>) {
            <span class="hljs-keyword">return</span> elm.attributes;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-531">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-531">&#182;</a>
              </div>
              <p>IE doesnt keep the selected attribute if you clone option elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (elm.nodeName === <span class="hljs-string">'OPTION'</span> &amp;&amp; <span class="hljs-keyword">this</span>.getAttrib(elm, <span class="hljs-string">'selected'</span>)) {
            attrs.push({ <span class="hljs-attr">specified</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">nodeName</span>: <span class="hljs-string">'selected'</span> });
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-532">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-532">&#182;</a>
              </div>
              <p>Its crazy that this is faster in IE but its because it returns all attributes all the time</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> attrRegExp = <span class="hljs-regexp">/&lt;\/?[\w:\-]+ ?|=[\"][^\"]+\"|=\'[^\']+\'|=[\w\-]+|&gt;/gi</span>;
          elm.cloneNode(<span class="hljs-literal">false</span>).outerHTML.replace(attrRegExp, <span class="hljs-string">''</span>).replace(<span class="hljs-regexp">/[\w:\-]+/gi</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
            attrs.push({ <span class="hljs-attr">specified</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">nodeName</span>: a });
          });

          <span class="hljs-keyword">return</span> attrs;
        }

        <span class="hljs-keyword">return</span> elm.attributes;
      },

      <span class="hljs-comment">/**
       * Returns true/false if the specified node is to be considered empty or not.
       *
       * @example
       * tinymce.DOM.isEmpty(node, {img: true});
       * @method isEmpty
       * @param {Object} elements Optional name/value object with elements that are automatically treated as non-empty elements.
       * @return {Boolean} true/false if the node is empty or not.
       */</span>
      isEmpty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, elements</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, i, attributes, type, whitespace, walker, name, brCount = <span class="hljs-number">0</span>;

        node = node.firstChild;
        <span class="hljs-keyword">if</span> (node) {
          walker = <span class="hljs-keyword">new</span> TreeWalker(node, node.parentNode);
          elements = elements || (self.schema ? self.schema.getNonEmptyElements() : <span class="hljs-literal">null</span>);
          whitespace = self.schema ? self.schema.getWhiteSpaceElements() : {};

          <span class="hljs-keyword">do</span> {
            type = node.nodeType;

            <span class="hljs-keyword">if</span> (type === <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-533">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-533">&#182;</a>
              </div>
              <p>Ignore bogus elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> bogusVal = node.getAttribute(<span class="hljs-string">'data-mce-bogus'</span>);
              <span class="hljs-keyword">if</span> (bogusVal) {
                node = walker.next(bogusVal === <span class="hljs-string">'all'</span>);
                <span class="hljs-keyword">continue</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-534">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-534">&#182;</a>
              </div>
              <p>Keep empty elements like <img /></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              name = node.nodeName.toLowerCase();
              <span class="hljs-keyword">if</span> (elements &amp;&amp; elements[name]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-535">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-535">&#182;</a>
              </div>
              <p>Ignore single BR elements in blocks like <p><br /></p> or <p><span><br /></span></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'br'</span>) {
                  brCount++;
                  node = walker.next();
                  <span class="hljs-keyword">continue</span>;
                }

                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-536">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-536">&#182;</a>
              </div>
              <p>Keep elements with data-bookmark attributes or name attribute like <a name="1"></a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              attributes = self.getAttribs(node);
              i = attributes.length;
              <span class="hljs-keyword">while</span> (i--) {
                name = attributes[i].nodeName;
                <span class="hljs-keyword">if</span> (name === <span class="hljs-string">"name"</span> || name === <span class="hljs-string">'data-mce-bookmark'</span>) {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-537">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-537">&#182;</a>
              </div>
              <p>Keep comment nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (type == <span class="hljs-number">8</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-538">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-538">&#182;</a>
              </div>
              <p>Keep non whitespace text nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (type === <span class="hljs-number">3</span> &amp;&amp; !whiteSpaceRegExp.test(node.nodeValue)) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-539">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-539">&#182;</a>
              </div>
              <p>Keep whitespace preserve elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (type === <span class="hljs-number">3</span> &amp;&amp; node.parentNode &amp;&amp; whitespace[node.parentNode.nodeName] &amp;&amp; whiteSpaceRegExp.test(node.nodeValue)) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            node = walker.next();
          } <span class="hljs-keyword">while</span> (node);
        }

        <span class="hljs-keyword">return</span> brCount &lt;= <span class="hljs-number">1</span>;
      },

      <span class="hljs-comment">/**
       * Creates a new DOM Range object. This will use the native DOM Range API if it's
       * available. If it's not, it will fall back to the custom TinyMCE implementation.
       *
       * @method createRng
       * @return {DOMRange} DOM Range object.
       * @example
       * var rng = tinymce.DOM.createRng();
       * alert(rng.startContainer + "," + rng.startOffset);
       */</span>
      createRng: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> doc = <span class="hljs-keyword">this</span>.doc;

        <span class="hljs-keyword">return</span> doc.createRange ? doc.createRange() : <span class="hljs-keyword">new</span> Range(<span class="hljs-keyword">this</span>);
      },

      <span class="hljs-comment">/**
       * Returns the index of the specified node within its parent.
       *
       * @method nodeIndex
       * @param {Node} node Node to look for.
       * @param {boolean} normalized Optional true/false state if the index is what it would be after a normalization.
       * @return {Number} Index of the specified node.
       */</span>
      nodeIndex: nodeIndex,

      <span class="hljs-comment">/**
       * Splits an element into two new elements and places the specified split
       * element or elements between the new ones. For example splitting the paragraph at the bold element in
       * this example &lt;p&gt;abc&lt;b&gt;abc&lt;/b&gt;123&lt;/p&gt; would produce &lt;p&gt;abc&lt;/p&gt;&lt;b&gt;abc&lt;/b&gt;&lt;p&gt;123&lt;/p&gt;.
       *
       * @method split
       * @param {Element} parentElm Parent element to split.
       * @param {Element} splitElm Element to split at.
       * @param {Element} replacementElm Optional replacement element to replace the split element with.
       * @return {Element} Returns the split element or the replacement element if that is specified.
       */</span>
      split: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parentElm, splitElm, replacementElm</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, r = self.createRng(), bef, aft, pa;</pre></div></div>
            
        </li>
        
        
        <li id="section-540">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-540">&#182;</a>
              </div>
              <p>W3C valid browsers tend to leave empty nodes to the left/right side of the contents - this makes sense
but we dont want that in our code since it serves no purpose for the end user
For example splitting this html at the bold element:
  <p>text 1<span><b>CHOP</b></span>text 2</p>
would produce:
  <p>text 1<span></span></p><b>CHOP</b><p><span></span>text 2</p>
this function will then trim off empty edges and produce:
  <p>text 1</p><b>CHOP</b><p>text 2</p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimNode</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> i, children = node.childNodes, type = node.nodeType;

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">surroundedBySpans</span>(<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">var</span> previousIsSpan = node.previousSibling &amp;&amp; node.previousSibling.nodeName == <span class="hljs-string">'SPAN'</span>;
            <span class="hljs-keyword">var</span> nextIsSpan = node.nextSibling &amp;&amp; node.nextSibling.nodeName == <span class="hljs-string">'SPAN'</span>;
            <span class="hljs-keyword">return</span> previousIsSpan &amp;&amp; nextIsSpan;
          }

          <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span> &amp;&amp; node.getAttribute(<span class="hljs-string">'data-mce-type'</span>) == <span class="hljs-string">'bookmark'</span>) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">for</span> (i = children.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            trimNode(children[i]);
          }

          <span class="hljs-keyword">if</span> (type != <span class="hljs-number">9</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-541">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-541">&#182;</a>
              </div>
              <p>Keep non whitespace text nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (type == <span class="hljs-number">3</span> &amp;&amp; node.nodeValue.length &gt; <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-542">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-542">&#182;</a>
              </div>
              <p>If parent element isnt a block or there isnt any useful contents for example <p>   </p>
Also keep text nodes with only spaces if surrounded by spans.
eg. <p><span>a</span> <span>b</span></p> should keep space between a and b</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> trimmedLength = trim(node.nodeValue).length;
              <span class="hljs-keyword">if</span> (!self.isBlock(node.parentNode) || trimmedLength &gt; <span class="hljs-number">0</span> || trimmedLength === <span class="hljs-number">0</span> &amp;&amp; surroundedBySpans(node)) {
                <span class="hljs-keyword">return</span>;
              }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-543">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-543">&#182;</a>
              </div>
              <p>If the only child is a bookmark then move it up</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              children = node.childNodes;</pre></div></div>
            
        </li>
        
        
        <li id="section-544">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-544">&#182;</a>
              </div>
              <p>TODO fix this complex if</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (children.length == <span class="hljs-number">1</span> &amp;&amp; children[<span class="hljs-number">0</span>] &amp;&amp; children[<span class="hljs-number">0</span>].nodeType == <span class="hljs-number">1</span> &amp;&amp;
                children[<span class="hljs-number">0</span>].getAttribute(<span class="hljs-string">'data-mce-type'</span>) == <span class="hljs-string">'bookmark'</span>) {
                node.parentNode.insertBefore(children[<span class="hljs-number">0</span>], node);
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-545">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-545">&#182;</a>
              </div>
              <p>Keep non empty elements or img, hr etc</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (children.length || <span class="hljs-regexp">/^(br|hr|input|img)$/i</span>.test(node.nodeName)) {
                <span class="hljs-keyword">return</span>;
              }
            }

            self.remove(node);
          }

          <span class="hljs-keyword">return</span> node;
        }

        <span class="hljs-keyword">if</span> (parentElm &amp;&amp; splitElm) {</pre></div></div>
            
        </li>
        
        
        <li id="section-546">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-546">&#182;</a>
              </div>
              <p>Get before chunk</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          r.setStart(parentElm.parentNode, self.nodeIndex(parentElm));
          r.setEnd(splitElm.parentNode, self.nodeIndex(splitElm));
          bef = r.extractContents();</pre></div></div>
            
        </li>
        
        
        <li id="section-547">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-547">&#182;</a>
              </div>
              <p>Get after chunk</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          r = self.createRng();
          r.setStart(splitElm.parentNode, self.nodeIndex(splitElm) + <span class="hljs-number">1</span>);
          r.setEnd(parentElm.parentNode, self.nodeIndex(parentElm) + <span class="hljs-number">1</span>);
          aft = r.extractContents();</pre></div></div>
            
        </li>
        
        
        <li id="section-548">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-548">&#182;</a>
              </div>
              <p>Insert before chunk</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          pa = parentElm.parentNode;
          pa.insertBefore(trimNode(bef), parentElm);</pre></div></div>
            
        </li>
        
        
        <li id="section-549">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-549">&#182;</a>
              </div>
              <p>Insert middle chunk</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (replacementElm) {
            pa.insertBefore(replacementElm, parentElm);</pre></div></div>
            
        </li>
        
        
        <li id="section-550">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-550">&#182;</a>
              </div>
              <p>pa.replaceChild(replacementElm, splitElm);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          } <span class="hljs-keyword">else</span> {
            pa.insertBefore(splitElm, parentElm);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-551">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-551">&#182;</a>
              </div>
              <p>Insert after chunk</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          pa.insertBefore(trimNode(aft), parentElm);
          self.remove(parentElm);

          <span class="hljs-keyword">return</span> replacementElm || splitElm;
        }
      },

      <span class="hljs-comment">/**
       * Adds an event handler to the specified object.
       *
       * @method bind
       * @param {Element/Document/Window/Array} target Target element to bind events to.
       * handler to or an array of elements/ids/documents.
       * @param {String} name Name of event handler to add, for example: click.
       * @param {function} func Function to execute when the event occurs.
       * @param {Object} scope Optional scope to execute the function in.
       * @return {function} Function callback handler the same as the one passed in.
       */</span>
      bind: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, name, func, scope</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (Tools.isArray(target)) {
          <span class="hljs-keyword">var</span> i = target.length;

          <span class="hljs-keyword">while</span> (i--) {
            target[i] = self.bind(target[i], name, func, scope);
          }

          <span class="hljs-keyword">return</span> target;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-552">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-552">&#182;</a>
              </div>
              <p>Collect all window/document events bound by editor instance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self.settings.collect &amp;&amp; (target === self.doc || target === self.win)) {
          self.boundEvents.push([target, name, func, scope]);
        }

        <span class="hljs-keyword">return</span> self.events.bind(target, name, func, scope || self);
      },

      <span class="hljs-comment">/**
       * Removes the specified event handler by name and function from an element or collection of elements.
       *
       * @method unbind
       * @param {Element/Document/Window/Array} target Target element to unbind events on.
       * @param {String} name Event handler name, for example: "click"
       * @param {function} func Function to remove.
       * @return {bool/Array} Bool state of true if the handler was removed, or an array of states if multiple input elements
       * were passed in.
       */</span>
      unbind: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, name, func</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, i;

        <span class="hljs-keyword">if</span> (Tools.isArray(target)) {
          i = target.length;

          <span class="hljs-keyword">while</span> (i--) {
            target[i] = self.unbind(target[i], name, func);
          }

          <span class="hljs-keyword">return</span> target;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-553">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-553">&#182;</a>
              </div>
              <p>Remove any bound events matching the input</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self.boundEvents &amp;&amp; (target === self.doc || target === self.win)) {
          i = self.boundEvents.length;

          <span class="hljs-keyword">while</span> (i--) {
            <span class="hljs-keyword">var</span> item = self.boundEvents[i];

            <span class="hljs-keyword">if</span> (target == item[<span class="hljs-number">0</span>] &amp;&amp; (!name || name == item[<span class="hljs-number">1</span>]) &amp;&amp; (!func || func == item[<span class="hljs-number">2</span>])) {
              <span class="hljs-keyword">this</span>.events.unbind(item[<span class="hljs-number">0</span>], item[<span class="hljs-number">1</span>], item[<span class="hljs-number">2</span>]);
            }
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.events.unbind(target, name, func);
      },

      <span class="hljs-comment">/**
       * Fires the specified event name with object on target.
       *
       * @method fire
       * @param {Node/Document/Window} target Target element or object to fire event on.
       * @param {String} name Name of the event to fire.
       * @param {Object} evt Event object to send.
       * @return {Event} Event object.
       */</span>
      fire: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, name, evt</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.events.fire(target, name, evt);
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-554">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-554">&#182;</a>
              </div>
              <p>Returns the content editable state of a node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      getContentEditable: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> contentEditable;</pre></div></div>
            
        </li>
        
        
        <li id="section-555">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-555">&#182;</a>
              </div>
              <p>Check type</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!node || node.nodeType != <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-556">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-556">&#182;</a>
              </div>
              <p>Check for fake content editable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        contentEditable = node.getAttribute(<span class="hljs-string">"data-mce-contenteditable"</span>);
        <span class="hljs-keyword">if</span> (contentEditable &amp;&amp; contentEditable !== <span class="hljs-string">"inherit"</span>) {
          <span class="hljs-keyword">return</span> contentEditable;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-557">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-557">&#182;</a>
              </div>
              <p>Check for real content editable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> node.contentEditable !== <span class="hljs-string">"inherit"</span> ? node.contentEditable : <span class="hljs-literal">null</span>;
      },

      <span class="hljs-attr">getContentEditableParent</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> root = <span class="hljs-keyword">this</span>.getRoot(), state = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">for</span> (; node &amp;&amp; node !== root; node = node.parentNode) {
          state = <span class="hljs-keyword">this</span>.getContentEditable(node);

          <span class="hljs-keyword">if</span> (state !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">break</span>;
          }
        }

        <span class="hljs-keyword">return</span> state;
      },

      <span class="hljs-comment">/**
       * Destroys all internal references to the DOM to solve IE leak issues.
       *
       * @method destroy
       */</span>
      destroy: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-558">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-558">&#182;</a>
              </div>
              <p>Unbind all events bound to window/document by editor instance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self.boundEvents) {
          <span class="hljs-keyword">var</span> i = self.boundEvents.length;

          <span class="hljs-keyword">while</span> (i--) {
            <span class="hljs-keyword">var</span> item = self.boundEvents[i];
            <span class="hljs-keyword">this</span>.events.unbind(item[<span class="hljs-number">0</span>], item[<span class="hljs-number">1</span>], item[<span class="hljs-number">2</span>]);
          }

          self.boundEvents = <span class="hljs-literal">null</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-559">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-559">&#182;</a>
              </div>
              <p>Restore sizzle document to window.document
Since the current document might be removed producing Permission denied on IE see #6325</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (Sizzle.setDocument) {
          Sizzle.setDocument();
        }

        self.win = self.doc = self.root = self.events = self.frag = <span class="hljs-literal">null</span>;
      },

      <span class="hljs-attr">isChildOf</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, parent</span>) </span>{
        <span class="hljs-keyword">while</span> (node) {
          <span class="hljs-keyword">if</span> (parent === node) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }

          node = node.parentNode;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-560">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-560">&#182;</a>
              </div>
              <p>#ifdef debug</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      dumpRng: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">r</span>) </span>{
        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'startContainer: '</span> + r.startContainer.nodeName +
          <span class="hljs-string">', startOffset: '</span> + r.startOffset +
          <span class="hljs-string">', endContainer: '</span> + r.endContainer.nodeName +
          <span class="hljs-string">', endOffset: '</span> + r.endOffset
        );
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-561">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-561">&#182;</a>
              </div>
              <p>#endif</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      _findSib: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, selector, name</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, func = selector;

        <span class="hljs-keyword">if</span> (node) {</pre></div></div>
            
        </li>
        
        
        <li id="section-562">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-562">&#182;</a>
              </div>
              <p>If expression make a function of it using is</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func == <span class="hljs-string">'string'</span>) {
            func = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
              <span class="hljs-keyword">return</span> self.is(node, selector);
            };
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-563">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-563">&#182;</a>
              </div>
              <p>Loop all siblings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (node = node[name]; node; node = node[name]) {
            <span class="hljs-keyword">if</span> (func(node)) {
              <span class="hljs-keyword">return</span> node;
            }
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    };

    <span class="hljs-comment">/**
     * Instance of DOMUtils for the current document.
     *
     * @static
     * @property DOM
     * @type tinymce.dom.DOMUtils
     * @example
     * // Example of how to add a class to some element by id
     * tinymce.DOM.addClass('someid', 'someclass');
     */</span>
    DOMUtils.DOM = <span class="hljs-keyword">new</span> DOMUtils(<span class="hljs-built_in">document</span>);
    DOMUtils.nodeIndex = nodeIndex;

    <span class="hljs-keyword">return</span> DOMUtils;
  }
);

<span class="hljs-comment">/**
 * ScriptLoader.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/*globals console*/</span>

<span class="hljs-comment">/**
 * This class handles asynchronous/synchronous loading of JavaScript files it will execute callbacks
 * when various items gets loaded. This class is useful to load external JavaScript files.
 *
 * @class tinymce.dom.ScriptLoader
 * @example
 * // Load a script from a specific URL using the global script loader
 * tinymce.ScriptLoader.load('somescript.js');
 *
 * // Load a script using a unique instance of the script loader
 * var scriptLoader = new tinymce.dom.ScriptLoader();
 *
 * scriptLoader.load('somescript.js');
 *
 * // Load multiple scripts
 * var scriptLoader = new tinymce.dom.ScriptLoader();
 *
 * scriptLoader.add('somescript1.js');
 * scriptLoader.add('somescript2.js');
 * scriptLoader.add('somescript3.js');
 *
 * scriptLoader.loadQueue(function() {
 *    alert('All scripts are now loaded.');
 * });
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.ScriptLoader'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.DOMUtils"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">DOMUtils, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> DOM = DOMUtils.DOM;
    <span class="hljs-keyword">var</span> each = Tools.each, grep = Tools.grep;

    <span class="hljs-keyword">var</span> isFunction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> f === <span class="hljs-string">'function'</span>;
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ScriptLoader</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> QUEUED = <span class="hljs-number">0</span>,
        LOADING = <span class="hljs-number">1</span>,
        LOADED = <span class="hljs-number">2</span>,
        FAILED = <span class="hljs-number">3</span>,
        states = {},
        queue = [],
        scriptLoadedCallbacks = {},
        queueLoadedCallbacks = [],
        loading = <span class="hljs-number">0</span>,
        undef;

      <span class="hljs-comment">/**
       * Loads a specific script directly without adding it to the load queue.
       *
       * @method load
       * @param {String} url Absolute URL to script to add.
       * @param {function} callback Optional success callback function when the script loaded successfully.
       * @param {function} callback Optional failure callback function when the script failed to load.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadScript</span>(<span class="hljs-params">url, success, failure</span>) </span>{
        <span class="hljs-keyword">var</span> dom = DOM, elm, id;</pre></div></div>
            
        </li>
        
        
        <li id="section-564">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-564">&#182;</a>
              </div>
              <p>Execute callback when script is loaded</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">done</span>(<span class="hljs-params"></span>) </span>{
          dom.remove(id);

          <span class="hljs-keyword">if</span> (elm) {
            elm.onreadystatechange = elm.onload = elm = <span class="hljs-literal">null</span>;
          }

          success();
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">error</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-comment">/*eslint no-console:0 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-565">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-565">&#182;</a>
              </div>
              <p>We cant mark it as done if there is a load error since
A) We dont want to produce 404 errors on the server and
B) the onerror event wont fire on all browsers.
done();</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">if</span> (isFunction(failure)) {
            failure();
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-566">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-566">&#182;</a>
              </div>
              <p>Report the error so its easier for people to spot loading errors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span> !== <span class="hljs-string">"undefined"</span> &amp;&amp; <span class="hljs-built_in">console</span>.log) {
              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Failed to load script: "</span> + url);
            }
          }
        }

        id = dom.uniqueId();</pre></div></div>
            
        </li>
        
        
        <li id="section-567">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-567">&#182;</a>
              </div>
              <p>Create new script element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        elm = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);
        elm.id = id;
        elm.type = <span class="hljs-string">'text/javascript'</span>;
        elm.src = Tools._addCacheSuffix(url);</pre></div></div>
            
        </li>
        
        
        <li id="section-568">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-568">&#182;</a>
              </div>
              <p>Seems that onreadystatechange works better on IE 10 onload seems to fire incorrectly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-string">"onreadystatechange"</span> <span class="hljs-keyword">in</span> elm) {
          elm.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/loaded|complete/</span>.test(elm.readyState)) {
              done();
            }
          };
        } <span class="hljs-keyword">else</span> {
          elm.onload = done;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-569">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-569">&#182;</a>
              </div>
              <p>Add onerror event will get fired on some browsers but not all of them</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        elm.onerror = error;</pre></div></div>
            
        </li>
        
        
        <li id="section-570">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-570">&#182;</a>
              </div>
              <p>Add script to document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        (<span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'head'</span>)[<span class="hljs-number">0</span>] || <span class="hljs-built_in">document</span>.body).appendChild(elm);
      }

      <span class="hljs-comment">/**
       * Returns true/false if a script has been loaded or not.
       *
       * @method isDone
       * @param {String} url URL to check for.
       * @return {Boolean} true/false if the URL is loaded.
       */</span>
      <span class="hljs-keyword">this</span>.isDone = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
        <span class="hljs-keyword">return</span> states[url] == LOADED;
      };

      <span class="hljs-comment">/**
       * Marks a specific script to be loaded. This can be useful if a script got loaded outside
       * the script loader or to skip it from loading some script.
       *
       * @method markDone
       * @param {string} url Absolute URL to the script to mark as loaded.
       */</span>
      <span class="hljs-keyword">this</span>.markDone = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
        states[url] = LOADED;
      };

      <span class="hljs-comment">/**
       * Adds a specific script to the load queue of the script loader.
       *
       * @method add
       * @param {String} url Absolute URL to script to add.
       * @param {function} success Optional success callback function to execute when the script loades successfully.
       * @param {Object} scope Optional scope to execute callback in.
       * @param {function} failure Optional failure callback function to execute when the script failed to load.
       */</span>
      <span class="hljs-keyword">this</span>.add = <span class="hljs-keyword">this</span>.load = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url, success, scope, failure</span>) </span>{
        <span class="hljs-keyword">var</span> state = states[url];</pre></div></div>
            
        </li>
        
        
        <li id="section-571">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-571">&#182;</a>
              </div>
              <p>Add url to load queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (state == undef) {
          queue.push(url);
          states[url] = QUEUED;
        }

        <span class="hljs-keyword">if</span> (success) {</pre></div></div>
            
        </li>
        
        
        <li id="section-572">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-572">&#182;</a>
              </div>
              <p>Store away callback for later execution</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!scriptLoadedCallbacks[url]) {
            scriptLoadedCallbacks[url] = [];
          }

          scriptLoadedCallbacks[url].push({
            <span class="hljs-attr">success</span>: success,
            <span class="hljs-attr">failure</span>: failure,
            <span class="hljs-attr">scope</span>: scope || <span class="hljs-keyword">this</span>
          });
        }
      };

      <span class="hljs-keyword">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
        <span class="hljs-keyword">delete</span> states[url];
        <span class="hljs-keyword">delete</span> scriptLoadedCallbacks[url];
      };

      <span class="hljs-comment">/**
       * Starts the loading of the queue.
       *
       * @method loadQueue
       * @param {function} success Optional callback to execute when all queued items are loaded.
       * @param {function} failure Optional callback to execute when queued items failed to load.
       * @param {Object} scope Optional scope to execute the callback in.
       */</span>
      <span class="hljs-keyword">this</span>.loadQueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">success, scope, failure</span>) </span>{
        <span class="hljs-keyword">this</span>.loadScripts(queue, success, scope, failure);
      };

      <span class="hljs-comment">/**
       * Loads the specified queue of files and executes the callback ones they are loaded.
       * This method is generally not used outside this class but it might be useful in some scenarios.
       *
       * @method loadScripts
       * @param {Array} scripts Array of queue items to load.
       * @param {function} callback Optional callback to execute when scripts is loaded successfully.
       * @param {Object} scope Optional scope to execute callback in.
       * @param {function} callback Optional callback to execute if scripts failed to load.
       */</span>
      <span class="hljs-keyword">this</span>.loadScripts = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scripts, success, scope, failure</span>) </span>{
        <span class="hljs-keyword">var</span> loadScripts, failures = [];

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execCallbacks</span>(<span class="hljs-params">name, url</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-573">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-573">&#182;</a>
              </div>
              <p>Execute URL callback functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          each(scriptLoadedCallbacks[url], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
            <span class="hljs-keyword">if</span> (isFunction(callback[name])) {
              callback[name].call(callback.scope);
            }
          });

          scriptLoadedCallbacks[url] = undef;
        }

        queueLoadedCallbacks.push({
          <span class="hljs-attr">success</span>: success,
          <span class="hljs-attr">failure</span>: failure,
          <span class="hljs-attr">scope</span>: scope || <span class="hljs-keyword">this</span>
        });

        loadScripts = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> loadingScripts = grep(scripts);</pre></div></div>
            
        </li>
        
        
        <li id="section-574">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-574">&#182;</a>
              </div>
              <p>Current scripts has been handled</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          scripts.length = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-575">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-575">&#182;</a>
              </div>
              <p>Load scripts that needs to be loaded</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          each(loadingScripts, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-576">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-576">&#182;</a>
              </div>
              <p>Script is already loaded then execute script callbacks directly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (states[url] === LOADED) {
              execCallbacks(<span class="hljs-string">'success'</span>, url);
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (states[url] === FAILED) {
              execCallbacks(<span class="hljs-string">'failure'</span>, url);
              <span class="hljs-keyword">return</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-577">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-577">&#182;</a>
              </div>
              <p>Is script not loading then start loading it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (states[url] !== LOADING) {
              states[url] = LOADING;
              loading++;

              loadScript(url, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                states[url] = LOADED;
                loading--;

                execCallbacks(<span class="hljs-string">'success'</span>, url);</pre></div></div>
            
        </li>
        
        
        <li id="section-578">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-578">&#182;</a>
              </div>
              <p>Load more scripts if they where added by the recently loaded script</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                loadScripts();
              }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                states[url] = FAILED;
                loading--;

                failures.push(url);
                execCallbacks(<span class="hljs-string">'failure'</span>, url);</pre></div></div>
            
        </li>
        
        
        <li id="section-579">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-579">&#182;</a>
              </div>
              <p>Load more scripts if they where added by the recently loaded script</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                loadScripts();
              });
            }
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-580">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-580">&#182;</a>
              </div>
              <p>No scripts are currently loading then execute all pending queue loaded callbacks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!loading) {
            each(queueLoadedCallbacks, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
              <span class="hljs-keyword">if</span> (failures.length === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (isFunction(callback.success)) {
                  callback.success.call(callback.scope);
                }
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (isFunction(callback.failure)) {
                  callback.failure.call(callback.scope, failures);
                }
              }
            });

            queueLoadedCallbacks.length = <span class="hljs-number">0</span>;
          }
        };

        loadScripts();
      };
    }

    ScriptLoader.ScriptLoader = <span class="hljs-keyword">new</span> ScriptLoader();

    <span class="hljs-keyword">return</span> ScriptLoader;
  }
);

<span class="hljs-comment">/**
 * AddOnManager.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class handles the loading of themes/plugins or other add-ons and their language packs.
 *
 * @class tinymce.AddOnManager
 */</span>
define(
  <span class="hljs-string">'tinymce.core.AddOnManager'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.ScriptLoader"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ScriptLoader, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> each = Tools.each;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AddOnManager</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

      self.items = [];
      self.urls = {};
      self.lookup = {};
    }

    AddOnManager.prototype = {
      <span class="hljs-comment">/**
       * Returns the specified add on by the short name.
       *
       * @method get
       * @param {String} name Add-on to look for.
       * @return {tinymce.Theme/tinymce.Plugin} Theme or plugin add-on instance or undefined.
       */</span>
      get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lookup[name]) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.lookup[name].instance;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      },

      <span class="hljs-attr">dependencies</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">var</span> result;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lookup[name]) {
          result = <span class="hljs-keyword">this</span>.lookup[name].dependencies;
        }

        <span class="hljs-keyword">return</span> result || [];
      },

      <span class="hljs-comment">/**
       * Loads a language pack for the specified add-on.
       *
       * @method requireLangPack
       * @param {String} name Short name of the add-on.
       * @param {String} languages Optional comma or space separated list of languages to check if it matches the name.
       */</span>
      requireLangPack: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, languages</span>) </span>{
        <span class="hljs-keyword">var</span> language = AddOnManager.language;

        <span class="hljs-keyword">if</span> (language &amp;&amp; AddOnManager.languageLoad !== <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">if</span> (languages) {
            languages = <span class="hljs-string">','</span> + languages + <span class="hljs-string">','</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-581">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-581">&#182;</a>
              </div>
              <p>Load short form sv.js or long form sv_SE.js</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (languages.indexOf(<span class="hljs-string">','</span> + language.substr(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) + <span class="hljs-string">','</span>) != <span class="hljs-number">-1</span>) {
              language = language.substr(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (languages.indexOf(<span class="hljs-string">','</span> + language + <span class="hljs-string">','</span>) == <span class="hljs-number">-1</span>) {
              <span class="hljs-keyword">return</span>;
            }
          }

          ScriptLoader.ScriptLoader.add(<span class="hljs-keyword">this</span>.urls[name] + <span class="hljs-string">'/langs/'</span> + language + <span class="hljs-string">'.js'</span>);
        }
      },

      <span class="hljs-comment">/**
       * Adds a instance of the add-on by it's short name.
       *
       * @method add
       * @param {String} id Short name/id for the add-on.
       * @param {tinymce.Theme/tinymce.Plugin} addOn Theme or plugin to add.
       * @return {tinymce.Theme/tinymce.Plugin} The same theme or plugin instance that got passed in.
       * @example
       * // Create a simple plugin
       * tinymce.create('tinymce.plugins.TestPlugin', {
       *   TestPlugin: function(ed, url) {
       *   ed.on('click', function(e) {
       *      ed.windowManager.alert('Hello World!');
       *   });
       *   }
       * });
       *
       * // Register plugin using the add method
       * tinymce.PluginManager.add('test', tinymce.plugins.TestPlugin);
       *
       * // Initialize TinyMCE
       * tinymce.init({
       *  ...
       *  plugins: '-test' // Init the plugin but don't try to load it
       * });
       */</span>
      add: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, addOn, dependencies</span>) </span>{
        <span class="hljs-keyword">this</span>.items.push(addOn);
        <span class="hljs-keyword">this</span>.lookup[id] = { <span class="hljs-attr">instance</span>: addOn, <span class="hljs-attr">dependencies</span>: dependencies };

        <span class="hljs-keyword">return</span> addOn;
      },

      <span class="hljs-attr">remove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.urls[name];
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.lookup[name];
      },

      <span class="hljs-attr">createUrl</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">baseUrl, dep</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> dep === <span class="hljs-string">"object"</span>) {
          <span class="hljs-keyword">return</span> dep;
        }

        <span class="hljs-keyword">return</span> { <span class="hljs-attr">prefix</span>: baseUrl.prefix, <span class="hljs-attr">resource</span>: dep, <span class="hljs-attr">suffix</span>: baseUrl.suffix };
      },

      <span class="hljs-comment">/**
       * Add a set of components that will make up the add-on. Using the url of the add-on name as the base url.
       * This should be used in development mode.  A new compressor/javascript munger process will ensure that the
       * components are put together into the plugin.js file and compressed correctly.
       *
       * @method addComponents
       * @param {String} pluginName name of the plugin to load scripts from (will be used to get the base url for the plugins).
       * @param {Array} scripts Array containing the names of the scripts to load.
       */</span>
      addComponents: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pluginName, scripts</span>) </span>{
        <span class="hljs-keyword">var</span> pluginUrl = <span class="hljs-keyword">this</span>.urls[pluginName];

        each(scripts, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">script</span>) </span>{
          ScriptLoader.ScriptLoader.add(pluginUrl + <span class="hljs-string">"/"</span> + script);
        });
      },

      <span class="hljs-comment">/**
       * Loads an add-on from a specific url.
       *
       * @method load
       * @param {String} name Short name of the add-on that gets loaded.
       * @param {String} addOnUrl URL to the add-on that will get loaded.
       * @param {function} success Optional success callback to execute when an add-on is loaded.
       * @param {Object} scope Optional scope to execute the callback in.
       * @param {function} failure Optional failure callback to execute when an add-on failed to load.
       * @example
       * // Loads a plugin from an external URL
       * tinymce.PluginManager.load('myplugin', '/some/dir/someplugin/plugin.js');
       *
       * // Initialize TinyMCE
       * tinymce.init({
       *  ...
       *  plugins: '-myplugin' // Don't try to load it again
       * });
       */</span>
      load: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, addOnUrl, success, scope, failure</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, url = addOnUrl;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadDependencies</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> dependencies = self.dependencies(name);

          each(dependencies, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dep</span>) </span>{
            <span class="hljs-keyword">var</span> newUrl = self.createUrl(addOnUrl, dep);

            self.load(newUrl.resource, newUrl, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>);
          });

          <span class="hljs-keyword">if</span> (success) {
            <span class="hljs-keyword">if</span> (scope) {
              success.call(scope);
            } <span class="hljs-keyword">else</span> {
              success.call(ScriptLoader);
            }
          }
        }

        <span class="hljs-keyword">if</span> (self.urls[name]) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> addOnUrl === <span class="hljs-string">"object"</span>) {
          url = addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
        }

        <span class="hljs-keyword">if</span> (url.indexOf(<span class="hljs-string">'/'</span>) !== <span class="hljs-number">0</span> &amp;&amp; url.indexOf(<span class="hljs-string">'://'</span>) == <span class="hljs-number">-1</span>) {
          url = AddOnManager.baseURL + <span class="hljs-string">'/'</span> + url;
        }

        self.urls[name] = url.substring(<span class="hljs-number">0</span>, url.lastIndexOf(<span class="hljs-string">'/'</span>));

        <span class="hljs-keyword">if</span> (self.lookup[name]) {
          loadDependencies();
        } <span class="hljs-keyword">else</span> {
          ScriptLoader.ScriptLoader.add(url, loadDependencies, scope, failure);
        }
      }
    };

    AddOnManager.PluginManager = <span class="hljs-keyword">new</span> AddOnManager();
    AddOnManager.ThemeManager = <span class="hljs-keyword">new</span> AddOnManager();

    <span class="hljs-keyword">return</span> AddOnManager;
  }
);

<span class="hljs-comment">/**
 * TinyMCE theme class.
 *
 * @class tinymce.Theme
 */</span>

<span class="hljs-comment">/**
 * This method is responsible for rendering/generating the overall user interface with toolbars, buttons, iframe containers etc.
 *
 * @method renderUI
 * @param {Object} obj Object parameter containing the targetNode DOM node that will be replaced visually with an editor instance.
 * @return {Object} an object with items like iframeContainer, editorContainer, sizeContainer, deltaWidth, deltaHeight.
 */</span>

<span class="hljs-comment">/**
 * Plugin base class, this is a pseudo class that describes how a plugin is to be created for TinyMCE. The methods below are all optional.
 *
 * @class tinymce.Plugin
 * @example
 * tinymce.PluginManager.add('example', function(editor, url) {
 *     // Add a button that opens a window
 *     editor.addButton('example', {
 *         text: 'My button',
 *         icon: false,
 *         onclick: function() {
 *             // Open window
 *             editor.windowManager.open({
 *                 title: 'Example plugin',
 *                 body: [
 *                     {type: 'textbox', name: 'title', label: 'Title'}
 *                 ],
 *                 onsubmit: function(e) {
 *                     // Insert content when the window form is submitted
 *                     editor.insertContent('Title: ' + e.data.title);
 *                 }
 *             });
 *         }
 *     });
 *
 *     // Adds a menu item to the tools menu
 *     editor.addMenuItem('example', {
 *         text: 'Example plugin',
 *         context: 'tools',
 *         onclick: function() {
 *             // Open window with a specific url
 *             editor.windowManager.open({
 *                 title: 'TinyMCE site',
 *                 url: 'http://www.tinymce.com',
 *                 width: 800,
 *                 height: 600,
 *                 buttons: [{
 *                     text: 'Close',
 *                     onclick: 'close'
 *                 }]
 *             });
 *         }
 *     });
 * });
 */</span>

<span class="hljs-comment">/**
 * NodeType.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Contains various node validation functions.
 *
 * @private
 * @class tinymce.dom.NodeType
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNodeType</span>(<span class="hljs-params">type</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> !!node &amp;&amp; node.nodeType == type;
      };
    }

    <span class="hljs-keyword">var</span> isElement = isNodeType(<span class="hljs-number">1</span>);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchNodeNames</span>(<span class="hljs-params">names</span>) </span>{
      names = names.toLowerCase().split(<span class="hljs-string">' '</span>);

      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> i, name;

        <span class="hljs-keyword">if</span> (node &amp;&amp; node.nodeType) {
          name = node.nodeName.toLowerCase();

          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; names.length; i++) {
            <span class="hljs-keyword">if</span> (name === names[i]) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchStyleValues</span>(<span class="hljs-params">name, values</span>) </span>{
      values = values.toLowerCase().split(<span class="hljs-string">' '</span>);

      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> i, cssValue;

        <span class="hljs-keyword">if</span> (isElement(node)) {
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; values.length; i++) {
            cssValue = node.ownerDocument.defaultView.getComputedStyle(node, <span class="hljs-literal">null</span>).getPropertyValue(name);
            <span class="hljs-keyword">if</span> (cssValue === values[i]) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasPropValue</span>(<span class="hljs-params">propName, propValue</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> isElement(node) &amp;&amp; node[propName] === propValue;
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasAttribute</span>(<span class="hljs-params">attrName, attrValue</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> isElement(node) &amp;&amp; node.hasAttribute(attrName);
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasAttributeValue</span>(<span class="hljs-params">attrName, attrValue</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> isElement(node) &amp;&amp; node.getAttribute(attrName) === attrValue;
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBogus</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> isElement(node) &amp;&amp; node.hasAttribute(<span class="hljs-string">'data-mce-bogus'</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasContentEditableState</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">if</span> (isElement(node)) {
          <span class="hljs-keyword">if</span> (node.contentEditable === value) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }

          <span class="hljs-keyword">if</span> (node.getAttribute(<span class="hljs-string">'data-mce-contenteditable'</span>) === value) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      };
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">isText</span>: isNodeType(<span class="hljs-number">3</span>),
      <span class="hljs-attr">isElement</span>: isElement,
      <span class="hljs-attr">isComment</span>: isNodeType(<span class="hljs-number">8</span>),
      <span class="hljs-attr">isBr</span>: matchNodeNames(<span class="hljs-string">'br'</span>),
      <span class="hljs-attr">isContentEditableTrue</span>: hasContentEditableState(<span class="hljs-string">'true'</span>),
      <span class="hljs-attr">isContentEditableFalse</span>: hasContentEditableState(<span class="hljs-string">'false'</span>),
      <span class="hljs-attr">matchNodeNames</span>: matchNodeNames,
      <span class="hljs-attr">hasPropValue</span>: hasPropValue,
      <span class="hljs-attr">hasAttribute</span>: hasAttribute,
      <span class="hljs-attr">hasAttributeValue</span>: hasAttributeValue,
      <span class="hljs-attr">matchStyleValues</span>: matchStyleValues,
      <span class="hljs-attr">isBogus</span>: isBogus
    };
  }
);
<span class="hljs-comment">/**
 * Zwsp.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Utility functions for working with zero width space
 * characters used as character containers etc.
 *
 * @private
 * @class tinymce.text.Zwsp
 * @example
 * var isZwsp = Zwsp.isZwsp('\uFEFF');
 * var abc = Zwsp.trim('a\uFEFFc');
 */</span>
define(
  <span class="hljs-string">'tinymce.core.text.Zwsp'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-582">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-582">&#182;</a>
              </div>
              <p>This is technically not a ZWSP but a ZWNBSP or a BYTE ORDER MARK it used to be a ZWSP</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> ZWSP = <span class="hljs-string">'\uFEFF'</span>;

    <span class="hljs-keyword">var</span> isZwsp = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chr</span>) </span>{
      <span class="hljs-keyword">return</span> chr === ZWSP;
    };

    <span class="hljs-keyword">var</span> trim = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
      <span class="hljs-keyword">return</span> text.replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(ZWSP, <span class="hljs-string">'g'</span>), <span class="hljs-string">''</span>);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">isZwsp</span>: isZwsp,
      <span class="hljs-attr">ZWSP</span>: ZWSP,
      <span class="hljs-attr">trim</span>: trim
    };
  }
);
<span class="hljs-comment">/**
 * CaretContainer.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module handles caret containers. A caret container is a node that
 * holds the caret for positional purposes.
 *
 * @private
 * @class tinymce.caret.CaretContainer
 */</span>
define(
  <span class="hljs-string">'tinymce.core.caret.CaretContainer'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.NodeType"</span>,
    <span class="hljs-string">"tinymce.core.text.Zwsp"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">NodeType, Zwsp</span>) </span>{
    <span class="hljs-keyword">var</span> isElement = NodeType.isElement,
      isText = NodeType.isText;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCaretContainerBlock</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">if</span> (isText(node)) {
        node = node.parentNode;
      }

      <span class="hljs-keyword">return</span> isElement(node) &amp;&amp; node.hasAttribute(<span class="hljs-string">'data-mce-caret'</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCaretContainerInline</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> isText(node) &amp;&amp; Zwsp.isZwsp(node.data);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCaretContainer</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> isCaretContainerBlock(node) || isCaretContainerInline(node);
    }

    <span class="hljs-keyword">var</span> hasContent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> node.firstChild !== node.lastChild || !NodeType.isBr(node.firstChild);
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertInline</span>(<span class="hljs-params">node, before</span>) </span>{
      <span class="hljs-keyword">var</span> doc, sibling, textNode, parentNode;

      doc = node.ownerDocument;
      textNode = doc.createTextNode(Zwsp.ZWSP);
      parentNode = node.parentNode;

      <span class="hljs-keyword">if</span> (!before) {
        sibling = node.nextSibling;
        <span class="hljs-keyword">if</span> (isText(sibling)) {
          <span class="hljs-keyword">if</span> (isCaretContainer(sibling)) {
            <span class="hljs-keyword">return</span> sibling;
          }

          <span class="hljs-keyword">if</span> (startsWithCaretContainer(sibling)) {
            sibling.splitText(<span class="hljs-number">1</span>);
            <span class="hljs-keyword">return</span> sibling;
          }
        }

        <span class="hljs-keyword">if</span> (node.nextSibling) {
          parentNode.insertBefore(textNode, node.nextSibling);
        } <span class="hljs-keyword">else</span> {
          parentNode.appendChild(textNode);
        }
      } <span class="hljs-keyword">else</span> {
        sibling = node.previousSibling;
        <span class="hljs-keyword">if</span> (isText(sibling)) {
          <span class="hljs-keyword">if</span> (isCaretContainer(sibling)) {
            <span class="hljs-keyword">return</span> sibling;
          }

          <span class="hljs-keyword">if</span> (endsWithCaretContainer(sibling)) {
            <span class="hljs-keyword">return</span> sibling.splitText(sibling.data.length - <span class="hljs-number">1</span>);
          }
        }

        parentNode.insertBefore(textNode, node);
      }

      <span class="hljs-keyword">return</span> textNode;
    }

    <span class="hljs-keyword">var</span> prependInline = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">if</span> (NodeType.isText(node)) {
        <span class="hljs-keyword">var</span> data = node.data;
        <span class="hljs-keyword">if</span> (data.length &gt; <span class="hljs-number">0</span> &amp;&amp; data.charAt(<span class="hljs-number">0</span>) !== Zwsp.ZWSP) {
          node.insertData(<span class="hljs-number">0</span>, Zwsp.ZWSP);
        }
        <span class="hljs-keyword">return</span> node;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    };

    <span class="hljs-keyword">var</span> appendInline = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">if</span> (NodeType.isText(node)) {
        <span class="hljs-keyword">var</span> data = node.data;
        <span class="hljs-keyword">if</span> (data.length &gt; <span class="hljs-number">0</span> &amp;&amp; data.charAt(data.length - <span class="hljs-number">1</span>) !== Zwsp.ZWSP) {
          node.insertData(data.length, Zwsp.ZWSP);
        }
        <span class="hljs-keyword">return</span> node;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    };

    <span class="hljs-keyword">var</span> isBeforeInline = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
      <span class="hljs-keyword">return</span> pos &amp;&amp; NodeType.isText(pos.container()) &amp;&amp; pos.container().data.charAt(pos.offset()) === Zwsp.ZWSP;
    };

    <span class="hljs-keyword">var</span> isAfterInline = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
      <span class="hljs-keyword">return</span> pos &amp;&amp; NodeType.isText(pos.container()) &amp;&amp; pos.container().data.charAt(pos.offset() - <span class="hljs-number">1</span>) === Zwsp.ZWSP;
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createBogusBr</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> br = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'br'</span>);
      br.setAttribute(<span class="hljs-string">'data-mce-bogus'</span>, <span class="hljs-string">'1'</span>);
      <span class="hljs-keyword">return</span> br;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertBlock</span>(<span class="hljs-params">blockName, node, before</span>) </span>{
      <span class="hljs-keyword">var</span> doc, blockNode, parentNode;

      doc = node.ownerDocument;
      blockNode = doc.createElement(blockName);
      blockNode.setAttribute(<span class="hljs-string">'data-mce-caret'</span>, before ? <span class="hljs-string">'before'</span> : <span class="hljs-string">'after'</span>);
      blockNode.setAttribute(<span class="hljs-string">'data-mce-bogus'</span>, <span class="hljs-string">'all'</span>);
      blockNode.appendChild(createBogusBr());
      parentNode = node.parentNode;

      <span class="hljs-keyword">if</span> (!before) {
        <span class="hljs-keyword">if</span> (node.nextSibling) {
          parentNode.insertBefore(blockNode, node.nextSibling);
        } <span class="hljs-keyword">else</span> {
          parentNode.appendChild(blockNode);
        }
      } <span class="hljs-keyword">else</span> {
        parentNode.insertBefore(blockNode, node);
      }

      <span class="hljs-keyword">return</span> blockNode;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startsWithCaretContainer</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> isText(node) &amp;&amp; node.data[<span class="hljs-number">0</span>] == Zwsp.ZWSP;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endsWithCaretContainer</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> isText(node) &amp;&amp; node.data[node.data.length - <span class="hljs-number">1</span>] == Zwsp.ZWSP;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimBogusBr</span>(<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">var</span> brs = elm.getElementsByTagName(<span class="hljs-string">'br'</span>);
      <span class="hljs-keyword">var</span> lastBr = brs[brs.length - <span class="hljs-number">1</span>];
      <span class="hljs-keyword">if</span> (NodeType.isBogus(lastBr)) {
        lastBr.parentNode.removeChild(lastBr);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showCaretContainerBlock</span>(<span class="hljs-params">caretContainer</span>) </span>{
      <span class="hljs-keyword">if</span> (caretContainer &amp;&amp; caretContainer.hasAttribute(<span class="hljs-string">'data-mce-caret'</span>)) {
        trimBogusBr(caretContainer);
        caretContainer.removeAttribute(<span class="hljs-string">'data-mce-caret'</span>);
        caretContainer.removeAttribute(<span class="hljs-string">'data-mce-bogus'</span>);
        caretContainer.removeAttribute(<span class="hljs-string">'style'</span>);
        caretContainer.removeAttribute(<span class="hljs-string">'_moz_abspos'</span>);
        <span class="hljs-keyword">return</span> caretContainer;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">isCaretContainer</span>: isCaretContainer,
      <span class="hljs-attr">isCaretContainerBlock</span>: isCaretContainerBlock,
      <span class="hljs-attr">isCaretContainerInline</span>: isCaretContainerInline,
      <span class="hljs-attr">showCaretContainerBlock</span>: showCaretContainerBlock,
      <span class="hljs-attr">insertInline</span>: insertInline,
      <span class="hljs-attr">prependInline</span>: prependInline,
      <span class="hljs-attr">appendInline</span>: appendInline,
      <span class="hljs-attr">isBeforeInline</span>: isBeforeInline,
      <span class="hljs-attr">isAfterInline</span>: isAfterInline,
      <span class="hljs-attr">insertBlock</span>: insertBlock,
      <span class="hljs-attr">hasContent</span>: hasContent,
      <span class="hljs-attr">startsWithCaretContainer</span>: startsWithCaretContainer,
      <span class="hljs-attr">endsWithCaretContainer</span>: endsWithCaretContainer
    };
  }
);
<span class="hljs-comment">/**
 * RangeUtils.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class contains a few utility methods for ranges.
 *
 * @class tinymce.dom.RangeUtils
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.RangeUtils'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.dom.TreeWalker"</span>,
    <span class="hljs-string">"tinymce.core.dom.NodeType"</span>,
    <span class="hljs-string">"tinymce.core.dom.Range"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretContainer"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Tools, TreeWalker, NodeType, Range, CaretContainer</span>) </span>{
    <span class="hljs-keyword">var</span> each = Tools.each,
      isContentEditableTrue = NodeType.isContentEditableTrue,
      isContentEditableFalse = NodeType.isContentEditableFalse,
      isCaretContainer = CaretContainer.isCaretContainer;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasCeProperty</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> isContentEditableTrue(node) || isContentEditableFalse(node);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEndChild</span>(<span class="hljs-params">container, index</span>) </span>{
      <span class="hljs-keyword">var</span> childNodes = container.childNodes;

      index--;

      <span class="hljs-keyword">if</span> (index &gt; childNodes.length - <span class="hljs-number">1</span>) {
        index = childNodes.length - <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) {
        index = <span class="hljs-number">0</span>;
      }

      <span class="hljs-keyword">return</span> childNodes[index] || container;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findParent</span>(<span class="hljs-params">node, rootNode, predicate</span>) </span>{
      <span class="hljs-keyword">while</span> (node &amp;&amp; node !== rootNode) {
        <span class="hljs-keyword">if</span> (predicate(node)) {
          <span class="hljs-keyword">return</span> node;
        }

        node = node.parentNode;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasParent</span>(<span class="hljs-params">node, rootNode, predicate</span>) </span>{
      <span class="hljs-keyword">return</span> findParent(node, rootNode, predicate) !== <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasParentWithName</span>(<span class="hljs-params">node, rootNode, name</span>) </span>{
      <span class="hljs-keyword">return</span> hasParent(node, rootNode, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> node.nodeName === name;
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFormatterCaret</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> node.id === <span class="hljs-string">'_mce_caret'</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCeFalseCaretContainer</span>(<span class="hljs-params">node, rootNode</span>) </span>{
      <span class="hljs-keyword">return</span> isCaretContainer(node) &amp;&amp; hasParent(node, rootNode, isFormatterCaret) === <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RangeUtils</span>(<span class="hljs-params">dom</span>) </span>{
      <span class="hljs-comment">/**
       * Walks the specified range like object and executes the callback for each sibling collection it finds.
       *
       * @private
       * @method walk
       * @param {Object} rng Range like object.
       * @param {function} callback Callback function to execute for each sibling collection.
       */</span>
      <span class="hljs-keyword">this</span>.walk = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rng, callback</span>) </span>{
        <span class="hljs-keyword">var</span> startContainer = rng.startContainer,
          startOffset = rng.startOffset,
          endContainer = rng.endContainer,
          endOffset = rng.endOffset,
          ancestor, startPoint,
          endPoint, node, parent, siblings, nodes;</pre></div></div>
            
        </li>
        
        
        <li id="section-583">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-583">&#182;</a>
              </div>
              <p>Handle table cell selection the table plugin enables
you to fake select table cells and perform formatting actions on them</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        nodes = dom.select(<span class="hljs-string">'td[data-mce-selected],th[data-mce-selected]'</span>);
        <span class="hljs-keyword">if</span> (nodes.length &gt; <span class="hljs-number">0</span>) {
          each(nodes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            callback([node]);
          });

          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">/**
         * Excludes start/end text node if they are out side the range
         *
         * @private
         * @param {Array} nodes Nodes to exclude items from.
         * @return {Array} Array with nodes excluding the start/end container if needed.
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exclude</span>(<span class="hljs-params">nodes</span>) </span>{
          <span class="hljs-keyword">var</span> node;</pre></div></div>
            
        </li>
        
        
        <li id="section-584">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-584">&#182;</a>
              </div>
              <p>First node is excluded</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          node = nodes[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">3</span> &amp;&amp; node === startContainer &amp;&amp; startOffset &gt;= node.nodeValue.length) {
            nodes.splice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-585">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-585">&#182;</a>
              </div>
              <p>Last node is excluded</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          node = nodes[nodes.length - <span class="hljs-number">1</span>];
          <span class="hljs-keyword">if</span> (endOffset === <span class="hljs-number">0</span> &amp;&amp; nodes.length &gt; <span class="hljs-number">0</span> &amp;&amp; node === endContainer &amp;&amp; node.nodeType === <span class="hljs-number">3</span>) {
            nodes.splice(nodes.length - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
          }

          <span class="hljs-keyword">return</span> nodes;
        }

        <span class="hljs-comment">/**
         * Collects siblings
         *
         * @private
         * @param {Node} node Node to collect siblings from.
         * @param {String} name Name of the sibling to check for.
         * @param {Node} endNode
         * @return {Array} Array of collected siblings.
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collectSiblings</span>(<span class="hljs-params">node, name, endNode</span>) </span>{
          <span class="hljs-keyword">var</span> siblings = [];

          <span class="hljs-keyword">for</span> (; node &amp;&amp; node != endNode; node = node[name]) {
            siblings.push(node);
          }

          <span class="hljs-keyword">return</span> siblings;
        }

        <span class="hljs-comment">/**
         * Find an end point this is the node just before the common ancestor root.
         *
         * @private
         * @param {Node} node Node to start at.
         * @param {Node} root Root/ancestor element to stop just before.
         * @return {Node} Node just before the root element.
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findEndPoint</span>(<span class="hljs-params">node, root</span>) </span>{
          <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">if</span> (node.parentNode == root) {
              <span class="hljs-keyword">return</span> node;
            }

            node = node.parentNode;
          } <span class="hljs-keyword">while</span> (node);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walkBoundary</span>(<span class="hljs-params">startNode, endNode, next</span>) </span>{
          <span class="hljs-keyword">var</span> siblingName = next ? <span class="hljs-string">'nextSibling'</span> : <span class="hljs-string">'previousSibling'</span>;

          <span class="hljs-keyword">for</span> (node = startNode, parent = node.parentNode; node &amp;&amp; node != endNode; node = parent) {
            parent = node.parentNode;
            siblings = collectSiblings(node == startNode ? node : node[siblingName], siblingName);

            <span class="hljs-keyword">if</span> (siblings.length) {
              <span class="hljs-keyword">if</span> (!next) {
                siblings.reverse();
              }

              callback(exclude(siblings));
            }
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-586">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-586">&#182;</a>
              </div>
              <p>If index based start position then resolve it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (startContainer.nodeType == <span class="hljs-number">1</span> &amp;&amp; startContainer.hasChildNodes()) {
          startContainer = startContainer.childNodes[startOffset];
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-587">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-587">&#182;</a>
              </div>
              <p>If index based end position then resolve it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (endContainer.nodeType == <span class="hljs-number">1</span> &amp;&amp; endContainer.hasChildNodes()) {
          endContainer = getEndChild(endContainer, endOffset);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-588">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-588">&#182;</a>
              </div>
              <p>Same container</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (startContainer == endContainer) {
          <span class="hljs-keyword">return</span> callback(exclude([startContainer]));
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-589">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-589">&#182;</a>
              </div>
              <p>Find common ancestor and end points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        ancestor = dom.findCommonAncestor(startContainer, endContainer);</pre></div></div>
            
        </li>
        
        
        <li id="section-590">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-590">&#182;</a>
              </div>
              <p>Process left side</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (node = startContainer; node; node = node.parentNode) {
          <span class="hljs-keyword">if</span> (node === endContainer) {
            <span class="hljs-keyword">return</span> walkBoundary(startContainer, ancestor, <span class="hljs-literal">true</span>);
          }

          <span class="hljs-keyword">if</span> (node === ancestor) {
            <span class="hljs-keyword">break</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-591">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-591">&#182;</a>
              </div>
              <p>Process right side</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (node = endContainer; node; node = node.parentNode) {
          <span class="hljs-keyword">if</span> (node === startContainer) {
            <span class="hljs-keyword">return</span> walkBoundary(endContainer, ancestor);
          }

          <span class="hljs-keyword">if</span> (node === ancestor) {
            <span class="hljs-keyword">break</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-592">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-592">&#182;</a>
              </div>
              <p>Find start/end point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        startPoint = findEndPoint(startContainer, ancestor) || startContainer;
        endPoint = findEndPoint(endContainer, ancestor) || endContainer;</pre></div></div>
            
        </li>
        
        
        <li id="section-593">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-593">&#182;</a>
              </div>
              <p>Walk left leaf</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        walkBoundary(startContainer, startPoint, <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-594">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-594">&#182;</a>
              </div>
              <p>Walk the middle from start to end point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        siblings = collectSiblings(
          startPoint == startContainer ? startPoint : startPoint.nextSibling,
          <span class="hljs-string">'nextSibling'</span>,
          endPoint == endContainer ? endPoint.nextSibling : endPoint
        );

        <span class="hljs-keyword">if</span> (siblings.length) {
          callback(exclude(siblings));
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-595">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-595">&#182;</a>
              </div>
              <p>Walk right leaf</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        walkBoundary(endContainer, endPoint);
      };

      <span class="hljs-comment">/**
       * Splits the specified range at it's start/end points.
       *
       * @private
       * @param {Range/RangeObject} rng Range to split.
       * @return {Object} Range position object.
       */</span>
      <span class="hljs-keyword">this</span>.split = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rng</span>) </span>{
        <span class="hljs-keyword">var</span> startContainer = rng.startContainer,
          startOffset = rng.startOffset,
          endContainer = rng.endContainer,
          endOffset = rng.endOffset;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">splitText</span>(<span class="hljs-params">node, offset</span>) </span>{
          <span class="hljs-keyword">return</span> node.splitText(offset);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-596">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-596">&#182;</a>
              </div>
              <p>Handle single text node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (startContainer == endContainer &amp;&amp; startContainer.nodeType == <span class="hljs-number">3</span>) {
          <span class="hljs-keyword">if</span> (startOffset &gt; <span class="hljs-number">0</span> &amp;&amp; startOffset &lt; startContainer.nodeValue.length) {
            endContainer = splitText(startContainer, startOffset);
            startContainer = endContainer.previousSibling;

            <span class="hljs-keyword">if</span> (endOffset &gt; startOffset) {
              endOffset = endOffset - startOffset;
              startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;
              endOffset = endContainer.nodeValue.length;
              startOffset = <span class="hljs-number">0</span>;
            } <span class="hljs-keyword">else</span> {
              endOffset = <span class="hljs-number">0</span>;
            }
          }
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-597">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-597">&#182;</a>
              </div>
              <p>Split startContainer text node if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (startContainer.nodeType == <span class="hljs-number">3</span> &amp;&amp; startOffset &gt; <span class="hljs-number">0</span> &amp;&amp; startOffset &lt; startContainer.nodeValue.length) {
            startContainer = splitText(startContainer, startOffset);
            startOffset = <span class="hljs-number">0</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-598">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-598">&#182;</a>
              </div>
              <p>Split endContainer text node if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (endContainer.nodeType == <span class="hljs-number">3</span> &amp;&amp; endOffset &gt; <span class="hljs-number">0</span> &amp;&amp; endOffset &lt; endContainer.nodeValue.length) {
            endContainer = splitText(endContainer, endOffset).previousSibling;
            endOffset = endContainer.nodeValue.length;
          }
        }

        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">startContainer</span>: startContainer,
          <span class="hljs-attr">startOffset</span>: startOffset,
          <span class="hljs-attr">endContainer</span>: endContainer,
          <span class="hljs-attr">endOffset</span>: endOffset
        };
      };

      <span class="hljs-comment">/**
       * Normalizes the specified range by finding the closest best suitable caret location.
       *
       * @private
       * @param {Range} rng Range to normalize.
       * @return {Boolean} True/false if the specified range was normalized or not.
       */</span>
      <span class="hljs-keyword">this</span>.normalize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rng</span>) </span>{
        <span class="hljs-keyword">var</span> normalized = <span class="hljs-literal">false</span>, collapsed;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeEndPoint</span>(<span class="hljs-params">start</span>) </span>{
          <span class="hljs-keyword">var</span> container, offset, walker, body = dom.getRoot(), node, nonEmptyElementsMap;
          <span class="hljs-keyword">var</span> directionLeft, isAfterNode;

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTableCell</span>(<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">return</span> node &amp;&amp; <span class="hljs-regexp">/^(TD|TH|CAPTION)$/</span>.test(node.nodeName);
          }

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasBrBeforeAfter</span>(<span class="hljs-params">node, left</span>) </span>{
            <span class="hljs-keyword">var</span> walker = <span class="hljs-keyword">new</span> TreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || body);

            <span class="hljs-keyword">while</span> ((node = walker[left ? <span class="hljs-string">'prev'</span> : <span class="hljs-string">'next'</span>]())) {
              <span class="hljs-keyword">if</span> (node.nodeName === <span class="hljs-string">"BR"</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              }
            }
          }

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasContentEditableFalseParent</span>(<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">while</span> (node &amp;&amp; node != body) {
              <span class="hljs-keyword">if</span> (isContentEditableFalse(node)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              }

              node = node.parentNode;
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPrevNode</span>(<span class="hljs-params">node, name</span>) </span>{
            <span class="hljs-keyword">return</span> node.previousSibling &amp;&amp; node.previousSibling.nodeName == name;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-599">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-599">&#182;</a>
              </div>
              <p>Walks the dom left/right to find a suitable text node to move the endpoint into
It will only walk within the current parent block or body and will stop if it hits a block or a BR/IMG</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findTextNodeRelative</span>(<span class="hljs-params">left, startNode</span>) </span>{
            <span class="hljs-keyword">var</span> walker, lastInlineElement, parentBlockContainer;

            startNode = startNode || container;
            parentBlockContainer = dom.getParent(startNode.parentNode, dom.isBlock) || body;</pre></div></div>
            
        </li>
        
        
        <li id="section-600">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-600">&#182;</a>
              </div>
              <p>Lean left before the BR element if its the only BR within a block element. Gecko bug: #6680
This: <p><br>|</p> becomes <p>|<br></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (left &amp;&amp; startNode.nodeName == <span class="hljs-string">'BR'</span> &amp;&amp; isAfterNode &amp;&amp; dom.isEmpty(parentBlockContainer)) {
              container = startNode.parentNode;
              offset = dom.nodeIndex(startNode);
              normalized = <span class="hljs-literal">true</span>;
              <span class="hljs-keyword">return</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-601">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-601">&#182;</a>
              </div>
              <p>Walk left until we hit a text node we can move to or a block/br/img</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            walker = <span class="hljs-keyword">new</span> TreeWalker(startNode, parentBlockContainer);
            <span class="hljs-keyword">while</span> ((node = walker[left ? <span class="hljs-string">'prev'</span> : <span class="hljs-string">'next'</span>]())) {</pre></div></div>
            
        </li>
        
        
        <li id="section-602">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-602">&#182;</a>
              </div>
              <p>Break if we hit a non content editable node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (dom.getContentEditableParent(node) === <span class="hljs-string">"false"</span> || isCeFalseCaretContainer(node, dom.getRoot())) {
                <span class="hljs-keyword">return</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-603">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-603">&#182;</a>
              </div>
              <p>Found text node that has a length</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">3</span> &amp;&amp; node.nodeValue.length &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (hasParentWithName(node, body, <span class="hljs-string">'A'</span>) === <span class="hljs-literal">false</span>) {
                  container = node;
                  offset = left ? node.nodeValue.length : <span class="hljs-number">0</span>;
                  normalized = <span class="hljs-literal">true</span>;
                }

                <span class="hljs-keyword">return</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-604">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-604">&#182;</a>
              </div>
              <p>Break if we find a block or a BR/IMG/INPUT etc</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
                <span class="hljs-keyword">return</span>;
              }

              lastInlineElement = node;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-605">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-605">&#182;</a>
              </div>
              <p>Only fetch the last inline element when in caret mode for now</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (collapsed &amp;&amp; lastInlineElement) {
              container = lastInlineElement;
              normalized = <span class="hljs-literal">true</span>;
              offset = <span class="hljs-number">0</span>;
            }
          }

          container = rng[(start ? <span class="hljs-string">'start'</span> : <span class="hljs-string">'end'</span>) + <span class="hljs-string">'Container'</span>];
          offset = rng[(start ? <span class="hljs-string">'start'</span> : <span class="hljs-string">'end'</span>) + <span class="hljs-string">'Offset'</span>];
          isAfterNode = container.nodeType == <span class="hljs-number">1</span> &amp;&amp; offset === container.childNodes.length;
          nonEmptyElementsMap = dom.schema.getNonEmptyElements();
          directionLeft = start;

          <span class="hljs-keyword">if</span> (isCaretContainer(container)) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">1</span> &amp;&amp; offset &gt; container.childNodes.length - <span class="hljs-number">1</span>) {
            directionLeft = <span class="hljs-literal">false</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-606">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-606">&#182;</a>
              </div>
              <p>If the container is a document move it to the body element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (container.nodeType === <span class="hljs-number">9</span>) {
            container = dom.getRoot();
            offset = <span class="hljs-number">0</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-607">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-607">&#182;</a>
              </div>
              <p>If the container is body try move it into the closest text node or position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (container === body) {</pre></div></div>
            
        </li>
        
        
        <li id="section-608">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-608">&#182;</a>
              </div>
              <p>If start is before/after a image, table etc</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (directionLeft) {
              node = container.childNodes[offset &gt; <span class="hljs-number">0</span> ? offset - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>];
              <span class="hljs-keyword">if</span> (node) {
                <span class="hljs-keyword">if</span> (isCaretContainer(node)) {
                  <span class="hljs-keyword">return</span>;
                }

                <span class="hljs-keyword">if</span> (nonEmptyElementsMap[node.nodeName] || node.nodeName == <span class="hljs-string">"TABLE"</span>) {
                  <span class="hljs-keyword">return</span>;
                }
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-609">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-609">&#182;</a>
              </div>
              <p>Resolve the index</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (container.hasChildNodes()) {
              offset = <span class="hljs-built_in">Math</span>.min(!directionLeft &amp;&amp; offset &gt; <span class="hljs-number">0</span> ? offset - <span class="hljs-number">1</span> : offset, container.childNodes.length - <span class="hljs-number">1</span>);
              container = container.childNodes[offset];
              offset = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-610">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-610">&#182;</a>
              </div>
              <p>Dont normalize non collapsed selections like <p>[a</p><table></table>]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (!collapsed &amp;&amp; container === body.lastChild &amp;&amp; container.nodeName === <span class="hljs-string">'TABLE'</span>) {
                <span class="hljs-keyword">return</span>;
              }

              <span class="hljs-keyword">if</span> (hasContentEditableFalseParent(container) || isCaretContainer(container)) {
                <span class="hljs-keyword">return</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-611">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-611">&#182;</a>
              </div>
              <p>Dont walk into elements that doesnt have any child nodes like a IMG</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (container.hasChildNodes() &amp;&amp; !<span class="hljs-regexp">/TABLE/</span>.test(container.nodeName)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-612">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-612">&#182;</a>
              </div>
              <p>Walk the DOM to find a text node to place the caret at or a BR</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                node = container;
                walker = <span class="hljs-keyword">new</span> TreeWalker(container, body);

                <span class="hljs-keyword">do</span> {
                  <span class="hljs-keyword">if</span> (isContentEditableFalse(node) || isCaretContainer(node)) {
                    normalized = <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">break</span>;
                  }</pre></div></div>
            
        </li>
        
        
        <li id="section-613">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-613">&#182;</a>
              </div>
              <p>Found a text node use that position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">3</span> &amp;&amp; node.nodeValue.length &gt; <span class="hljs-number">0</span>) {
                    offset = directionLeft ? <span class="hljs-number">0</span> : node.nodeValue.length;
                    container = node;
                    normalized = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">break</span>;
                  }</pre></div></div>
            
        </li>
        
        
        <li id="section-614">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-614">&#182;</a>
              </div>
              <p>Found a BR/IMG element that we can place the caret before</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">if</span> (nonEmptyElementsMap[node.nodeName.toLowerCase()] &amp;&amp; !isTableCell(node)) {
                    offset = dom.nodeIndex(node);
                    container = node.parentNode;</pre></div></div>
            
        </li>
        
        
        <li id="section-615">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-615">&#182;</a>
              </div>
              <p>Put caret after image when moving the end point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> (node.nodeName == <span class="hljs-string">"IMG"</span> &amp;&amp; !directionLeft) {
                      offset++;
                    }

                    normalized = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">break</span>;
                  }
                } <span class="hljs-keyword">while</span> ((node = (directionLeft ? walker.next() : walker.prev())));
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-616">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-616">&#182;</a>
              </div>
              <p>Lean the caret to the left if possible</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (collapsed) {</pre></div></div>
            
        </li>
        
        
        <li id="section-617">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-617">&#182;</a>
              </div>
              <p>So this: <b>x</b><i>|x</i>
Becomes: <b>x|</b><i>x</i>
Seems that only gecko has issues with this</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (container.nodeType === <span class="hljs-number">3</span> &amp;&amp; offset === <span class="hljs-number">0</span>) {
              findTextNodeRelative(<span class="hljs-literal">true</span>);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-618">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-618">&#182;</a>
              </div>
              <p>Lean left into empty inline elements when the caret is before a BR
So this: <i><b></b><i>|<br></i>
Becomes: <i><b>|</b><i><br></i>
Seems that only gecko has issues with this.
Special edge case for <p><a>x</a>|<br></p> since we dont want <p><a>x|</a><br></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (container.nodeType === <span class="hljs-number">1</span>) {
              node = container.childNodes[offset];</pre></div></div>
            
        </li>
        
        
        <li id="section-619">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-619">&#182;</a>
              </div>
              <p>Offset is after the containers last child
then use the previous child for normalization</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (!node) {
                node = container.childNodes[offset - <span class="hljs-number">1</span>];
              }

              <span class="hljs-keyword">if</span> (node &amp;&amp; node.nodeName === <span class="hljs-string">'BR'</span> &amp;&amp; !isPrevNode(node, <span class="hljs-string">'A'</span>) &amp;&amp;
                !hasBrBeforeAfter(node) &amp;&amp; !hasBrBeforeAfter(node, <span class="hljs-literal">true</span>)) {
                findTextNodeRelative(<span class="hljs-literal">true</span>, node);
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-620">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-620">&#182;</a>
              </div>
              <p>Lean the start of the selection right if possible
So this: x[<b>x]</b>
Becomes: x<b>[x]</b></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (directionLeft &amp;&amp; !collapsed &amp;&amp; container.nodeType === <span class="hljs-number">3</span> &amp;&amp; offset === container.nodeValue.length) {
            findTextNodeRelative(<span class="hljs-literal">false</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-621">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-621">&#182;</a>
              </div>
              <p>Set endpoint if it was normalized</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (normalized) {
            rng[<span class="hljs-string">'set'</span> + (start ? <span class="hljs-string">'Start'</span> : <span class="hljs-string">'End'</span>)](container, offset);
          }
        }

        collapsed = rng.collapsed;

        normalizeEndPoint(<span class="hljs-literal">true</span>);

        <span class="hljs-keyword">if</span> (!collapsed) {
          normalizeEndPoint();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-622">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-622">&#182;</a>
              </div>
              <p>If it was collapsed then make sure it still is</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (normalized &amp;&amp; collapsed) {
          rng.collapse(<span class="hljs-literal">true</span>);
        }

        <span class="hljs-keyword">return</span> normalized;
      };
    }

    <span class="hljs-comment">/**
     * Compares two ranges and checks if they are equal.
     *
     * @static
     * @method compareRanges
     * @param {DOMRange} rng1 First range to compare.
     * @param {DOMRange} rng2 First range to compare.
     * @return {Boolean} true/false if the ranges are equal.
     */</span>
    RangeUtils.compareRanges = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rng1, rng2</span>) </span>{
      <span class="hljs-keyword">if</span> (rng1 &amp;&amp; rng2) {</pre></div></div>
            
        </li>
        
        
        <li id="section-623">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-623">&#182;</a>
              </div>
              <p>Compare native IE ranges</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (rng1.item || rng1.duplicate) {</pre></div></div>
            
        </li>
        
        
        <li id="section-624">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-624">&#182;</a>
              </div>
              <p>Both are control ranges and the selected element matches</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (rng1.item &amp;&amp; rng2.item &amp;&amp; rng1.item(<span class="hljs-number">0</span>) === rng2.item(<span class="hljs-number">0</span>)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-625">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-625">&#182;</a>
              </div>
              <p>Both are text ranges and the range matches</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (rng1.isEqual &amp;&amp; rng2.isEqual &amp;&amp; rng2.isEqual(rng1)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-626">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-626">&#182;</a>
              </div>
              <p>Compare w3c ranges</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> rng1.startContainer == rng2.startContainer &amp;&amp; rng1.startOffset == rng2.startOffset;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    };

    <span class="hljs-comment">/**
     * Finds the closest selection rect tries to get the range from that.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findClosestIeRange</span>(<span class="hljs-params">clientX, clientY, doc</span>) </span>{
      <span class="hljs-keyword">var</span> element, rng, rects;

      element = doc.elementFromPoint(clientX, clientY);
      rng = doc.body.createTextRange();

      <span class="hljs-keyword">if</span> (!element || element.tagName == <span class="hljs-string">'HTML'</span>) {
        element = doc.body;
      }

      rng.moveToElementText(element);
      rects = Tools.toArray(rng.getClientRects());

      rects = rects.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
        a = <span class="hljs-built_in">Math</span>.abs(<span class="hljs-built_in">Math</span>.max(a.top - clientY, a.bottom - clientY));
        b = <span class="hljs-built_in">Math</span>.abs(<span class="hljs-built_in">Math</span>.max(b.top - clientY, b.bottom - clientY));

        <span class="hljs-keyword">return</span> a - b;
      });

      <span class="hljs-keyword">if</span> (rects.length &gt; <span class="hljs-number">0</span>) {
        clientY = (rects[<span class="hljs-number">0</span>].bottom + rects[<span class="hljs-number">0</span>].top) / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">try</span> {
          rng.moveToPoint(clientX, clientY);
          rng.collapse(<span class="hljs-literal">true</span>);

          <span class="hljs-keyword">return</span> rng;
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-627">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-627">&#182;</a>
              </div>
              <p>At least we tried</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveOutOfContentEditableFalse</span>(<span class="hljs-params">rng, rootNode</span>) </span>{
      <span class="hljs-keyword">var</span> parentElement = rng &amp;&amp; rng.parentElement ? rng.parentElement() : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">return</span> isContentEditableFalse(findParent(parentElement, rootNode, hasCeProperty)) ? <span class="hljs-literal">null</span> : rng;
    }

    <span class="hljs-comment">/**
     * Gets the caret range for the given x/y location.
     *
     * @static
     * @method getCaretRangeFromPoint
     * @param {Number} clientX X coordinate for range
     * @param {Number} clientY Y coordinate for range
     * @param {Document} doc Document that x/y are relative to
     * @returns {Range} caret range
     */</span>
    RangeUtils.getCaretRangeFromPoint = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clientX, clientY, doc</span>) </span>{
      <span class="hljs-keyword">var</span> rng, point;

      <span class="hljs-keyword">if</span> (doc.caretPositionFromPoint) {
        point = doc.caretPositionFromPoint(clientX, clientY);
        rng = doc.createRange();
        rng.setStart(point.offsetNode, point.offset);
        rng.collapse(<span class="hljs-literal">true</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (doc.caretRangeFromPoint) {
        rng = doc.caretRangeFromPoint(clientX, clientY);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (doc.body.createTextRange) {
        rng = doc.body.createTextRange();

        <span class="hljs-keyword">try</span> {
          rng.moveToPoint(clientX, clientY);
          rng.collapse(<span class="hljs-literal">true</span>);
        } <span class="hljs-keyword">catch</span> (ex) {
          rng = findClosestIeRange(clientX, clientY, doc);
        }

        <span class="hljs-keyword">return</span> moveOutOfContentEditableFalse(rng, doc.body);
      }

      <span class="hljs-keyword">return</span> rng;
    };

    RangeUtils.getSelectedNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">range</span>) </span>{
      <span class="hljs-keyword">var</span> startContainer = range.startContainer,
        startOffset = range.startOffset;

      <span class="hljs-keyword">if</span> (startContainer.hasChildNodes() &amp;&amp; range.endOffset == startOffset + <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> startContainer.childNodes[startOffset];
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    };

    RangeUtils.getNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">container, offset</span>) </span>{
      <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">1</span> &amp;&amp; container.hasChildNodes()) {
        <span class="hljs-keyword">if</span> (offset &gt;= container.childNodes.length) {
          offset = container.childNodes.length - <span class="hljs-number">1</span>;
        }

        container = container.childNodes[offset];
      }

      <span class="hljs-keyword">return</span> container;
    };

    <span class="hljs-keyword">return</span> RangeUtils;
  }
);

<span class="hljs-comment">/**
 * Node.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class is a minimalistic implementation of a DOM like node used by the DomParser class.
 *
 * @example
 * var node = new tinymce.html.Node('strong', 1);
 * someRoot.append(node);
 *
 * @class tinymce.html.Node
 * @version 3.4
 */</span>
define(
  <span class="hljs-string">'tinymce.core.html.Node'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> whiteSpaceRegExp = <span class="hljs-regexp">/^[ \t\r\n]*$/</span>;
    <span class="hljs-keyword">var</span> typeLookup = {
      <span class="hljs-string">'#text'</span>: <span class="hljs-number">3</span>,
      <span class="hljs-string">'#comment'</span>: <span class="hljs-number">8</span>,
      <span class="hljs-string">'#cdata'</span>: <span class="hljs-number">4</span>,
      <span class="hljs-string">'#pi'</span>: <span class="hljs-number">7</span>,
      <span class="hljs-string">'#doctype'</span>: <span class="hljs-number">10</span>,
      <span class="hljs-string">'#document-fragment'</span>: <span class="hljs-number">11</span>
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-628">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-628">&#182;</a>
              </div>
              <p>Walks the tree left/right</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walk</span>(<span class="hljs-params">node, rootNode, prev</span>) </span>{
      <span class="hljs-keyword">var</span> sibling, parent, startName = prev ? <span class="hljs-string">'lastChild'</span> : <span class="hljs-string">'firstChild'</span>, siblingName = prev ? <span class="hljs-string">'prev'</span> : <span class="hljs-string">'next'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-629">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-629">&#182;</a>
              </div>
              <p>Walk into nodes if it has a start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (node[startName]) {
        <span class="hljs-keyword">return</span> node[startName];
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-630">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-630">&#182;</a>
              </div>
              <p>Return the sibling if it has one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (node !== rootNode) {
        sibling = node[siblingName];

        <span class="hljs-keyword">if</span> (sibling) {
          <span class="hljs-keyword">return</span> sibling;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-631">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-631">&#182;</a>
              </div>
              <p>Walk up the parents to look for siblings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (parent = node.parent; parent &amp;&amp; parent !== rootNode; parent = parent.parent) {
          sibling = parent[siblingName];

          <span class="hljs-keyword">if</span> (sibling) {
            <span class="hljs-keyword">return</span> sibling;
          }
        }
      }
    }

    <span class="hljs-comment">/**
     * Constructs a new Node instance.
     *
     * @constructor
     * @method Node
     * @param {String} name Name of the node type.
     * @param {Number} type Numeric type representing the node.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">name, type</span>) </span>{
      <span class="hljs-keyword">this</span>.name = name;
      <span class="hljs-keyword">this</span>.type = type;

      <span class="hljs-keyword">if</span> (type === <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">this</span>.attributes = [];
        <span class="hljs-keyword">this</span>.attributes.map = {};
      }
    }

    Node.prototype = {
      <span class="hljs-comment">/**
       * Replaces the current node with the specified one.
       *
       * @example
       * someNode.replace(someNewNode);
       *
       * @method replace
       * @param {tinymce.html.Node} node Node to replace the current node with.
       * @return {tinymce.html.Node} The old node that got replaced.
       */</span>
      replace: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (node.parent) {
          node.remove();
        }

        self.insert(node, self);
        self.remove();

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Gets/sets or removes an attribute by name.
       *
       * @example
       * someNode.attr("name", "value"); // Sets an attribute
       * console.log(someNode.attr("name")); // Gets an attribute
       * someNode.attr("name", null); // Removes an attribute
       *
       * @method attr
       * @param {String} name Attribute name to set or get.
       * @param {String} value Optional value to set.
       * @return {String/tinymce.html.Node} String or undefined on a get operation or the current node on a set operation.
       */</span>
      attr: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, attrs, i, undef;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name !== <span class="hljs-string">"string"</span>) {
          <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> name) {
            self.attr(i, name[i]);
          }

          <span class="hljs-keyword">return</span> self;
        }

        <span class="hljs-keyword">if</span> ((attrs = self.attributes)) {
          <span class="hljs-keyword">if</span> (value !== undef) {</pre></div></div>
            
        </li>
        
        
        <li id="section-632">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-632">&#182;</a>
              </div>
              <p>Remove attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> attrs.map) {
                <span class="hljs-keyword">delete</span> attrs.map[name];

                i = attrs.length;
                <span class="hljs-keyword">while</span> (i--) {
                  <span class="hljs-keyword">if</span> (attrs[i].name === name) {
                    attrs = attrs.splice(i, <span class="hljs-number">1</span>);
                    <span class="hljs-keyword">return</span> self;
                  }
                }
              }

              <span class="hljs-keyword">return</span> self;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-633">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-633">&#182;</a>
              </div>
              <p>Set attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> attrs.map) {</pre></div></div>
            
        </li>
        
        
        <li id="section-634">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-634">&#182;</a>
              </div>
              <p>Set attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              i = attrs.length;
              <span class="hljs-keyword">while</span> (i--) {
                <span class="hljs-keyword">if</span> (attrs[i].name === name) {
                  attrs[i].value = value;
                  <span class="hljs-keyword">break</span>;
                }
              }
            } <span class="hljs-keyword">else</span> {
              attrs.push({ <span class="hljs-attr">name</span>: name, <span class="hljs-attr">value</span>: value });
            }

            attrs.map[name] = value;

            <span class="hljs-keyword">return</span> self;
          }

          <span class="hljs-keyword">return</span> attrs.map[name];
        }
      },

      <span class="hljs-comment">/**
       * Does a shallow clones the node into a new node. It will also exclude id attributes since
       * there should only be one id per document.
       *
       * @example
       * var clonedNode = node.clone();
       *
       * @method clone
       * @return {tinymce.html.Node} New copy of the original node.
       */</span>
      clone: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, clone = <span class="hljs-keyword">new</span> Node(self.name, self.type), i, l, selfAttrs, selfAttr, cloneAttrs;</pre></div></div>
            
        </li>
        
        
        <li id="section-635">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-635">&#182;</a>
              </div>
              <p>Clone element attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((selfAttrs = self.attributes)) {
          cloneAttrs = [];
          cloneAttrs.map = {};

          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = selfAttrs.length; i &lt; l; i++) {
            selfAttr = selfAttrs[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-636">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-636">&#182;</a>
              </div>
              <p>Clone everything except id</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (selfAttr.name !== <span class="hljs-string">'id'</span>) {
              cloneAttrs[cloneAttrs.length] = { <span class="hljs-attr">name</span>: selfAttr.name, <span class="hljs-attr">value</span>: selfAttr.value };
              cloneAttrs.map[selfAttr.name] = selfAttr.value;
            }
          }

          clone.attributes = cloneAttrs;
        }

        clone.value = self.value;
        clone.shortEnded = self.shortEnded;

        <span class="hljs-keyword">return</span> clone;
      },

      <span class="hljs-comment">/**
       * Wraps the node in in another node.
       *
       * @example
       * node.wrap(wrapperNode);
       *
       * @method wrap
       */</span>
      wrap: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">wrapper</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.parent.insert(wrapper, self);
        wrapper.append(self);

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Unwraps the node in other words it removes the node but keeps the children.
       *
       * @example
       * node.unwrap();
       *
       * @method unwrap
       */</span>
      unwrap: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, node, next;

        <span class="hljs-keyword">for</span> (node = self.firstChild; node;) {
          next = node.next;
          self.insert(node, self, <span class="hljs-literal">true</span>);
          node = next;
        }

        self.remove();
      },

      <span class="hljs-comment">/**
       * Removes the node from it's parent.
       *
       * @example
       * node.remove();
       *
       * @method remove
       * @return {tinymce.html.Node} Current node that got removed.
       */</span>
      remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, parent = self.parent, next = self.next, prev = self.prev;

        <span class="hljs-keyword">if</span> (parent) {
          <span class="hljs-keyword">if</span> (parent.firstChild === self) {
            parent.firstChild = next;

            <span class="hljs-keyword">if</span> (next) {
              next.prev = <span class="hljs-literal">null</span>;
            }
          } <span class="hljs-keyword">else</span> {
            prev.next = next;
          }

          <span class="hljs-keyword">if</span> (parent.lastChild === self) {
            parent.lastChild = prev;

            <span class="hljs-keyword">if</span> (prev) {
              prev.next = <span class="hljs-literal">null</span>;
            }
          } <span class="hljs-keyword">else</span> {
            next.prev = prev;
          }

          self.parent = self.next = self.prev = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Appends a new node as a child of the current node.
       *
       * @example
       * node.append(someNode);
       *
       * @method append
       * @param {tinymce.html.Node} node Node to append as a child of the current one.
       * @return {tinymce.html.Node} The node that got appended.
       */</span>
      append: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, last;

        <span class="hljs-keyword">if</span> (node.parent) {
          node.remove();
        }

        last = self.lastChild;
        <span class="hljs-keyword">if</span> (last) {
          last.next = node;
          node.prev = last;
          self.lastChild = node;
        } <span class="hljs-keyword">else</span> {
          self.lastChild = self.firstChild = node;
        }

        node.parent = self;

        <span class="hljs-keyword">return</span> node;
      },

      <span class="hljs-comment">/**
       * Inserts a node at a specific position as a child of the current node.
       *
       * @example
       * parentNode.insert(newChildNode, oldChildNode);
       *
       * @method insert
       * @param {tinymce.html.Node} node Node to insert as a child of the current node.
       * @param {tinymce.html.Node} refNode Reference node to set node before/after.
       * @param {Boolean} before Optional state to insert the node before the reference node.
       * @return {tinymce.html.Node} The node that got inserted.
       */</span>
      insert: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, refNode, before</span>) </span>{
        <span class="hljs-keyword">var</span> parent;

        <span class="hljs-keyword">if</span> (node.parent) {
          node.remove();
        }

        parent = refNode.parent || <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (before) {
          <span class="hljs-keyword">if</span> (refNode === parent.firstChild) {
            parent.firstChild = node;
          } <span class="hljs-keyword">else</span> {
            refNode.prev.next = node;
          }

          node.prev = refNode.prev;
          node.next = refNode;
          refNode.prev = node;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (refNode === parent.lastChild) {
            parent.lastChild = node;
          } <span class="hljs-keyword">else</span> {
            refNode.next.prev = node;
          }

          node.next = refNode.next;
          node.prev = refNode;
          refNode.next = node;
        }

        node.parent = parent;

        <span class="hljs-keyword">return</span> node;
      },

      <span class="hljs-comment">/**
       * Get all children by name.
       *
       * @method getAll
       * @param {String} name Name of the child nodes to collect.
       * @return {Array} Array with child nodes matchin the specified name.
       */</span>
      getAll: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, node, collection = [];

        <span class="hljs-keyword">for</span> (node = self.firstChild; node; node = walk(node, self)) {
          <span class="hljs-keyword">if</span> (node.name === name) {
            collection.push(node);
          }
        }

        <span class="hljs-keyword">return</span> collection;
      },

      <span class="hljs-comment">/**
       * Removes all children of the current node.
       *
       * @method empty
       * @return {tinymce.html.Node} The current node that got cleared.
       */</span>
      empty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, nodes, i, node;</pre></div></div>
            
        </li>
        
        
        <li id="section-637">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-637">&#182;</a>
              </div>
              <p>Remove all children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self.firstChild) {
          nodes = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-638">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-638">&#182;</a>
              </div>
              <p>Collect the children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (node = self.firstChild; node; node = walk(node, self)) {
            nodes.push(node);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-639">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-639">&#182;</a>
              </div>
              <p>Remove the children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          i = nodes.length;
          <span class="hljs-keyword">while</span> (i--) {
            node = nodes[i];
            node.parent = node.firstChild = node.lastChild = node.next = node.prev = <span class="hljs-literal">null</span>;
          }
        }

        self.firstChild = self.lastChild = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Returns true/false if the node is to be considered empty or not.
       *
       * @example
       * node.isEmpty({img: true});
       * @method isEmpty
       * @param {Object} elements Name/value object with elements that are automatically treated as non empty elements.
       * @param {Object} whitespace Name/value object with elements that are automatically treated whitespace preservables.
       * @return {Boolean} true/false if the node is empty or not.
       */</span>
      isEmpty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elements, whitespace</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, node = self.firstChild, i, name;

        whitespace = whitespace || {};

        <span class="hljs-keyword">if</span> (node) {
          <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-640">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-640">&#182;</a>
              </div>
              <p>Ignore bogus elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (node.attributes.map[<span class="hljs-string">'data-mce-bogus'</span>]) {
                <span class="hljs-keyword">continue</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-641">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-641">&#182;</a>
              </div>
              <p>Keep empty elements like <img /></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (elements[node.name]) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-642">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-642">&#182;</a>
              </div>
              <p>Keep bookmark nodes and name attribute like <a name="1"></a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              i = node.attributes.length;
              <span class="hljs-keyword">while</span> (i--) {
                name = node.attributes[i].name;
                <span class="hljs-keyword">if</span> (name === <span class="hljs-string">"name"</span> || name.indexOf(<span class="hljs-string">'data-mce-bookmark'</span>) === <span class="hljs-number">0</span>) {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-643">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-643">&#182;</a>
              </div>
              <p>Keep comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">8</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-644">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-644">&#182;</a>
              </div>
              <p>Keep non whitespace text nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">3</span> &amp;&amp; !whiteSpaceRegExp.test(node.value)) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-645">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-645">&#182;</a>
              </div>
              <p>Keep whitespace preserve elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">3</span> &amp;&amp; node.parent &amp;&amp; whitespace[node.parent.name] &amp;&amp; whiteSpaceRegExp.test(node.value)) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          } <span class="hljs-keyword">while</span> ((node = walk(node, self)));
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      },

      <span class="hljs-comment">/**
       * Walks to the next or previous node and returns that node or null if it wasn't found.
       *
       * @method walk
       * @param {Boolean} prev Optional previous node state defaults to false.
       * @return {tinymce.html.Node} Node that is next to or previous of the current node.
       */</span>
      walk: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prev</span>) </span>{
        <span class="hljs-keyword">return</span> walk(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, prev);
      }
    };

    <span class="hljs-comment">/**
     * Creates a node of a specific type.
     *
     * @static
     * @method create
     * @param {String} name Name of the node type to create for example "b" or "#text".
     * @param {Object} attrs Name/value collection of attributes that will be applied to elements.
     */</span>
    Node.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, attrs</span>) </span>{
      <span class="hljs-keyword">var</span> node, attrName;</pre></div></div>
            
        </li>
        
        
        <li id="section-646">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-646">&#182;</a>
              </div>
              <p>Create node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      node = <span class="hljs-keyword">new</span> Node(name, typeLookup[name] || <span class="hljs-number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-647">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-647">&#182;</a>
              </div>
              <p>Add attributes if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (attrs) {
        <span class="hljs-keyword">for</span> (attrName <span class="hljs-keyword">in</span> attrs) {
          node.attr(attrName, attrs[attrName]);
        }
      }

      <span class="hljs-keyword">return</span> node;
    };

    <span class="hljs-keyword">return</span> Node;
  }
);

<span class="hljs-comment">/**
 * SaxParser.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/*eslint max-depth:[2, 9] */</span>

<span class="hljs-comment">/**
 * This class parses HTML code using pure JavaScript and executes various events for each item it finds. It will
 * always execute the events in the right order for tag soup code like &lt;b&gt;&lt;p&gt;&lt;/b&gt;&lt;/p&gt;. It will also remove elements
 * and attributes that doesn't fit the schema if the validate setting is enabled.
 *
 * @example
 * var parser = new tinymce.html.SaxParser({
 *     validate: true,
 *
 *     comment: function(text) {
 *         console.log('Comment:', text);
 *     },
 *
 *     cdata: function(text) {
 *         console.log('CDATA:', text);
 *     },
 *
 *     text: function(text, raw) {
 *         console.log('Text:', text, 'Raw:', raw);
 *     },
 *
 *     start: function(name, attrs, empty) {
 *         console.log('Start:', name, attrs, empty);
 *     },
 *
 *     end: function(name) {
 *         console.log('End:', name);
 *     },
 *
 *     pi: function(name, text) {
 *         console.log('PI:', name, text);
 *     },
 *
 *     doctype: function(text) {
 *         console.log('DocType:', text);
 *     }
 * }, schema);
 * @class tinymce.html.SaxParser
 * @version 3.4
 */</span>
define(
  <span class="hljs-string">'tinymce.core.html.SaxParser'</span>,
  [
    <span class="hljs-string">"tinymce.core.html.Schema"</span>,
    <span class="hljs-string">"tinymce.core.html.Entities"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Schema, Entities, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> each = Tools.each;

    <span class="hljs-keyword">var</span> isValidPrefixAttrName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
      <span class="hljs-keyword">return</span> name.indexOf(<span class="hljs-string">'data-'</span>) === <span class="hljs-number">0</span> || name.indexOf(<span class="hljs-string">'aria-'</span>) === <span class="hljs-number">0</span>;
    };

    <span class="hljs-comment">/**
     * Returns the index of the end tag for a specific start tag. This can be
     * used to skip all children of a parent element from being processed.
     *
     * @private
     * @method findEndTag
     * @param {tinymce.html.Schema} schema Schema instance to use to match short ended elements.
     * @param {String} html HTML string to find the end tag in.
     * @param {Number} startIndex Indext to start searching at should be after the start tag.
     * @return {Number} Index of the end tag.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findEndTag</span>(<span class="hljs-params">schema, html, startIndex</span>) </span>{
      <span class="hljs-keyword">var</span> count = <span class="hljs-number">1</span>, index, matches, tokenRegExp, shortEndedElements;

      shortEndedElements = schema.getShortEndedElements();
      tokenRegExp = <span class="hljs-regexp">/&lt;([!?\/])?([A-Za-z0-9\-_\:\.]+)((?:\s+[^"\'&gt;]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^&gt;]*))*|\/|\s+)&gt;/g</span>;
      tokenRegExp.lastIndex = index = startIndex;

      <span class="hljs-keyword">while</span> ((matches = tokenRegExp.exec(html))) {
        index = tokenRegExp.lastIndex;

        <span class="hljs-keyword">if</span> (matches[<span class="hljs-number">1</span>] === <span class="hljs-string">'/'</span>) { <span class="hljs-comment">// End element</span>
          count--;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!matches[<span class="hljs-number">1</span>]) { <span class="hljs-comment">// Start element</span>
          <span class="hljs-keyword">if</span> (matches[<span class="hljs-number">2</span>] <span class="hljs-keyword">in</span> shortEndedElements) {
            <span class="hljs-keyword">continue</span>;
          }

          count++;
        }

        <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">break</span>;
        }
      }

      <span class="hljs-keyword">return</span> index;
    }

    <span class="hljs-comment">/**
     * Constructs a new SaxParser instance.
     *
     * @constructor
     * @method SaxParser
     * @param {Object} settings Name/value collection of settings. comment, cdata, text, start and end are callbacks.
     * @param {tinymce.html.Schema} schema HTML Schema class to use when parsing.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SaxParser</span>(<span class="hljs-params">settings, schema</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span>(<span class="hljs-params"></span>) </span>{ }

      settings = settings || {};
      self.schema = schema = schema || <span class="hljs-keyword">new</span> Schema();

      <span class="hljs-keyword">if</span> (settings.fix_self_closing !== <span class="hljs-literal">false</span>) {
        settings.fix_self_closing = <span class="hljs-literal">true</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-648">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-648">&#182;</a>
              </div>
              <p>Add handler functions from settings and setup default handlers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      each(<span class="hljs-string">'comment cdata text start end pi doctype'</span>.split(<span class="hljs-string">' '</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">if</span> (name) {
          self[name] = settings[name] || noop;
        }
      });

      <span class="hljs-comment">/**
       * Parses the specified HTML string and executes the callbacks for each item it finds.
       *
       * @example
       * new SaxParser({...}).parse('&lt;b&gt;text&lt;/b&gt;');
       * @method parse
       * @param {String} html Html string to sax parse.
       */</span>
      self.parse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">html</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, matches, index = <span class="hljs-number">0</span>, value, endRegExp, stack = [], attrList, i, text, name;
        <span class="hljs-keyword">var</span> isInternalElement, removeInternalElements, shortEndedElements, fillAttrsMap, isShortEnded;
        <span class="hljs-keyword">var</span> validate, elementRule, isValidElement, attr, attribsValue, validAttributesMap, validAttributePatterns;
        <span class="hljs-keyword">var</span> attributesRequired, attributesDefault, attributesForced;
        <span class="hljs-keyword">var</span> anyAttributesRequired, selfClosing, tokenRegExp, attrRegExp, specialElements, attrValue, idCount = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> decode = Entities.decode, fixSelfClosing, filteredUrlAttrs = Tools.makeMap(<span class="hljs-string">'src,href,data,background,formaction,poster'</span>);
        <span class="hljs-keyword">var</span> scriptUriRegExp = <span class="hljs-regexp">/((java|vb)script|mhtml):/i</span>, dataUriRegExp = <span class="hljs-regexp">/^data:/i</span>;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processEndTag</span>(<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">var</span> pos, i;</pre></div></div>
            
        </li>
        
        
        <li id="section-649">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-649">&#182;</a>
              </div>
              <p>Find position of parent of the same type</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          pos = stack.length;
          <span class="hljs-keyword">while</span> (pos--) {
            <span class="hljs-keyword">if</span> (stack[pos].name === name) {
              <span class="hljs-keyword">break</span>;
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-650">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-650">&#182;</a>
              </div>
              <p>Found parent</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (pos &gt;= <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-651">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-651">&#182;</a>
              </div>
              <p>Close all the open elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">for</span> (i = stack.length - <span class="hljs-number">1</span>; i &gt;= pos; i--) {
              name = stack[i];

              <span class="hljs-keyword">if</span> (name.valid) {
                self.end(name.name);
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-652">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-652">&#182;</a>
              </div>
              <p>Remove the open elements from the stack</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            stack.length = pos;
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseAttribute</span>(<span class="hljs-params">match, name, value, val2, val3</span>) </span>{
          <span class="hljs-keyword">var</span> attrRule, i, trimRegExp = <span class="hljs-regexp">/[\s\u0000-\u001F]+/g</span>;

          name = name.toLowerCase();
          value = name <span class="hljs-keyword">in</span> fillAttrsMap ? name : decode(value || val2 || val3 || <span class="hljs-string">''</span>); <span class="hljs-comment">// Handle boolean attribute than value attribute</span></pre></div></div>
            
        </li>
        
        
        <li id="section-653">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-653">&#182;</a>
              </div>
              <p>Validate name and value pass through all data- attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (validate &amp;&amp; !isInternalElement &amp;&amp; isValidPrefixAttrName(name) === <span class="hljs-literal">false</span>) {
            attrRule = validAttributesMap[name];</pre></div></div>
            
        </li>
        
        
        <li id="section-654">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-654">&#182;</a>
              </div>
              <p>Find rule by pattern matching</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!attrRule &amp;&amp; validAttributePatterns) {
              i = validAttributePatterns.length;
              <span class="hljs-keyword">while</span> (i--) {
                attrRule = validAttributePatterns[i];
                <span class="hljs-keyword">if</span> (attrRule.pattern.test(name)) {
                  <span class="hljs-keyword">break</span>;
                }
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-655">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-655">&#182;</a>
              </div>
              <p>No rule matched</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (i === <span class="hljs-number">-1</span>) {
                attrRule = <span class="hljs-literal">null</span>;
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-656">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-656">&#182;</a>
              </div>
              <p>No attribute rule found</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!attrRule) {
              <span class="hljs-keyword">return</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-657">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-657">&#182;</a>
              </div>
              <p>Validate value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (attrRule.validValues &amp;&amp; !(value <span class="hljs-keyword">in</span> attrRule.validValues)) {
              <span class="hljs-keyword">return</span>;
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-658">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-658">&#182;</a>
              </div>
              <p>Block any javascript: urls or non image data uris</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (filteredUrlAttrs[name] &amp;&amp; !settings.allow_script_urls) {
            <span class="hljs-keyword">var</span> uri = value.replace(trimRegExp, <span class="hljs-string">''</span>);

            <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-659">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-659">&#182;</a>
              </div>
              <p>Might throw malformed URI sequence</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              uri = <span class="hljs-built_in">decodeURIComponent</span>(uri);
            } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-660">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-660">&#182;</a>
              </div>
              <p>Fallback to non UTF-8 decoder</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              uri = <span class="hljs-built_in">unescape</span>(uri);
            }

            <span class="hljs-keyword">if</span> (scriptUriRegExp.test(uri)) {
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (!settings.allow_html_data_urls &amp;&amp; dataUriRegExp.test(uri) &amp;&amp; !<span class="hljs-regexp">/^data:image\//i</span>.test(uri)) {
              <span class="hljs-keyword">return</span>;
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-661">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-661">&#182;</a>
              </div>
              <p>Add attribute to list and map</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          attrList.map[name] = value;
          attrList.push({
            <span class="hljs-attr">name</span>: name,
            <span class="hljs-attr">value</span>: value
          });
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-662">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-662">&#182;</a>
              </div>
              <p>Precompile RegExps and map objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        tokenRegExp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'&lt;(?:'</span> +
          <span class="hljs-string">'(?:!--([\\w\\W]*?)--&gt;)|'</span> + <span class="hljs-comment">// Comment</span>
          <span class="hljs-string">'(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]&gt;)|'</span> + <span class="hljs-comment">// CDATA</span>
          <span class="hljs-string">'(?:!DOCTYPE([\\w\\W]*?)&gt;)|'</span> + <span class="hljs-comment">// DOCTYPE</span>
          <span class="hljs-string">'(?:\\?([^\\s\\/&lt;&gt;]+) ?([\\w\\W]*?)[?/]&gt;)|'</span> + <span class="hljs-comment">// PI</span>
          <span class="hljs-string">'(?:\\/([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)&gt;)|'</span> + <span class="hljs-comment">// End element</span>
          <span class="hljs-string">'(?:([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)((?:\\s+[^"\'&gt;]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^&gt;]*))*|\\/|\\s+)&gt;)'</span> + <span class="hljs-comment">// Start element</span>
          <span class="hljs-string">')'</span>, <span class="hljs-string">'g'</span>);

        attrRegExp = <span class="hljs-regexp">/([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^&gt;\s]+)))?/g</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-663">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-663">&#182;</a>
              </div>
              <p>Setup lookup tables for empty elements and boolean attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        shortEndedElements = schema.getShortEndedElements();
        selfClosing = settings.self_closing_elements || schema.getSelfClosingElements();
        fillAttrsMap = schema.getBoolAttrs();
        validate = settings.validate;
        removeInternalElements = settings.remove_internals;
        fixSelfClosing = settings.fix_self_closing;
        specialElements = schema.getSpecialElements();

        <span class="hljs-keyword">while</span> ((matches = tokenRegExp.exec(html + <span class="hljs-string">'&gt;'</span>))) { <span class="hljs-comment">// Adds and extra '&gt;' to keep regexps from doing catastrofic backtracking on malformed html</span></pre></div></div>
            
        </li>
        
        
        <li id="section-664">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-664">&#182;</a>
              </div>
              <p>Text</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (index &lt; matches.index) {
            self.text(decode(html.substr(index, matches.index - index)));
          }

          <span class="hljs-keyword">if</span> ((value = matches[<span class="hljs-number">6</span>])) { <span class="hljs-comment">// End element</span>
            value = value.toLowerCase();</pre></div></div>
            
        </li>
        
        
        <li id="section-665">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-665">&#182;</a>
              </div>
              <p>IE will add a : in front of elements it doesnt understand like custom elements or HTML5 elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (value.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">':'</span>) {
              value = value.substr(<span class="hljs-number">1</span>);
            }

            processEndTag(value);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((value = matches[<span class="hljs-number">7</span>])) { <span class="hljs-comment">// Start element</span></pre></div></div>
            
        </li>
        
        
        <li id="section-666">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-666">&#182;</a>
              </div>
              <p>Did we consume the extra character then treat it as text
This handles the case with html like this: text a&lt;b text</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (matches.index + matches[<span class="hljs-number">0</span>].length &gt; html.length) {
              self.text(decode(html.substr(matches.index)));
              index = matches.index + matches[<span class="hljs-number">0</span>].length;
              <span class="hljs-keyword">continue</span>;
            }

            value = value.toLowerCase();</pre></div></div>
            
        </li>
        
        
        <li id="section-667">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-667">&#182;</a>
              </div>
              <p>IE will add a : in front of elements it doesnt understand like custom elements or HTML5 elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (value.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">':'</span>) {
              value = value.substr(<span class="hljs-number">1</span>);
            }

            isShortEnded = value <span class="hljs-keyword">in</span> shortEndedElements;</pre></div></div>
            
        </li>
        
        
        <li id="section-668">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-668">&#182;</a>
              </div>
              <p>Is self closing tag for example an <li> after an open <li></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (fixSelfClosing &amp;&amp; selfClosing[value] &amp;&amp; stack.length &gt; <span class="hljs-number">0</span> &amp;&amp; stack[stack.length - <span class="hljs-number">1</span>].name === value) {
              processEndTag(value);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-669">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-669">&#182;</a>
              </div>
              <p>Validate element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!validate || (elementRule = schema.getElementRule(value))) {
              isValidElement = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-670">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-670">&#182;</a>
              </div>
              <p>Grab attributes map and patters when validation is enabled</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (validate) {
                validAttributesMap = elementRule.attributes;
                validAttributePatterns = elementRule.attributePatterns;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-671">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-671">&#182;</a>
              </div>
              <p>Parse attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> ((attribsValue = matches[<span class="hljs-number">8</span>])) {
                isInternalElement = attribsValue.indexOf(<span class="hljs-string">'data-mce-type'</span>) !== <span class="hljs-number">-1</span>; <span class="hljs-comment">// Check if the element is an internal element</span></pre></div></div>
            
        </li>
        
        
        <li id="section-672">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-672">&#182;</a>
              </div>
              <p>If the element has internal attributes then remove it if we are told to do so</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (isInternalElement &amp;&amp; removeInternalElements) {
                  isValidElement = <span class="hljs-literal">false</span>;
                }

                attrList = [];
                attrList.map = {};

                attribsValue.replace(attrRegExp, parseAttribute);
              } <span class="hljs-keyword">else</span> {
                attrList = [];
                attrList.map = {};
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-673">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-673">&#182;</a>
              </div>
              <p>Process attributes if validation is enabled</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (validate &amp;&amp; !isInternalElement) {
                attributesRequired = elementRule.attributesRequired;
                attributesDefault = elementRule.attributesDefault;
                attributesForced = elementRule.attributesForced;
                anyAttributesRequired = elementRule.removeEmptyAttrs;</pre></div></div>
            
        </li>
        
        
        <li id="section-674">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-674">&#182;</a>
              </div>
              <p>Check if any attribute exists</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (anyAttributesRequired &amp;&amp; !attrList.length) {
                  isValidElement = <span class="hljs-literal">false</span>;
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-675">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-675">&#182;</a>
              </div>
              <p>Handle forced attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (attributesForced) {
                  i = attributesForced.length;
                  <span class="hljs-keyword">while</span> (i--) {
                    attr = attributesForced[i];
                    name = attr.name;
                    attrValue = attr.value;

                    <span class="hljs-keyword">if</span> (attrValue === <span class="hljs-string">'{$uid}'</span>) {
                      attrValue = <span class="hljs-string">'mce_'</span> + idCount++;
                    }

                    attrList.map[name] = attrValue;
                    attrList.push({ <span class="hljs-attr">name</span>: name, <span class="hljs-attr">value</span>: attrValue });
                  }
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-676">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-676">&#182;</a>
              </div>
              <p>Handle default attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (attributesDefault) {
                  i = attributesDefault.length;
                  <span class="hljs-keyword">while</span> (i--) {
                    attr = attributesDefault[i];
                    name = attr.name;

                    <span class="hljs-keyword">if</span> (!(name <span class="hljs-keyword">in</span> attrList.map)) {
                      attrValue = attr.value;

                      <span class="hljs-keyword">if</span> (attrValue === <span class="hljs-string">'{$uid}'</span>) {
                        attrValue = <span class="hljs-string">'mce_'</span> + idCount++;
                      }

                      attrList.map[name] = attrValue;
                      attrList.push({ <span class="hljs-attr">name</span>: name, <span class="hljs-attr">value</span>: attrValue });
                    }
                  }
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-677">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-677">&#182;</a>
              </div>
              <p>Handle required attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (attributesRequired) {
                  i = attributesRequired.length;
                  <span class="hljs-keyword">while</span> (i--) {
                    <span class="hljs-keyword">if</span> (attributesRequired[i] <span class="hljs-keyword">in</span> attrList.map) {
                      <span class="hljs-keyword">break</span>;
                    }
                  }</pre></div></div>
            
        </li>
        
        
        <li id="section-678">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-678">&#182;</a>
              </div>
              <p>None of the required attributes where found</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">-1</span>) {
                    isValidElement = <span class="hljs-literal">false</span>;
                  }
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-679">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-679">&#182;</a>
              </div>
              <p>Invalidate element if its marked as bogus</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> ((attr = attrList.map[<span class="hljs-string">'data-mce-bogus'</span>])) {
                  <span class="hljs-keyword">if</span> (attr === <span class="hljs-string">'all'</span>) {
                    index = findEndTag(schema, html, tokenRegExp.lastIndex);
                    tokenRegExp.lastIndex = index;
                    <span class="hljs-keyword">continue</span>;
                  }

                  isValidElement = <span class="hljs-literal">false</span>;
                }
              }

              <span class="hljs-keyword">if</span> (isValidElement) {
                self.start(value, attrList, isShortEnded);
              }
            } <span class="hljs-keyword">else</span> {
              isValidElement = <span class="hljs-literal">false</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-680">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-680">&#182;</a>
              </div>
              <p>Treat script, noscript and style a bit different since they may include code that looks like elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ((endRegExp = specialElements[value])) {
              endRegExp.lastIndex = index = matches.index + matches[<span class="hljs-number">0</span>].length;

              <span class="hljs-keyword">if</span> ((matches = endRegExp.exec(html))) {
                <span class="hljs-keyword">if</span> (isValidElement) {
                  text = html.substr(index, matches.index - index);
                }

                index = matches.index + matches[<span class="hljs-number">0</span>].length;
              } <span class="hljs-keyword">else</span> {
                text = html.substr(index);
                index = html.length;
              }

              <span class="hljs-keyword">if</span> (isValidElement) {
                <span class="hljs-keyword">if</span> (text.length &gt; <span class="hljs-number">0</span>) {
                  self.text(text, <span class="hljs-literal">true</span>);
                }

                self.end(value);
              }

              tokenRegExp.lastIndex = index;
              <span class="hljs-keyword">continue</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-681">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-681">&#182;</a>
              </div>
              <p>Push value on to stack</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!isShortEnded) {
              <span class="hljs-keyword">if</span> (!attribsValue || attribsValue.indexOf(<span class="hljs-string">'/'</span>) != attribsValue.length - <span class="hljs-number">1</span>) {
                stack.push({ <span class="hljs-attr">name</span>: value, <span class="hljs-attr">valid</span>: isValidElement });
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isValidElement) {
                self.end(value);
              }
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((value = matches[<span class="hljs-number">1</span>])) { <span class="hljs-comment">// Comment</span></pre></div></div>
            
        </li>
        
        
        <li id="section-682">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-682">&#182;</a>
              </div>
              <p>Padd comment value to avoid browsers from parsing invalid comments as HTML</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (value.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'&gt;'</span>) {
              value = <span class="hljs-string">' '</span> + value;
            }

            <span class="hljs-keyword">if</span> (!settings.allow_conditional_comments &amp;&amp; value.substr(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>).toLowerCase() === <span class="hljs-string">'[if'</span>) {
              value = <span class="hljs-string">' '</span> + value;
            }

            self.comment(value);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((value = matches[<span class="hljs-number">2</span>])) { <span class="hljs-comment">// CDATA</span>
            self.cdata(value);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((value = matches[<span class="hljs-number">3</span>])) { <span class="hljs-comment">// DOCTYPE</span>
            self.doctype(value);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((value = matches[<span class="hljs-number">4</span>])) { <span class="hljs-comment">// PI</span>
            self.pi(value, matches[<span class="hljs-number">5</span>]);
          }

          index = matches.index + matches[<span class="hljs-number">0</span>].length;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-683">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-683">&#182;</a>
              </div>
              <p>Text</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (index &lt; html.length) {
          self.text(decode(html.substr(index)));
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-684">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-684">&#182;</a>
              </div>
              <p>Close any open elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (i = stack.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
          value = stack[i];

          <span class="hljs-keyword">if</span> (value.valid) {
            self.end(value.name);
          }
        }
      };
    }

    SaxParser.findEndTag = findEndTag;

    <span class="hljs-keyword">return</span> SaxParser;
  }
);
<span class="hljs-comment">/**
 * DomParser.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class parses HTML code into a DOM like structure of nodes it will remove redundant whitespace and make
 * sure that the node tree is valid according to the specified schema.
 * So for example: &lt;p&gt;a&lt;p&gt;b&lt;/p&gt;c&lt;/p&gt; will become &lt;p&gt;a&lt;/p&gt;&lt;p&gt;b&lt;/p&gt;&lt;p&gt;c&lt;/p&gt;
 *
 * @example
 * var parser = new tinymce.html.DomParser({validate: true}, schema);
 * var rootNode = parser.parse('&lt;h1&gt;content&lt;/h1&gt;');
 *
 * @class tinymce.html.DomParser
 * @version 3.4
 */</span>
define(
  <span class="hljs-string">'tinymce.core.html.DomParser'</span>,
  [
    <span class="hljs-string">"tinymce.core.html.Node"</span>,
    <span class="hljs-string">"tinymce.core.html.Schema"</span>,
    <span class="hljs-string">"tinymce.core.html.SaxParser"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Node, Schema, SaxParser, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> makeMap = Tools.makeMap, each = Tools.each, explode = Tools.explode, extend = Tools.extend;

    <span class="hljs-keyword">var</span> paddEmptyNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings, node</span>) </span>{
      <span class="hljs-keyword">if</span> (settings.padd_empty_with_br) {
        node.empty().append(<span class="hljs-keyword">new</span> Node(<span class="hljs-string">'br'</span>, <span class="hljs-string">'1'</span>)).shortEnded = <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> {
        node.empty().append(<span class="hljs-keyword">new</span> Node(<span class="hljs-string">'#text'</span>, <span class="hljs-string">'3'</span>)).value = <span class="hljs-string">'\u00a0'</span>;
      }
    };

    <span class="hljs-keyword">var</span> hasOnlyChild = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, name</span>) </span>{
      <span class="hljs-keyword">return</span> node &amp;&amp; node.firstChild === node.lastChild &amp;&amp; node.firstChild.name === name;
    };

    <span class="hljs-comment">/**
     * Constructs a new DomParser instance.
     *
     * @constructor
     * @method DomParser
     * @param {Object} settings Name/value collection of settings. comment, cdata, text, start and end are callbacks.
     * @param {tinymce.html.Schema} schema HTML Schema class to use when parsing.
     */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings, schema</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, nodeFilters = {}, attributeFilters = [], matchedNodes = {}, matchedAttributes = {};

      settings = settings || {};
      settings.validate = <span class="hljs-string">"validate"</span> <span class="hljs-keyword">in</span> settings ? settings.validate : <span class="hljs-literal">true</span>;
      settings.root_name = settings.root_name || <span class="hljs-string">'body'</span>;
      self.schema = schema = schema || <span class="hljs-keyword">new</span> Schema();

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fixInvalidChildren</span>(<span class="hljs-params">nodes</span>) </span>{
        <span class="hljs-keyword">var</span> ni, node, parent, parents, newParent, currentNode, tempNode, childNode, i;
        <span class="hljs-keyword">var</span> nonEmptyElements, whitespaceElements, nonSplitableElements, textBlockElements, specialElements, sibling, nextNode;

        nonSplitableElements = makeMap(<span class="hljs-string">'tr,td,th,tbody,thead,tfoot,table'</span>);
        nonEmptyElements = schema.getNonEmptyElements();
        whitespaceElements = schema.getWhiteSpaceElements();
        textBlockElements = schema.getTextBlockElements();
        specialElements = schema.getSpecialElements();

        <span class="hljs-keyword">for</span> (ni = <span class="hljs-number">0</span>; ni &lt; nodes.length; ni++) {
          node = nodes[ni];</pre></div></div>
            
        </li>
        
        
        <li id="section-685">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-685">&#182;</a>
              </div>
              <p>Already removed or fixed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!node.parent || node.fixed) {
            <span class="hljs-keyword">continue</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-686">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-686">&#182;</a>
              </div>
              <p>If the invalid element is a text block and the text block is within a parent LI element
Then unwrap the first text block and convert other sibling text blocks to LI elements similar to Word/Open Office</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (textBlockElements[node.name] &amp;&amp; node.parent.name == <span class="hljs-string">'li'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-687">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-687">&#182;</a>
              </div>
              <p>Move sibling text blocks after LI element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            sibling = node.next;
            <span class="hljs-keyword">while</span> (sibling) {
              <span class="hljs-keyword">if</span> (textBlockElements[sibling.name]) {
                sibling.name = <span class="hljs-string">'li'</span>;
                sibling.fixed = <span class="hljs-literal">true</span>;
                node.parent.insert(sibling, node.parent);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">break</span>;
              }

              sibling = sibling.next;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-688">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-688">&#182;</a>
              </div>
              <p>Unwrap current text block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            node.unwrap(node);
            <span class="hljs-keyword">continue</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-689">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-689">&#182;</a>
              </div>
              <p>Get list of all parent nodes until we find a valid parent to stick the child into</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          parents = [node];
          <span class="hljs-keyword">for</span> (parent = node.parent; parent &amp;&amp; !schema.isValidChild(parent.name, node.name) &amp;&amp;
            !nonSplitableElements[parent.name]; parent = parent.parent) {
            parents.push(parent);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-690">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-690">&#182;</a>
              </div>
              <p>Found a suitable parent</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (parent &amp;&amp; parents.length &gt; <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-691">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-691">&#182;</a>
              </div>
              <p>Reverse the array since it makes looping easier</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            parents.reverse();</pre></div></div>
            
        </li>
        
        
        <li id="section-692">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-692">&#182;</a>
              </div>
              <p>Clone the related parent and insert that after the moved node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            newParent = currentNode = self.filterNode(parents[<span class="hljs-number">0</span>].clone());</pre></div></div>
            
        </li>
        
        
        <li id="section-693">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-693">&#182;</a>
              </div>
              <p>Start cloning and moving children on the left side of the target node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; parents.length - <span class="hljs-number">1</span>; i++) {
              <span class="hljs-keyword">if</span> (schema.isValidChild(currentNode.name, parents[i].name)) {
                tempNode = self.filterNode(parents[i].clone());
                currentNode.append(tempNode);
              } <span class="hljs-keyword">else</span> {
                tempNode = currentNode;
              }

              <span class="hljs-keyword">for</span> (childNode = parents[i].firstChild; childNode &amp;&amp; childNode != parents[i + <span class="hljs-number">1</span>];) {
                nextNode = childNode.next;
                tempNode.append(childNode);
                childNode = nextNode;
              }

              currentNode = tempNode;
            }

            <span class="hljs-keyword">if</span> (!newParent.isEmpty(nonEmptyElements, whitespaceElements)) {
              parent.insert(newParent, parents[<span class="hljs-number">0</span>], <span class="hljs-literal">true</span>);
              parent.insert(node, newParent);
            } <span class="hljs-keyword">else</span> {
              parent.insert(node, parents[<span class="hljs-number">0</span>], <span class="hljs-literal">true</span>);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-694">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-694">&#182;</a>
              </div>
              <p>Check if the element is empty by looking through its contents and special treatment for <p><br /></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            parent = parents[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (parent.isEmpty(nonEmptyElements, whitespaceElements) || hasOnlyChild(parent, <span class="hljs-string">'br'</span>)) {
              parent.empty().remove();
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.parent) {</pre></div></div>
            
        </li>
        
        
        <li id="section-695">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-695">&#182;</a>
              </div>
              <p>If its an LI try to find a UL/OL for it or wrap it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (node.name === <span class="hljs-string">'li'</span>) {
              sibling = node.prev;
              <span class="hljs-keyword">if</span> (sibling &amp;&amp; (sibling.name === <span class="hljs-string">'ul'</span> || sibling.name === <span class="hljs-string">'ul'</span>)) {
                sibling.append(node);
                <span class="hljs-keyword">continue</span>;
              }

              sibling = node.next;
              <span class="hljs-keyword">if</span> (sibling &amp;&amp; (sibling.name === <span class="hljs-string">'ul'</span> || sibling.name === <span class="hljs-string">'ul'</span>)) {
                sibling.insert(node, sibling.firstChild, <span class="hljs-literal">true</span>);
                <span class="hljs-keyword">continue</span>;
              }

              node.wrap(self.filterNode(<span class="hljs-keyword">new</span> Node(<span class="hljs-string">'ul'</span>, <span class="hljs-number">1</span>)));
              <span class="hljs-keyword">continue</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-696">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-696">&#182;</a>
              </div>
              <p>Try wrapping the element in a DIV</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (schema.isValidChild(node.parent.name, <span class="hljs-string">'div'</span>) &amp;&amp; schema.isValidChild(<span class="hljs-string">'div'</span>, node.name)) {
              node.wrap(self.filterNode(<span class="hljs-keyword">new</span> Node(<span class="hljs-string">'div'</span>, <span class="hljs-number">1</span>)));
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-697">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-697">&#182;</a>
              </div>
              <p>We failed wrapping it, then remove or unwrap it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (specialElements[node.name]) {
                node.empty().remove();
              } <span class="hljs-keyword">else</span> {
                node.unwrap();
              }
            }
          }
        }
      }

      <span class="hljs-comment">/**
       * Runs the specified node though the element and attributes filters.
       *
       * @method filterNode
       * @param {tinymce.html.Node} Node the node to run filters on.
       * @return {tinymce.html.Node} The passed in node.
       */</span>
      self.filterNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> i, name, list;</pre></div></div>
            
        </li>
        
        
        <li id="section-698">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-698">&#182;</a>
              </div>
              <p>Run element filters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> nodeFilters) {
          list = matchedNodes[name];

          <span class="hljs-keyword">if</span> (list) {
            list.push(node);
          } <span class="hljs-keyword">else</span> {
            matchedNodes[name] = [node];
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-699">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-699">&#182;</a>
              </div>
              <p>Run attribute filters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        i = attributeFilters.length;
        <span class="hljs-keyword">while</span> (i--) {
          name = attributeFilters[i].name;

          <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> node.attributes.map) {
            list = matchedAttributes[name];

            <span class="hljs-keyword">if</span> (list) {
              list.push(node);
            } <span class="hljs-keyword">else</span> {
              matchedAttributes[name] = [node];
            }
          }
        }

        <span class="hljs-keyword">return</span> node;
      };

      <span class="hljs-comment">/**
       * Adds a node filter function to the parser, the parser will collect the specified nodes by name
       * and then execute the callback ones it has finished parsing the document.
       *
       * @example
       * parser.addNodeFilter('p,h1', function(nodes, name) {
       *  for (var i = 0; i &lt; nodes.length; i++) {
       *   console.log(nodes[i].name);
       *  }
       * });
       * @method addNodeFilter
       * @method {String} name Comma separated list of nodes to collect.
       * @param {function} callback Callback function to execute once it has collected nodes.
       */</span>
      self.addNodeFilter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, callback</span>) </span>{
        each(explode(name), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">var</span> list = nodeFilters[name];

          <span class="hljs-keyword">if</span> (!list) {
            nodeFilters[name] = list = [];
          }

          list.push(callback);
        });
      };

      <span class="hljs-comment">/**
       * Adds a attribute filter function to the parser, the parser will collect nodes that has the specified attributes
       * and then execute the callback ones it has finished parsing the document.
       *
       * @example
       * parser.addAttributeFilter('src,href', function(nodes, name) {
       *  for (var i = 0; i &lt; nodes.length; i++) {
       *   console.log(nodes[i].name);
       *  }
       * });
       * @method addAttributeFilter
       * @method {String} name Comma separated list of nodes to collect.
       * @param {function} callback Callback function to execute once it has collected nodes.
       */</span>
      self.addAttributeFilter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, callback</span>) </span>{
        each(explode(name), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">var</span> i;

          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; attributeFilters.length; i++) {
            <span class="hljs-keyword">if</span> (attributeFilters[i].name === name) {
              attributeFilters[i].callbacks.push(callback);
              <span class="hljs-keyword">return</span>;
            }
          }

          attributeFilters.push({ <span class="hljs-attr">name</span>: name, <span class="hljs-attr">callbacks</span>: [callback] });
        });
      };

      <span class="hljs-comment">/**
       * Parses the specified HTML string into a DOM like node tree and returns the result.
       *
       * @example
       * var rootNode = new DomParser({...}).parse('&lt;b&gt;text&lt;/b&gt;');
       * @method parse
       * @param {String} html Html string to sax parse.
       * @param {Object} args Optional args object that gets passed to all filter functions.
       * @return {tinymce.html.Node} Root node containing the tree.
       */</span>
      self.parse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">html, args</span>) </span>{
        <span class="hljs-keyword">var</span> parser, rootNode, node, nodes, i, l, fi, fl, list, name, validate;
        <span class="hljs-keyword">var</span> blockElements, startWhiteSpaceRegExp, invalidChildren = [], isInWhiteSpacePreservedElement;
        <span class="hljs-keyword">var</span> endWhiteSpaceRegExp, allWhiteSpaceRegExp, isAllWhiteSpaceRegExp, whiteSpaceElements;
        <span class="hljs-keyword">var</span> children, nonEmptyElements, rootBlockName;

        args = args || {};
        matchedNodes = {};
        matchedAttributes = {};
        blockElements = extend(makeMap(<span class="hljs-string">'script,style,head,html,body,title,meta,param'</span>), schema.getBlockElements());
        nonEmptyElements = schema.getNonEmptyElements();
        children = schema.children;
        validate = settings.validate;
        rootBlockName = <span class="hljs-string">"forced_root_block"</span> <span class="hljs-keyword">in</span> args ? args.forced_root_block : settings.forced_root_block;

        whiteSpaceElements = schema.getWhiteSpaceElements();
        startWhiteSpaceRegExp = <span class="hljs-regexp">/^[ \t\r\n]+/</span>;
        endWhiteSpaceRegExp = <span class="hljs-regexp">/[ \t\r\n]+$/</span>;
        allWhiteSpaceRegExp = <span class="hljs-regexp">/[ \t\r\n]+/g</span>;
        isAllWhiteSpaceRegExp = <span class="hljs-regexp">/^[ \t\r\n]+$/</span>;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRootBlocks</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> node = rootNode.firstChild, next, rootBlockNode;</pre></div></div>
            
        </li>
        
        
        <li id="section-700">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-700">&#182;</a>
              </div>
              <p>Removes whitespace at beginning and end of block so:</p>
<p> x </p> -&gt; <p>x</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trim</span>(<span class="hljs-params">rootBlockNode</span>) </span>{
            <span class="hljs-keyword">if</span> (rootBlockNode) {
              node = rootBlockNode.firstChild;
              <span class="hljs-keyword">if</span> (node &amp;&amp; node.type == <span class="hljs-number">3</span>) {
                node.value = node.value.replace(startWhiteSpaceRegExp, <span class="hljs-string">''</span>);
              }

              node = rootBlockNode.lastChild;
              <span class="hljs-keyword">if</span> (node &amp;&amp; node.type == <span class="hljs-number">3</span>) {
                node.value = node.value.replace(endWhiteSpaceRegExp, <span class="hljs-string">''</span>);
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-701">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-701">&#182;</a>
              </div>
              <p>Check if rootBlock is valid within rootNode for example if P is valid in H1 if H1 is the contentEditabe root</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">while</span> (node) {
            next = node.next;

            <span class="hljs-keyword">if</span> (node.type == <span class="hljs-number">3</span> || (node.type == <span class="hljs-number">1</span> &amp;&amp; node.name !== <span class="hljs-string">'p'</span> &amp;&amp;
              !blockElements[node.name] &amp;&amp; !node.attr(<span class="hljs-string">'data-mce-type'</span>))) {
              <span class="hljs-keyword">if</span> (!rootBlockNode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-702">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-702">&#182;</a>
              </div>
              <p>Create a new root block element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                rootBlockNode = createNode(rootBlockName, <span class="hljs-number">1</span>);
                rootBlockNode.attr(settings.forced_root_block_attrs);
                rootNode.insert(rootBlockNode, node);
                rootBlockNode.append(node);
              } <span class="hljs-keyword">else</span> {
                rootBlockNode.append(node);
              }
            } <span class="hljs-keyword">else</span> {
              trim(rootBlockNode);
              rootBlockNode = <span class="hljs-literal">null</span>;
            }

            node = next;
          }

          trim(rootBlockNode);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createNode</span>(<span class="hljs-params">name, type</span>) </span>{
          <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(name, type), list;

          <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> nodeFilters) {
            list = matchedNodes[name];

            <span class="hljs-keyword">if</span> (list) {
              list.push(node);
            } <span class="hljs-keyword">else</span> {
              matchedNodes[name] = [node];
            }
          }

          <span class="hljs-keyword">return</span> node;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeWhitespaceBefore</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> textNode, textNodeNext, textVal, sibling, blockElements = schema.getBlockElements();

          <span class="hljs-keyword">for</span> (textNode = node.prev; textNode &amp;&amp; textNode.type === <span class="hljs-number">3</span>;) {
            textVal = textNode.value.replace(endWhiteSpaceRegExp, <span class="hljs-string">''</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-703">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-703">&#182;</a>
              </div>
              <p>Found a text node with non whitespace then trim that and break</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (textVal.length &gt; <span class="hljs-number">0</span>) {
              textNode.value = textVal;
              <span class="hljs-keyword">return</span>;
            }

            textNodeNext = textNode.next;</pre></div></div>
            
        </li>
        
        
        <li id="section-704">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-704">&#182;</a>
              </div>
              <p>Fix for bug #7543 where bogus nodes would produce empty
text nodes and these would be removed if a nested list was before it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (textNodeNext) {
              <span class="hljs-keyword">if</span> (textNodeNext.type == <span class="hljs-number">3</span> &amp;&amp; textNodeNext.value.length) {
                textNode = textNode.prev;
                <span class="hljs-keyword">continue</span>;
              }

              <span class="hljs-keyword">if</span> (!blockElements[textNodeNext.name] &amp;&amp; textNodeNext.name != <span class="hljs-string">'script'</span> &amp;&amp; textNodeNext.name != <span class="hljs-string">'style'</span>) {
                textNode = textNode.prev;
                <span class="hljs-keyword">continue</span>;
              }
            }

            sibling = textNode.prev;
            textNode.remove();
            textNode = sibling;
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneAndExcludeBlocks</span>(<span class="hljs-params">input</span>) </span>{
          <span class="hljs-keyword">var</span> name, output = {};

          <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> input) {
            <span class="hljs-keyword">if</span> (name !== <span class="hljs-string">'li'</span> &amp;&amp; name != <span class="hljs-string">'p'</span>) {
              output[name] = input[name];
            }
          }

          <span class="hljs-keyword">return</span> output;
        }

        parser = <span class="hljs-keyword">new</span> SaxParser({
          <span class="hljs-attr">validate</span>: validate,
          <span class="hljs-attr">allow_script_urls</span>: settings.allow_script_urls,
          <span class="hljs-attr">allow_conditional_comments</span>: settings.allow_conditional_comments,</pre></div></div>
            
        </li>
        
        
        <li id="section-705">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-705">&#182;</a>
              </div>
              <p>Exclude P and LI from DOM parsing since its treated better by the DOM parser</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          self_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),

          <span class="hljs-attr">cdata</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
            node.append(createNode(<span class="hljs-string">'#cdata'</span>, <span class="hljs-number">4</span>)).value = text;
          },

          <span class="hljs-attr">text</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, raw</span>) </span>{
            <span class="hljs-keyword">var</span> textNode;</pre></div></div>
            
        </li>
        
        
        <li id="section-706">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-706">&#182;</a>
              </div>
              <p>Trim all redundant whitespace on non white space elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!isInWhiteSpacePreservedElement) {
              text = text.replace(allWhiteSpaceRegExp, <span class="hljs-string">' '</span>);

              <span class="hljs-keyword">if</span> (node.lastChild &amp;&amp; blockElements[node.lastChild.name]) {
                text = text.replace(startWhiteSpaceRegExp, <span class="hljs-string">''</span>);
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-707">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-707">&#182;</a>
              </div>
              <p>Do we need to create the node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (text.length !== <span class="hljs-number">0</span>) {
              textNode = createNode(<span class="hljs-string">'#text'</span>, <span class="hljs-number">3</span>);
              textNode.raw = !!raw;
              node.append(textNode).value = text;
            }
          },

          <span class="hljs-attr">comment</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
            node.append(createNode(<span class="hljs-string">'#comment'</span>, <span class="hljs-number">8</span>)).value = text;
          },

          <span class="hljs-attr">pi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, text</span>) </span>{
            node.append(createNode(name, <span class="hljs-number">7</span>)).value = text;
            removeWhitespaceBefore(node);
          },

          <span class="hljs-attr">doctype</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
            <span class="hljs-keyword">var</span> newNode;

            newNode = node.append(createNode(<span class="hljs-string">'#doctype'</span>, <span class="hljs-number">10</span>));
            newNode.value = text;
            removeWhitespaceBefore(node);
          },

          <span class="hljs-attr">start</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, attrs, empty</span>) </span>{
            <span class="hljs-keyword">var</span> newNode, attrFiltersLen, elementRule, attrName, parent;

            elementRule = validate ? schema.getElementRule(name) : {};
            <span class="hljs-keyword">if</span> (elementRule) {
              newNode = createNode(elementRule.outputName || name, <span class="hljs-number">1</span>);
              newNode.attributes = attrs;
              newNode.shortEnded = empty;

              node.append(newNode);</pre></div></div>
            
        </li>
        
        
        <li id="section-708">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-708">&#182;</a>
              </div>
              <p>Check if node is valid child of the parent node is the child is
unknown we dont collect it since its probably a custom element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              parent = children[node.name];
              <span class="hljs-keyword">if</span> (parent &amp;&amp; children[newNode.name] &amp;&amp; !parent[newNode.name]) {
                invalidChildren.push(newNode);
              }

              attrFiltersLen = attributeFilters.length;
              <span class="hljs-keyword">while</span> (attrFiltersLen--) {
                attrName = attributeFilters[attrFiltersLen].name;

                <span class="hljs-keyword">if</span> (attrName <span class="hljs-keyword">in</span> attrs.map) {
                  list = matchedAttributes[attrName];

                  <span class="hljs-keyword">if</span> (list) {
                    list.push(newNode);
                  } <span class="hljs-keyword">else</span> {
                    matchedAttributes[attrName] = [newNode];
                  }
                }
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-709">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-709">&#182;</a>
              </div>
              <p>Trim whitespace before block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (blockElements[name]) {
                removeWhitespaceBefore(newNode);
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-710">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-710">&#182;</a>
              </div>
              <p>Change current node if the element wasnt empty i.e not <br /> or <img /></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (!empty) {
                node = newNode;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-711">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-711">&#182;</a>
              </div>
              <p>Check if we are inside a whitespace preserved element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (!isInWhiteSpacePreservedElement &amp;&amp; whiteSpaceElements[name]) {
                isInWhiteSpacePreservedElement = <span class="hljs-literal">true</span>;
              }
            }
          },

          <span class="hljs-attr">end</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
            <span class="hljs-keyword">var</span> textNode, elementRule, text, sibling, tempNode;

            elementRule = validate ? schema.getElementRule(name) : {};
            <span class="hljs-keyword">if</span> (elementRule) {
              <span class="hljs-keyword">if</span> (blockElements[name]) {
                <span class="hljs-keyword">if</span> (!isInWhiteSpacePreservedElement) {</pre></div></div>
            
        </li>
        
        
        <li id="section-712">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-712">&#182;</a>
              </div>
              <p>Trim whitespace of the first node in a block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  textNode = node.firstChild;
                  <span class="hljs-keyword">if</span> (textNode &amp;&amp; textNode.type === <span class="hljs-number">3</span>) {
                    text = textNode.value.replace(startWhiteSpaceRegExp, <span class="hljs-string">''</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-713">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-713">&#182;</a>
              </div>
              <p>Any characters left after trim or should we remove it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> (text.length &gt; <span class="hljs-number">0</span>) {
                      textNode.value = text;
                      textNode = textNode.next;
                    } <span class="hljs-keyword">else</span> {
                      sibling = textNode.next;
                      textNode.remove();
                      textNode = sibling;</pre></div></div>
            
        </li>
        
        
        <li id="section-714">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-714">&#182;</a>
              </div>
              <p>Remove any pure whitespace siblings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                      <span class="hljs-keyword">while</span> (textNode &amp;&amp; textNode.type === <span class="hljs-number">3</span>) {
                        text = textNode.value;
                        sibling = textNode.next;

                        <span class="hljs-keyword">if</span> (text.length === <span class="hljs-number">0</span> || isAllWhiteSpaceRegExp.test(text)) {
                          textNode.remove();
                          textNode = sibling;
                        }

                        textNode = sibling;
                      }
                    }
                  }</pre></div></div>
            
        </li>
        
        
        <li id="section-715">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-715">&#182;</a>
              </div>
              <p>Trim whitespace of the last node in a block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  textNode = node.lastChild;
                  <span class="hljs-keyword">if</span> (textNode &amp;&amp; textNode.type === <span class="hljs-number">3</span>) {
                    text = textNode.value.replace(endWhiteSpaceRegExp, <span class="hljs-string">''</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-716">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-716">&#182;</a>
              </div>
              <p>Any characters left after trim or should we remove it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> (text.length &gt; <span class="hljs-number">0</span>) {
                      textNode.value = text;
                      textNode = textNode.prev;
                    } <span class="hljs-keyword">else</span> {
                      sibling = textNode.prev;
                      textNode.remove();
                      textNode = sibling;</pre></div></div>
            
        </li>
        
        
        <li id="section-717">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-717">&#182;</a>
              </div>
              <p>Remove any pure whitespace siblings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                      <span class="hljs-keyword">while</span> (textNode &amp;&amp; textNode.type === <span class="hljs-number">3</span>) {
                        text = textNode.value;
                        sibling = textNode.prev;

                        <span class="hljs-keyword">if</span> (text.length === <span class="hljs-number">0</span> || isAllWhiteSpaceRegExp.test(text)) {
                          textNode.remove();
                          textNode = sibling;
                        }

                        textNode = sibling;
                      }
                    }
                  }
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-718">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-718">&#182;</a>
              </div>
              <p>Trim start white space
Removed due to: #5424</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-comment">/*textNode = node.prev;
                if (textNode &amp;&amp; textNode.type === 3) {
                  text = textNode.value.replace(startWhiteSpaceRegExp, '');

                  if (text.length &gt; 0)
                    textNode.value = text;
                  else
                    textNode.remove();
                }*/</span>
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-719">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-719">&#182;</a>
              </div>
              <p>Check if we exited a whitespace preserved element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (isInWhiteSpacePreservedElement &amp;&amp; whiteSpaceElements[name]) {
                isInWhiteSpacePreservedElement = <span class="hljs-literal">false</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-720">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-720">&#182;</a>
              </div>
              <p>Handle empty nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (elementRule.removeEmpty || elementRule.paddEmpty) {
                <span class="hljs-keyword">if</span> (node.isEmpty(nonEmptyElements, whiteSpaceElements)) {
                  <span class="hljs-keyword">if</span> (elementRule.paddEmpty) {
                    paddEmptyNode(settings, node);
                  } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-721">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-721">&#182;</a>
              </div>
              <p>Leave nodes that have a name like <a name="name"></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> (!node.attributes.map.name &amp;&amp; !node.attributes.map.id) {
                      tempNode = node.parent;

                      <span class="hljs-keyword">if</span> (blockElements[node.name]) {
                        node.empty().remove();
                      } <span class="hljs-keyword">else</span> {
                        node.unwrap();
                      }

                      node = tempNode;
                      <span class="hljs-keyword">return</span>;
                    }
                  }
                }
              }

              node = node.parent;
            }
          }
        }, schema);

        rootNode = node = <span class="hljs-keyword">new</span> Node(args.context || settings.root_name, <span class="hljs-number">11</span>);

        parser.parse(html);</pre></div></div>
            
        </li>
        
        
        <li id="section-722">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-722">&#182;</a>
              </div>
              <p>Fix invalid children or report invalid children in a contextual parsing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (validate &amp;&amp; invalidChildren.length) {
          <span class="hljs-keyword">if</span> (!args.context) {
            fixInvalidChildren(invalidChildren);
          } <span class="hljs-keyword">else</span> {
            args.invalid = <span class="hljs-literal">true</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-723">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-723">&#182;</a>
              </div>
              <p>Wrap nodes in the root into block elements if the root is body</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (rootBlockName &amp;&amp; (rootNode.name == <span class="hljs-string">'body'</span> || args.isRootContent)) {
          addRootBlocks();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-724">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-724">&#182;</a>
              </div>
              <p>Run filters only when the contents is valid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!args.invalid) {</pre></div></div>
            
        </li>
        
        
        <li id="section-725">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-725">&#182;</a>
              </div>
              <p>Run node filters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> matchedNodes) {
            list = nodeFilters[name];
            nodes = matchedNodes[name];</pre></div></div>
            
        </li>
        
        
        <li id="section-726">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-726">&#182;</a>
              </div>
              <p>Remove already removed children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            fi = nodes.length;
            <span class="hljs-keyword">while</span> (fi--) {
              <span class="hljs-keyword">if</span> (!nodes[fi].parent) {
                nodes.splice(fi, <span class="hljs-number">1</span>);
              }
            }

            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = list.length; i &lt; l; i++) {
              list[i](nodes, name, args);
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-727">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-727">&#182;</a>
              </div>
              <p>Run attribute filters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = attributeFilters.length; i &lt; l; i++) {
            list = attributeFilters[i];

            <span class="hljs-keyword">if</span> (list.name <span class="hljs-keyword">in</span> matchedAttributes) {
              nodes = matchedAttributes[list.name];</pre></div></div>
            
        </li>
        
        
        <li id="section-728">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-728">&#182;</a>
              </div>
              <p>Remove already removed children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              fi = nodes.length;
              <span class="hljs-keyword">while</span> (fi--) {
                <span class="hljs-keyword">if</span> (!nodes[fi].parent) {
                  nodes.splice(fi, <span class="hljs-number">1</span>);
                }
              }

              <span class="hljs-keyword">for</span> (fi = <span class="hljs-number">0</span>, fl = list.callbacks.length; fi &lt; fl; fi++) {
                list.callbacks[fi](nodes, list.name, args);
              }
            }
          }
        }

        <span class="hljs-keyword">return</span> rootNode;
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-729">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-729">&#182;</a>
              </div>
              <p>Remove <br> at end of block elements Gecko and WebKit injects BR elements to
make it possible to place the caret inside empty blocks. This logic tries to remove
these elements and keep br elements that where intended to be there intact</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (settings.remove_trailing_brs) {
        self.addNodeFilter(<span class="hljs-string">'br'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
          <span class="hljs-keyword">var</span> i, l = nodes.length, node, blockElements = extend({}, schema.getBlockElements());
          <span class="hljs-keyword">var</span> nonEmptyElements = schema.getNonEmptyElements(), parent, lastParent, prev, prevName;
          <span class="hljs-keyword">var</span> whiteSpaceElements = schema.getNonEmptyElements();
          <span class="hljs-keyword">var</span> elementRule, textNode;</pre></div></div>
            
        </li>
        
        
        <li id="section-730">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-730">&#182;</a>
              </div>
              <p>Remove brs from body element as well</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          blockElements.body = <span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-731">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-731">&#182;</a>
              </div>
              <p>Must loop forwards since it will otherwise remove all brs in <p>a<br><br><br></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; l; i++) {
            node = nodes[i];
            parent = node.parent;

            <span class="hljs-keyword">if</span> (blockElements[node.parent.name] &amp;&amp; node === parent.lastChild) {</pre></div></div>
            
        </li>
        
        
        <li id="section-732">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-732">&#182;</a>
              </div>
              <p>Loop all nodes to the left of the current node and check for other BR elements
excluding bookmarks since they are invisible</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              prev = node.prev;
              <span class="hljs-keyword">while</span> (prev) {
                prevName = prev.name;</pre></div></div>
            
        </li>
        
        
        <li id="section-733">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-733">&#182;</a>
              </div>
              <p>Ignore bookmarks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (prevName !== <span class="hljs-string">"span"</span> || prev.attr(<span class="hljs-string">'data-mce-type'</span>) !== <span class="hljs-string">'bookmark'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-734">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-734">&#182;</a>
              </div>
              <p>Found a non BR element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">if</span> (prevName !== <span class="hljs-string">"br"</span>) {
                    <span class="hljs-keyword">break</span>;
                  }</pre></div></div>
            
        </li>
        
        
        <li id="section-735">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-735">&#182;</a>
              </div>
              <p>Found another br its a <br><br> structure then dont remove anything</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">if</span> (prevName === <span class="hljs-string">'br'</span>) {
                    node = <span class="hljs-literal">null</span>;
                    <span class="hljs-keyword">break</span>;
                  }
                }

                prev = prev.prev;
              }

              <span class="hljs-keyword">if</span> (node) {
                node.remove();</pre></div></div>
            
        </li>
        
        
        <li id="section-736">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-736">&#182;</a>
              </div>
              <p>Is the parent to be considered empty after we removed the BR</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (parent.isEmpty(nonEmptyElements, whiteSpaceElements)) {
                  elementRule = schema.getElementRule(parent.name);</pre></div></div>
            
        </li>
        
        
        <li id="section-737">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-737">&#182;</a>
              </div>
              <p>Remove or padd the element depending on schema rule</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">if</span> (elementRule) {
                    <span class="hljs-keyword">if</span> (elementRule.removeEmpty) {
                      parent.remove();
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elementRule.paddEmpty) {
                      paddEmptyNode(settings, parent);
                    }
                  }
                }
              }
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-738">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-738">&#182;</a>
              </div>
              <p>Replaces BR elements inside inline elements like <p><b><i><br></i></b></p>
so they become <p><b><i>&nbsp;</i></b></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              lastParent = node;
              <span class="hljs-keyword">while</span> (parent &amp;&amp; parent.firstChild === lastParent &amp;&amp; parent.lastChild === lastParent) {
                lastParent = parent;

                <span class="hljs-keyword">if</span> (blockElements[parent.name]) {
                  <span class="hljs-keyword">break</span>;
                }

                parent = parent.parent;
              }

              <span class="hljs-keyword">if</span> (lastParent === parent &amp;&amp; settings.padd_empty_with_br !== <span class="hljs-literal">true</span>) {
                textNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'#text'</span>, <span class="hljs-number">3</span>);
                textNode.value = <span class="hljs-string">'\u00a0'</span>;
                node.replace(textNode);
              }
            }
          }
        });
      }

      <span class="hljs-keyword">if</span> (!settings.allow_unsafe_link_target) {
        self.addAttributeFilter(<span class="hljs-string">'href'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
          <span class="hljs-keyword">var</span> i = nodes.length, node, rel;
          <span class="hljs-keyword">var</span> rules = <span class="hljs-string">'noopener noreferrer'</span>;

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTargetRules</span>(<span class="hljs-params">rel</span>) </span>{
            rel = removeTargetRules(rel);
            <span class="hljs-keyword">return</span> rel ? [rel, rules].join(<span class="hljs-string">' '</span>) : rules;
          }

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeTargetRules</span>(<span class="hljs-params">rel</span>) </span>{
            <span class="hljs-keyword">var</span> regExp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'('</span> + rules.replace(<span class="hljs-string">' '</span>, <span class="hljs-string">'|'</span>) + <span class="hljs-string">')'</span>, <span class="hljs-string">'g'</span>);
            <span class="hljs-keyword">if</span> (rel) {
              rel = Tools.trim(rel.replace(regExp, <span class="hljs-string">''</span>));
            }
            <span class="hljs-keyword">return</span> rel ? rel : <span class="hljs-literal">null</span>;
          }

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleTargetRules</span>(<span class="hljs-params">rel, isUnsafe</span>) </span>{
            <span class="hljs-keyword">return</span> isUnsafe ? addTargetRules(rel) : removeTargetRules(rel);
          }

          <span class="hljs-keyword">while</span> (i--) {
            node = nodes[i];
            rel = node.attr(<span class="hljs-string">'rel'</span>);
            <span class="hljs-keyword">if</span> (node.name === <span class="hljs-string">'a'</span>) {
              node.attr(<span class="hljs-string">'rel'</span>, toggleTargetRules(rel, node.attr(<span class="hljs-string">'target'</span>) == <span class="hljs-string">'_blank'</span>));
            }
          }
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-739">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-739">&#182;</a>
              </div>
              <p>Force anchor names closed, unless the setting allow_html_in_named_anchor is explicitly included.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!settings.allow_html_in_named_anchor) {
        self.addAttributeFilter(<span class="hljs-string">'id,name'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
          <span class="hljs-keyword">var</span> i = nodes.length, sibling, prevSibling, parent, node;

          <span class="hljs-keyword">while</span> (i--) {
            node = nodes[i];
            <span class="hljs-keyword">if</span> (node.name === <span class="hljs-string">'a'</span> &amp;&amp; node.firstChild &amp;&amp; !node.attr(<span class="hljs-string">'href'</span>)) {
              parent = node.parent;</pre></div></div>
            
        </li>
        
        
        <li id="section-740">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-740">&#182;</a>
              </div>
              <p>Move children after current node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              sibling = node.lastChild;
              <span class="hljs-keyword">do</span> {
                prevSibling = sibling.prev;
                parent.insert(sibling, node);
                sibling = prevSibling;
              } <span class="hljs-keyword">while</span> (sibling);
            }
          }
        });
      }

      <span class="hljs-keyword">if</span> (settings.fix_list_elements) {
        self.addNodeFilter(<span class="hljs-string">'ul,ol'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
          <span class="hljs-keyword">var</span> i = nodes.length, node, parentNode;

          <span class="hljs-keyword">while</span> (i--) {
            node = nodes[i];
            parentNode = node.parent;

            <span class="hljs-keyword">if</span> (parentNode.name === <span class="hljs-string">'ul'</span> || parentNode.name === <span class="hljs-string">'ol'</span>) {
              <span class="hljs-keyword">if</span> (node.prev &amp;&amp; node.prev.name === <span class="hljs-string">'li'</span>) {
                node.prev.append(node);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> li = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'li'</span>, <span class="hljs-number">1</span>);
                li.attr(<span class="hljs-string">'style'</span>, <span class="hljs-string">'list-style-type: none'</span>);
                node.wrap(li);
              }
            }
          }
        });
      }

      <span class="hljs-keyword">if</span> (settings.validate &amp;&amp; schema.getValidClasses()) {
        self.addAttributeFilter(<span class="hljs-string">'class'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
          <span class="hljs-keyword">var</span> i = nodes.length, node, classList, ci, className, classValue;
          <span class="hljs-keyword">var</span> validClasses = schema.getValidClasses(), validClassesMap, valid;

          <span class="hljs-keyword">while</span> (i--) {
            node = nodes[i];
            classList = node.attr(<span class="hljs-string">'class'</span>).split(<span class="hljs-string">' '</span>);
            classValue = <span class="hljs-string">''</span>;

            <span class="hljs-keyword">for</span> (ci = <span class="hljs-number">0</span>; ci &lt; classList.length; ci++) {
              className = classList[ci];
              valid = <span class="hljs-literal">false</span>;

              validClassesMap = validClasses[<span class="hljs-string">'*'</span>];
              <span class="hljs-keyword">if</span> (validClassesMap &amp;&amp; validClassesMap[className]) {
                valid = <span class="hljs-literal">true</span>;
              }

              validClassesMap = validClasses[node.name];
              <span class="hljs-keyword">if</span> (!valid &amp;&amp; validClassesMap &amp;&amp; validClassesMap[className]) {
                valid = <span class="hljs-literal">true</span>;
              }

              <span class="hljs-keyword">if</span> (valid) {
                <span class="hljs-keyword">if</span> (classValue) {
                  classValue += <span class="hljs-string">' '</span>;
                }

                classValue += className;
              }
            }

            <span class="hljs-keyword">if</span> (!classValue.length) {
              classValue = <span class="hljs-literal">null</span>;
            }

            node.attr(<span class="hljs-string">'class'</span>, classValue);
          }
        });
      }
    };
  }
);

<span class="hljs-comment">/**
 * Writer.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class is used to write HTML tags out it can be used with the Serializer or the SaxParser.
 *
 * @class tinymce.html.Writer
 * @example
 * var writer = new tinymce.html.Writer({indent: true});
 * var parser = new tinymce.html.SaxParser(writer).parse('&lt;p&gt;&lt;br&gt;&lt;/p&gt;');
 * console.log(writer.getContent());
 *
 * @class tinymce.html.Writer
 * @version 3.4
 */</span>
define(
  <span class="hljs-string">'tinymce.core.html.Writer'</span>,
  [
    <span class="hljs-string">"tinymce.core.html.Entities"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Entities, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> makeMap = Tools.makeMap;

    <span class="hljs-comment">/**
     * Constructs a new Writer instance.
     *
     * @constructor
     * @method Writer
     * @param {Object} settings Name/value settings object.
     */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
      <span class="hljs-keyword">var</span> html = [], indent, indentBefore, indentAfter, encode, htmlOutput;

      settings = settings || {};
      indent = settings.indent;
      indentBefore = makeMap(settings.indent_before || <span class="hljs-string">''</span>);
      indentAfter = makeMap(settings.indent_after || <span class="hljs-string">''</span>);
      encode = Entities.getEncodeFunc(settings.entity_encoding || <span class="hljs-string">'raw'</span>, settings.entities);
      htmlOutput = settings.element_format == <span class="hljs-string">"html"</span>;

      <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">/**
         * Writes the a start element such as &lt;p id="a"&gt;.
         *
         * @method start
         * @param {String} name Name of the element.
         * @param {Array} attrs Optional attribute array or undefined if it hasn't any.
         * @param {Boolean} empty Optional empty state if the tag should end like &lt;br /&gt;.
         */</span>
        start: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, attrs, empty</span>) </span>{
          <span class="hljs-keyword">var</span> i, l, attr, value;

          <span class="hljs-keyword">if</span> (indent &amp;&amp; indentBefore[name] &amp;&amp; html.length &gt; <span class="hljs-number">0</span>) {
            value = html[html.length - <span class="hljs-number">1</span>];

            <span class="hljs-keyword">if</span> (value.length &gt; <span class="hljs-number">0</span> &amp;&amp; value !== <span class="hljs-string">'\n'</span>) {
              html.push(<span class="hljs-string">'\n'</span>);
            }
          }

          html.push(<span class="hljs-string">'&lt;'</span>, name);

          <span class="hljs-keyword">if</span> (attrs) {
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = attrs.length; i &lt; l; i++) {
              attr = attrs[i];
              html.push(<span class="hljs-string">' '</span>, attr.name, <span class="hljs-string">'="'</span>, encode(attr.value, <span class="hljs-literal">true</span>), <span class="hljs-string">'"'</span>);
            }
          }

          <span class="hljs-keyword">if</span> (!empty || htmlOutput) {
            html[html.length] = <span class="hljs-string">'&gt;'</span>;
          } <span class="hljs-keyword">else</span> {
            html[html.length] = <span class="hljs-string">' /&gt;'</span>;
          }

          <span class="hljs-keyword">if</span> (empty &amp;&amp; indent &amp;&amp; indentAfter[name] &amp;&amp; html.length &gt; <span class="hljs-number">0</span>) {
            value = html[html.length - <span class="hljs-number">1</span>];

            <span class="hljs-keyword">if</span> (value.length &gt; <span class="hljs-number">0</span> &amp;&amp; value !== <span class="hljs-string">'\n'</span>) {
              html.push(<span class="hljs-string">'\n'</span>);
            }
          }
        },

        <span class="hljs-comment">/**
         * Writes the a end element such as &lt;/p&gt;.
         *
         * @method end
         * @param {String} name Name of the element.
         */</span>
        end: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">var</span> value;

          <span class="hljs-comment">/*if (indent &amp;&amp; indentBefore[name] &amp;&amp; html.length &gt; 0) {
            value = html[html.length - 1];

            if (value.length &gt; 0 &amp;&amp; value !== '\n')
              html.push('\n');
          }*/</span>

          html.push(<span class="hljs-string">'&lt;/'</span>, name, <span class="hljs-string">'&gt;'</span>);

          <span class="hljs-keyword">if</span> (indent &amp;&amp; indentAfter[name] &amp;&amp; html.length &gt; <span class="hljs-number">0</span>) {
            value = html[html.length - <span class="hljs-number">1</span>];

            <span class="hljs-keyword">if</span> (value.length &gt; <span class="hljs-number">0</span> &amp;&amp; value !== <span class="hljs-string">'\n'</span>) {
              html.push(<span class="hljs-string">'\n'</span>);
            }
          }
        },

        <span class="hljs-comment">/**
         * Writes a text node.
         *
         * @method text
         * @param {String} text String to write out.
         * @param {Boolean} raw Optional raw state if true the contents wont get encoded.
         */</span>
        text: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, raw</span>) </span>{
          <span class="hljs-keyword">if</span> (text.length &gt; <span class="hljs-number">0</span>) {
            html[html.length] = raw ? text : encode(text);
          }
        },

        <span class="hljs-comment">/**
         * Writes a cdata node such as &lt;![CDATA[data]]&gt;.
         *
         * @method cdata
         * @param {String} text String to write out inside the cdata.
         */</span>
        cdata: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
          html.push(<span class="hljs-string">'&lt;![CDATA['</span>, text, <span class="hljs-string">']]&gt;'</span>);
        },

        <span class="hljs-comment">/**
         * Writes a comment node such as &lt;!-- Comment --&gt;.
         *
         * @method cdata
         * @param {String} text String to write out inside the comment.
         */</span>
        comment: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
          html.push(<span class="hljs-string">'&lt;!--'</span>, text, <span class="hljs-string">'--&gt;'</span>);
        },

        <span class="hljs-comment">/**
         * Writes a PI node such as &lt;?xml attr="value" ?&gt;.
         *
         * @method pi
         * @param {String} name Name of the pi.
         * @param {String} text String to write out inside the pi.
         */</span>
        pi: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, text</span>) </span>{
          <span class="hljs-keyword">if</span> (text) {
            html.push(<span class="hljs-string">'&lt;?'</span>, name, <span class="hljs-string">' '</span>, encode(text), <span class="hljs-string">'?&gt;'</span>);
          } <span class="hljs-keyword">else</span> {
            html.push(<span class="hljs-string">'&lt;?'</span>, name, <span class="hljs-string">'?&gt;'</span>);
          }

          <span class="hljs-keyword">if</span> (indent) {
            html.push(<span class="hljs-string">'\n'</span>);
          }
        },

        <span class="hljs-comment">/**
         * Writes a doctype node such as &lt;!DOCTYPE data&gt;.
         *
         * @method doctype
         * @param {String} text String to write out inside the doctype.
         */</span>
        doctype: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
          html.push(<span class="hljs-string">'&lt;!DOCTYPE'</span>, text, <span class="hljs-string">'&gt;'</span>, indent ? <span class="hljs-string">'\n'</span> : <span class="hljs-string">''</span>);
        },

        <span class="hljs-comment">/**
         * Resets the internal buffer if one wants to reuse the writer.
         *
         * @method reset
         */</span>
        reset: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          html.length = <span class="hljs-number">0</span>;
        },

        <span class="hljs-comment">/**
         * Returns the contents that got serialized.
         *
         * @method getContent
         * @return {String} HTML contents that got written down.
         */</span>
        getContent: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> html.join(<span class="hljs-string">''</span>).replace(<span class="hljs-regexp">/\n$/</span>, <span class="hljs-string">''</span>);
        }
      };
    };
  }
);
<span class="hljs-comment">/**
 * Serializer.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class is used to serialize down the DOM tree into a string using a Writer instance.
 *
 *
 * @example
 * new tinymce.html.Serializer().serialize(new tinymce.html.DomParser().parse('&lt;p&gt;text&lt;/p&gt;'));
 * @class tinymce.html.Serializer
 * @version 3.4
 */</span>
define(
  <span class="hljs-string">'tinymce.core.html.Serializer'</span>,
  [
    <span class="hljs-string">"tinymce.core.html.Writer"</span>,
    <span class="hljs-string">"tinymce.core.html.Schema"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Writer, Schema</span>) </span>{
    <span class="hljs-comment">/**
     * Constructs a new Serializer instance.
     *
     * @constructor
     * @method Serializer
     * @param {Object} settings Name/value settings object.
     * @param {tinymce.html.Schema} schema Schema instance to use.
     */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings, schema</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, writer = <span class="hljs-keyword">new</span> Writer(settings);

      settings = settings || {};
      settings.validate = <span class="hljs-string">"validate"</span> <span class="hljs-keyword">in</span> settings ? settings.validate : <span class="hljs-literal">true</span>;

      self.schema = schema = schema || <span class="hljs-keyword">new</span> Schema();
      self.writer = writer;

      <span class="hljs-comment">/**
       * Serializes the specified node into a string.
       *
       * @example
       * new tinymce.html.Serializer().serialize(new tinymce.html.DomParser().parse('&lt;p&gt;text&lt;/p&gt;'));
       * @method serialize
       * @param {tinymce.html.Node} node Node instance to serialize.
       * @return {String} String with HTML based on DOM tree.
       */</span>
      self.serialize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> handlers, validate;

        validate = settings.validate;

        handlers = {</pre></div></div>
            
        </li>
        
        
        <li id="section-741">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-741">&#182;</a>
              </div>
              <p>#text</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-number">3</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            writer.text(node.value, node.raw);
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-742">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-742">&#182;</a>
              </div>
              <p>#comment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-number">8</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            writer.comment(node.value);
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-743">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-743">&#182;</a>
              </div>
              <p>Processing instruction</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-number">7</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            writer.pi(node.name, node.value);
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-744">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-744">&#182;</a>
              </div>
              <p>Doctype</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-number">10</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            writer.doctype(node.value);
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-745">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-745">&#182;</a>
              </div>
              <p>CDATA</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-number">4</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            writer.cdata(node.value);
          },</pre></div></div>
            
        </li>
        
        
        <li id="section-746">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-746">&#182;</a>
              </div>
              <p>Document fragment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-number">11</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">if</span> ((node = node.firstChild)) {
              <span class="hljs-keyword">do</span> {
                walk(node);
              } <span class="hljs-keyword">while</span> ((node = node.next));
            }
          }
        };

        writer.reset();

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walk</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> handler = handlers[node.type], name, isEmpty, attrs, attrName, attrValue, sortedAttrs, i, l, elementRule;

          <span class="hljs-keyword">if</span> (!handler) {
            name = node.name;
            isEmpty = node.shortEnded;
            attrs = node.attributes;</pre></div></div>
            
        </li>
        
        
        <li id="section-747">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-747">&#182;</a>
              </div>
              <p>Sort attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (validate &amp;&amp; attrs &amp;&amp; attrs.length &gt; <span class="hljs-number">1</span>) {
              sortedAttrs = [];
              sortedAttrs.map = {};

              elementRule = schema.getElementRule(node.name);
              <span class="hljs-keyword">if</span> (elementRule) {
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = elementRule.attributesOrder.length; i &lt; l; i++) {
                  attrName = elementRule.attributesOrder[i];

                  <span class="hljs-keyword">if</span> (attrName <span class="hljs-keyword">in</span> attrs.map) {
                    attrValue = attrs.map[attrName];
                    sortedAttrs.map[attrName] = attrValue;
                    sortedAttrs.push({ <span class="hljs-attr">name</span>: attrName, <span class="hljs-attr">value</span>: attrValue });
                  }
                }

                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = attrs.length; i &lt; l; i++) {
                  attrName = attrs[i].name;

                  <span class="hljs-keyword">if</span> (!(attrName <span class="hljs-keyword">in</span> sortedAttrs.map)) {
                    attrValue = attrs.map[attrName];
                    sortedAttrs.map[attrName] = attrValue;
                    sortedAttrs.push({ <span class="hljs-attr">name</span>: attrName, <span class="hljs-attr">value</span>: attrValue });
                  }
                }

                attrs = sortedAttrs;
              }
            }

            writer.start(node.name, attrs, isEmpty);

            <span class="hljs-keyword">if</span> (!isEmpty) {
              <span class="hljs-keyword">if</span> ((node = node.firstChild)) {
                <span class="hljs-keyword">do</span> {
                  walk(node);
                } <span class="hljs-keyword">while</span> ((node = node.next));
              }

              writer.end(name);
            }
          } <span class="hljs-keyword">else</span> {
            handler(node);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-748">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-748">&#182;</a>
              </div>
              <p>Serialize element and treat all non elements as fragments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (node.type == <span class="hljs-number">1</span> &amp;&amp; !settings.inner) {
          walk(node);
        } <span class="hljs-keyword">else</span> {
          handlers[<span class="hljs-number">11</span>](node);
        }

        <span class="hljs-keyword">return</span> writer.getContent();
      };
    };
  }
);

<span class="hljs-comment">/**
 * Serializer.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class is used to serialize DOM trees into a string. Consult the TinyMCE Wiki API for
 * more details and examples on how to use this class.
 *
 * @class tinymce.dom.Serializer
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.Serializer'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.DOMUtils"</span>,
    <span class="hljs-string">"tinymce.core.html.DomParser"</span>,
    <span class="hljs-string">"tinymce.core.html.SaxParser"</span>,
    <span class="hljs-string">"tinymce.core.html.Entities"</span>,
    <span class="hljs-string">"tinymce.core.html.Serializer"</span>,
    <span class="hljs-string">"tinymce.core.html.Node"</span>,
    <span class="hljs-string">"tinymce.core.html.Schema"</span>,
    <span class="hljs-string">"tinymce.core.Env"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.text.Zwsp"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">DOMUtils, DomParser, SaxParser, Entities, Serializer, Node, Schema, Env, Tools, Zwsp</span>) </span>{
    <span class="hljs-keyword">var</span> each = Tools.each, trim = Tools.trim;
    <span class="hljs-keyword">var</span> DOM = DOMUtils.DOM;

    <span class="hljs-comment">/**
     * IE 11 has a fantastic bug where it will produce two trailing BR elements to iframe bodies when
     * the iframe is hidden by display: none on a parent container. The DOM is actually out of sync
     * with innerHTML in this case. It's like IE adds shadow DOM BR elements that appears on innerHTML
     * but not as the lastChild of the body. So this fix simply removes the last two
     * BR elements at the end of the document.
     *
     * Example of what happens: &lt;body&gt;text&lt;/body&gt; becomes &lt;body&gt;text&lt;br&gt;&lt;br&gt;&lt;/body&gt;
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimTrailingBr</span>(<span class="hljs-params">rootNode</span>) </span>{
      <span class="hljs-keyword">var</span> brNode1, brNode2;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBr</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> node &amp;&amp; node.name === <span class="hljs-string">'br'</span>;
      }

      brNode1 = rootNode.lastChild;
      <span class="hljs-keyword">if</span> (isBr(brNode1)) {
        brNode2 = brNode1.prev;

        <span class="hljs-keyword">if</span> (isBr(brNode2)) {
          brNode1.remove();
          brNode2.remove();
        }
      }
    }

    <span class="hljs-comment">/**
     * Constructs a new DOM serializer class.
     *
     * @constructor
     * @method Serializer
     * @param {Object} settings Serializer settings object.
     * @param {tinymce.Editor} editor Optional editor to bind events to and get schema/dom from.
     */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings, editor</span>) </span>{
      <span class="hljs-keyword">var</span> dom, schema, htmlParser, tempAttrs = [<span class="hljs-string">"data-mce-selected"</span>];

      <span class="hljs-keyword">if</span> (editor) {
        dom = editor.dom;
        schema = editor.schema;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimHtml</span>(<span class="hljs-params">html</span>) </span>{
        <span class="hljs-keyword">var</span> trimContentRegExp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>([
          <span class="hljs-string">'&lt;span[^&gt;]+data-mce-bogus[^&gt;]+&gt;[\u200B\uFEFF]+&lt;\\/span&gt;'</span>, <span class="hljs-comment">// Trim bogus spans like caret containers</span>
          <span class="hljs-string">'\\s?('</span> + tempAttrs.join(<span class="hljs-string">'|'</span>) + <span class="hljs-string">')="[^"]+"'</span> <span class="hljs-comment">// Trim temporaty data-mce prefixed attributes like data-mce-selected</span>
        ].join(<span class="hljs-string">'|'</span>), <span class="hljs-string">'gi'</span>);

        html = Zwsp.trim(html.replace(trimContentRegExp, <span class="hljs-string">''</span>));

        <span class="hljs-keyword">return</span> html;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimContent</span>(<span class="hljs-params">html</span>) </span>{
        <span class="hljs-keyword">var</span> content = html;
        <span class="hljs-keyword">var</span> bogusAllRegExp = <span class="hljs-regexp">/&lt;(\w+) [^&gt;]*data-mce-bogus="all"[^&gt;]*&gt;/g</span>;
        <span class="hljs-keyword">var</span> endTagIndex, index, matchLength, matches, shortEndedElements, schema = editor.schema;

        content = trimHtml(content);
        shortEndedElements = schema.getShortEndedElements();</pre></div></div>
            
        </li>
        
        
        <li id="section-749">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-749">&#182;</a>
              </div>
              <p>Remove all bogus elements marked with all</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">while</span> ((matches = bogusAllRegExp.exec(content))) {
          index = bogusAllRegExp.lastIndex;
          matchLength = matches[<span class="hljs-number">0</span>].length;

          <span class="hljs-keyword">if</span> (shortEndedElements[matches[<span class="hljs-number">1</span>]]) {
            endTagIndex = index;
          } <span class="hljs-keyword">else</span> {
            endTagIndex = SaxParser.findEndTag(schema, content, index);
          }

          content = content.substring(<span class="hljs-number">0</span>, index - matchLength) + content.substring(endTagIndex);
          bogusAllRegExp.lastIndex = index - matchLength;
        }

        <span class="hljs-keyword">return</span> content;
      }

      <span class="hljs-comment">/**
       * Returns a trimmed version of the editor contents to be used for the undo level. This
       * will remove any data-mce-bogus="all" marked elements since these are used for UI it will also
       * remove the data-mce-selected attributes used for selection of objects and caret containers.
       * It will keep all data-mce-bogus="1" elements since these can be used to place the caret etc and will
       * be removed by the serialization logic when you save.
       *
       * @private
       * @return {String} HTML contents of the editor excluding some internal bogus elements.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTrimmedContent</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> trimContent(editor.getBody().innerHTML);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTempAttr</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">if</span> (Tools.inArray(tempAttrs, name) === <span class="hljs-number">-1</span>) {
          htmlParser.addAttributeFilter(name, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes, name</span>) </span>{
            <span class="hljs-keyword">var</span> i = nodes.length;

            <span class="hljs-keyword">while</span> (i--) {
              nodes[i].attr(name, <span class="hljs-literal">null</span>);
            }
          });

          tempAttrs.push(name);
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-750">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-750">&#182;</a>
              </div>
              <p>Default DOM and Schema if they are undefined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      dom = dom || DOM;
      schema = schema || <span class="hljs-keyword">new</span> Schema(settings);
      settings.entity_encoding = settings.entity_encoding || <span class="hljs-string">'named'</span>;
      settings.remove_trailing_brs = <span class="hljs-string">"remove_trailing_brs"</span> <span class="hljs-keyword">in</span> settings ? settings.remove_trailing_brs : <span class="hljs-literal">true</span>;

      htmlParser = <span class="hljs-keyword">new</span> DomParser(settings, schema);</pre></div></div>
            
        </li>
        
        
        <li id="section-751">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-751">&#182;</a>
              </div>
              <p>Convert tabindex back to elements when serializing contents</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      htmlParser.addAttributeFilter(<span class="hljs-string">'data-mce-tabindex'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes, name</span>) </span>{
        <span class="hljs-keyword">var</span> i = nodes.length, node;

        <span class="hljs-keyword">while</span> (i--) {
          node = nodes[i];
          node.attr(<span class="hljs-string">'tabindex'</span>, node.attributes.map[<span class="hljs-string">'data-mce-tabindex'</span>]);
          node.attr(name, <span class="hljs-literal">null</span>);
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-752">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-752">&#182;</a>
              </div>
              <p>Convert move data-mce-src, data-mce-href and data-mce-style into nodes or process them if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      htmlParser.addAttributeFilter(<span class="hljs-string">'src,href,style'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes, name</span>) </span>{
        <span class="hljs-keyword">var</span> i = nodes.length, node, value, internalName = <span class="hljs-string">'data-mce-'</span> + name;
        <span class="hljs-keyword">var</span> urlConverter = settings.url_converter, urlConverterScope = settings.url_converter_scope, undef;

        <span class="hljs-keyword">while</span> (i--) {
          node = nodes[i];

          value = node.attributes.map[internalName];
          <span class="hljs-keyword">if</span> (value !== undef) {</pre></div></div>
            
        </li>
        
        
        <li id="section-753">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-753">&#182;</a>
              </div>
              <p>Set external name to internal value and remove internal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            node.attr(name, value.length &gt; <span class="hljs-number">0</span> ? value : <span class="hljs-literal">null</span>);
            node.attr(internalName, <span class="hljs-literal">null</span>);
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-754">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-754">&#182;</a>
              </div>
              <p>No internal attribute found then convert the value we have in the DOM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            value = node.attributes.map[name];

            <span class="hljs-keyword">if</span> (name === <span class="hljs-string">"style"</span>) {
              value = dom.serializeStyle(dom.parseStyle(value), node.name);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (urlConverter) {
              value = urlConverter.call(urlConverterScope, value, name, node.name);
            }

            node.attr(name, value.length &gt; <span class="hljs-number">0</span> ? value : <span class="hljs-literal">null</span>);
          }
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-755">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-755">&#182;</a>
              </div>
              <p>Remove internal classes mceItem&lt;..&gt; or mceSelected</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      htmlParser.addAttributeFilter(<span class="hljs-string">'class'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
        <span class="hljs-keyword">var</span> i = nodes.length, node, value;

        <span class="hljs-keyword">while</span> (i--) {
          node = nodes[i];
          value = node.attr(<span class="hljs-string">'class'</span>);

          <span class="hljs-keyword">if</span> (value) {
            value = node.attr(<span class="hljs-string">'class'</span>).replace(<span class="hljs-regexp">/(?:^|\s)mce-item-\w+(?!\S)/g</span>, <span class="hljs-string">''</span>);
            node.attr(<span class="hljs-string">'class'</span>, value.length &gt; <span class="hljs-number">0</span> ? value : <span class="hljs-literal">null</span>);
          }
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-756">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-756">&#182;</a>
              </div>
              <p>Remove bookmark elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      htmlParser.addAttributeFilter(<span class="hljs-string">'data-mce-type'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes, name, args</span>) </span>{
        <span class="hljs-keyword">var</span> i = nodes.length, node;

        <span class="hljs-keyword">while</span> (i--) {
          node = nodes[i];

          <span class="hljs-keyword">if</span> (node.attributes.map[<span class="hljs-string">'data-mce-type'</span>] === <span class="hljs-string">'bookmark'</span> &amp;&amp; !args.cleanup) {
            node.remove();
          }
        }
      });

      htmlParser.addNodeFilter(<span class="hljs-string">'noscript'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
        <span class="hljs-keyword">var</span> i = nodes.length, node;

        <span class="hljs-keyword">while</span> (i--) {
          node = nodes[i].firstChild;

          <span class="hljs-keyword">if</span> (node) {
            node.value = Entities.decode(node.value);
          }
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-757">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-757">&#182;</a>
              </div>
              <p>Force script into CDATA sections and remove the mce- prefix also add comments around styles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      htmlParser.addNodeFilter(<span class="hljs-string">'script,style'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes, name</span>) </span>{
        <span class="hljs-keyword">var</span> i = nodes.length, node, value, type;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trim</span>(<span class="hljs-params">value</span>) </span>{
          <span class="hljs-comment">/*jshint maxlen:255 */</span>
          <span class="hljs-comment">/*eslint max-len:0 */</span>
          <span class="hljs-keyword">return</span> value.replace(<span class="hljs-regexp">/(&lt;!--\[CDATA\[|\]\]--&gt;)/g</span>, <span class="hljs-string">'\n'</span>)
            .replace(<span class="hljs-regexp">/^[\r\n]*|[\r\n]*$/g</span>, <span class="hljs-string">''</span>)
            .replace(<span class="hljs-regexp">/^\s*((&lt;!--)?(\s*\/\/)?\s*&lt;!\[CDATA\[|(&lt;!--\s*)?\/\*\s*&lt;!\[CDATA\[\s*\*\/|(\/\/)?\s*&lt;!--|\/\*\s*&lt;!--\s*\*\/)\s*[\r\n]*/gi</span>, <span class="hljs-string">''</span>)
            .replace(<span class="hljs-regexp">/\s*(\/\*\s*\]\]&gt;\s*\*\/(--&gt;)?|\s*\/\/\s*\]\]&gt;(--&gt;)?|\/\/\s*(--&gt;)?|\]\]&gt;|\/\*\s*--&gt;\s*\*\/|\s*--&gt;\s*)\s*$/g</span>, <span class="hljs-string">''</span>);
        }

        <span class="hljs-keyword">while</span> (i--) {
          node = nodes[i];
          value = node.firstChild ? node.firstChild.value : <span class="hljs-string">''</span>;

          <span class="hljs-keyword">if</span> (name === <span class="hljs-string">"script"</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-758">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-758">&#182;</a>
              </div>
              <p>Remove mce- prefix from script elements and remove default type since the user specified
a script element without type attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            type = node.attr(<span class="hljs-string">'type'</span>);
            <span class="hljs-keyword">if</span> (type) {
              node.attr(<span class="hljs-string">'type'</span>, type == <span class="hljs-string">'mce-no/type'</span> ? <span class="hljs-literal">null</span> : type.replace(<span class="hljs-regexp">/^mce\-/</span>, <span class="hljs-string">''</span>));
            }

            <span class="hljs-keyword">if</span> (value.length &gt; <span class="hljs-number">0</span>) {
              node.firstChild.value = <span class="hljs-string">'// &lt;![CDATA[\n'</span> + trim(value) + <span class="hljs-string">'\n// ]]&gt;'</span>;
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (value.length &gt; <span class="hljs-number">0</span>) {
              node.firstChild.value = <span class="hljs-string">'&lt;!--\n'</span> + trim(value) + <span class="hljs-string">'\n--&gt;'</span>;
            }
          }
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-759">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-759">&#182;</a>
              </div>
              <p>Convert comments to cdata and handle protected comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      htmlParser.addNodeFilter(<span class="hljs-string">'#comment'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
        <span class="hljs-keyword">var</span> i = nodes.length, node;

        <span class="hljs-keyword">while</span> (i--) {
          node = nodes[i];

          <span class="hljs-keyword">if</span> (node.value.indexOf(<span class="hljs-string">'[CDATA['</span>) === <span class="hljs-number">0</span>) {
            node.name = <span class="hljs-string">'#cdata'</span>;
            node.type = <span class="hljs-number">4</span>;
            node.value = node.value.replace(<span class="hljs-regexp">/^\[CDATA\[|\]\]$/g</span>, <span class="hljs-string">''</span>);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.value.indexOf(<span class="hljs-string">'mce:protected '</span>) === <span class="hljs-number">0</span>) {
            node.name = <span class="hljs-string">"#text"</span>;
            node.type = <span class="hljs-number">3</span>;
            node.raw = <span class="hljs-literal">true</span>;
            node.value = <span class="hljs-built_in">unescape</span>(node.value).substr(<span class="hljs-number">14</span>);
          }
        }
      });

      htmlParser.addNodeFilter(<span class="hljs-string">'xml:namespace,input'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes, name</span>) </span>{
        <span class="hljs-keyword">var</span> i = nodes.length, node;

        <span class="hljs-keyword">while</span> (i--) {
          node = nodes[i];
          <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">7</span>) {
            node.remove();
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (name === <span class="hljs-string">"input"</span> &amp;&amp; !(<span class="hljs-string">"type"</span> <span class="hljs-keyword">in</span> node.attributes.map)) {
              node.attr(<span class="hljs-string">'type'</span>, <span class="hljs-string">'text'</span>);
            }
          }
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-760">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-760">&#182;</a>
              </div>
              <p>Remove internal data attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      htmlParser.addAttributeFilter(
        <span class="hljs-string">'data-mce-src,data-mce-href,data-mce-style,'</span> +
        <span class="hljs-string">'data-mce-selected,data-mce-expando,'</span> +
        <span class="hljs-string">'data-mce-type,data-mce-resize'</span>,

        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes, name</span>) </span>{
          <span class="hljs-keyword">var</span> i = nodes.length;

          <span class="hljs-keyword">while</span> (i--) {
            nodes[i].attr(name, <span class="hljs-literal">null</span>);
          }
        }
      );</pre></div></div>
            
        </li>
        
        
        <li id="section-761">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-761">&#182;</a>
              </div>
              <p>Return public methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">/**
         * Schema instance that was used to when the Serializer was constructed.
         *
         * @field {tinymce.html.Schema} schema
         */</span>
        schema: schema,

        <span class="hljs-comment">/**
         * Adds a node filter function to the parser used by the serializer, the parser will collect the specified nodes by name
         * and then execute the callback ones it has finished parsing the document.
         *
         * @example
         * parser.addNodeFilter('p,h1', function(nodes, name) {
         *  for (var i = 0; i &lt; nodes.length; i++) {
         *   console.log(nodes[i].name);
         *  }
         * });
         * @method addNodeFilter
         * @method {String} name Comma separated list of nodes to collect.
         * @param {function} callback Callback function to execute once it has collected nodes.
         */</span>
        addNodeFilter: htmlParser.addNodeFilter,

        <span class="hljs-comment">/**
         * Adds a attribute filter function to the parser used by the serializer, the parser will
         * collect nodes that has the specified attributes
         * and then execute the callback ones it has finished parsing the document.
         *
         * @example
         * parser.addAttributeFilter('src,href', function(nodes, name) {
         *  for (var i = 0; i &lt; nodes.length; i++) {
         *   console.log(nodes[i].name);
         *  }
         * });
         * @method addAttributeFilter
         * @method {String} name Comma separated list of nodes to collect.
         * @param {function} callback Callback function to execute once it has collected nodes.
         */</span>
        addAttributeFilter: htmlParser.addAttributeFilter,

        <span class="hljs-comment">/**
         * Serializes the specified browser DOM node into a HTML string.
         *
         * @method serialize
         * @param {DOMNode} node DOM node to serialize.
         * @param {Object} args Arguments option that gets passed to event handlers.
         */</span>
        serialize: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, args</span>) </span>{
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, impl, doc, oldDoc, htmlSerializer, content, rootNode;</pre></div></div>
            
        </li>
        
        
        <li id="section-762">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-762">&#182;</a>
              </div>
              <p>Explorer wont clone contents of script and style and the
selected index of select elements are cleared on a clone operation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (Env.ie &amp;&amp; dom.select(<span class="hljs-string">'script,style,select,map'</span>).length &gt; <span class="hljs-number">0</span>) {
            content = node.innerHTML;
            node = node.cloneNode(<span class="hljs-literal">false</span>);
            dom.setHTML(node, content);
          } <span class="hljs-keyword">else</span> {
            node = node.cloneNode(<span class="hljs-literal">true</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-763">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-763">&#182;</a>
              </div>
              <p>Nodes needs to be attached to something in WebKit/Opera
This fix will make DOM ranges and make Sizzle happy!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          impl = <span class="hljs-built_in">document</span>.implementation;
          <span class="hljs-keyword">if</span> (impl.createHTMLDocument) {</pre></div></div>
            
        </li>
        
        
        <li id="section-764">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-764">&#182;</a>
              </div>
              <p>Create an empty HTML document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            doc = impl.createHTMLDocument(<span class="hljs-string">""</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-765">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-765">&#182;</a>
              </div>
              <p>Add the element or its children if its a body element to the new document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            each(node.nodeName == <span class="hljs-string">'BODY'</span> ? node.childNodes : [node], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
              doc.body.appendChild(doc.importNode(node, <span class="hljs-literal">true</span>));
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-766">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-766">&#182;</a>
              </div>
              <p>Grab first child or body element for serialization</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (node.nodeName != <span class="hljs-string">'BODY'</span>) {
              node = doc.body.firstChild;
            } <span class="hljs-keyword">else</span> {
              node = doc.body;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-767">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-767">&#182;</a>
              </div>
              <p>set the new document in DOMUtils so createElement etc works</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            oldDoc = dom.doc;
            dom.doc = doc;
          }

          args = args || {};
          args.format = args.format || <span class="hljs-string">'html'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-768">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-768">&#182;</a>
              </div>
              <p>Dont wrap content if we want selected html</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (args.selection) {
            args.forced_root_block = <span class="hljs-string">''</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-769">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-769">&#182;</a>
              </div>
              <p>Pre process</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!args.no_events) {
            args.node = node;
            self.onPreProcess(args);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-770">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-770">&#182;</a>
              </div>
              <p>Parse HTML</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          rootNode = htmlParser.parse(trim(args.getInner ? node.innerHTML : dom.getOuterHTML(node)), args);
          trimTrailingBr(rootNode);</pre></div></div>
            
        </li>
        
        
        <li id="section-771">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-771">&#182;</a>
              </div>
              <p>Serialize HTML</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          htmlSerializer = <span class="hljs-keyword">new</span> Serializer(settings, schema);
          args.content = htmlSerializer.serialize(rootNode);</pre></div></div>
            
        </li>
        
        
        <li id="section-772">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-772">&#182;</a>
              </div>
              <p>Replace all BOM characters for now until we can find a better solution</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!args.cleanup) {
            args.content = Zwsp.trim(args.content);
            args.content = args.content.replace(<span class="hljs-regexp">/\uFEFF/g</span>, <span class="hljs-string">''</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-773">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-773">&#182;</a>
              </div>
              <p>Post process</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!args.no_events) {
            self.onPostProcess(args);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-774">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-774">&#182;</a>
              </div>
              <p>Restore the old document if it was changed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (oldDoc) {
            dom.doc = oldDoc;
          }

          args.node = <span class="hljs-literal">null</span>;

          <span class="hljs-keyword">return</span> args.content;
        },

        <span class="hljs-comment">/**
         * Adds valid elements rules to the serializers schema instance this enables you to specify things
         * like what elements should be outputted and what attributes specific elements might have.
         * Consult the Wiki for more details on this format.
         *
         * @method addRules
         * @param {String} rules Valid elements rules string to add to schema.
         */</span>
        addRules: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rules</span>) </span>{
          schema.addValidElements(rules);
        },

        <span class="hljs-comment">/**
         * Sets the valid elements rules to the serializers schema instance this enables you to specify things
         * like what elements should be outputted and what attributes specific elements might have.
         * Consult the Wiki for more details on this format.
         *
         * @method setRules
         * @param {String} rules Valid elements rules string.
         */</span>
        setRules: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rules</span>) </span>{
          schema.setValidElements(rules);
        },

        <span class="hljs-attr">onPreProcess</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>{
          <span class="hljs-keyword">if</span> (editor) {
            editor.fire(<span class="hljs-string">'PreProcess'</span>, args);
          }
        },

        <span class="hljs-attr">onPostProcess</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>{
          <span class="hljs-keyword">if</span> (editor) {
            editor.fire(<span class="hljs-string">'PostProcess'</span>, args);
          }
        },

        <span class="hljs-comment">/**
         * Adds a temporary internal attribute these attributes will get removed on undo and
         * when getting contents out of the editor.
         *
         * @method addTempAttr
         * @param {String} name string
         */</span>
        addTempAttr: addTempAttr,</pre></div></div>
            
        </li>
        
        
        <li id="section-775">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-775">&#182;</a>
              </div>
              <p>Internal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        trimHtml: trimHtml,
        <span class="hljs-attr">getTrimmedContent</span>: getTrimmedContent,
        <span class="hljs-attr">trimContent</span>: trimContent
      };
    };
  }
);

<span class="hljs-comment">/**
 * VK.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This file exposes a set of the common KeyCodes for use. Please grow it as needed.
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.VK'</span>,
  [
    <span class="hljs-string">"tinymce.core.Env"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Env</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">BACKSPACE</span>: <span class="hljs-number">8</span>,
      <span class="hljs-attr">DELETE</span>: <span class="hljs-number">46</span>,
      <span class="hljs-attr">DOWN</span>: <span class="hljs-number">40</span>,
      <span class="hljs-attr">ENTER</span>: <span class="hljs-number">13</span>,
      <span class="hljs-attr">LEFT</span>: <span class="hljs-number">37</span>,
      <span class="hljs-attr">RIGHT</span>: <span class="hljs-number">39</span>,
      <span class="hljs-attr">SPACEBAR</span>: <span class="hljs-number">32</span>,
      <span class="hljs-attr">TAB</span>: <span class="hljs-number">9</span>,
      <span class="hljs-attr">UP</span>: <span class="hljs-number">38</span>,

      <span class="hljs-attr">modifierPressed</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">return</span> e.shiftKey || e.ctrlKey || e.altKey || <span class="hljs-keyword">this</span>.metaKeyPressed(e);
      },

      <span class="hljs-attr">metaKeyPressed</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-776">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-776">&#182;</a>
              </div>
              <p>Check if ctrl or meta key is pressed. Edge case for AltGr on Windows where it produces ctrlKey+altKey states</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> (Env.mac ? e.metaKey : e.ctrlKey &amp;&amp; !e.altKey);
      }
    };
  }
);

<span class="hljs-comment">/**
 * ControlSelection.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class handles control selection of elements. Controls are elements
 * that can be resized and needs to be selected as a whole. It adds custom resize handles
 * to all browser engines that support properly disabling the built in resize logic.
 *
 * @class tinymce.dom.ControlSelection
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.ControlSelection'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.VK"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.util.Delay"</span>,
    <span class="hljs-string">"tinymce.core.Env"</span>,
    <span class="hljs-string">"tinymce.core.dom.NodeType"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">VK, Tools, Delay, Env, NodeType</span>) </span>{
    <span class="hljs-keyword">var</span> isContentEditableFalse = NodeType.isContentEditableFalse;
    <span class="hljs-keyword">var</span> isContentEditableTrue = NodeType.isContentEditableTrue;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContentEditableRoot</span>(<span class="hljs-params">root, node</span>) </span>{
      <span class="hljs-keyword">while</span> (node &amp;&amp; node != root) {
        <span class="hljs-keyword">if</span> (isContentEditableTrue(node) || isContentEditableFalse(node)) {
          <span class="hljs-keyword">return</span> node;
        }

        node = node.parentNode;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection, editor</span>) </span>{
      <span class="hljs-keyword">var</span> dom = editor.dom, each = Tools.each;
      <span class="hljs-keyword">var</span> selectedElm, selectedElmGhost, resizeHelper, resizeHandles, selectedHandle, lastMouseDownEvent;
      <span class="hljs-keyword">var</span> startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
      <span class="hljs-keyword">var</span> width, height, editableDoc = editor.getDoc(), rootDocument = <span class="hljs-built_in">document</span>, isIE = Env.ie &amp;&amp; Env.ie &lt; <span class="hljs-number">11</span>;
      <span class="hljs-keyword">var</span> abs = <span class="hljs-built_in">Math</span>.abs, round = <span class="hljs-built_in">Math</span>.round, rootElement = editor.getBody(), startScrollWidth, startScrollHeight;</pre></div></div>
            
        </li>
        
        
        <li id="section-777">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-777">&#182;</a>
              </div>
              <p>Details about each resize handle how to scale etc</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      resizeHandles = {</pre></div></div>
            
        </li>
        
        
        <li id="section-778">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-778">&#182;</a>
              </div>
              <p>Name: x multiplier, y multiplier, delta size x, delta size y</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/*n: [0.5, 0, 0, -1],
        e: [1, 0.5, 1, 0],
        s: [0.5, 1, 0, 1],
        w: [0, 0.5, -1, 0],*/</span>
        nw: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>],
        <span class="hljs-attr">ne</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>],
        <span class="hljs-attr">se</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
        <span class="hljs-attr">sw</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>]
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-779">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-779">&#182;</a>
              </div>
              <p>Add CSS for resize handles, cloned element and selected</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> rootClass = <span class="hljs-string">'.mce-content-body'</span>;
      editor.contentStyles.push(
        rootClass + <span class="hljs-string">' div.mce-resizehandle {'</span> +
        <span class="hljs-string">'position: absolute;'</span> +
        <span class="hljs-string">'border: 1px solid black;'</span> +
        <span class="hljs-string">'box-sizing: box-sizing;'</span> +
        <span class="hljs-string">'background: #FFF;'</span> +
        <span class="hljs-string">'width: 7px;'</span> +
        <span class="hljs-string">'height: 7px;'</span> +
        <span class="hljs-string">'z-index: 10000'</span> +
        <span class="hljs-string">'}'</span> +
        rootClass + <span class="hljs-string">' .mce-resizehandle:hover {'</span> +
        <span class="hljs-string">'background: #000'</span> +
        <span class="hljs-string">'}'</span> +
        rootClass + <span class="hljs-string">' img[data-mce-selected],'</span> + rootClass + <span class="hljs-string">' hr[data-mce-selected] {'</span> +
        <span class="hljs-string">'outline: 1px solid black;'</span> +
        <span class="hljs-string">'resize: none'</span> + <span class="hljs-comment">// Have been talks about implementing this in browsers</span>
        <span class="hljs-string">'}'</span> +
        rootClass + <span class="hljs-string">' .mce-clonedresizable {'</span> +
        <span class="hljs-string">'position: absolute;'</span> +
        (Env.gecko ? <span class="hljs-string">''</span> : <span class="hljs-string">'outline: 1px dashed black;'</span>) + <span class="hljs-comment">// Gecko produces trails while resizing</span>
        <span class="hljs-string">'opacity: .5;'</span> +
        <span class="hljs-string">'filter: alpha(opacity=50);'</span> +
        <span class="hljs-string">'z-index: 10000'</span> +
        <span class="hljs-string">'}'</span> +
        rootClass + <span class="hljs-string">' .mce-resize-helper {'</span> +
        <span class="hljs-string">'background: #555;'</span> +
        <span class="hljs-string">'background: rgba(0,0,0,0.75);'</span> +
        <span class="hljs-string">'border-radius: 3px;'</span> +
        <span class="hljs-string">'border: 1px;'</span> +
        <span class="hljs-string">'color: white;'</span> +
        <span class="hljs-string">'display: none;'</span> +
        <span class="hljs-string">'font-family: sans-serif;'</span> +
        <span class="hljs-string">'font-size: 12px;'</span> +
        <span class="hljs-string">'white-space: nowrap;'</span> +
        <span class="hljs-string">'line-height: 14px;'</span> +
        <span class="hljs-string">'margin: 5px 10px;'</span> +
        <span class="hljs-string">'padding: 5px;'</span> +
        <span class="hljs-string">'position: absolute;'</span> +
        <span class="hljs-string">'z-index: 10001'</span> +
        <span class="hljs-string">'}'</span>
      );

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isResizable</span>(<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">var</span> selector = editor.settings.object_resizing;

        <span class="hljs-keyword">if</span> (selector === <span class="hljs-literal">false</span> || Env.iOS) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> selector != <span class="hljs-string">'string'</span>) {
          selector = <span class="hljs-string">'table,img,div'</span>;
        }

        <span class="hljs-keyword">if</span> (elm.getAttribute(<span class="hljs-string">'data-mce-resize'</span>) === <span class="hljs-string">'false'</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">if</span> (elm == editor.getBody()) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">return</span> editor.dom.is(elm, selector);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resizeGhostElement</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> deltaX, deltaY, proportional;
        <span class="hljs-keyword">var</span> resizeHelperX, resizeHelperY;</pre></div></div>
            
        </li>
        
        
        <li id="section-780">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-780">&#182;</a>
              </div>
              <p>Calc new width/height</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        deltaX = e.screenX - startX;
        deltaY = e.screenY - startY;</pre></div></div>
            
        </li>
        
        
        <li id="section-781">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-781">&#182;</a>
              </div>
              <p>Calc new size</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        width = deltaX * selectedHandle[<span class="hljs-number">2</span>] + startW;
        height = deltaY * selectedHandle[<span class="hljs-number">3</span>] + startH;</pre></div></div>
            
        </li>
        
        
        <li id="section-782">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-782">&#182;</a>
              </div>
              <p>Never scale down lower than 5 pixels</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        width = width &lt; <span class="hljs-number">5</span> ? <span class="hljs-number">5</span> : width;
        height = height &lt; <span class="hljs-number">5</span> ? <span class="hljs-number">5</span> : height;

        <span class="hljs-keyword">if</span> (selectedElm.nodeName == <span class="hljs-string">"IMG"</span> &amp;&amp; editor.settings.resize_img_proportional !== <span class="hljs-literal">false</span>) {
          proportional = !VK.modifierPressed(e);
        } <span class="hljs-keyword">else</span> {
          proportional = VK.modifierPressed(e) || (selectedElm.nodeName == <span class="hljs-string">"IMG"</span> &amp;&amp; selectedHandle[<span class="hljs-number">2</span>] * selectedHandle[<span class="hljs-number">3</span>] !== <span class="hljs-number">0</span>);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-783">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-783">&#182;</a>
              </div>
              <p>Constrain proportions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (proportional) {
          <span class="hljs-keyword">if</span> (abs(deltaX) &gt; abs(deltaY)) {
            height = round(width * ratio);
            width = round(height / ratio);
          } <span class="hljs-keyword">else</span> {
            width = round(height / ratio);
            height = round(width * ratio);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-784">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-784">&#182;</a>
              </div>
              <p>Update ghost size</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        dom.setStyles(selectedElmGhost, {
          <span class="hljs-attr">width</span>: width,
          <span class="hljs-attr">height</span>: height
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-785">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-785">&#182;</a>
              </div>
              <p>Update resize helper position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        resizeHelperX = selectedHandle.startPos.x + deltaX;
        resizeHelperY = selectedHandle.startPos.y + deltaY;
        resizeHelperX = resizeHelperX &gt; <span class="hljs-number">0</span> ? resizeHelperX : <span class="hljs-number">0</span>;
        resizeHelperY = resizeHelperY &gt; <span class="hljs-number">0</span> ? resizeHelperY : <span class="hljs-number">0</span>;

        dom.setStyles(resizeHelper, {
          <span class="hljs-attr">left</span>: resizeHelperX,
          <span class="hljs-attr">top</span>: resizeHelperY,
          <span class="hljs-attr">display</span>: <span class="hljs-string">'block'</span>
        });

        resizeHelper.innerHTML = width + <span class="hljs-string">' &amp;times; '</span> + height;</pre></div></div>
            
        </li>
        
        
        <li id="section-786">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-786">&#182;</a>
              </div>
              <p>Update ghost X position if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (selectedHandle[<span class="hljs-number">2</span>] &lt; <span class="hljs-number">0</span> &amp;&amp; selectedElmGhost.clientWidth &lt;= width) {
          dom.setStyle(selectedElmGhost, <span class="hljs-string">'left'</span>, selectedElmX + (startW - width));
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-787">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-787">&#182;</a>
              </div>
              <p>Update ghost Y position if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (selectedHandle[<span class="hljs-number">3</span>] &lt; <span class="hljs-number">0</span> &amp;&amp; selectedElmGhost.clientHeight &lt;= height) {
          dom.setStyle(selectedElmGhost, <span class="hljs-string">'top'</span>, selectedElmY + (startH - height));
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-788">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-788">&#182;</a>
              </div>
              <p>Calculate how must overflow we got</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        deltaX = rootElement.scrollWidth - startScrollWidth;
        deltaY = rootElement.scrollHeight - startScrollHeight;</pre></div></div>
            
        </li>
        
        
        <li id="section-789">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-789">&#182;</a>
              </div>
              <p>Re-position the resize helper based on the overflow</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (deltaX + deltaY !== <span class="hljs-number">0</span>) {
          dom.setStyles(resizeHelper, {
            <span class="hljs-attr">left</span>: resizeHelperX - deltaX,
            <span class="hljs-attr">top</span>: resizeHelperY - deltaY
          });
        }

        <span class="hljs-keyword">if</span> (!resizeStarted) {
          editor.fire(<span class="hljs-string">'ObjectResizeStart'</span>, { <span class="hljs-attr">target</span>: selectedElm, <span class="hljs-attr">width</span>: startW, <span class="hljs-attr">height</span>: startH });
          resizeStarted = <span class="hljs-literal">true</span>;
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endGhostResize</span>(<span class="hljs-params"></span>) </span>{
        resizeStarted = <span class="hljs-literal">false</span>;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSizeProp</span>(<span class="hljs-params">name, value</span>) </span>{
          <span class="hljs-keyword">if</span> (value) {</pre></div></div>
            
        </li>
        
        
        <li id="section-790">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-790">&#182;</a>
              </div>
              <p>Resize by using style or attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (selectedElm.style[name] || !editor.schema.isValid(selectedElm.nodeName.toLowerCase(), name)) {
              dom.setStyle(selectedElm, name, value);
            } <span class="hljs-keyword">else</span> {
              dom.setAttrib(selectedElm, name, value);
            }
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-791">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-791">&#182;</a>
              </div>
              <p>Set width/height properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        setSizeProp(<span class="hljs-string">'width'</span>, width);
        setSizeProp(<span class="hljs-string">'height'</span>, height);

        dom.unbind(editableDoc, <span class="hljs-string">'mousemove'</span>, resizeGhostElement);
        dom.unbind(editableDoc, <span class="hljs-string">'mouseup'</span>, endGhostResize);

        <span class="hljs-keyword">if</span> (rootDocument != editableDoc) {
          dom.unbind(rootDocument, <span class="hljs-string">'mousemove'</span>, resizeGhostElement);
          dom.unbind(rootDocument, <span class="hljs-string">'mouseup'</span>, endGhostResize);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-792">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-792">&#182;</a>
              </div>
              <p>Remove ghost/helper and update resize handle positions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        dom.remove(selectedElmGhost);
        dom.remove(resizeHelper);

        <span class="hljs-keyword">if</span> (!isIE || selectedElm.nodeName == <span class="hljs-string">"TABLE"</span>) {
          showResizeRect(selectedElm);
        }

        editor.fire(<span class="hljs-string">'ObjectResized'</span>, { <span class="hljs-attr">target</span>: selectedElm, <span class="hljs-attr">width</span>: width, <span class="hljs-attr">height</span>: height });
        dom.setAttrib(selectedElm, <span class="hljs-string">'style'</span>, dom.getAttrib(selectedElm, <span class="hljs-string">'style'</span>));
        editor.nodeChanged();
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showResizeRect</span>(<span class="hljs-params">targetElm, mouseDownHandleName, mouseDownEvent</span>) </span>{
        <span class="hljs-keyword">var</span> position, targetWidth, targetHeight, e, rect;

        hideResizeRect();
        unbindResizeHandleEvents();</pre></div></div>
            
        </li>
        
        
        <li id="section-793">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-793">&#182;</a>
              </div>
              <p>Get position and size of target</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        position = dom.getPos(targetElm, rootElement);
        selectedElmX = position.x;
        selectedElmY = position.y;
        rect = targetElm.getBoundingClientRect(); <span class="hljs-comment">// Fix for Gecko offsetHeight for table with caption</span>
        targetWidth = rect.width || (rect.right - rect.left);
        targetHeight = rect.height || (rect.bottom - rect.top);</pre></div></div>
            
        </li>
        
        
        <li id="section-794">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-794">&#182;</a>
              </div>
              <p>Reset width/height if user selects a new image/table</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (selectedElm != targetElm) {
          detachResizeStartListener();
          selectedElm = targetElm;
          width = height = <span class="hljs-number">0</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-795">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-795">&#182;</a>
              </div>
              <p>Makes it possible to disable resizing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        e = editor.fire(<span class="hljs-string">'ObjectSelected'</span>, { <span class="hljs-attr">target</span>: targetElm });

        <span class="hljs-keyword">if</span> (isResizable(targetElm) &amp;&amp; !e.isDefaultPrevented()) {
          each(resizeHandles, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">handle, name</span>) </span>{
            <span class="hljs-keyword">var</span> handleElm;

            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startDrag</span>(<span class="hljs-params">e</span>) </span>{
              startX = e.screenX;
              startY = e.screenY;
              startW = selectedElm.clientWidth;
              startH = selectedElm.clientHeight;
              ratio = startH / startW;
              selectedHandle = handle;

              handle.startPos = {
                <span class="hljs-attr">x</span>: targetWidth * handle[<span class="hljs-number">0</span>] + selectedElmX,
                <span class="hljs-attr">y</span>: targetHeight * handle[<span class="hljs-number">1</span>] + selectedElmY
              };

              startScrollWidth = rootElement.scrollWidth;
              startScrollHeight = rootElement.scrollHeight;

              selectedElmGhost = selectedElm.cloneNode(<span class="hljs-literal">true</span>);
              dom.addClass(selectedElmGhost, <span class="hljs-string">'mce-clonedresizable'</span>);
              dom.setAttrib(selectedElmGhost, <span class="hljs-string">'data-mce-bogus'</span>, <span class="hljs-string">'all'</span>);
              selectedElmGhost.contentEditable = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Hides IE move layer cursor</span>
              selectedElmGhost.unSelectabe = <span class="hljs-literal">true</span>;
              dom.setStyles(selectedElmGhost, {
                <span class="hljs-attr">left</span>: selectedElmX,
                <span class="hljs-attr">top</span>: selectedElmY,
                <span class="hljs-attr">margin</span>: <span class="hljs-number">0</span>
              });

              selectedElmGhost.removeAttribute(<span class="hljs-string">'data-mce-selected'</span>);
              rootElement.appendChild(selectedElmGhost);

              dom.bind(editableDoc, <span class="hljs-string">'mousemove'</span>, resizeGhostElement);
              dom.bind(editableDoc, <span class="hljs-string">'mouseup'</span>, endGhostResize);

              <span class="hljs-keyword">if</span> (rootDocument != editableDoc) {
                dom.bind(rootDocument, <span class="hljs-string">'mousemove'</span>, resizeGhostElement);
                dom.bind(rootDocument, <span class="hljs-string">'mouseup'</span>, endGhostResize);
              }

              resizeHelper = dom.add(rootElement, <span class="hljs-string">'div'</span>, {
                <span class="hljs-string">'class'</span>: <span class="hljs-string">'mce-resize-helper'</span>,
                <span class="hljs-string">'data-mce-bogus'</span>: <span class="hljs-string">'all'</span>
              }, startW + <span class="hljs-string">' &amp;times; '</span> + startH);
            }

            <span class="hljs-keyword">if</span> (mouseDownHandleName) {</pre></div></div>
            
        </li>
        
        
        <li id="section-796">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-796">&#182;</a>
              </div>
              <p>Drag started by IE native resizestart</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (name == mouseDownHandleName) {
                startDrag(mouseDownEvent);
              }

              <span class="hljs-keyword">return</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-797">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-797">&#182;</a>
              </div>
              <p>Get existing or render resize handle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            handleElm = dom.get(<span class="hljs-string">'mceResizeHandle'</span> + name);
            <span class="hljs-keyword">if</span> (handleElm) {
              dom.remove(handleElm);
            }

            handleElm = dom.add(rootElement, <span class="hljs-string">'div'</span>, {
              <span class="hljs-attr">id</span>: <span class="hljs-string">'mceResizeHandle'</span> + name,
              <span class="hljs-string">'data-mce-bogus'</span>: <span class="hljs-string">'all'</span>,
              <span class="hljs-string">'class'</span>: <span class="hljs-string">'mce-resizehandle'</span>,
              <span class="hljs-attr">unselectable</span>: <span class="hljs-literal">true</span>,
              <span class="hljs-attr">style</span>: <span class="hljs-string">'cursor:'</span> + name + <span class="hljs-string">'-resize; margin:0; padding:0'</span>
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-798">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-798">&#182;</a>
              </div>
              <p>Hides IE move layer cursor
If we set it on Chrome we get this wounderful bug: #6725</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (Env.ie) {
              handleElm.contentEditable = <span class="hljs-literal">false</span>;
            }

            dom.bind(handleElm, <span class="hljs-string">'mousedown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
              e.stopImmediatePropagation();
              e.preventDefault();
              startDrag(e);
            });

            handle.elm = handleElm;</pre></div></div>
            
        </li>
        
        
        <li id="section-799">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-799">&#182;</a>
              </div>
              <p>Position element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            dom.setStyles(handleElm, {
              <span class="hljs-attr">left</span>: (targetWidth * handle[<span class="hljs-number">0</span>] + selectedElmX) - (handleElm.offsetWidth / <span class="hljs-number">2</span>),
              <span class="hljs-attr">top</span>: (targetHeight * handle[<span class="hljs-number">1</span>] + selectedElmY) - (handleElm.offsetHeight / <span class="hljs-number">2</span>)
            });
          });
        } <span class="hljs-keyword">else</span> {
          hideResizeRect();
        }

        selectedElm.setAttribute(<span class="hljs-string">'data-mce-selected'</span>, <span class="hljs-string">'1'</span>);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hideResizeRect</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> name, handleElm;

        unbindResizeHandleEvents();

        <span class="hljs-keyword">if</span> (selectedElm) {
          selectedElm.removeAttribute(<span class="hljs-string">'data-mce-selected'</span>);
        }

        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> resizeHandles) {
          handleElm = dom.get(<span class="hljs-string">'mceResizeHandle'</span> + name);
          <span class="hljs-keyword">if</span> (handleElm) {
            dom.unbind(handleElm);
            dom.remove(handleElm);
          }
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateResizeRect</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> startElm, controlElm;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isChildOrEqual</span>(<span class="hljs-params">node, parent</span>) </span>{
          <span class="hljs-keyword">if</span> (node) {
            <span class="hljs-keyword">do</span> {
              <span class="hljs-keyword">if</span> (node === parent) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              }
            } <span class="hljs-keyword">while</span> ((node = node.parentNode));
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-800">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-800">&#182;</a>
              </div>
              <p>Ignore all events while resizing or if the editor instance was removed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (resizeStarted || editor.removed) {
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-801">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-801">&#182;</a>
              </div>
              <p>Remove data-mce-selected from all elements since they might have been copied using Ctrl+c/v</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        each(dom.select(<span class="hljs-string">'img[data-mce-selected],hr[data-mce-selected]'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">img</span>) </span>{
          img.removeAttribute(<span class="hljs-string">'data-mce-selected'</span>);
        });

        controlElm = e.type == <span class="hljs-string">'mousedown'</span> ? e.target : selection.getNode();
        controlElm = dom.$(controlElm).closest(isIE ? <span class="hljs-string">'table'</span> : <span class="hljs-string">'table,img,hr'</span>)[<span class="hljs-number">0</span>];

        <span class="hljs-keyword">if</span> (isChildOrEqual(controlElm, rootElement)) {
          disableGeckoResize();
          startElm = selection.getStart(<span class="hljs-literal">true</span>);

          <span class="hljs-keyword">if</span> (isChildOrEqual(startElm, controlElm) &amp;&amp; isChildOrEqual(selection.getEnd(<span class="hljs-literal">true</span>), controlElm)) {
            <span class="hljs-keyword">if</span> (!isIE || (controlElm != startElm &amp;&amp; startElm.nodeName !== <span class="hljs-string">'IMG'</span>)) {
              showResizeRect(controlElm);
              <span class="hljs-keyword">return</span>;
            }
          }
        }

        hideResizeRect();
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attachEvent</span>(<span class="hljs-params">elm, name, func</span>) </span>{
        <span class="hljs-keyword">if</span> (elm &amp;&amp; elm.attachEvent) {
          elm.attachEvent(<span class="hljs-string">'on'</span> + name, func);
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detachEvent</span>(<span class="hljs-params">elm, name, func</span>) </span>{
        <span class="hljs-keyword">if</span> (elm &amp;&amp; elm.detachEvent) {
          elm.detachEvent(<span class="hljs-string">'on'</span> + name, func);
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resizeNativeStart</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> target = e.srcElement, pos, name, corner, cornerX, cornerY, relativeX, relativeY;

        pos = target.getBoundingClientRect();
        relativeX = lastMouseDownEvent.clientX - pos.left;
        relativeY = lastMouseDownEvent.clientY - pos.top;</pre></div></div>
            
        </li>
        
        
        <li id="section-802">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-802">&#182;</a>
              </div>
              <p>Figure out what corner we are draging on</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> resizeHandles) {
          corner = resizeHandles[name];

          cornerX = target.offsetWidth * corner[<span class="hljs-number">0</span>];
          cornerY = target.offsetHeight * corner[<span class="hljs-number">1</span>];

          <span class="hljs-keyword">if</span> (abs(cornerX - relativeX) &lt; <span class="hljs-number">8</span> &amp;&amp; abs(cornerY - relativeY) &lt; <span class="hljs-number">8</span>) {
            selectedHandle = corner;
            <span class="hljs-keyword">break</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-803">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-803">&#182;</a>
              </div>
              <p>Remove native selection and let the magic begin</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        resizeStarted = <span class="hljs-literal">true</span>;
        editor.fire(<span class="hljs-string">'ObjectResizeStart'</span>, {
          <span class="hljs-attr">target</span>: selectedElm,
          <span class="hljs-attr">width</span>: selectedElm.clientWidth,
          <span class="hljs-attr">height</span>: selectedElm.clientHeight
        });
        editor.getDoc().selection.empty();
        showResizeRect(target, name, lastMouseDownEvent);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preventDefault</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (e.preventDefault) {
          e.preventDefault();
        } <span class="hljs-keyword">else</span> {
          e.returnValue = <span class="hljs-literal">false</span>; <span class="hljs-comment">// IE</span>
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isWithinContentEditableFalse</span>(<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">return</span> isContentEditableFalse(getContentEditableRoot(editor.getBody(), elm));
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nativeControlSelect</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> target = e.srcElement;

        <span class="hljs-keyword">if</span> (isWithinContentEditableFalse(target)) {
          preventDefault(e);
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (target != selectedElm) {
          editor.fire(<span class="hljs-string">'ObjectSelected'</span>, { <span class="hljs-attr">target</span>: target });
          detachResizeStartListener();

          <span class="hljs-keyword">if</span> (target.id.indexOf(<span class="hljs-string">'mceResizeHandle'</span>) === <span class="hljs-number">0</span>) {
            e.returnValue = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (target.nodeName == <span class="hljs-string">'IMG'</span> || target.nodeName == <span class="hljs-string">'TABLE'</span>) {
            hideResizeRect();
            selectedElm = target;
            attachEvent(target, <span class="hljs-string">'resizestart'</span>, resizeNativeStart);
          }
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detachResizeStartListener</span>(<span class="hljs-params"></span>) </span>{
        detachEvent(selectedElm, <span class="hljs-string">'resizestart'</span>, resizeNativeStart);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unbindResizeHandleEvents</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> resizeHandles) {
          <span class="hljs-keyword">var</span> handle = resizeHandles[name];

          <span class="hljs-keyword">if</span> (handle.elm) {
            dom.unbind(handle.elm);
            <span class="hljs-keyword">delete</span> handle.elm;
          }
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disableGeckoResize</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-804">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-804">&#182;</a>
              </div>
              <p>Disable object resizing on Gecko</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          editor.getDoc().execCommand(<span class="hljs-string">'enableObjectResizing'</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-805">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-805">&#182;</a>
              </div>
              <p>Ignore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">controlSelect</span>(<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">var</span> ctrlRng;

        <span class="hljs-keyword">if</span> (!isIE) {
          <span class="hljs-keyword">return</span>;
        }

        ctrlRng = editableDoc.body.createControlRange();

        <span class="hljs-keyword">try</span> {
          ctrlRng.addElement(elm);
          ctrlRng.select();
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-806">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-806">&#182;</a>
              </div>
              <p>Ignore since the element cant be control selected for example a P tag</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }
      }

      editor.on(<span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (isIE) {</pre></div></div>
            
        </li>
        
        
        <li id="section-807">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-807">&#182;</a>
              </div>
              <p>Hide the resize rect on resize and reselect the image</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          editor.on(<span class="hljs-string">'ObjectResized'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">if</span> (e.target.nodeName != <span class="hljs-string">'TABLE'</span>) {
              hideResizeRect();
              controlSelect(e.target);
            }
          });

          attachEvent(rootElement, <span class="hljs-string">'controlselect'</span>, nativeControlSelect);

          editor.on(<span class="hljs-string">'mousedown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            lastMouseDownEvent = e;
          });
        } <span class="hljs-keyword">else</span> {
          disableGeckoResize();</pre></div></div>
            
        </li>
        
        
        <li id="section-808">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-808">&#182;</a>
              </div>
              <p>Sniff sniff, hard to feature detect this stuff</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (Env.ie &gt;= <span class="hljs-number">11</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-809">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-809">&#182;</a>
              </div>
              <p>Needs to be mousedown for drag/drop to work on IE 11
Needs to be click on Edge to properly select images</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            editor.on(<span class="hljs-string">'mousedown click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
              <span class="hljs-keyword">var</span> target = e.target, nodeName = target.nodeName;

              <span class="hljs-keyword">if</span> (!resizeStarted &amp;&amp; <span class="hljs-regexp">/^(TABLE|IMG|HR)$/</span>.test(nodeName) &amp;&amp; !isWithinContentEditableFalse(target)) {
                editor.selection.select(target, nodeName == <span class="hljs-string">'TABLE'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-810">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-810">&#182;</a>
              </div>
              <p>Only fire once since nodeChange is expensive</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (e.type == <span class="hljs-string">'mousedown'</span>) {
                  editor.nodeChanged();
                }
              }
            });

            editor.dom.bind(rootElement, <span class="hljs-string">'mscontrolselect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
              <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delayedSelect</span>(<span class="hljs-params">node</span>) </span>{
                Delay.setEditorTimeout(editor, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                  editor.selection.select(node);
                });
              }

              <span class="hljs-keyword">if</span> (isWithinContentEditableFalse(e.target)) {
                e.preventDefault();
                delayedSelect(e.target);
                <span class="hljs-keyword">return</span>;
              }

              <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(TABLE|IMG|HR)$/</span>.test(e.target.nodeName)) {
                e.preventDefault();</pre></div></div>
            
        </li>
        
        
        <li id="section-811">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-811">&#182;</a>
              </div>
              <p>This moves the selection from being a control selection to a text like selection like in WebKit #6753
TODO: Fix this the day IE works like other browsers without this nasty native ugly control selections.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (e.target.tagName == <span class="hljs-string">'IMG'</span>) {
                  delayedSelect(e.target);
                }
              }
            });
          }
        }

        <span class="hljs-keyword">var</span> throttledUpdateResizeRect = Delay.throttle(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (!editor.composing) {
            updateResizeRect(e);
          }
        });

        editor.on(<span class="hljs-string">'nodechange ResizeEditor ResizeWindow drop'</span>, throttledUpdateResizeRect);</pre></div></div>
            
        </li>
        
        
        <li id="section-812">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-812">&#182;</a>
              </div>
              <p>Update resize rect while typing in a table</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        editor.on(<span class="hljs-string">'keyup compositionend'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-813">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-813">&#182;</a>
              </div>
              <p>Dont update the resize rect while composing since it blows away the IME see: #2710</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (selectedElm &amp;&amp; selectedElm.nodeName == <span class="hljs-string">"TABLE"</span>) {
            throttledUpdateResizeRect(e);
          }
        });

        editor.on(<span class="hljs-string">'hide blur'</span>, hideResizeRect);</pre></div></div>
            
        </li>
        
        
        <li id="section-814">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-814">&#182;</a>
              </div>
              <p>Hide rect on focusout since it would float on top of windows otherwise
editor.on(focusout, hideResizeRect);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      });

      editor.on(<span class="hljs-string">'remove'</span>, unbindResizeHandleEvents);

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destroy</span>(<span class="hljs-params"></span>) </span>{
        selectedElm = selectedElmGhost = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (isIE) {
          detachResizeStartListener();
          detachEvent(rootElement, <span class="hljs-string">'controlselect'</span>, nativeControlSelect);
        }
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">isResizable</span>: isResizable,
        <span class="hljs-attr">showResizeRect</span>: showResizeRect,
        <span class="hljs-attr">hideResizeRect</span>: hideResizeRect,
        <span class="hljs-attr">updateResizeRect</span>: updateResizeRect,
        <span class="hljs-attr">controlSelect</span>: controlSelect,
        <span class="hljs-attr">destroy</span>: destroy
      };
    };
  }
);

<span class="hljs-comment">/**
 * Fun.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Functional utility class.
 *
 * @private
 * @class tinymce.util.Fun
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.Fun'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> slice = [].slice;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constant</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> value;
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">negate</span>(<span class="hljs-params">predicate</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
        <span class="hljs-keyword">return</span> !predicate(x);
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">f, g</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
        <span class="hljs-keyword">return</span> f(g(x));
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">or</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> args = slice.call(<span class="hljs-built_in">arguments</span>);

      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) {
          <span class="hljs-keyword">if</span> (args[i](x)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">and</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> args = slice.call(<span class="hljs-built_in">arguments</span>);

      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) {
          <span class="hljs-keyword">if</span> (!args[i](x)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>{
      <span class="hljs-keyword">var</span> args = slice.call(<span class="hljs-built_in">arguments</span>);

      <span class="hljs-keyword">if</span> (args.length - <span class="hljs-number">1</span> &gt;= fn.length) {
        <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args.slice(<span class="hljs-number">1</span>));
      }

      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> tempArgs = args.concat([].slice.call(<span class="hljs-built_in">arguments</span>));
        <span class="hljs-keyword">return</span> curry.apply(<span class="hljs-keyword">this</span>, tempArgs);
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span>(<span class="hljs-params"></span>) </span>{
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">constant</span>: constant,
      <span class="hljs-attr">negate</span>: negate,
      <span class="hljs-attr">and</span>: and,
      <span class="hljs-attr">or</span>: or,
      <span class="hljs-attr">curry</span>: curry,
      <span class="hljs-attr">compose</span>: compose,
      <span class="hljs-attr">noop</span>: noop
    };
  }
);
<span class="hljs-comment">/**
 * CaretCandidate.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module contains logic for handling caret candidates. A caret candidate is
 * for example text nodes, images, input elements, cE=false elements etc.
 *
 * @private
 * @class tinymce.caret.CaretCandidate
 */</span>
define(
  <span class="hljs-string">'tinymce.core.caret.CaretCandidate'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.NodeType"</span>,
    <span class="hljs-string">"tinymce.core.util.Arr"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretContainer"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">NodeType, Arr, CaretContainer</span>) </span>{
    <span class="hljs-keyword">var</span> isContentEditableTrue = NodeType.isContentEditableTrue,
      isContentEditableFalse = NodeType.isContentEditableFalse,
      isBr = NodeType.isBr,
      isText = NodeType.isText,
      isInvalidTextElement = NodeType.matchNodeNames(<span class="hljs-string">'script style textarea'</span>),
      isAtomicInline = NodeType.matchNodeNames(<span class="hljs-string">'img input textarea hr iframe video audio object'</span>),
      isTable = NodeType.matchNodeNames(<span class="hljs-string">'table'</span>),
      isCaretContainer = CaretContainer.isCaretContainer;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCaretCandidate</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">if</span> (isCaretContainer(node)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">if</span> (isText(node)) {
        <span class="hljs-keyword">if</span> (isInvalidTextElement(node.parentNode)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">return</span> isAtomicInline(node) || isBr(node) || isTable(node) || isContentEditableFalse(node);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isInEditable</span>(<span class="hljs-params">node, rootNode</span>) </span>{
      <span class="hljs-keyword">for</span> (node = node.parentNode; node &amp;&amp; node != rootNode; node = node.parentNode) {
        <span class="hljs-keyword">if</span> (isContentEditableFalse(node)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">if</span> (isContentEditableTrue(node)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAtomicContentEditableFalse</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">if</span> (!isContentEditableFalse(node)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">return</span> Arr.reduce(node.getElementsByTagName(<span class="hljs-string">'*'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result, elm</span>) </span>{
        <span class="hljs-keyword">return</span> result || isContentEditableTrue(elm);
      }, <span class="hljs-literal">false</span>) !== <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAtomic</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> isAtomicInline(node) || isAtomicContentEditableFalse(node);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEditableCaretCandidate</span>(<span class="hljs-params">node, rootNode</span>) </span>{
      <span class="hljs-keyword">return</span> isCaretCandidate(node) &amp;&amp; isInEditable(node, rootNode);
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">isCaretCandidate</span>: isCaretCandidate,
      <span class="hljs-attr">isInEditable</span>: isInEditable,
      <span class="hljs-attr">isAtomic</span>: isAtomic,
      <span class="hljs-attr">isEditableCaretCandidate</span>: isEditableCaretCandidate
    };
  }
);
<span class="hljs-comment">/**
 * ClientRect.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Utility functions for working with client rects.
 *
 * @private
 * @class tinymce.geom.ClientRect
 */</span>
define(
  <span class="hljs-string">'tinymce.core.geom.ClientRect'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> round = <span class="hljs-built_in">Math</span>.round;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">rect</span>) </span>{
      <span class="hljs-keyword">if</span> (!rect) {
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">bottom</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">right</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">0</span> };
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">left</span>: round(rect.left),
        <span class="hljs-attr">top</span>: round(rect.top),
        <span class="hljs-attr">bottom</span>: round(rect.bottom),
        <span class="hljs-attr">right</span>: round(rect.right),
        <span class="hljs-attr">width</span>: round(rect.width),
        <span class="hljs-attr">height</span>: round(rect.height)
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collapse</span>(<span class="hljs-params">clientRect, toStart</span>) </span>{
      clientRect = clone(clientRect);

      <span class="hljs-keyword">if</span> (toStart) {
        clientRect.right = clientRect.left;
      } <span class="hljs-keyword">else</span> {
        clientRect.left = clientRect.left + clientRect.width;
        clientRect.right = clientRect.left;
      }

      clientRect.width = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">return</span> clientRect;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEqual</span>(<span class="hljs-params">rect1, rect2</span>) </span>{
      <span class="hljs-keyword">return</span> (
        rect1.left === rect2.left &amp;&amp;
        rect1.top === rect2.top &amp;&amp;
        rect1.bottom === rect2.bottom &amp;&amp;
        rect1.right === rect2.right
      );
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidOverflow</span>(<span class="hljs-params">overflowY, clientRect1, clientRect2</span>) </span>{
      <span class="hljs-keyword">return</span> overflowY &gt;= <span class="hljs-number">0</span> &amp;&amp; overflowY &lt;= <span class="hljs-built_in">Math</span>.min(clientRect1.height, clientRect2.height) / <span class="hljs-number">2</span>;

    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAbove</span>(<span class="hljs-params">clientRect1, clientRect2</span>) </span>{
      <span class="hljs-keyword">if</span> ((clientRect1.bottom - clientRect1.height / <span class="hljs-number">2</span>) &lt; clientRect2.top) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (clientRect1.top &gt; clientRect2.bottom) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">return</span> isValidOverflow(clientRect2.top - clientRect1.bottom, clientRect1, clientRect2);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBelow</span>(<span class="hljs-params">clientRect1, clientRect2</span>) </span>{
      <span class="hljs-keyword">if</span> (clientRect1.top &gt; clientRect2.bottom) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (clientRect1.bottom &lt; clientRect2.top) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">return</span> isValidOverflow(clientRect2.bottom - clientRect1.top, clientRect1, clientRect2);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLeft</span>(<span class="hljs-params">clientRect1, clientRect2</span>) </span>{
      <span class="hljs-keyword">return</span> clientRect1.left &lt; clientRect2.left;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isRight</span>(<span class="hljs-params">clientRect1, clientRect2</span>) </span>{
      <span class="hljs-keyword">return</span> clientRect1.right &gt; clientRect2.right;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare</span>(<span class="hljs-params">clientRect1, clientRect2</span>) </span>{
      <span class="hljs-keyword">if</span> (isAbove(clientRect1, clientRect2)) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
      }

      <span class="hljs-keyword">if</span> (isBelow(clientRect1, clientRect2)) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
      }

      <span class="hljs-keyword">if</span> (isLeft(clientRect1, clientRect2)) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
      }

      <span class="hljs-keyword">if</span> (isRight(clientRect1, clientRect2)) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">containsXY</span>(<span class="hljs-params">clientRect, clientX, clientY</span>) </span>{
      <span class="hljs-keyword">return</span> (
        clientX &gt;= clientRect.left &amp;&amp;
        clientX &lt;= clientRect.right &amp;&amp;
        clientY &gt;= clientRect.top &amp;&amp;
        clientY &lt;= clientRect.bottom
      );
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">clone</span>: clone,
      <span class="hljs-attr">collapse</span>: collapse,
      <span class="hljs-attr">isEqual</span>: isEqual,
      <span class="hljs-attr">isAbove</span>: isAbove,
      <span class="hljs-attr">isBelow</span>: isBelow,
      <span class="hljs-attr">isLeft</span>: isLeft,
      <span class="hljs-attr">isRight</span>: isRight,
      <span class="hljs-attr">compare</span>: compare,
      <span class="hljs-attr">containsXY</span>: containsXY
    };
  }
);

<span class="hljs-comment">/**
 * ExtendingChar.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class contains logic for detecting extending characters.
 *
 * @private
 * @class tinymce.text.ExtendingChar
 * @example
 * var isExtending = ExtendingChar.isExtendingChar('a');
 */</span>
define(
  <span class="hljs-string">'tinymce.core.text.ExtendingChar'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-815">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-815">&#182;</a>
              </div>
              <p>Generated from: <a href="http://www.unicode.org/Public/UNIDATA/DerivedCoreProperties.txt">http://www.unicode.org/Public/UNIDATA/DerivedCoreProperties.txt</a>
Only includes the characters in that fit into UCS-2 16 bit</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> extendingChars = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(
      <span class="hljs-string">"[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A"</span> +
      <span class="hljs-string">"\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0"</span> +
      <span class="hljs-string">"\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C"</span> +
      <span class="hljs-string">"\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2-\u09E3"</span> +
      <span class="hljs-string">"\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC"</span> +
      <span class="hljs-string">"\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B57"</span> +
      <span class="hljs-string">"\u0B62-\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56"</span> +
      <span class="hljs-string">"\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC-\u0CCD\u0CD5-\u0CD6\u0CE2-\u0CE3\u0D01\u0D3E\u0D41-\u0D44"</span> +
      <span class="hljs-string">"\u0D4D\u0D57\u0D62-\u0D63\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9"</span> +
      <span class="hljs-string">"\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97"</span> +
      <span class="hljs-string">"\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074"</span> +
      <span class="hljs-string">"\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5"</span> +
      <span class="hljs-string">"\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18"</span> +
      <span class="hljs-string">"\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1ABE\u1B00-\u1B03\u1B34"</span> +
      <span class="hljs-string">"\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9"</span> +
      <span class="hljs-string">"\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9"</span> +
      <span class="hljs-string">"\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C-\u200D\u20D0-\u20DC\u20DD-\u20E0\u20E1\u20E2-\u20E4\u20E5-\u20F0\u2CEF-\u2CF1"</span> +
      <span class="hljs-string">"\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u302E-\u302F\u3099-\u309A\uA66F\uA670-\uA672\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1"</span> +
      <span class="hljs-string">"\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC"</span> +
      <span class="hljs-string">"\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1"</span> +
      <span class="hljs-string">"\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E-\uFF9F]"</span>
    );

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isExtendingChar</span>(<span class="hljs-params">ch</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> ch == <span class="hljs-string">"string"</span> &amp;&amp; ch.charCodeAt(<span class="hljs-number">0</span>) &gt;= <span class="hljs-number">768</span> &amp;&amp; extendingChars.test(ch);
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">isExtendingChar</span>: isExtendingChar
    };
  }
);
<span class="hljs-comment">/**
 * CaretPosition.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module contains logic for creating caret positions within a document a caretposition
 * is similar to a DOMRange object but it doesn't have two endpoints and is also more lightweight
 * since it's now updated live when the DOM changes.
 *
 * @private
 * @class tinymce.caret.CaretPosition
 * @example
 * var caretPos1 = new CaretPosition(container, offset);
 * var caretPos2 = CaretPosition.fromRangeStart(someRange);
 */</span>
define(
  <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Fun"</span>,
    <span class="hljs-string">"tinymce.core.dom.NodeType"</span>,
    <span class="hljs-string">"tinymce.core.dom.DOMUtils"</span>,
    <span class="hljs-string">"tinymce.core.dom.RangeUtils"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretCandidate"</span>,
    <span class="hljs-string">"tinymce.core.geom.ClientRect"</span>,
    <span class="hljs-string">"tinymce.core.text.ExtendingChar"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, NodeType, DOMUtils, RangeUtils, CaretCandidate, ClientRect, ExtendingChar</span>) </span>{
    <span class="hljs-keyword">var</span> isElement = NodeType.isElement,
      isCaretCandidate = CaretCandidate.isCaretCandidate,
      isBlock = NodeType.matchStyleValues(<span class="hljs-string">'display'</span>, <span class="hljs-string">'block table'</span>),
      isFloated = NodeType.matchStyleValues(<span class="hljs-string">'float'</span>, <span class="hljs-string">'left right'</span>),
      isValidElementCaretCandidate = Fun.and(isElement, isCaretCandidate, Fun.negate(isFloated)),
      isNotPre = Fun.negate(NodeType.matchStyleValues(<span class="hljs-string">'white-space'</span>, <span class="hljs-string">'pre pre-line pre-wrap'</span>)),
      isText = NodeType.isText,
      isBr = NodeType.isBr,
      nodeIndex = DOMUtils.nodeIndex,
      resolveIndex = RangeUtils.getNode;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRange</span>(<span class="hljs-params">doc</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-string">"createRange"</span> <span class="hljs-keyword">in</span> doc ? doc.createRange() : DOMUtils.DOM.createRng();
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isWhiteSpace</span>(<span class="hljs-params">chr</span>) </span>{
      <span class="hljs-keyword">return</span> chr &amp;&amp; <span class="hljs-regexp">/[\r\n\t ]/</span>.test(chr);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isHiddenWhiteSpaceRange</span>(<span class="hljs-params">range</span>) </span>{
      <span class="hljs-keyword">var</span> container = range.startContainer,
        offset = range.startOffset,
        text;

      <span class="hljs-keyword">if</span> (isWhiteSpace(range.toString()) &amp;&amp; isNotPre(container.parentNode)) {
        text = container.data;

        <span class="hljs-keyword">if</span> (isWhiteSpace(text[offset - <span class="hljs-number">1</span>]) || isWhiteSpace(text[offset + <span class="hljs-number">1</span>])) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCaretPositionClientRects</span>(<span class="hljs-params">caretPosition</span>) </span>{
      <span class="hljs-keyword">var</span> clientRects = [], beforeNode, node;</pre></div></div>
            
        </li>
        
        
        <li id="section-816">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-816">&#182;</a>
              </div>
              <p>Hack for older WebKit versions that doesnt
support getBoundingClientRect on BR elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBrClientRect</span>(<span class="hljs-params">brNode</span>) </span>{
        <span class="hljs-keyword">var</span> doc = brNode.ownerDocument,
          rng = createRange(doc),
          nbsp = doc.createTextNode(<span class="hljs-string">'\u00a0'</span>),
          parentNode = brNode.parentNode,
          clientRect;

        parentNode.insertBefore(nbsp, brNode);
        rng.setStart(nbsp, <span class="hljs-number">0</span>);
        rng.setEnd(nbsp, <span class="hljs-number">1</span>);
        clientRect = ClientRect.clone(rng.getBoundingClientRect());
        parentNode.removeChild(nbsp);

        <span class="hljs-keyword">return</span> clientRect;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBoundingClientRect</span>(<span class="hljs-params">item</span>) </span>{
        <span class="hljs-keyword">var</span> clientRect, clientRects;

        clientRects = item.getClientRects();
        <span class="hljs-keyword">if</span> (clientRects.length &gt; <span class="hljs-number">0</span>) {
          clientRect = ClientRect.clone(clientRects[<span class="hljs-number">0</span>]);
        } <span class="hljs-keyword">else</span> {
          clientRect = ClientRect.clone(item.getBoundingClientRect());
        }

        <span class="hljs-keyword">if</span> (isBr(item) &amp;&amp; clientRect.left === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> getBrClientRect(item);
        }

        <span class="hljs-keyword">return</span> clientRect;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collapseAndInflateWidth</span>(<span class="hljs-params">clientRect, toStart</span>) </span>{
        clientRect = ClientRect.collapse(clientRect, toStart);
        clientRect.width = <span class="hljs-number">1</span>;
        clientRect.right = clientRect.left + <span class="hljs-number">1</span>;

        <span class="hljs-keyword">return</span> clientRect;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addUniqueAndValidRect</span>(<span class="hljs-params">clientRect</span>) </span>{
        <span class="hljs-keyword">if</span> (clientRect.height === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (clientRects.length &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">if</span> (ClientRect.isEqual(clientRect, clientRects[clientRects.length - <span class="hljs-number">1</span>])) {
            <span class="hljs-keyword">return</span>;
          }
        }

        clientRects.push(clientRect);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCharacterOffset</span>(<span class="hljs-params">container, offset</span>) </span>{
        <span class="hljs-keyword">var</span> range = createRange(container.ownerDocument);

        <span class="hljs-keyword">if</span> (offset &lt; container.data.length) {
          <span class="hljs-keyword">if</span> (ExtendingChar.isExtendingChar(container.data[offset])) {
            <span class="hljs-keyword">return</span> clientRects;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-817">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-817">&#182;</a>
              </div>
              <p>WebKit returns two client rects for a position after an extending
character a\uxxx|b so expand on b and collapse to start of b box</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (ExtendingChar.isExtendingChar(container.data[offset - <span class="hljs-number">1</span>])) {
            range.setStart(container, offset);
            range.setEnd(container, offset + <span class="hljs-number">1</span>);

            <span class="hljs-keyword">if</span> (!isHiddenWhiteSpaceRange(range)) {
              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), <span class="hljs-literal">false</span>));
              <span class="hljs-keyword">return</span> clientRects;
            }
          }
        }

        <span class="hljs-keyword">if</span> (offset &gt; <span class="hljs-number">0</span>) {
          range.setStart(container, offset - <span class="hljs-number">1</span>);
          range.setEnd(container, offset);

          <span class="hljs-keyword">if</span> (!isHiddenWhiteSpaceRange(range)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), <span class="hljs-literal">false</span>));
          }
        }

        <span class="hljs-keyword">if</span> (offset &lt; container.data.length) {
          range.setStart(container, offset);
          range.setEnd(container, offset + <span class="hljs-number">1</span>);

          <span class="hljs-keyword">if</span> (!isHiddenWhiteSpaceRange(range)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), <span class="hljs-literal">true</span>));
          }
        }
      }

      <span class="hljs-keyword">if</span> (isText(caretPosition.container())) {
        addCharacterOffset(caretPosition.container(), caretPosition.offset());
        <span class="hljs-keyword">return</span> clientRects;
      }

      <span class="hljs-keyword">if</span> (isElement(caretPosition.container())) {
        <span class="hljs-keyword">if</span> (caretPosition.isAtEnd()) {
          node = resolveIndex(caretPosition.container(), caretPosition.offset());
          <span class="hljs-keyword">if</span> (isText(node)) {
            addCharacterOffset(node, node.data.length);
          }

          <span class="hljs-keyword">if</span> (isValidElementCaretCandidate(node) &amp;&amp; !isBr(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), <span class="hljs-literal">false</span>));
          }
        } <span class="hljs-keyword">else</span> {
          node = resolveIndex(caretPosition.container(), caretPosition.offset());
          <span class="hljs-keyword">if</span> (isText(node)) {
            addCharacterOffset(node, <span class="hljs-number">0</span>);
          }

          <span class="hljs-keyword">if</span> (isValidElementCaretCandidate(node) &amp;&amp; caretPosition.isAtEnd()) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), <span class="hljs-literal">false</span>));
            <span class="hljs-keyword">return</span> clientRects;
          }

          beforeNode = resolveIndex(caretPosition.container(), caretPosition.offset() - <span class="hljs-number">1</span>);
          <span class="hljs-keyword">if</span> (isValidElementCaretCandidate(beforeNode) &amp;&amp; !isBr(beforeNode)) {
            <span class="hljs-keyword">if</span> (isBlock(beforeNode) || isBlock(node) || !isValidElementCaretCandidate(node)) {
              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(beforeNode), <span class="hljs-literal">false</span>));
            }
          }

          <span class="hljs-keyword">if</span> (isValidElementCaretCandidate(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), <span class="hljs-literal">true</span>));
          }
        }
      }

      <span class="hljs-keyword">return</span> clientRects;
    }

    <span class="hljs-comment">/**
     * Represents a location within the document by a container and an offset.
     *
     * @constructor
     * @param {Node} container Container node.
     * @param {Number} offset Offset within that container node.
     * @param {Array} clientRects Optional client rects array for the position.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CaretPosition</span>(<span class="hljs-params">container, offset, clientRects</span>) </span>{
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAtStart</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (isText(container)) {
          <span class="hljs-keyword">return</span> offset === <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">return</span> offset === <span class="hljs-number">0</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAtEnd</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (isText(container)) {
          <span class="hljs-keyword">return</span> offset &gt;= container.data.length;
        }

        <span class="hljs-keyword">return</span> offset &gt;= container.childNodes.length;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toRange</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> range;

        range = createRange(container.ownerDocument);
        range.setStart(container, offset);
        range.setEnd(container, offset);

        <span class="hljs-keyword">return</span> range;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getClientRects</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!clientRects) {
          clientRects = getCaretPositionClientRects(<span class="hljs-keyword">new</span> CaretPosition(container, offset));
        }

        <span class="hljs-keyword">return</span> clientRects;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isVisible</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> getClientRects().length &gt; <span class="hljs-number">0</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEqual</span>(<span class="hljs-params">caretPosition</span>) </span>{
        <span class="hljs-keyword">return</span> caretPosition &amp;&amp; container === caretPosition.container() &amp;&amp; offset === caretPosition.offset();
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNode</span>(<span class="hljs-params">before</span>) </span>{
        <span class="hljs-keyword">return</span> resolveIndex(container, before ? offset - <span class="hljs-number">1</span> : offset);
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">/**
         * Returns the container node.
         *
         * @method container
         * @return {Node} Container node.
         */</span>
        container: Fun.constant(container),

        <span class="hljs-comment">/**
         * Returns the offset within the container node.
         *
         * @method offset
         * @return {Number} Offset within the container node.
         */</span>
        offset: Fun.constant(offset),

        <span class="hljs-comment">/**
         * Returns a range out of a the caret position.
         *
         * @method toRange
         * @return {DOMRange} range for the caret position.
         */</span>
        toRange: toRange,

        <span class="hljs-comment">/**
         * Returns the client rects for the caret position. Might be multiple rects between
         * block elements.
         *
         * @method getClientRects
         * @return {Array} Array of client rects.
         */</span>
        getClientRects: getClientRects,

        <span class="hljs-comment">/**
         * Returns true if the caret location is visible/displayed on screen.
         *
         * @method isVisible
         * @return {Boolean} true/false if the position is visible or not.
         */</span>
        isVisible: isVisible,

        <span class="hljs-comment">/**
         * Returns true if the caret location is at the beginning of text node or container.
         *
         * @method isVisible
         * @return {Boolean} true/false if the position is at the beginning.
         */</span>
        isAtStart: isAtStart,

        <span class="hljs-comment">/**
         * Returns true if the caret location is at the end of text node or container.
         *
         * @method isVisible
         * @return {Boolean} true/false if the position is at the end.
         */</span>
        isAtEnd: isAtEnd,

        <span class="hljs-comment">/**
         * Compares the caret position to another caret position. This will only compare the
         * container and offset not it's visual position.
         *
         * @method isEqual
         * @param {tinymce.caret.CaretPosition} caretPosition Caret position to compare with.
         * @return {Boolean} true if the caret positions are equal.
         */</span>
        isEqual: isEqual,

        <span class="hljs-comment">/**
         * Returns the closest resolved node from a node index. That means if you have an offset after the
         * last node in a container it will return that last node.
         *
         * @method getNode
         * @return {Node} Node that is closest to the index.
         */</span>
        getNode: getNode
      };
    }

    <span class="hljs-comment">/**
     * Creates a caret position from the start of a range.
     *
     * @method fromRangeStart
     * @param {DOMRange} range DOM Range to create caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the start of DOM range.
     */</span>
    CaretPosition.fromRangeStart = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">range</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CaretPosition(range.startContainer, range.startOffset);
    };

    <span class="hljs-comment">/**
     * Creates a caret position from the end of a range.
     *
     * @method fromRangeEnd
     * @param {DOMRange} range DOM Range to create caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the end of DOM range.
     */</span>
    CaretPosition.fromRangeEnd = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">range</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CaretPosition(range.endContainer, range.endOffset);
    };

    <span class="hljs-comment">/**
     * Creates a caret position from a node and places the offset after it.
     *
     * @method after
     * @param {Node} node Node to get caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the node.
     */</span>
    CaretPosition.after = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CaretPosition(node.parentNode, nodeIndex(node) + <span class="hljs-number">1</span>);
    };

    <span class="hljs-comment">/**
     * Creates a caret position from a node and places the offset before it.
     *
     * @method before
     * @param {Node} node Node to get caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the node.
     */</span>
    CaretPosition.before = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CaretPosition(node.parentNode, nodeIndex(node));
    };

    CaretPosition.isAtStart = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
      <span class="hljs-keyword">return</span> pos ? pos.isAtStart() : <span class="hljs-literal">false</span>;
    };

    CaretPosition.isAtEnd = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
      <span class="hljs-keyword">return</span> pos ? pos.isAtEnd() : <span class="hljs-literal">false</span>;
    };

    CaretPosition.isTextPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
      <span class="hljs-keyword">return</span> pos ? NodeType.isText(pos.container()) : <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">return</span> CaretPosition;
  }
);
<span class="hljs-comment">/**
 * CaretBookmark.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module creates or resolves xpath like string representation of a CaretPositions.
 *
 * The format is a / separated list of chunks with:
 * &lt;element|text()&gt;[index|after|before]
 *
 * For example:
 *  p[0]/b[0]/text()[0],1 = &lt;p&gt;&lt;b&gt;a|c&lt;/b&gt;&lt;/p&gt;
 *  p[0]/img[0],before = &lt;p&gt;|&lt;img&gt;&lt;/p&gt;
 *  p[0]/img[0],after = &lt;p&gt;&lt;img&gt;|&lt;/p&gt;
 *
 * @private
 * @static
 * @class tinymce.caret.CaretBookmark
 * @example
 * var bookmark = CaretBookmark.create(rootElm, CaretPosition.before(rootElm.firstChild));
 * var caretPosition = CaretBookmark.resolve(bookmark);
 */</span>
define(
  <span class="hljs-string">'tinymce.core.caret.CaretBookmark'</span>,
  [
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.dom.DOMUtils'</span>,
    <span class="hljs-string">'tinymce.core.util.Fun'</span>,
    <span class="hljs-string">'tinymce.core.util.Arr'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">NodeType, DomUtils, Fun, Arr, CaretPosition</span>) </span>{
    <span class="hljs-keyword">var</span> isText = NodeType.isText,
      isBogus = NodeType.isBogus,
      nodeIndex = DomUtils.nodeIndex;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizedParent</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">var</span> parentNode = node.parentNode;

      <span class="hljs-keyword">if</span> (isBogus(parentNode)) {
        <span class="hljs-keyword">return</span> normalizedParent(parentNode);
      }

      <span class="hljs-keyword">return</span> parentNode;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChildNodes</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">if</span> (!node) {
        <span class="hljs-keyword">return</span> [];
      }

      <span class="hljs-keyword">return</span> Arr.reduce(node.childNodes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result, node</span>) </span>{
        <span class="hljs-keyword">if</span> (isBogus(node) &amp;&amp; node.nodeName != <span class="hljs-string">'BR'</span>) {
          result = result.concat(getChildNodes(node));
        } <span class="hljs-keyword">else</span> {
          result.push(node);
        }

        <span class="hljs-keyword">return</span> result;
      }, []);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizedTextOffset</span>(<span class="hljs-params">textNode, offset</span>) </span>{
      <span class="hljs-keyword">while</span> ((textNode = textNode.previousSibling)) {
        <span class="hljs-keyword">if</span> (!isText(textNode)) {
          <span class="hljs-keyword">break</span>;
        }

        offset += textNode.data.length;
      }

      <span class="hljs-keyword">return</span> offset;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">equal</span>(<span class="hljs-params">targetValue</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> targetValue === value;
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizedNodeIndex</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">var</span> nodes, index, numTextFragments;

      nodes = getChildNodes(normalizedParent(node));
      index = Arr.findIndex(nodes, equal(node), node);
      nodes = nodes.slice(<span class="hljs-number">0</span>, index + <span class="hljs-number">1</span>);
      numTextFragments = Arr.reduce(nodes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result, node, i</span>) </span>{
        <span class="hljs-keyword">if</span> (isText(node) &amp;&amp; isText(nodes[i - <span class="hljs-number">1</span>])) {
          result++;
        }

        <span class="hljs-keyword">return</span> result;
      }, <span class="hljs-number">0</span>);

      nodes = Arr.filter(nodes, NodeType.matchNodeNames(node.nodeName));
      index = Arr.findIndex(nodes, equal(node), node);

      <span class="hljs-keyword">return</span> index - numTextFragments;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPathItem</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">var</span> name;

      <span class="hljs-keyword">if</span> (isText(node)) {
        name = <span class="hljs-string">'text()'</span>;
      } <span class="hljs-keyword">else</span> {
        name = node.nodeName.toLowerCase();
      }

      <span class="hljs-keyword">return</span> name + <span class="hljs-string">'['</span> + normalizedNodeIndex(node) + <span class="hljs-string">']'</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parentsUntil</span>(<span class="hljs-params">rootNode, node, predicate</span>) </span>{
      <span class="hljs-keyword">var</span> parents = [];

      <span class="hljs-keyword">for</span> (node = node.parentNode; node != rootNode; node = node.parentNode) {
        <span class="hljs-keyword">if</span> (predicate &amp;&amp; predicate(node)) {
          <span class="hljs-keyword">break</span>;
        }

        parents.push(node);
      }

      <span class="hljs-keyword">return</span> parents;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">rootNode, caretPosition</span>) </span>{
      <span class="hljs-keyword">var</span> container, offset, path = [],
        outputOffset, childNodes, parents;

      container = caretPosition.container();
      offset = caretPosition.offset();

      <span class="hljs-keyword">if</span> (isText(container)) {
        outputOffset = normalizedTextOffset(container, offset);
      } <span class="hljs-keyword">else</span> {
        childNodes = container.childNodes;
        <span class="hljs-keyword">if</span> (offset &gt;= childNodes.length) {
          outputOffset = <span class="hljs-string">'after'</span>;
          offset = childNodes.length - <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
          outputOffset = <span class="hljs-string">'before'</span>;
        }

        container = childNodes[offset];
      }

      path.push(createPathItem(container));
      parents = parentsUntil(rootNode, container);
      parents = Arr.filter(parents, Fun.negate(NodeType.isBogus));
      path = path.concat(Arr.map(parents, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> createPathItem(node);
      }));

      <span class="hljs-keyword">return</span> path.reverse().join(<span class="hljs-string">'/'</span>) + <span class="hljs-string">','</span> + outputOffset;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePathItem</span>(<span class="hljs-params">node, name, index</span>) </span>{
      <span class="hljs-keyword">var</span> nodes = getChildNodes(node);

      nodes = Arr.filter(nodes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, index</span>) </span>{
        <span class="hljs-keyword">return</span> !isText(node) || !isText(nodes[index - <span class="hljs-number">1</span>]);
      });

      nodes = Arr.filter(nodes, NodeType.matchNodeNames(name));
      <span class="hljs-keyword">return</span> nodes[index];
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findTextPosition</span>(<span class="hljs-params">container, offset</span>) </span>{
      <span class="hljs-keyword">var</span> node = container, targetOffset = <span class="hljs-number">0</span>, dataLen;

      <span class="hljs-keyword">while</span> (isText(node)) {
        dataLen = node.data.length;

        <span class="hljs-keyword">if</span> (offset &gt;= targetOffset &amp;&amp; offset &lt;= targetOffset + dataLen) {
          container = node;
          offset = offset - targetOffset;
          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">if</span> (!isText(node.nextSibling)) {
          container = node;
          offset = dataLen;
          <span class="hljs-keyword">break</span>;
        }

        targetOffset += dataLen;
        node = node.nextSibling;
      }

      <span class="hljs-keyword">if</span> (offset &gt; container.data.length) {
        offset = container.data.length;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CaretPosition(container, offset);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">rootNode, path</span>) </span>{
      <span class="hljs-keyword">var</span> parts, container, offset;

      <span class="hljs-keyword">if</span> (!path) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      parts = path.split(<span class="hljs-string">','</span>);
      path = parts[<span class="hljs-number">0</span>].split(<span class="hljs-string">'/'</span>);
      offset = parts.length &gt; <span class="hljs-number">1</span> ? parts[<span class="hljs-number">1</span>] : <span class="hljs-string">'before'</span>;

      container = Arr.reduce(path, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result, value</span>) </span>{
        value = <span class="hljs-regexp">/([\w\-\(\)]+)\[([0-9]+)\]/</span>.exec(value);
        <span class="hljs-keyword">if</span> (!value) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">if</span> (value[<span class="hljs-number">1</span>] === <span class="hljs-string">'text()'</span>) {
          value[<span class="hljs-number">1</span>] = <span class="hljs-string">'#text'</span>;
        }

        <span class="hljs-keyword">return</span> resolvePathItem(result, value[<span class="hljs-number">1</span>], <span class="hljs-built_in">parseInt</span>(value[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>));
      }, rootNode);

      <span class="hljs-keyword">if</span> (!container) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (!isText(container)) {
        <span class="hljs-keyword">if</span> (offset === <span class="hljs-string">'after'</span>) {
          offset = nodeIndex(container) + <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
          offset = nodeIndex(container);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CaretPosition(container.parentNode, offset);
      }

      <span class="hljs-keyword">return</span> findTextPosition(container, <span class="hljs-built_in">parseInt</span>(offset, <span class="hljs-number">10</span>));
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">/**
       * Create a xpath bookmark location for the specified caret position.
       *
       * @method create
       * @param {Node} rootNode Root node to create bookmark within.
       * @param {tinymce.caret.CaretPosition} caretPosition Caret position within the root node.
       * @return {String} String xpath like location of caret position.
       */</span>
      create: create,

      <span class="hljs-comment">/**
       * Resolves a xpath like bookmark location to the a caret position.
       *
       * @method resolve
       * @param {Node} rootNode Root node to resolve xpath bookmark within.
       * @param {String} bookmark Bookmark string to resolve.
       * @return {tinymce.caret.CaretPosition} Caret position resolved from xpath like bookmark.
       */</span>
      resolve: resolve
    };
  }
);
<span class="hljs-comment">/**
 * BookmarkManager.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class handles selection bookmarks.
 *
 * @class tinymce.dom.BookmarkManager
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.BookmarkManager'</span>,
  [
    <span class="hljs-string">'tinymce.core.caret.CaretBookmark'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretContainer'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.dom.RangeUtils'</span>,
    <span class="hljs-string">'tinymce.core.Env'</span>,
    <span class="hljs-string">'tinymce.core.text.Zwsp'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">CaretBookmark, CaretContainer, CaretPosition, NodeType, RangeUtils, Env, Zwsp, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> isContentEditableFalse = NodeType.isContentEditableFalse;

    <span class="hljs-keyword">var</span> getNormalizedTextOffset = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">container, offset</span>) </span>{
      <span class="hljs-keyword">var</span> node, trimmedOffset;

      trimmedOffset = Zwsp.trim(container.data.slice(<span class="hljs-number">0</span>, offset)).length;
      <span class="hljs-keyword">for</span> (node = container.previousSibling; node &amp;&amp; node.nodeType === <span class="hljs-number">3</span>; node = node.previousSibling) {
        trimmedOffset += Zwsp.trim(node.data).length;
      }

      <span class="hljs-keyword">return</span> trimmedOffset;
    };

    <span class="hljs-comment">/**
     * Constructs a new BookmarkManager instance for a specific selection instance.
     *
     * @constructor
     * @method BookmarkManager
     * @param {tinymce.dom.Selection} selection Selection instance to handle bookmarks for.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BookmarkManager</span>(<span class="hljs-params">selection</span>) </span>{
      <span class="hljs-keyword">var</span> dom = selection.dom;

      <span class="hljs-comment">/**
       * Returns a bookmark location for the current selection. This bookmark object
       * can then be used to restore the selection after some content modification to the document.
       *
       * @method getBookmark
       * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.
       * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.
       * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.
       * @example
       * // Stores a bookmark of the current selection
       * var bm = tinymce.activeEditor.selection.getBookmark();
       *
       * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
       *
       * // Restore the selection bookmark
       * tinymce.activeEditor.selection.moveToBookmark(bm);
       */</span>
      <span class="hljs-keyword">this</span>.getBookmark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, normalized</span>) </span>{
        <span class="hljs-keyword">var</span> rng, rng2, id, collapsed, name, element, chr = <span class="hljs-string">'&amp;#xFEFF;'</span>, styles;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findIndex</span>(<span class="hljs-params">name, element</span>) </span>{
          <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;

          Tools.each(dom.select(name), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">if</span> (node.getAttribute(<span class="hljs-string">'data-mce-bogus'</span>) === <span class="hljs-string">'all'</span>) {
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (node == element) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            count++;
          });

          <span class="hljs-keyword">return</span> count;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeTableCellSelection</span>(<span class="hljs-params">rng</span>) </span>{
          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveEndPoint</span>(<span class="hljs-params">start</span>) </span>{
            <span class="hljs-keyword">var</span> container, offset, childNodes, prefix = start ? <span class="hljs-string">'start'</span> : <span class="hljs-string">'end'</span>;

            container = rng[prefix + <span class="hljs-string">'Container'</span>];
            offset = rng[prefix + <span class="hljs-string">'Offset'</span>];

            <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">1</span> &amp;&amp; container.nodeName == <span class="hljs-string">"TR"</span>) {
              childNodes = container.childNodes;
              container = childNodes[<span class="hljs-built_in">Math</span>.min(start ? offset : offset - <span class="hljs-number">1</span>, childNodes.length - <span class="hljs-number">1</span>)];
              <span class="hljs-keyword">if</span> (container) {
                offset = start ? <span class="hljs-number">0</span> : container.childNodes.length;
                rng[<span class="hljs-string">'set'</span> + (start ? <span class="hljs-string">'Start'</span> : <span class="hljs-string">'End'</span>)](container, offset);
              }
            }
          }

          moveEndPoint(<span class="hljs-literal">true</span>);
          moveEndPoint();

          <span class="hljs-keyword">return</span> rng;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLocation</span>(<span class="hljs-params">rng</span>) </span>{
          <span class="hljs-keyword">var</span> root = dom.getRoot(), bookmark = {};

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPoint</span>(<span class="hljs-params">rng, start</span>) </span>{
            <span class="hljs-keyword">var</span> container = rng[start ? <span class="hljs-string">'startContainer'</span> : <span class="hljs-string">'endContainer'</span>],
              offset = rng[start ? <span class="hljs-string">'startOffset'</span> : <span class="hljs-string">'endOffset'</span>], point = [], childNodes, after = <span class="hljs-number">0</span>;

            <span class="hljs-keyword">if</span> (container.nodeType === <span class="hljs-number">3</span>) {
              point.push(normalized ? getNormalizedTextOffset(container, offset) : offset);
            } <span class="hljs-keyword">else</span> {
              childNodes = container.childNodes;

              <span class="hljs-keyword">if</span> (offset &gt;= childNodes.length &amp;&amp; childNodes.length) {
                after = <span class="hljs-number">1</span>;
                offset = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, childNodes.length - <span class="hljs-number">1</span>);
              }

              point.push(dom.nodeIndex(childNodes[offset], normalized) + after);
            }

            <span class="hljs-keyword">for</span> (; container &amp;&amp; container != root; container = container.parentNode) {
              point.push(dom.nodeIndex(container, normalized));
            }

            <span class="hljs-keyword">return</span> point;
          }

          bookmark.start = getPoint(rng, <span class="hljs-literal">true</span>);

          <span class="hljs-keyword">if</span> (!selection.isCollapsed()) {
            bookmark.end = getPoint(rng);
          }

          <span class="hljs-keyword">return</span> bookmark;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findAdjacentContentEditableFalseElm</span>(<span class="hljs-params">rng</span>) </span>{
          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSibling</span>(<span class="hljs-params">node, offset</span>) </span>{
            <span class="hljs-keyword">var</span> sibling;

            <span class="hljs-keyword">if</span> (NodeType.isElement(node)) {
              node = RangeUtils.getNode(node, offset);
              <span class="hljs-keyword">if</span> (isContentEditableFalse(node)) {
                <span class="hljs-keyword">return</span> node;
              }
            }

            <span class="hljs-keyword">if</span> (CaretContainer.isCaretContainer(node)) {
              <span class="hljs-keyword">if</span> (NodeType.isText(node) &amp;&amp; CaretContainer.isCaretContainerBlock(node)) {
                node = node.parentNode;
              }

              sibling = node.previousSibling;
              <span class="hljs-keyword">if</span> (isContentEditableFalse(sibling)) {
                <span class="hljs-keyword">return</span> sibling;
              }

              sibling = node.nextSibling;
              <span class="hljs-keyword">if</span> (isContentEditableFalse(sibling)) {
                <span class="hljs-keyword">return</span> sibling;
              }
            }
          }

          <span class="hljs-keyword">return</span> findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
        }

        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">2</span>) {
          element = selection.getNode();
          name = element ? element.nodeName : <span class="hljs-literal">null</span>;
          rng = selection.getRng();

          <span class="hljs-keyword">if</span> (isContentEditableFalse(element) || name == <span class="hljs-string">'IMG'</span>) {
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">name</span>: name, <span class="hljs-attr">index</span>: findIndex(name, element) };
          }

          <span class="hljs-keyword">if</span> (selection.tridentSel) {
            <span class="hljs-keyword">return</span> selection.tridentSel.getBookmark(type);
          }

          element = findAdjacentContentEditableFalseElm(rng);
          <span class="hljs-keyword">if</span> (element) {
            name = element.tagName;
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">name</span>: name, <span class="hljs-attr">index</span>: findIndex(name, element) };
          }

          <span class="hljs-keyword">return</span> getLocation(rng);
        }

        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">3</span>) {
          rng = selection.getRng();

          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">start</span>: CaretBookmark.create(dom.getRoot(), CaretPosition.fromRangeStart(rng)),
            <span class="hljs-attr">end</span>: CaretBookmark.create(dom.getRoot(), CaretPosition.fromRangeEnd(rng))
          };
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-818">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-818">&#182;</a>
              </div>
              <p>Handle simple range</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (type) {
          <span class="hljs-keyword">return</span> { <span class="hljs-attr">rng</span>: selection.getRng() };
        }

        rng = selection.getRng();
        id = dom.uniqueId();
        collapsed = selection.isCollapsed();
        styles = <span class="hljs-string">'overflow:hidden;line-height:0px'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-819">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-819">&#182;</a>
              </div>
              <p>Explorer method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (rng.duplicate || rng.item) {</pre></div></div>
            
        </li>
        
        
        <li id="section-820">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-820">&#182;</a>
              </div>
              <p>Text selection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!rng.item) {
            rng2 = rng.duplicate();

            <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-821">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-821">&#182;</a>
              </div>
              <p>Insert start marker</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              rng.collapse();
              rng.pasteHTML(<span class="hljs-string">'&lt;span data-mce-type="bookmark" id="'</span> + id + <span class="hljs-string">'_start" style="'</span> + styles + <span class="hljs-string">'"&gt;'</span> + chr + <span class="hljs-string">'&lt;/span&gt;'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-822">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-822">&#182;</a>
              </div>
              <p>Insert end marker</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (!collapsed) {
                rng2.collapse(<span class="hljs-literal">false</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-823">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-823">&#182;</a>
              </div>
              <p>Detect the empty space after block elements in IE and move the
end back one character <p></p>] becomes <p>]</p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                rng.moveToElementText(rng2.parentElement());
                <span class="hljs-keyword">if</span> (rng.compareEndPoints(<span class="hljs-string">'StartToEnd'</span>, rng2) === <span class="hljs-number">0</span>) {
                  rng2.move(<span class="hljs-string">'character'</span>, <span class="hljs-number">-1</span>);
                }

                rng2.pasteHTML(<span class="hljs-string">'&lt;span data-mce-type="bookmark" id="'</span> + id + <span class="hljs-string">'_end" style="'</span> + styles + <span class="hljs-string">'"&gt;'</span> + chr + <span class="hljs-string">'&lt;/span&gt;'</span>);
              }
            } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-824">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-824">&#182;</a>
              </div>
              <p>IE might throw unspecified error so lets ignore it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-825">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-825">&#182;</a>
              </div>
              <p>Control selection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            element = rng.item(<span class="hljs-number">0</span>);
            name = element.nodeName;

            <span class="hljs-keyword">return</span> { <span class="hljs-attr">name</span>: name, <span class="hljs-attr">index</span>: findIndex(name, element) };
          }
        } <span class="hljs-keyword">else</span> {
          element = selection.getNode();
          name = element.nodeName;
          <span class="hljs-keyword">if</span> (name == <span class="hljs-string">'IMG'</span>) {
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">name</span>: name, <span class="hljs-attr">index</span>: findIndex(name, element) };
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-826">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-826">&#182;</a>
              </div>
              <p>W3C method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          rng2 = normalizeTableCellSelection(rng.cloneRange());</pre></div></div>
            
        </li>
        
        
        <li id="section-827">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-827">&#182;</a>
              </div>
              <p>Insert end marker</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!collapsed) {
            rng2.collapse(<span class="hljs-literal">false</span>);
            rng2.insertNode(dom.create(<span class="hljs-string">'span'</span>, { <span class="hljs-string">'data-mce-type'</span>: <span class="hljs-string">"bookmark"</span>, <span class="hljs-attr">id</span>: id + <span class="hljs-string">'_end'</span>, <span class="hljs-attr">style</span>: styles }, chr));
          }

          rng = normalizeTableCellSelection(rng);
          rng.collapse(<span class="hljs-literal">true</span>);
          rng.insertNode(dom.create(<span class="hljs-string">'span'</span>, { <span class="hljs-string">'data-mce-type'</span>: <span class="hljs-string">"bookmark"</span>, <span class="hljs-attr">id</span>: id + <span class="hljs-string">'_start'</span>, <span class="hljs-attr">style</span>: styles }, chr));
        }

        selection.moveToBookmark({ <span class="hljs-attr">id</span>: id, <span class="hljs-attr">keep</span>: <span class="hljs-number">1</span> });

        <span class="hljs-keyword">return</span> { <span class="hljs-attr">id</span>: id };
      };

      <span class="hljs-comment">/**
       * Restores the selection to the specified bookmark.
       *
       * @method moveToBookmark
       * @param {Object} bookmark Bookmark to restore selection from.
       * @return {Boolean} true/false if it was successful or not.
       * @example
       * // Stores a bookmark of the current selection
       * var bm = tinymce.activeEditor.selection.getBookmark();
       *
       * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
       *
       * // Restore the selection bookmark
       * tinymce.activeEditor.selection.moveToBookmark(bm);
       */</span>
      <span class="hljs-keyword">this</span>.moveToBookmark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">bookmark</span>) </span>{
        <span class="hljs-keyword">var</span> rng, root, startContainer, endContainer, startOffset, endOffset;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setEndPoint</span>(<span class="hljs-params">start</span>) </span>{
          <span class="hljs-keyword">var</span> point = bookmark[start ? <span class="hljs-string">'start'</span> : <span class="hljs-string">'end'</span>], i, node, offset, children;

          <span class="hljs-keyword">if</span> (point) {
            offset = point[<span class="hljs-number">0</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-828">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-828">&#182;</a>
              </div>
              <p>Find container node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">for</span> (node = root, i = point.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) {
              children = node.childNodes;

              <span class="hljs-keyword">if</span> (point[i] &gt; children.length - <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span>;
              }

              node = children[point[i]];
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-829">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-829">&#182;</a>
              </div>
              <p>Move text offset to best suitable location</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">3</span>) {
              offset = <span class="hljs-built_in">Math</span>.min(point[<span class="hljs-number">0</span>], node.nodeValue.length);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-830">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-830">&#182;</a>
              </div>
              <p>Move element offset to best suitable location</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span>) {
              offset = <span class="hljs-built_in">Math</span>.min(point[<span class="hljs-number">0</span>], node.childNodes.length);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-831">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-831">&#182;</a>
              </div>
              <p>Set offset within container node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (start) {
              rng.setStart(node, offset);
            } <span class="hljs-keyword">else</span> {
              rng.setEnd(node, offset);
            }
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restoreEndPoint</span>(<span class="hljs-params">suffix</span>) </span>{
          <span class="hljs-keyword">var</span> marker = dom.get(bookmark.id + <span class="hljs-string">'_'</span> + suffix), node, idx, next, prev, keep = bookmark.keep;

          <span class="hljs-keyword">if</span> (marker) {
            node = marker.parentNode;

            <span class="hljs-keyword">if</span> (suffix == <span class="hljs-string">'start'</span>) {
              <span class="hljs-keyword">if</span> (!keep) {
                idx = dom.nodeIndex(marker);
              } <span class="hljs-keyword">else</span> {
                node = marker.firstChild;
                idx = <span class="hljs-number">1</span>;
              }

              startContainer = endContainer = node;
              startOffset = endOffset = idx;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">if</span> (!keep) {
                idx = dom.nodeIndex(marker);
              } <span class="hljs-keyword">else</span> {
                node = marker.firstChild;
                idx = <span class="hljs-number">1</span>;
              }

              endContainer = node;
              endOffset = idx;
            }

            <span class="hljs-keyword">if</span> (!keep) {
              prev = marker.previousSibling;
              next = marker.nextSibling;</pre></div></div>
            
        </li>
        
        
        <li id="section-832">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-832">&#182;</a>
              </div>
              <p>Remove all marker text nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              Tools.each(Tools.grep(marker.childNodes), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
                <span class="hljs-keyword">if</span> (node.nodeType == <span class="hljs-number">3</span>) {
                  node.nodeValue = node.nodeValue.replace(<span class="hljs-regexp">/\uFEFF/g</span>, <span class="hljs-string">''</span>);
                }
              });</pre></div></div>
            
        </li>
        
        
        <li id="section-833">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-833">&#182;</a>
              </div>
              <p>Remove marker but keep children if for example contents where inserted into the marker
Also remove duplicated instances of the marker for example by a
split operation or by WebKit auto split on paste feature</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">while</span> ((marker = dom.get(bookmark.id + <span class="hljs-string">'_'</span> + suffix))) {
                dom.remove(marker, <span class="hljs-number">1</span>);
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-834">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-834">&#182;</a>
              </div>
              <p>If siblings are text nodes then merge them unless its Opera since it some how removes the node
and we are sniffing since adding a lot of detection code for a browser with 3% of the market
isnt worth the effort. Sorry, Opera but its just a fact</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (prev &amp;&amp; next &amp;&amp; prev.nodeType == next.nodeType &amp;&amp; prev.nodeType == <span class="hljs-number">3</span> &amp;&amp; !Env.opera) {
                idx = prev.nodeValue.length;
                prev.appendData(next.nodeValue);
                dom.remove(next);

                <span class="hljs-keyword">if</span> (suffix == <span class="hljs-string">'start'</span>) {
                  startContainer = endContainer = prev;
                  startOffset = endOffset = idx;
                } <span class="hljs-keyword">else</span> {
                  endContainer = prev;
                  endOffset = idx;
                }
              }
            }
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addBogus</span>(<span class="hljs-params">node</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-835">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-835">&#182;</a>
              </div>
              <p>Adds a bogus BR element for empty block elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (dom.isBlock(node) &amp;&amp; !node.innerHTML &amp;&amp; !Env.ie) {
            node.innerHTML = <span class="hljs-string">'&lt;br data-mce-bogus="1" /&gt;'</span>;
          }

          <span class="hljs-keyword">return</span> node;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveCaretPositionBookmark</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> rng, pos;

          rng = dom.createRng();
          pos = CaretBookmark.resolve(dom.getRoot(), bookmark.start);
          rng.setStart(pos.container(), pos.offset());

          pos = CaretBookmark.resolve(dom.getRoot(), bookmark.end);
          rng.setEnd(pos.container(), pos.offset());

          <span class="hljs-keyword">return</span> rng;
        }

        <span class="hljs-keyword">if</span> (bookmark) {
          <span class="hljs-keyword">if</span> (Tools.isArray(bookmark.start)) {
            rng = dom.createRng();
            root = dom.getRoot();

            <span class="hljs-keyword">if</span> (selection.tridentSel) {
              <span class="hljs-keyword">return</span> selection.tridentSel.moveToBookmark(bookmark);
            }

            <span class="hljs-keyword">if</span> (setEndPoint(<span class="hljs-literal">true</span>) &amp;&amp; setEndPoint()) {
              selection.setRng(rng);
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> bookmark.start == <span class="hljs-string">'string'</span>) {
            selection.setRng(resolveCaretPositionBookmark(bookmark));
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bookmark.id) {</pre></div></div>
            
        </li>
        
        
        <li id="section-836">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-836">&#182;</a>
              </div>
              <p>Restore start/end points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            restoreEndPoint(<span class="hljs-string">'start'</span>);
            restoreEndPoint(<span class="hljs-string">'end'</span>);

            <span class="hljs-keyword">if</span> (startContainer) {
              rng = dom.createRng();
              rng.setStart(addBogus(startContainer), startOffset);
              rng.setEnd(addBogus(endContainer), endOffset);
              selection.setRng(rng);
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bookmark.name) {
            selection.select(dom.select(bookmark.name)[bookmark.index]);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bookmark.rng) {
            selection.setRng(bookmark.rng);
          }
        }
      };
    }

    <span class="hljs-comment">/**
     * Returns true/false if the specified node is a bookmark node or not.
     *
     * @static
     * @method isBookmarkNode
     * @param {DOMNode} node DOM Node to check if it's a bookmark node or not.
     * @return {Boolean} true/false if the node is a bookmark node or not.
     */</span>
    BookmarkManager.isBookmarkNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> node &amp;&amp; node.tagName === <span class="hljs-string">'SPAN'</span> &amp;&amp; node.getAttribute(<span class="hljs-string">'data-mce-type'</span>) === <span class="hljs-string">'bookmark'</span>;
    };

    <span class="hljs-keyword">return</span> BookmarkManager;
  }
);
<span class="hljs-comment">/**
 * ScrollIntoView.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.dom.ScrollIntoView'</span>,
  [
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">NodeType</span>) </span>{
    <span class="hljs-keyword">var</span> getPos = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">var</span> offsetParent = elm;
      <span class="hljs-keyword">while</span> (offsetParent &amp;&amp; offsetParent.nodeType) {
        x += offsetParent.offsetLeft || <span class="hljs-number">0</span>;
        y += offsetParent.offsetTop || <span class="hljs-number">0</span>;
        offsetParent = offsetParent.offsetParent;
      }

      <span class="hljs-keyword">return</span> { <span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y };
    };

    <span class="hljs-keyword">var</span> fireScrollIntoViewEvent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, elm, alignToTop</span>) </span>{
      <span class="hljs-keyword">var</span> scrollEvent = { <span class="hljs-attr">elm</span>: elm, <span class="hljs-attr">alignToTop</span>: alignToTop };
      editor.fire(<span class="hljs-string">'scrollIntoView'</span>, scrollEvent);
      <span class="hljs-keyword">return</span> scrollEvent.isDefaultPrevented();
    };

    <span class="hljs-keyword">var</span> scrollIntoView = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, elm, alignToTop</span>) </span>{
      <span class="hljs-keyword">var</span> y, viewPort, dom = editor.dom, root = dom.getRoot(), viewPortY, viewPortH, offsetY = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (fireScrollIntoViewEvent(editor, elm, alignToTop)) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (!NodeType.isElement(elm)) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (alignToTop === <span class="hljs-literal">false</span>) {
        offsetY = elm.offsetHeight;
      }

      <span class="hljs-keyword">if</span> (root.nodeName !== <span class="hljs-string">'BODY'</span>) {
        <span class="hljs-keyword">var</span> scrollContainer = editor.selection.getScrollContainer();
        <span class="hljs-keyword">if</span> (scrollContainer) {
          y = getPos(elm).y - getPos(scrollContainer).y + offsetY;
          viewPortH = scrollContainer.clientHeight;
          viewPortY = scrollContainer.scrollTop;
          <span class="hljs-keyword">if</span> (y &lt; viewPortY || y + <span class="hljs-number">25</span> &gt; viewPortY + viewPortH) {
            scrollContainer.scrollTop = y &lt; viewPortY ? y : y - viewPortH + <span class="hljs-number">25</span>;
          }

          <span class="hljs-keyword">return</span>;
        }
      }

      viewPort = dom.getViewPort(editor.getWin());
      y = dom.getPos(elm).y + offsetY;
      viewPortY = viewPort.y;
      viewPortH = viewPort.h;
      <span class="hljs-keyword">if</span> (y &lt; viewPort.y || y + <span class="hljs-number">25</span> &gt; viewPortY + viewPortH) {
        editor.getWin().scrollTo(<span class="hljs-number">0</span>, y &lt; viewPortY ? y : y - viewPortH + <span class="hljs-number">25</span>);
      }
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">scrollIntoView</span>: scrollIntoView
    };
  }
);

<span class="hljs-comment">/**
 * TridentSelection.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Selection class for old explorer versions. This one fakes the
 * native selection object available on modern browsers.
 *
 * @private
 * @class tinymce.dom.TridentSelection
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.TridentSelection'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Selection</span>(<span class="hljs-params">selection</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, dom = selection.dom, FALSE = <span class="hljs-literal">false</span>;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPosition</span>(<span class="hljs-params">rng, start</span>) </span>{
        <span class="hljs-keyword">var</span> checkRng, startIndex = <span class="hljs-number">0</span>, endIndex, inside,
          children, child, offset, index, position = <span class="hljs-number">-1</span>, parent;</pre></div></div>
            
        </li>
        
        
        <li id="section-837">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-837">&#182;</a>
              </div>
              <p>Setup test range, collapse it and get the parent</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        checkRng = rng.duplicate();
        checkRng.collapse(start);
        parent = checkRng.parentElement();</pre></div></div>
            
        </li>
        
        
        <li id="section-838">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-838">&#182;</a>
              </div>
              <p>Check if the selection is within the right document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (parent.ownerDocument !== selection.dom.doc) {
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-839">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-839">&#182;</a>
              </div>
              <p>IE will report non editable elements as its parent so look for an editable one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">while</span> (parent.contentEditable === <span class="hljs-string">"false"</span>) {
          parent = parent.parentNode;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-840">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-840">&#182;</a>
              </div>
              <p>If parent doesnt have any children then return that we are inside the element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!parent.hasChildNodes()) {
          <span class="hljs-keyword">return</span> { <span class="hljs-attr">node</span>: parent, <span class="hljs-attr">inside</span>: <span class="hljs-number">1</span> };
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-841">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-841">&#182;</a>
              </div>
              <p>Setup node list and endIndex</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        children = parent.children;
        endIndex = children.length - <span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-842">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-842">&#182;</a>
              </div>
              <p>Perform a binary search for the position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">while</span> (startIndex &lt;= endIndex) {
          index = <span class="hljs-built_in">Math</span>.floor((startIndex + endIndex) / <span class="hljs-number">2</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-843">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-843">&#182;</a>
              </div>
              <p>Move selection to node and compare the ranges</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          child = children[index];
          checkRng.moveToElementText(child);
          position = checkRng.compareEndPoints(start ? <span class="hljs-string">'StartToStart'</span> : <span class="hljs-string">'EndToEnd'</span>, rng);</pre></div></div>
            
        </li>
        
        
        <li id="section-844">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-844">&#182;</a>
              </div>
              <p>Before/after or an exact match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (position &gt; <span class="hljs-number">0</span>) {
            endIndex = index - <span class="hljs-number">1</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span>) {
            startIndex = index + <span class="hljs-number">1</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">node</span>: child };
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-845">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-845">&#182;</a>
              </div>
              <p>Check if child position is before or we didnt find a position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-846">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-846">&#182;</a>
              </div>
              <p>No element child was found use the parent element and the offset inside that</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!child) {
            checkRng.moveToElementText(parent);
            checkRng.collapse(<span class="hljs-literal">true</span>);
            child = parent;
            inside = <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            checkRng.collapse(<span class="hljs-literal">false</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-847">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-847">&#182;</a>
              </div>
              <p>Walk character by character in text node until we hit the selected range endpoint,
hit the end of document or parent isnt the right one
We need to walk char by char since rng.text or rng.htmlText will trim line endings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          offset = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">while</span> (checkRng.compareEndPoints(start ? <span class="hljs-string">'StartToStart'</span> : <span class="hljs-string">'StartToEnd'</span>, rng) !== <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (checkRng.move(<span class="hljs-string">'character'</span>, <span class="hljs-number">1</span>) === <span class="hljs-number">0</span> || parent != checkRng.parentElement()) {
              <span class="hljs-keyword">break</span>;
            }

            offset++;
          }
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-848">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-848">&#182;</a>
              </div>
              <p>Child position is after the selection endpoint</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          checkRng.collapse(<span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-849">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-849">&#182;</a>
              </div>
              <p>Walk character by character in text node until we hit the selected range endpoint, hit
the end of document or parent isnt the right one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          offset = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">while</span> (checkRng.compareEndPoints(start ? <span class="hljs-string">'StartToStart'</span> : <span class="hljs-string">'StartToEnd'</span>, rng) !== <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (checkRng.move(<span class="hljs-string">'character'</span>, <span class="hljs-number">-1</span>) === <span class="hljs-number">0</span> || parent != checkRng.parentElement()) {
              <span class="hljs-keyword">break</span>;
            }

            offset++;
          }
        }

        <span class="hljs-keyword">return</span> { <span class="hljs-attr">node</span>: child, <span class="hljs-attr">position</span>: position, <span class="hljs-attr">offset</span>: offset, <span class="hljs-attr">inside</span>: inside };
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-850">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-850">&#182;</a>
              </div>
              <p>Returns a W3C DOM compatible range object by using the IE Range API</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRange</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> ieRange = selection.getRng(), domRange = dom.createRng(), element, collapsed, tmpRange, element2, bookmark;</pre></div></div>
            
        </li>
        
        
        <li id="section-851">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-851">&#182;</a>
              </div>
              <p>If selection is outside the current document just return an empty range</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        element = ieRange.item ? ieRange.item(<span class="hljs-number">0</span>) : ieRange.parentElement();
        <span class="hljs-keyword">if</span> (element.ownerDocument != dom.doc) {
          <span class="hljs-keyword">return</span> domRange;
        }

        collapsed = selection.isCollapsed();</pre></div></div>
            
        </li>
        
        
        <li id="section-852">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-852">&#182;</a>
              </div>
              <p>Handle control selection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (ieRange.item) {
          domRange.setStart(element.parentNode, dom.nodeIndex(element));
          domRange.setEnd(domRange.startContainer, domRange.startOffset + <span class="hljs-number">1</span>);

          <span class="hljs-keyword">return</span> domRange;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findEndPoint</span>(<span class="hljs-params">start</span>) </span>{
          <span class="hljs-keyword">var</span> endPoint = getPosition(ieRange, start), container, offset, textNodeOffset = <span class="hljs-number">0</span>, sibling, undef, nodeValue;

          container = endPoint.node;
          offset = endPoint.offset;

          <span class="hljs-keyword">if</span> (endPoint.inside &amp;&amp; !container.hasChildNodes()) {
            domRange[start ? <span class="hljs-string">'setStart'</span> : <span class="hljs-string">'setEnd'</span>](container, <span class="hljs-number">0</span>);
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (offset === undef) {
            domRange[start ? <span class="hljs-string">'setStartBefore'</span> : <span class="hljs-string">'setEndAfter'</span>](container);
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (endPoint.position &lt; <span class="hljs-number">0</span>) {
            sibling = endPoint.inside ? container.firstChild : container.nextSibling;

            <span class="hljs-keyword">if</span> (!sibling) {
              domRange[start ? <span class="hljs-string">'setStartAfter'</span> : <span class="hljs-string">'setEndAfter'</span>](container);
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (!offset) {
              <span class="hljs-keyword">if</span> (sibling.nodeType == <span class="hljs-number">3</span>) {
                domRange[start ? <span class="hljs-string">'setStart'</span> : <span class="hljs-string">'setEnd'</span>](sibling, <span class="hljs-number">0</span>);
              } <span class="hljs-keyword">else</span> {
                domRange[start ? <span class="hljs-string">'setStartBefore'</span> : <span class="hljs-string">'setEndBefore'</span>](sibling);
              }

              <span class="hljs-keyword">return</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-853">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-853">&#182;</a>
              </div>
              <p>Find the text node and offset</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">while</span> (sibling) {
              <span class="hljs-keyword">if</span> (sibling.nodeType == <span class="hljs-number">3</span>) {
                nodeValue = sibling.nodeValue;
                textNodeOffset += nodeValue.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-854">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-854">&#182;</a>
              </div>
              <p>We are at or passed the position we where looking for</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (textNodeOffset &gt;= offset) {
                  container = sibling;
                  textNodeOffset -= offset;
                  textNodeOffset = nodeValue.length - textNodeOffset;
                  <span class="hljs-keyword">break</span>;
                }
              }

              sibling = sibling.nextSibling;
            }
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-855">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-855">&#182;</a>
              </div>
              <p>Find the text node and offset</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            sibling = container.previousSibling;

            <span class="hljs-keyword">if</span> (!sibling) {
              <span class="hljs-keyword">return</span> domRange[start ? <span class="hljs-string">'setStartBefore'</span> : <span class="hljs-string">'setEndBefore'</span>](container);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-856">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-856">&#182;</a>
              </div>
              <p>If there isnt any text to loop then use the first position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!offset) {
              <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">3</span>) {
                domRange[start ? <span class="hljs-string">'setStart'</span> : <span class="hljs-string">'setEnd'</span>](sibling, container.nodeValue.length);
              } <span class="hljs-keyword">else</span> {
                domRange[start ? <span class="hljs-string">'setStartAfter'</span> : <span class="hljs-string">'setEndAfter'</span>](sibling);
              }

              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">while</span> (sibling) {
              <span class="hljs-keyword">if</span> (sibling.nodeType == <span class="hljs-number">3</span>) {
                textNodeOffset += sibling.nodeValue.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-857">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-857">&#182;</a>
              </div>
              <p>We are at or passed the position we where looking for</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (textNodeOffset &gt;= offset) {
                  container = sibling;
                  textNodeOffset -= offset;
                  <span class="hljs-keyword">break</span>;
                }
              }

              sibling = sibling.previousSibling;
            }
          }

          domRange[start ? <span class="hljs-string">'setStart'</span> : <span class="hljs-string">'setEnd'</span>](container, textNodeOffset);
        }

        <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-858">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-858">&#182;</a>
              </div>
              <p>Find start point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          findEndPoint(<span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-859">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-859">&#182;</a>
              </div>
              <p>Find end point if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!collapsed) {
            findEndPoint();
          }
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-860">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-860">&#182;</a>
              </div>
              <p>IE has a nasty bug where text nodes might throw invalid argument when you
access the nodeValue or other properties of text nodes. This seems to happen when
text nodes are split into two nodes by a delete/backspace call.
So let us detect and try to fix it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (ex.number == <span class="hljs-number">-2147024809</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-861">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-861">&#182;</a>
              </div>
              <p>Get the current selection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            bookmark = self.getBookmark(<span class="hljs-number">2</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-862">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-862">&#182;</a>
              </div>
              <p>Get start element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            tmpRange = ieRange.duplicate();
            tmpRange.collapse(<span class="hljs-literal">true</span>);
            element = tmpRange.parentElement();</pre></div></div>
            
        </li>
        
        
        <li id="section-863">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-863">&#182;</a>
              </div>
              <p>Get end element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!collapsed) {
              tmpRange = ieRange.duplicate();
              tmpRange.collapse(<span class="hljs-literal">false</span>);
              element2 = tmpRange.parentElement();
              element2.innerHTML = element2.innerHTML;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-864">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-864">&#182;</a>
              </div>
              <p>Remove the broken elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            element.innerHTML = element.innerHTML;</pre></div></div>
            
        </li>
        
        
        <li id="section-865">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-865">&#182;</a>
              </div>
              <p>Restore the selection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            self.moveToBookmark(bookmark);</pre></div></div>
            
        </li>
        
        
        <li id="section-866">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-866">&#182;</a>
              </div>
              <p>Since the range has moved we need to re-get it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            ieRange = selection.getRng();</pre></div></div>
            
        </li>
        
        
        <li id="section-867">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-867">&#182;</a>
              </div>
              <p>Find start point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            findEndPoint(<span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-868">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-868">&#182;</a>
              </div>
              <p>Find end point if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!collapsed) {
              findEndPoint();
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> ex; <span class="hljs-comment">// Throw other errors</span>
          }
        }

        <span class="hljs-keyword">return</span> domRange;
      }

      <span class="hljs-keyword">this</span>.getBookmark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
        <span class="hljs-keyword">var</span> rng = selection.getRng(), bookmark = {};

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getIndexes</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> parent, root, children, i, indexes = [];

          parent = node.parentNode;
          root = dom.getRoot().parentNode;

          <span class="hljs-keyword">while</span> (parent != root &amp;&amp; parent.nodeType !== <span class="hljs-number">9</span>) {
            children = parent.children;

            i = children.length;
            <span class="hljs-keyword">while</span> (i--) {
              <span class="hljs-keyword">if</span> (node === children[i]) {
                indexes.push(i);
                <span class="hljs-keyword">break</span>;
              }
            }

            node = parent;
            parent = parent.parentNode;
          }

          <span class="hljs-keyword">return</span> indexes;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBookmarkEndPoint</span>(<span class="hljs-params">start</span>) </span>{
          <span class="hljs-keyword">var</span> position;

          position = getPosition(rng, start);
          <span class="hljs-keyword">if</span> (position) {
            <span class="hljs-keyword">return</span> {
              <span class="hljs-attr">position</span>: position.position,
              <span class="hljs-attr">offset</span>: position.offset,
              <span class="hljs-attr">indexes</span>: getIndexes(position.node),
              <span class="hljs-attr">inside</span>: position.inside
            };
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-869">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-869">&#182;</a>
              </div>
              <p>Non ubstructive bookmark</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (type === <span class="hljs-number">2</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-870">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-870">&#182;</a>
              </div>
              <p>Handle text selection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!rng.item) {
            bookmark.start = getBookmarkEndPoint(<span class="hljs-literal">true</span>);

            <span class="hljs-keyword">if</span> (!selection.isCollapsed()) {
              bookmark.end = getBookmarkEndPoint();
            }
          } <span class="hljs-keyword">else</span> {
            bookmark.start = { <span class="hljs-attr">ctrl</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">indexes</span>: getIndexes(rng.item(<span class="hljs-number">0</span>)) };
          }
        }

        <span class="hljs-keyword">return</span> bookmark;
      };

      <span class="hljs-keyword">this</span>.moveToBookmark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">bookmark</span>) </span>{
        <span class="hljs-keyword">var</span> rng, body = dom.doc.body;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveIndexes</span>(<span class="hljs-params">indexes</span>) </span>{
          <span class="hljs-keyword">var</span> node, i, idx, children;

          node = dom.getRoot();
          <span class="hljs-keyword">for</span> (i = indexes.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            children = node.children;
            idx = indexes[i];

            <span class="hljs-keyword">if</span> (idx &lt;= children.length - <span class="hljs-number">1</span>) {
              node = children[idx];
            }
          }

          <span class="hljs-keyword">return</span> node;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setBookmarkEndPoint</span>(<span class="hljs-params">start</span>) </span>{
          <span class="hljs-keyword">var</span> endPoint = bookmark[start ? <span class="hljs-string">'start'</span> : <span class="hljs-string">'end'</span>], moveLeft, moveRng, undef, offset;

          <span class="hljs-keyword">if</span> (endPoint) {
            moveLeft = endPoint.position &gt; <span class="hljs-number">0</span>;

            moveRng = body.createTextRange();
            moveRng.moveToElementText(resolveIndexes(endPoint.indexes));

            offset = endPoint.offset;
            <span class="hljs-keyword">if</span> (offset !== undef) {
              moveRng.collapse(endPoint.inside || moveLeft);
              moveRng.moveStart(<span class="hljs-string">'character'</span>, moveLeft ? -offset : offset);
            } <span class="hljs-keyword">else</span> {
              moveRng.collapse(start);
            }

            rng.setEndPoint(start ? <span class="hljs-string">'StartToStart'</span> : <span class="hljs-string">'EndToStart'</span>, moveRng);

            <span class="hljs-keyword">if</span> (start) {
              rng.collapse(<span class="hljs-literal">true</span>);
            }
          }
        }

        <span class="hljs-keyword">if</span> (bookmark.start) {
          <span class="hljs-keyword">if</span> (bookmark.start.ctrl) {
            rng = body.createControlRange();
            rng.addElement(resolveIndexes(bookmark.start.indexes));
            rng.select();
          } <span class="hljs-keyword">else</span> {
            rng = body.createTextRange();
            setBookmarkEndPoint(<span class="hljs-literal">true</span>);
            setBookmarkEndPoint();
            rng.select();
          }
        }
      };

      <span class="hljs-keyword">this</span>.addRange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rng</span>) </span>{
        <span class="hljs-keyword">var</span> ieRng, ctrlRng, startContainer, startOffset, endContainer, endOffset, sibling,
          doc = selection.dom.doc, body = doc.body, nativeRng, ctrlElm;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setEndPoint</span>(<span class="hljs-params">start</span>) </span>{
          <span class="hljs-keyword">var</span> container, offset, marker, tmpRng, nodes;

          marker = dom.create(<span class="hljs-string">'a'</span>);
          container = start ? startContainer : endContainer;
          offset = start ? startOffset : endOffset;
          tmpRng = ieRng.duplicate();

          <span class="hljs-keyword">if</span> (container == doc || container == doc.documentElement) {
            container = body;
            offset = <span class="hljs-number">0</span>;
          }

          <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">3</span>) {
            container.parentNode.insertBefore(marker, container);
            tmpRng.moveToElementText(marker);
            tmpRng.moveStart(<span class="hljs-string">'character'</span>, offset);
            dom.remove(marker);
            ieRng.setEndPoint(start ? <span class="hljs-string">'StartToStart'</span> : <span class="hljs-string">'EndToEnd'</span>, tmpRng);
          } <span class="hljs-keyword">else</span> {
            nodes = container.childNodes;

            <span class="hljs-keyword">if</span> (nodes.length) {
              <span class="hljs-keyword">if</span> (offset &gt;= nodes.length) {
                dom.insertAfter(marker, nodes[nodes.length - <span class="hljs-number">1</span>]);
              } <span class="hljs-keyword">else</span> {
                container.insertBefore(marker, nodes[offset]);
              }

              tmpRng.moveToElementText(marker);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (container.canHaveHTML) {</pre></div></div>
            
        </li>
        
        
        <li id="section-871">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-871">&#182;</a>
              </div>
              <p>Empty node selection for example <div>|</div>
Setting innerHTML with a span marker then remove that marker seems to keep empty block elements open</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              container.innerHTML = <span class="hljs-string">'&lt;span&gt;&amp;#xFEFF;&lt;/span&gt;'</span>;
              marker = container.firstChild;
              tmpRng.moveToElementText(marker);
              tmpRng.collapse(FALSE); <span class="hljs-comment">// Collapse false works better than true for some odd reason</span>
            }

            ieRng.setEndPoint(start ? <span class="hljs-string">'StartToStart'</span> : <span class="hljs-string">'EndToEnd'</span>, tmpRng);
            dom.remove(marker);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-872">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-872">&#182;</a>
              </div>
              <p>Setup some shorter versions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        startContainer = rng.startContainer;
        startOffset = rng.startOffset;
        endContainer = rng.endContainer;
        endOffset = rng.endOffset;
        ieRng = body.createTextRange();</pre></div></div>
            
        </li>
        
        
        <li id="section-873">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-873">&#182;</a>
              </div>
              <p>If single element selection then try making a control selection out of it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (startContainer == endContainer &amp;&amp; startContainer.nodeType == <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-874">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-874">&#182;</a>
              </div>
              <p>Trick to place the caret inside an empty block element like <p></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (startOffset == endOffset &amp;&amp; !startContainer.hasChildNodes()) {
            <span class="hljs-keyword">if</span> (startContainer.canHaveHTML) {</pre></div></div>
            
        </li>
        
        
        <li id="section-875">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-875">&#182;</a>
              </div>
              <p>Check if previous sibling is an empty block if it is then we need to render it
IE would otherwise move the caret into the sibling instead of the empty startContainer see: #5236
Example this: <p></p><p>|</p> would become this: <p>|</p><p></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              sibling = startContainer.previousSibling;
              <span class="hljs-keyword">if</span> (sibling &amp;&amp; !sibling.hasChildNodes() &amp;&amp; dom.isBlock(sibling)) {
                sibling.innerHTML = <span class="hljs-string">'&amp;#xFEFF;'</span>;
              } <span class="hljs-keyword">else</span> {
                sibling = <span class="hljs-literal">null</span>;
              }

              startContainer.innerHTML = <span class="hljs-string">'&lt;span&gt;&amp;#xFEFF;&lt;/span&gt;&lt;span&gt;&amp;#xFEFF;&lt;/span&gt;'</span>;
              ieRng.moveToElementText(startContainer.lastChild);
              ieRng.select();
              dom.doc.selection.clear();
              startContainer.innerHTML = <span class="hljs-string">''</span>;

              <span class="hljs-keyword">if</span> (sibling) {
                sibling.innerHTML = <span class="hljs-string">''</span>;
              }
              <span class="hljs-keyword">return</span>;
            }

            startOffset = dom.nodeIndex(startContainer);
            startContainer = startContainer.parentNode;
          }

          <span class="hljs-keyword">if</span> (startOffset == endOffset - <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">try</span> {
              ctrlElm = startContainer.childNodes[startOffset];
              ctrlRng = body.createControlRange();
              ctrlRng.addElement(ctrlElm);
              ctrlRng.select();</pre></div></div>
            
        </li>
        
        
        <li id="section-876">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-876">&#182;</a>
              </div>
              <p>Check if the range produced is on the correct element and is a control range
On IE 8 it will select the parent contentEditable container if you select an inner element see: #5398</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              nativeRng = selection.getRng();
              <span class="hljs-keyword">if</span> (nativeRng.item &amp;&amp; ctrlElm === nativeRng.item(<span class="hljs-number">0</span>)) {
                <span class="hljs-keyword">return</span>;
              }
            } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-877">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-877">&#182;</a>
              </div>
              <p>Ignore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            }
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-878">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-878">&#182;</a>
              </div>
              <p>Set start/end point of selection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        setEndPoint(<span class="hljs-literal">true</span>);
        setEndPoint();</pre></div></div>
            
        </li>
        
        
        <li id="section-879">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-879">&#182;</a>
              </div>
              <p>Select the new range and scroll it into view</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        ieRng.select();
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-880">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-880">&#182;</a>
              </div>
              <p>Expose range method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>.getRangeAt = getRange;
    }

    <span class="hljs-keyword">return</span> Selection;
  }
);

<span class="hljs-comment">/**
 * Selection.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class handles text and control selection it's an crossbrowser utility class.
 * Consult the TinyMCE Wiki API for more details and examples on how to use this class.
 *
 * @class tinymce.dom.Selection
 * @example
 * // Getting the currently selected node for the active editor
 * alert(tinymce.activeEditor.selection.getNode().nodeName);
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.Selection'</span>,
  [
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.dom.BookmarkManager'</span>,
    <span class="hljs-string">'tinymce.core.dom.ControlSelection'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.dom.RangeUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.ScrollIntoView'</span>,
    <span class="hljs-string">'tinymce.core.dom.TreeWalker'</span>,
    <span class="hljs-string">'tinymce.core.dom.TridentSelection'</span>,
    <span class="hljs-string">'tinymce.core.Env'</span>,
    <span class="hljs-string">'tinymce.core.text.Zwsp'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">CaretPosition, BookmarkManager, ControlSelection, NodeType, RangeUtils, ScrollIntoView, TreeWalker, TridentSelection, Env, Zwsp, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> each = Tools.each, trim = Tools.trim;
    <span class="hljs-keyword">var</span> isIE = Env.ie;

    <span class="hljs-comment">/**
     * Constructs a new selection instance.
     *
     * @constructor
     * @method Selection
     * @param {tinymce.dom.DOMUtils} dom DOMUtils object reference.
     * @param {Window} win Window to bind the selection object to.
     * @param {tinymce.Editor} editor Editor instance of the selection.
     * @param {tinymce.dom.Serializer} serializer DOM serialization class to use for getContent.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Selection</span>(<span class="hljs-params">dom, win, serializer, editor</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

      self.dom = dom;
      self.win = win;
      self.serializer = serializer;
      self.editor = editor;
      self.bookmarkManager = <span class="hljs-keyword">new</span> BookmarkManager(self);
      self.controlSelection = <span class="hljs-keyword">new</span> ControlSelection(self, editor);</pre></div></div>
            
        </li>
        
        
        <li id="section-881">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-881">&#182;</a>
              </div>
              <p>No W3C Range support</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!self.win.getSelection) {
        self.tridentSel = <span class="hljs-keyword">new</span> TridentSelection(self);
      }
    }

    Selection.prototype = {
      <span class="hljs-comment">/**
       * Move the selection cursor range to the specified node and offset.
       * If there is no node specified it will move it to the first suitable location within the body.
       *
       * @method setCursorLocation
       * @param {Node} node Optional node to put the cursor in.
       * @param {Number} offset Optional offset from the start of the node to put the cursor at.
       */</span>
      setCursorLocation: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, offset</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, rng = self.dom.createRng();

        <span class="hljs-keyword">if</span> (!node) {
          self._moveEndPoint(rng, self.editor.getBody(), <span class="hljs-literal">true</span>);
          self.setRng(rng);
        } <span class="hljs-keyword">else</span> {
          rng.setStart(node, offset);
          rng.setEnd(node, offset);
          self.setRng(rng);
          self.collapse(<span class="hljs-literal">false</span>);
        }
      },

      <span class="hljs-comment">/**
       * Returns the selected contents using the DOM serializer passed in to this class.
       *
       * @method getContent
       * @param {Object} args Optional settings class with for example output format text or html.
       * @return {String} Selected contents in for example HTML format.
       * @example
       * // Alerts the currently selected contents
       * alert(tinymce.activeEditor.selection.getContent());
       *
       * // Alerts the currently selected contents as plain text
       * alert(tinymce.activeEditor.selection.getContent({format: 'text'}));
       */</span>
      getContent: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, rng = self.getRng(), tmpElm = self.dom.create(<span class="hljs-string">"body"</span>);
        <span class="hljs-keyword">var</span> se = self.getSel(), whiteSpaceBefore, whiteSpaceAfter, fragment;

        args = args || {};
        whiteSpaceBefore = whiteSpaceAfter = <span class="hljs-string">''</span>;
        args.get = <span class="hljs-literal">true</span>;
        args.format = args.format || <span class="hljs-string">'html'</span>;
        args.selection = <span class="hljs-literal">true</span>;
        self.editor.fire(<span class="hljs-string">'BeforeGetContent'</span>, args);

        <span class="hljs-keyword">if</span> (args.format === <span class="hljs-string">'text'</span>) {
          <span class="hljs-keyword">return</span> self.isCollapsed() ? <span class="hljs-string">''</span> : Zwsp.trim(rng.text || (se.toString ? se.toString() : <span class="hljs-string">''</span>));
        }

        <span class="hljs-keyword">if</span> (rng.cloneContents) {
          fragment = rng.cloneContents();

          <span class="hljs-keyword">if</span> (fragment) {
            tmpElm.appendChild(fragment);
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rng.item !== <span class="hljs-literal">undefined</span> || rng.htmlText !== <span class="hljs-literal">undefined</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-882">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-882">&#182;</a>
              </div>
              <p>IE will produce invalid markup if elements are present that
it doesnt understand like custom elements or HTML5 elements.
Adding a BR in front of the contents and then remoiving it seems to fix it though.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          tmpElm.innerHTML = <span class="hljs-string">'&lt;br&gt;'</span> + (rng.item ? rng.item(<span class="hljs-number">0</span>).outerHTML : rng.htmlText);
          tmpElm.removeChild(tmpElm.firstChild);
        } <span class="hljs-keyword">else</span> {
          tmpElm.innerHTML = rng.toString();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-883">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-883">&#182;</a>
              </div>
              <p>Keep whitespace before and after</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\s/</span>.test(tmpElm.innerHTML)) {
          whiteSpaceBefore = <span class="hljs-string">' '</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\s+$/</span>.test(tmpElm.innerHTML)) {
          whiteSpaceAfter = <span class="hljs-string">' '</span>;
        }

        args.getInner = <span class="hljs-literal">true</span>;

        args.content = self.isCollapsed() ? <span class="hljs-string">''</span> : whiteSpaceBefore + self.serializer.serialize(tmpElm, args) + whiteSpaceAfter;
        self.editor.fire(<span class="hljs-string">'GetContent'</span>, args);

        <span class="hljs-keyword">return</span> args.content;
      },

      <span class="hljs-comment">/**
       * Sets the current selection to the specified content. If any contents is selected it will be replaced
       * with the contents passed in to this function. If there is no selection the contents will be inserted
       * where the caret is placed in the editor/page.
       *
       * @method setContent
       * @param {String} content HTML contents to set could also be other formats depending on settings.
       * @param {Object} args Optional settings object with for example data format.
       * @example
       * // Inserts some HTML contents at the current selection
       * tinymce.activeEditor.selection.setContent('&lt;strong&gt;Some contents&lt;/strong&gt;');
       */</span>
      setContent: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">content, args</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, rng = self.getRng(), caretNode, doc = self.win.document, frag, temp;

        args = args || { <span class="hljs-attr">format</span>: <span class="hljs-string">'html'</span> };
        args.set = <span class="hljs-literal">true</span>;
        args.selection = <span class="hljs-literal">true</span>;
        args.content = content;</pre></div></div>
            
        </li>
        
        
        <li id="section-884">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-884">&#182;</a>
              </div>
              <p>Dispatch before set content event</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!args.no_events) {
          self.editor.fire(<span class="hljs-string">'BeforeSetContent'</span>, args);
        }

        content = args.content;

        <span class="hljs-keyword">if</span> (rng.insertNode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-885">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-885">&#182;</a>
              </div>
              <p>Make caret marker since insertNode places the caret in the beginning of text after insert</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          content += <span class="hljs-string">'&lt;span id="__caret"&gt;_&lt;/span&gt;'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-886">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-886">&#182;</a>
              </div>
              <p>Delete and insert new node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (rng.startContainer == doc &amp;&amp; rng.endContainer == doc) {</pre></div></div>
            
        </li>
        
        
        <li id="section-887">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-887">&#182;</a>
              </div>
              <p>WebKit will fail if the body is empty since the range is then invalid and it cant insert contents</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            doc.body.innerHTML = content;
          } <span class="hljs-keyword">else</span> {
            rng.deleteContents();

            <span class="hljs-keyword">if</span> (doc.body.childNodes.length === <span class="hljs-number">0</span>) {
              doc.body.innerHTML = content;
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-888">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-888">&#182;</a>
              </div>
              <p>createContextualFragment doesnt exists in IE 9 DOMRanges</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (rng.createContextualFragment) {
                rng.insertNode(rng.createContextualFragment(content));
              } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-889">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-889">&#182;</a>
              </div>
              <p>Fake createContextualFragment call in IE 9</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                frag = doc.createDocumentFragment();
                temp = doc.createElement(<span class="hljs-string">'div'</span>);

                frag.appendChild(temp);
                temp.outerHTML = content;

                rng.insertNode(frag);
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-890">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-890">&#182;</a>
              </div>
              <p>Move to caret marker</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          caretNode = self.dom.get(<span class="hljs-string">'__caret'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-891">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-891">&#182;</a>
              </div>
              <p>Make sure we wrap it compleatly, Opera fails with a simple select call</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          rng = doc.createRange();
          rng.setStartBefore(caretNode);
          rng.setEndBefore(caretNode);
          self.setRng(rng);</pre></div></div>
            
        </li>
        
        
        <li id="section-892">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-892">&#182;</a>
              </div>
              <p>Remove the caret position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          self.dom.remove(<span class="hljs-string">'__caret'</span>);

          <span class="hljs-keyword">try</span> {
            self.setRng(rng);
          } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-893">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-893">&#182;</a>
              </div>
              <p>Might fail on Opera for some odd reason</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (rng.item) {</pre></div></div>
            
        </li>
        
        
        <li id="section-894">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-894">&#182;</a>
              </div>
              <p>Delete content and get caret text selection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            doc.execCommand(<span class="hljs-string">'Delete'</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);
            rng = self.getRng();
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-895">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-895">&#182;</a>
              </div>
              <p>Explorer removes spaces from the beginning of pasted contents</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\s+/</span>.test(content)) {
            rng.pasteHTML(<span class="hljs-string">'&lt;span id="__mce_tmp"&gt;_&lt;/span&gt;'</span> + content);
            self.dom.remove(<span class="hljs-string">'__mce_tmp'</span>);
          } <span class="hljs-keyword">else</span> {
            rng.pasteHTML(content);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-896">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-896">&#182;</a>
              </div>
              <p>Dispatch set content event</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!args.no_events) {
          self.editor.fire(<span class="hljs-string">'SetContent'</span>, args);
        }
      },

      <span class="hljs-comment">/**
       * Returns the start element of a selection range. If the start is in a text
       * node the parent element will be returned.
       *
       * @method getStart
       * @param {Boolean} real Optional state to get the real parent when the selection is collapsed not the closest element.
       * @return {Element} Start element of selection range.
       */</span>
      getStart: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">real</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, rng = self.getRng(), startElement, parentElement, checkRng, node;

        <span class="hljs-keyword">if</span> (rng.duplicate || rng.item) {</pre></div></div>
            
        </li>
        
        
        <li id="section-897">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-897">&#182;</a>
              </div>
              <p>Control selection, return first item</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (rng.item) {
            <span class="hljs-keyword">return</span> rng.item(<span class="hljs-number">0</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-898">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-898">&#182;</a>
              </div>
              <p>Get start element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          checkRng = rng.duplicate();
          checkRng.collapse(<span class="hljs-number">1</span>);
          startElement = checkRng.parentElement();
          <span class="hljs-keyword">if</span> (startElement.ownerDocument !== self.dom.doc) {
            startElement = self.dom.getRoot();
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-899">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-899">&#182;</a>
              </div>
              <p>Check if range parent is inside the start element, then return the inner parent element
This will fix issues when a single element is selected, IE would otherwise return the wrong start element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          parentElement = node = rng.parentElement();
          <span class="hljs-keyword">while</span> ((node = node.parentNode)) {
            <span class="hljs-keyword">if</span> (node == startElement) {
              startElement = parentElement;
              <span class="hljs-keyword">break</span>;
            }
          }

          <span class="hljs-keyword">return</span> startElement;
        }

        startElement = rng.startContainer;

        <span class="hljs-keyword">if</span> (startElement.nodeType == <span class="hljs-number">1</span> &amp;&amp; startElement.hasChildNodes()) {
          <span class="hljs-keyword">if</span> (!real || !rng.collapsed) {
            startElement = startElement.childNodes[<span class="hljs-built_in">Math</span>.min(startElement.childNodes.length - <span class="hljs-number">1</span>, rng.startOffset)];
          }
        }

        <span class="hljs-keyword">if</span> (startElement &amp;&amp; startElement.nodeType == <span class="hljs-number">3</span>) {
          <span class="hljs-keyword">return</span> startElement.parentNode;
        }

        <span class="hljs-keyword">return</span> startElement;
      },

      <span class="hljs-comment">/**
       * Returns the end element of a selection range. If the end is in a text
       * node the parent element will be returned.
       *
       * @method getEnd
       * @param {Boolean} real Optional state to get the real parent when the selection is collapsed not the closest element.
       * @return {Element} End element of selection range.
       */</span>
      getEnd: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">real</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, rng = self.getRng(), endElement, endOffset;

        <span class="hljs-keyword">if</span> (rng.duplicate || rng.item) {
          <span class="hljs-keyword">if</span> (rng.item) {
            <span class="hljs-keyword">return</span> rng.item(<span class="hljs-number">0</span>);
          }

          rng = rng.duplicate();
          rng.collapse(<span class="hljs-number">0</span>);
          endElement = rng.parentElement();
          <span class="hljs-keyword">if</span> (endElement.ownerDocument !== self.dom.doc) {
            endElement = self.dom.getRoot();
          }

          <span class="hljs-keyword">if</span> (endElement &amp;&amp; endElement.nodeName == <span class="hljs-string">'BODY'</span>) {
            <span class="hljs-keyword">return</span> endElement.lastChild || endElement;
          }

          <span class="hljs-keyword">return</span> endElement;
        }

        endElement = rng.endContainer;
        endOffset = rng.endOffset;

        <span class="hljs-keyword">if</span> (endElement.nodeType == <span class="hljs-number">1</span> &amp;&amp; endElement.hasChildNodes()) {
          <span class="hljs-keyword">if</span> (!real || !rng.collapsed) {
            endElement = endElement.childNodes[endOffset &gt; <span class="hljs-number">0</span> ? endOffset - <span class="hljs-number">1</span> : endOffset];
          }
        }

        <span class="hljs-keyword">if</span> (endElement &amp;&amp; endElement.nodeType == <span class="hljs-number">3</span>) {
          <span class="hljs-keyword">return</span> endElement.parentNode;
        }

        <span class="hljs-keyword">return</span> endElement;
      },

      <span class="hljs-comment">/**
       * Returns a bookmark location for the current selection. This bookmark object
       * can then be used to restore the selection after some content modification to the document.
       *
       * @method getBookmark
       * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.
       * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.
       * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.
       * @example
       * // Stores a bookmark of the current selection
       * var bm = tinymce.activeEditor.selection.getBookmark();
       *
       * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
       *
       * // Restore the selection bookmark
       * tinymce.activeEditor.selection.moveToBookmark(bm);
       */</span>
      getBookmark: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, normalized</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bookmarkManager.getBookmark(type, normalized);
      },

      <span class="hljs-comment">/**
       * Restores the selection to the specified bookmark.
       *
       * @method moveToBookmark
       * @param {Object} bookmark Bookmark to restore selection from.
       * @return {Boolean} true/false if it was successful or not.
       * @example
       * // Stores a bookmark of the current selection
       * var bm = tinymce.activeEditor.selection.getBookmark();
       *
       * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
       *
       * // Restore the selection bookmark
       * tinymce.activeEditor.selection.moveToBookmark(bm);
       */</span>
      moveToBookmark: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">bookmark</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bookmarkManager.moveToBookmark(bookmark);
      },

      <span class="hljs-comment">/**
       * Selects the specified element. This will place the start and end of the selection range around the element.
       *
       * @method select
       * @param {Element} node HTML DOM element to select.
       * @param {Boolean} content Optional bool state if the contents should be selected or not on non IE browser.
       * @return {Element} Selected element the same element as the one that got passed in.
       * @example
       * // Select the first paragraph in the active editor
       * tinymce.activeEditor.selection.select(tinymce.activeEditor.dom.select('p')[0]);
       */</span>
      select: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, content</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, dom = self.dom, rng = dom.createRng(), idx;</pre></div></div>
            
        </li>
        
        
        <li id="section-900">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-900">&#182;</a>
              </div>
              <p>Clear stored range set by FocusManager</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self.lastFocusBookmark = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (node) {
          <span class="hljs-keyword">if</span> (!content &amp;&amp; self.controlSelection.controlSelect(node)) {
            <span class="hljs-keyword">return</span>;
          }

          idx = dom.nodeIndex(node);
          rng.setStart(node.parentNode, idx);
          rng.setEnd(node.parentNode, idx + <span class="hljs-number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-901">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-901">&#182;</a>
              </div>
              <p>Find first/last text node or BR element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (content) {
            self._moveEndPoint(rng, node, <span class="hljs-literal">true</span>);
            self._moveEndPoint(rng, node);
          }

          self.setRng(rng);
        }

        <span class="hljs-keyword">return</span> node;
      },

      <span class="hljs-comment">/**
       * Returns true/false if the selection range is collapsed or not. Collapsed means if it's a caret or a larger selection.
       *
       * @method isCollapsed
       * @return {Boolean} true/false state if the selection range is collapsed or not.
       * Collapsed means if it's a caret or a larger selection.
       */</span>
      isCollapsed: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, rng = self.getRng(), sel = self.getSel();

        <span class="hljs-keyword">if</span> (!rng || rng.item) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">if</span> (rng.compareEndPoints) {
          <span class="hljs-keyword">return</span> rng.compareEndPoints(<span class="hljs-string">'StartToEnd'</span>, rng) === <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">return</span> !sel || rng.collapsed;
      },

      <span class="hljs-comment">/**
       * Collapse the selection to start or end of range.
       *
       * @method collapse
       * @param {Boolean} toStart Optional boolean state if to collapse to end or not. Defaults to false.
       */</span>
      collapse: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">toStart</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, rng = self.getRng(), node;</pre></div></div>
            
        </li>
        
        
        <li id="section-902">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-902">&#182;</a>
              </div>
              <p>Control range on IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (rng.item) {
          node = rng.item(<span class="hljs-number">0</span>);
          rng = self.win.document.body.createTextRange();
          rng.moveToElementText(node);
        }

        rng.collapse(!!toStart);
        self.setRng(rng);
      },

      <span class="hljs-comment">/**
       * Returns the browsers internal selection object.
       *
       * @method getSel
       * @return {Selection} Internal browser selection object.
       */</span>
      getSel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> win = <span class="hljs-keyword">this</span>.win;

        <span class="hljs-keyword">return</span> win.getSelection ? win.getSelection() : win.document.selection;
      },

      <span class="hljs-comment">/**
       * Returns the browsers internal range object.
       *
       * @method getRng
       * @param {Boolean} w3c Forces a compatible W3C range on IE.
       * @return {Range} Internal browser range object.
       * @see http://www.quirksmode.org/dom/range_intro.html
       * @see http://www.dotvoid.com/2001/03/using-the-range-object-in-mozilla/
       */</span>
      getRng: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">w3c</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, selection, rng, elm, doc, ieRng, evt;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryCompareBoundaryPoints</span>(<span class="hljs-params">how, sourceRange, destinationRange</span>) </span>{
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> sourceRange.compareBoundaryPoints(how, destinationRange);
          } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-903">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-903">&#182;</a>
              </div>
              <p>Gecko throws wrong document exception if the range points
to nodes that where removed from the dom #6690
Browsers should mutate existing DOMRange instances so that they always point
to something in the document this is not the case in Gecko works fine in IE/WebKit/Blink
For performance reasons just return -1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
          }
        }

        <span class="hljs-keyword">if</span> (!self.win) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        doc = self.win.document;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> doc === <span class="hljs-string">'undefined'</span> || doc === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-904">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-904">&#182;</a>
              </div>
              <p>Use last rng passed from FocusManager if its available this enables
calls to editor.selection.getStart() to work when caret focus is lost on IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!w3c &amp;&amp; self.lastFocusBookmark) {
          <span class="hljs-keyword">var</span> bookmark = self.lastFocusBookmark;</pre></div></div>
            
        </li>
        
        
        <li id="section-905">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-905">&#182;</a>
              </div>
              <p>Convert bookmark to range IE 11 fix</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (bookmark.startContainer) {
            rng = doc.createRange();
            rng.setStart(bookmark.startContainer, bookmark.startOffset);
            rng.setEnd(bookmark.endContainer, bookmark.endOffset);
          } <span class="hljs-keyword">else</span> {
            rng = bookmark;
          }

          <span class="hljs-keyword">return</span> rng;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-906">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-906">&#182;</a>
              </div>
              <p>Found tridentSel object then we need to use that one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (w3c &amp;&amp; self.tridentSel) {
          <span class="hljs-keyword">return</span> self.tridentSel.getRangeAt(<span class="hljs-number">0</span>);
        }

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">if</span> ((selection = self.getSel())) {
            <span class="hljs-keyword">if</span> (selection.rangeCount &gt; <span class="hljs-number">0</span>) {
              rng = selection.getRangeAt(<span class="hljs-number">0</span>);
            } <span class="hljs-keyword">else</span> {
              rng = selection.createRange ? selection.createRange() : doc.createRange();
            }
          }
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-907">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-907">&#182;</a>
              </div>
              <p>IE throws unspecified error here if TinyMCE is placed in a frame/iframe</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }

        evt = self.editor.fire(<span class="hljs-string">'GetSelectionRange'</span>, { <span class="hljs-attr">range</span>: rng });
        <span class="hljs-keyword">if</span> (evt.range !== rng) {
          <span class="hljs-keyword">return</span> evt.range;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-908">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-908">&#182;</a>
              </div>
              <p>We have W3C ranges and its IE then fake control selection since IE9 doesnt handle that correctly yet
IE 11 doesnt support the selection object so we check for that as well</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (isIE &amp;&amp; rng &amp;&amp; rng.setStart &amp;&amp; doc.selection) {
          <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-909">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-909">&#182;</a>
              </div>
              <p>IE will sometimes throw an exception here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            ieRng = doc.selection.createRange();
          } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-910">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-910">&#182;</a>
              </div>
              <p>Ignore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          }

          <span class="hljs-keyword">if</span> (ieRng &amp;&amp; ieRng.item) {
            elm = ieRng.item(<span class="hljs-number">0</span>);
            rng = doc.createRange();
            rng.setStartBefore(elm);
            rng.setEndAfter(elm);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-911">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-911">&#182;</a>
              </div>
              <p>No range found then create an empty one
This can occur when the editor is placed in a hidden container element on Gecko
Or on IE when there was an exception</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!rng) {
          rng = doc.createRange ? doc.createRange() : doc.body.createTextRange();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-912">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-912">&#182;</a>
              </div>
              <p>If range is at start of document then move it to start of body</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (rng.setStart &amp;&amp; rng.startContainer.nodeType === <span class="hljs-number">9</span> &amp;&amp; rng.collapsed) {
          elm = self.dom.getRoot();
          rng.setStart(elm, <span class="hljs-number">0</span>);
          rng.setEnd(elm, <span class="hljs-number">0</span>);
        }

        <span class="hljs-keyword">if</span> (self.selectedRange &amp;&amp; self.explicitRange) {
          <span class="hljs-keyword">if</span> (tryCompareBoundaryPoints(rng.START_TO_START, rng, self.selectedRange) === <span class="hljs-number">0</span> &amp;&amp;
            tryCompareBoundaryPoints(rng.END_TO_END, rng, self.selectedRange) === <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-913">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-913">&#182;</a>
              </div>
              <p>Safari, Opera and Chrome only ever select text which causes the range to change.
This lets us use the originally set range if the selection hasnt been changed by the user.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            rng = self.explicitRange;
          } <span class="hljs-keyword">else</span> {
            self.selectedRange = <span class="hljs-literal">null</span>;
            self.explicitRange = <span class="hljs-literal">null</span>;
          }
        }

        <span class="hljs-keyword">return</span> rng;
      },

      <span class="hljs-comment">/**
       * Changes the selection to the specified DOM range.
       *
       * @method setRng
       * @param {Range} rng Range to select.
       * @param {Boolean} forward Optional boolean if the selection is forwards or backwards.
       */</span>
      setRng: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rng, forward</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, sel, node, evt;

        <span class="hljs-keyword">if</span> (!rng) {
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-914">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-914">&#182;</a>
              </div>
              <p>Is IE specific range</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (rng.select) {
          self.explicitRange = <span class="hljs-literal">null</span>;

          <span class="hljs-keyword">try</span> {
            rng.select();
          } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-915">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-915">&#182;</a>
              </div>
              <p>Needed for some odd IE bug #1843306</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          }

          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (!self.tridentSel) {
          sel = self.getSel();

          evt = self.editor.fire(<span class="hljs-string">'SetSelectionRange'</span>, { <span class="hljs-attr">range</span>: rng, <span class="hljs-attr">forward</span>: forward });
          rng = evt.range;

          <span class="hljs-keyword">if</span> (sel) {
            self.explicitRange = rng;

            <span class="hljs-keyword">try</span> {
              sel.removeAllRanges();
              sel.addRange(rng);
            } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-916">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-916">&#182;</a>
              </div>
              <p>IE might throw errors here if the editor is within a hidden container and selection is changed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            }</pre></div></div>
            
        </li>
        
        
        <li id="section-917">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-917">&#182;</a>
              </div>
              <p>Forward is set to false and we have an extend function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (forward === <span class="hljs-literal">false</span> &amp;&amp; sel.extend) {
              sel.collapse(rng.endContainer, rng.endOffset);
              sel.extend(rng.startContainer, rng.startOffset);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-918">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-918">&#182;</a>
              </div>
              <p>adding range isnt always successful so we need to check range count otherwise an exception can occur</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            self.selectedRange = sel.rangeCount &gt; <span class="hljs-number">0</span> ? sel.getRangeAt(<span class="hljs-number">0</span>) : <span class="hljs-literal">null</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-919">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-919">&#182;</a>
              </div>
              <p>WebKit egde case selecting images works better using setBaseAndExtent when the image is floated</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!rng.collapsed &amp;&amp; rng.startContainer === rng.endContainer &amp;&amp; sel.setBaseAndExtent &amp;&amp; !Env.ie) {
            <span class="hljs-keyword">if</span> (rng.endOffset - rng.startOffset &lt; <span class="hljs-number">2</span>) {
              <span class="hljs-keyword">if</span> (rng.startContainer.hasChildNodes()) {
                node = rng.startContainer.childNodes[rng.startOffset];
                <span class="hljs-keyword">if</span> (node &amp;&amp; node.tagName === <span class="hljs-string">'IMG'</span>) {
                  sel.setBaseAndExtent(
                    rng.startContainer,
                    rng.startOffset,
                    rng.endContainer,
                    rng.endOffset
                  );</pre></div></div>
            
        </li>
        
        
        <li id="section-920">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-920">&#182;</a>
              </div>
              <p>Since the setBaseAndExtent is fixed in more recent Blink versions we
need to detect if its doing the wrong thing and falling back to the
crazy incorrect behavior api call since that seems to be the only way
to get it to work on Safari WebKit as of 2017-02-23</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">if</span> (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
                    sel.setBaseAndExtent(node, <span class="hljs-number">0</span>, node, <span class="hljs-number">1</span>);
                  }
                }
              }
            }
          }

          self.editor.fire(<span class="hljs-string">'AfterSetSelectionRange'</span>, { <span class="hljs-attr">range</span>: rng, <span class="hljs-attr">forward</span>: forward });
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-921">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-921">&#182;</a>
              </div>
              <p>Is W3C Range fake range on IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (rng.cloneRange) {
            <span class="hljs-keyword">try</span> {
              self.tridentSel.addRange(rng);
            } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-922">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-922">&#182;</a>
              </div>
              <p>IE9 throws an error here if called before selection is placed in the editor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            }
          }
        }
      },

      <span class="hljs-comment">/**
       * Sets the current selection to the specified DOM element.
       *
       * @method setNode
       * @param {Element} elm Element to set as the contents of the selection.
       * @return {Element} Returns the element that got passed in.
       * @example
       * // Inserts a DOM node at current selection/caret location
       * tinymce.activeEditor.selection.setNode(tinymce.activeEditor.dom.create('img', {src: 'some.gif', title: 'some title'}));
       */</span>
      setNode: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.setContent(self.dom.getOuterHTML(elm));

        <span class="hljs-keyword">return</span> elm;
      },

      <span class="hljs-comment">/**
       * Returns the currently selected element or the common ancestor element for both start and end of the selection.
       *
       * @method getNode
       * @return {Element} Currently selected element or common ancestor element.
       * @example
       * // Alerts the currently selected elements node name
       * alert(tinymce.activeEditor.selection.getNode().nodeName);
       */</span>
      getNode: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, rng = self.getRng(), elm;
        <span class="hljs-keyword">var</span> startContainer, endContainer, startOffset, endOffset, root = self.dom.getRoot();

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipEmptyTextNodes</span>(<span class="hljs-params">node, forwards</span>) </span>{
          <span class="hljs-keyword">var</span> orig = node;

          <span class="hljs-keyword">while</span> (node &amp;&amp; node.nodeType === <span class="hljs-number">3</span> &amp;&amp; node.length === <span class="hljs-number">0</span>) {
            node = forwards ? node.nextSibling : node.previousSibling;
          }

          <span class="hljs-keyword">return</span> node || orig;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-923">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-923">&#182;</a>
              </div>
              <p>Range maybe lost after the editor is made visible again</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!rng) {
          <span class="hljs-keyword">return</span> root;
        }

        startContainer = rng.startContainer;
        endContainer = rng.endContainer;
        startOffset = rng.startOffset;
        endOffset = rng.endOffset;

        <span class="hljs-keyword">if</span> (rng.setStart) {
          elm = rng.commonAncestorContainer;</pre></div></div>
            
        </li>
        
        
        <li id="section-924">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-924">&#182;</a>
              </div>
              <p>Handle selection a image or other control like element such as anchors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!rng.collapsed) {
            <span class="hljs-keyword">if</span> (startContainer == endContainer) {
              <span class="hljs-keyword">if</span> (endOffset - startOffset &lt; <span class="hljs-number">2</span>) {
                <span class="hljs-keyword">if</span> (startContainer.hasChildNodes()) {
                  elm = startContainer.childNodes[startOffset];
                }
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-925">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-925">&#182;</a>
              </div>
              <p>If the anchor node is a element instead of a text node then return this element
if (tinymce.isWebKit &amp;&amp; sel.anchorNode &amp;&amp; sel.anchorNode.nodeType == 1)
return sel.anchorNode.childNodes[sel.anchorOffset];</p>

            </div>
            
        </li>
        
        
        <li id="section-926">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-926">&#182;</a>
              </div>
              <p>Handle cases where the selection is immediately wrapped around a node and return that node instead of its parent.
This happens when you double click an underlined word in FireFox.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (startContainer.nodeType === <span class="hljs-number">3</span> &amp;&amp; endContainer.nodeType === <span class="hljs-number">3</span>) {
              <span class="hljs-keyword">if</span> (startContainer.length === startOffset) {
                startContainer = skipEmptyTextNodes(startContainer.nextSibling, <span class="hljs-literal">true</span>);
              } <span class="hljs-keyword">else</span> {
                startContainer = startContainer.parentNode;
              }

              <span class="hljs-keyword">if</span> (endOffset === <span class="hljs-number">0</span>) {
                endContainer = skipEmptyTextNodes(endContainer.previousSibling, <span class="hljs-literal">false</span>);
              } <span class="hljs-keyword">else</span> {
                endContainer = endContainer.parentNode;
              }

              <span class="hljs-keyword">if</span> (startContainer &amp;&amp; startContainer === endContainer) {
                <span class="hljs-keyword">return</span> startContainer;
              }
            }
          }

          <span class="hljs-keyword">if</span> (elm &amp;&amp; elm.nodeType == <span class="hljs-number">3</span>) {
            <span class="hljs-keyword">return</span> elm.parentNode;
          }

          <span class="hljs-keyword">return</span> elm;
        }

        elm = rng.item ? rng.item(<span class="hljs-number">0</span>) : rng.parentElement();</pre></div></div>
            
        </li>
        
        
        <li id="section-927">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-927">&#182;</a>
              </div>
              <p>IE 7 might return elements outside the iframe</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (elm.ownerDocument !== self.win.document) {
          elm = root;
        }

        <span class="hljs-keyword">return</span> elm;
      },

      <span class="hljs-attr">getSelectedBlocks</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">startElm, endElm</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, dom = self.dom, node, root, selectedBlocks = [];

        root = dom.getRoot();
        startElm = dom.getParent(startElm || self.getStart(), dom.isBlock);
        endElm = dom.getParent(endElm || self.getEnd(), dom.isBlock);

        <span class="hljs-keyword">if</span> (startElm &amp;&amp; startElm != root) {
          selectedBlocks.push(startElm);
        }

        <span class="hljs-keyword">if</span> (startElm &amp;&amp; endElm &amp;&amp; startElm != endElm) {
          node = startElm;

          <span class="hljs-keyword">var</span> walker = <span class="hljs-keyword">new</span> TreeWalker(startElm, root);
          <span class="hljs-keyword">while</span> ((node = walker.next()) &amp;&amp; node != endElm) {
            <span class="hljs-keyword">if</span> (dom.isBlock(node)) {
              selectedBlocks.push(node);
            }
          }
        }

        <span class="hljs-keyword">if</span> (endElm &amp;&amp; startElm != endElm &amp;&amp; endElm != root) {
          selectedBlocks.push(endElm);
        }

        <span class="hljs-keyword">return</span> selectedBlocks;
      },

      <span class="hljs-attr">isForward</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> dom = <span class="hljs-keyword">this</span>.dom, sel = <span class="hljs-keyword">this</span>.getSel(), anchorRange, focusRange;</pre></div></div>
            
        </li>
        
        
        <li id="section-928">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-928">&#182;</a>
              </div>
              <p>No support for selection direction then always return true</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!sel || !sel.anchorNode || !sel.focusNode) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        anchorRange = dom.createRng();
        anchorRange.setStart(sel.anchorNode, sel.anchorOffset);
        anchorRange.collapse(<span class="hljs-literal">true</span>);

        focusRange = dom.createRng();
        focusRange.setStart(sel.focusNode, sel.focusOffset);
        focusRange.collapse(<span class="hljs-literal">true</span>);

        <span class="hljs-keyword">return</span> anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) &lt;= <span class="hljs-number">0</span>;
      },

      <span class="hljs-attr">normalize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, rng = self.getRng();

        <span class="hljs-keyword">if</span> (Env.range &amp;&amp; <span class="hljs-keyword">new</span> RangeUtils(self.dom).normalize(rng)) {
          self.setRng(rng, self.isForward());
        }

        <span class="hljs-keyword">return</span> rng;
      },

      <span class="hljs-comment">/**
       * Executes callback when the current selection starts/stops matching the specified selector. The current
       * state will be passed to the callback as it's first argument.
       *
       * @method selectorChanged
       * @param {String} selector CSS selector to check for.
       * @param {function} callback Callback with state and args when the selector is matches or not.
       */</span>
      selectorChanged: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector, callback</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, currentSelectors;

        <span class="hljs-keyword">if</span> (!self.selectorChangedData) {
          self.selectorChangedData = {};
          currentSelectors = {};

          self.editor.on(<span class="hljs-string">'NodeChange'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">var</span> node = e.element, dom = self.dom, parents = dom.getParents(node, <span class="hljs-literal">null</span>, dom.getRoot()), matchedSelectors = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-929">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-929">&#182;</a>
              </div>
              <p>Check for new matching selectors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            each(self.selectorChangedData, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callbacks, selector</span>) </span>{
              each(parents, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
                <span class="hljs-keyword">if</span> (dom.is(node, selector)) {
                  <span class="hljs-keyword">if</span> (!currentSelectors[selector]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-930">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-930">&#182;</a>
              </div>
              <p>Execute callbacks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    each(callbacks, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
                      callback(<span class="hljs-literal">true</span>, { <span class="hljs-attr">node</span>: node, <span class="hljs-attr">selector</span>: selector, <span class="hljs-attr">parents</span>: parents });
                    });

                    currentSelectors[selector] = callbacks;
                  }

                  matchedSelectors[selector] = callbacks;
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
              });
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-931">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-931">&#182;</a>
              </div>
              <p>Check if current selectors still match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            each(currentSelectors, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callbacks, selector</span>) </span>{
              <span class="hljs-keyword">if</span> (!matchedSelectors[selector]) {
                <span class="hljs-keyword">delete</span> currentSelectors[selector];

                each(callbacks, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
                  callback(<span class="hljs-literal">false</span>, { <span class="hljs-attr">node</span>: node, <span class="hljs-attr">selector</span>: selector, <span class="hljs-attr">parents</span>: parents });
                });
              }
            });
          });
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-932">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-932">&#182;</a>
              </div>
              <p>Add selector listeners</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!self.selectorChangedData[selector]) {
          self.selectorChangedData[selector] = [];
        }

        self.selectorChangedData[selector].push(callback);

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-attr">getScrollContainer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> scrollContainer, node = <span class="hljs-keyword">this</span>.dom.getRoot();

        <span class="hljs-keyword">while</span> (node &amp;&amp; node.nodeName != <span class="hljs-string">'BODY'</span>) {
          <span class="hljs-keyword">if</span> (node.scrollHeight &gt; node.clientHeight) {
            scrollContainer = node;
            <span class="hljs-keyword">break</span>;
          }

          node = node.parentNode;
        }

        <span class="hljs-keyword">return</span> scrollContainer;
      },

      <span class="hljs-attr">scrollIntoView</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, alignToTop</span>) </span>{
        ScrollIntoView.scrollIntoView(<span class="hljs-keyword">this</span>.editor, elm, alignToTop);
      },

      <span class="hljs-attr">placeCaretAt</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clientX, clientY</span>) </span>{
        <span class="hljs-keyword">this</span>.setRng(RangeUtils.getCaretRangeFromPoint(clientX, clientY, <span class="hljs-keyword">this</span>.editor.getDoc()));
      },

      <span class="hljs-attr">_moveEndPoint</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rng, node, start</span>) </span>{
        <span class="hljs-keyword">var</span> root = node, walker = <span class="hljs-keyword">new</span> TreeWalker(node, root);
        <span class="hljs-keyword">var</span> nonEmptyElementsMap = <span class="hljs-keyword">this</span>.dom.schema.getNonEmptyElements();

        <span class="hljs-keyword">do</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-933">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-933">&#182;</a>
              </div>
              <p>Text node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (node.nodeType == <span class="hljs-number">3</span> &amp;&amp; trim(node.nodeValue).length !== <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (start) {
              rng.setStart(node, <span class="hljs-number">0</span>);
            } <span class="hljs-keyword">else</span> {
              rng.setEnd(node, node.nodeValue.length);
            }

            <span class="hljs-keyword">return</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-934">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-934">&#182;</a>
              </div>
              <p>BR/IMG/INPUT elements but not table cells</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (nonEmptyElementsMap[node.nodeName] &amp;&amp; !<span class="hljs-regexp">/^(TD|TH)$/</span>.test(node.nodeName)) {
            <span class="hljs-keyword">if</span> (start) {
              rng.setStartBefore(node);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">if</span> (node.nodeName == <span class="hljs-string">'BR'</span>) {
                rng.setEndBefore(node);
              } <span class="hljs-keyword">else</span> {
                rng.setEndAfter(node);
              }
            }

            <span class="hljs-keyword">return</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-935">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-935">&#182;</a>
              </div>
              <p>Found empty text block old IE can place the selection inside those</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (Env.ie &amp;&amp; Env.ie &lt; <span class="hljs-number">11</span> &amp;&amp; <span class="hljs-keyword">this</span>.dom.isBlock(node) &amp;&amp; <span class="hljs-keyword">this</span>.dom.isEmpty(node)) {
            <span class="hljs-keyword">if</span> (start) {
              rng.setStart(node, <span class="hljs-number">0</span>);
            } <span class="hljs-keyword">else</span> {
              rng.setEnd(node, <span class="hljs-number">0</span>);
            }

            <span class="hljs-keyword">return</span>;
          }
        } <span class="hljs-keyword">while</span> ((node = (start ? walker.next() : walker.prev())));</pre></div></div>
            
        </li>
        
        
        <li id="section-936">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-936">&#182;</a>
              </div>
              <p>Failed to find any text node or other suitable location then move to the root of body</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (root.nodeName == <span class="hljs-string">'BODY'</span>) {
          <span class="hljs-keyword">if</span> (start) {
            rng.setStart(root, <span class="hljs-number">0</span>);
          } <span class="hljs-keyword">else</span> {
            rng.setEnd(root, root.childNodes.length);
          }
        }
      },

      <span class="hljs-attr">getBoundingClientRect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> rng = <span class="hljs-keyword">this</span>.getRng();
        <span class="hljs-keyword">return</span> rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[<span class="hljs-number">0</span>] : rng.getBoundingClientRect();
      },

      <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.win = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">this</span>.controlSelection.destroy();
      }
    };

    <span class="hljs-keyword">return</span> Selection;
  }
);

<span class="hljs-comment">/**
 * ElementUtils.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Utility class for various element specific functions.
 *
 * @private
 * @class tinymce.dom.ElementUtils
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.ElementUtils'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.BookmarkManager"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">BookmarkManager, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> each = Tools.each;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ElementUtils</span>(<span class="hljs-params">dom</span>) </span>{
      <span class="hljs-comment">/**
       * Compares two nodes and checks if it's attributes and styles matches.
       * This doesn't compare classes as items since their order is significant.
       *
       * @method compare
       * @param {Node} node1 First node to compare with.
       * @param {Node} node2 Second node to compare with.
       * @return {boolean} True/false if the nodes are the same or not.
       */</span>
      <span class="hljs-keyword">this</span>.compare = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node1, node2</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-937">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-937">&#182;</a>
              </div>
              <p>Not the same name</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (node1.nodeName != node2.nodeName) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-comment">/**
         * Returns all the nodes attributes excluding internal ones, styles and classes.
         *
         * @private
         * @param {Node} node Node to get attributes from.
         * @return {Object} Name/value object with attributes and attribute values.
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAttribs</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> attribs = {};

          each(dom.getAttribs(node), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">attr</span>) </span>{
            <span class="hljs-keyword">var</span> name = attr.nodeName.toLowerCase();</pre></div></div>
            
        </li>
        
        
        <li id="section-938">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-938">&#182;</a>
              </div>
              <p>Dont compare internal attributes or style</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (name.indexOf(<span class="hljs-string">'_'</span>) !== <span class="hljs-number">0</span> &amp;&amp; name !== <span class="hljs-string">'style'</span> &amp;&amp; name.indexOf(<span class="hljs-string">'data-'</span>) !== <span class="hljs-number">0</span>) {
              attribs[name] = dom.getAttrib(node, name);
            }
          });

          <span class="hljs-keyword">return</span> attribs;
        }

        <span class="hljs-comment">/**
         * Compares two objects checks if it's key + value exists in the other one.
         *
         * @private
         * @param {Object} obj1 First object to compare.
         * @param {Object} obj2 Second object to compare.
         * @return {boolean} True/false if the objects matches or not.
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareObjects</span>(<span class="hljs-params">obj1, obj2</span>) </span>{
          <span class="hljs-keyword">var</span> value, name;

          <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> obj1) {</pre></div></div>
            
        </li>
        
        
        <li id="section-939">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-939">&#182;</a>
              </div>
              <p>Obj1 has item obj2 doesnt have</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (obj1.hasOwnProperty(name)) {
              value = obj2[name];</pre></div></div>
            
        </li>
        
        
        <li id="section-940">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-940">&#182;</a>
              </div>
              <p>Obj2 doesnt have obj1 item</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">"undefined"</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-941">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-941">&#182;</a>
              </div>
              <p>Obj2 item has a different value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (obj1[name] != value) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-942">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-942">&#182;</a>
              </div>
              <p>Delete similar value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">delete</span> obj2[name];
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-943">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-943">&#182;</a>
              </div>
              <p>Check if obj 2 has something obj 1 doesnt have</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> obj2) {</pre></div></div>
            
        </li>
        
        
        <li id="section-944">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-944">&#182;</a>
              </div>
              <p>Obj2 has item obj1 doesnt have</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (obj2.hasOwnProperty(name)) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-945">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-945">&#182;</a>
              </div>
              <p>Attribs are not the same</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!compareObjects(getAttribs(node1), getAttribs(node2))) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-946">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-946">&#182;</a>
              </div>
              <p>Styles are not the same</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!compareObjects(dom.parseStyle(dom.getAttrib(node1, <span class="hljs-string">'style'</span>)), dom.parseStyle(dom.getAttrib(node2, <span class="hljs-string">'style'</span>)))) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">return</span> !BookmarkManager.isBookmarkNode(node1) &amp;&amp; !BookmarkManager.isBookmarkNode(node2);
      };
    }

    <span class="hljs-keyword">return</span> ElementUtils;
  }
);

<span class="hljs-comment">/**
 * Preview.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Internal class for generating previews styles for formats.
 *
 * Example:
 *  Preview.getCssText(editor, 'bold');
 *
 * @private
 * @class tinymce.fmt.Preview
 */</span>
define(
  <span class="hljs-string">'tinymce.core.fmt.Preview'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.DOMUtils"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.html.Schema"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">DOMUtils, Tools, Schema</span>) </span>{
    <span class="hljs-keyword">var</span> each = Tools.each;
    <span class="hljs-keyword">var</span> dom = DOMUtils.DOM;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parsedSelectorToHtml</span>(<span class="hljs-params">ancestry, editor</span>) </span>{
      <span class="hljs-keyword">var</span> elm, item, fragment;
      <span class="hljs-keyword">var</span> schema = editor &amp;&amp; editor.schema || <span class="hljs-keyword">new</span> Schema({});

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decorate</span>(<span class="hljs-params">elm, item</span>) </span>{
        <span class="hljs-keyword">if</span> (item.classes.length) {
          dom.addClass(elm, item.classes.join(<span class="hljs-string">' '</span>));
        }
        dom.setAttribs(elm, item.attrs);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>(<span class="hljs-params">sItem</span>) </span>{
        <span class="hljs-keyword">var</span> elm;

        item = <span class="hljs-keyword">typeof</span> sItem === <span class="hljs-string">'string'</span> ? {
          <span class="hljs-attr">name</span>: sItem,
          <span class="hljs-attr">classes</span>: [],
          <span class="hljs-attr">attrs</span>: {}
        } : sItem;

        elm = dom.create(item.name);
        decorate(elm, item);
        <span class="hljs-keyword">return</span> elm;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRequiredParent</span>(<span class="hljs-params">elm, candidate</span>) </span>{
        <span class="hljs-keyword">var</span> name = <span class="hljs-keyword">typeof</span> elm !== <span class="hljs-string">'string'</span> ? elm.nodeName.toLowerCase() : elm;
        <span class="hljs-keyword">var</span> elmRule = schema.getElementRule(name);
        <span class="hljs-keyword">var</span> parentsRequired = elmRule.parentsRequired;

        <span class="hljs-keyword">if</span> (parentsRequired &amp;&amp; parentsRequired.length) {
          <span class="hljs-keyword">return</span> candidate &amp;&amp; Tools.inArray(parentsRequired, candidate) !== <span class="hljs-number">-1</span> ? candidate : parentsRequired[<span class="hljs-number">0</span>];
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapInHtml</span>(<span class="hljs-params">elm, ancestry, siblings</span>) </span>{
        <span class="hljs-keyword">var</span> parent, parentCandidate, parentRequired;
        <span class="hljs-keyword">var</span> ancestor = ancestry.length &amp;&amp; ancestry[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">var</span> ancestorName = ancestor &amp;&amp; ancestor.name;

        parentRequired = getRequiredParent(elm, ancestorName);

        <span class="hljs-keyword">if</span> (parentRequired) {
          <span class="hljs-keyword">if</span> (ancestorName == parentRequired) {
            parentCandidate = ancestry[<span class="hljs-number">0</span>];
            ancestry = ancestry.slice(<span class="hljs-number">1</span>);
          } <span class="hljs-keyword">else</span> {
            parentCandidate = parentRequired;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ancestor) {
          parentCandidate = ancestry[<span class="hljs-number">0</span>];
          ancestry = ancestry.slice(<span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!siblings) {
          <span class="hljs-keyword">return</span> elm;
        }

        <span class="hljs-keyword">if</span> (parentCandidate) {
          parent = createElement(parentCandidate);
          parent.appendChild(elm);
        }

        <span class="hljs-keyword">if</span> (siblings) {
          <span class="hljs-keyword">if</span> (!parent) {</pre></div></div>
            
        </li>
        
        
        <li id="section-947">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-947">&#182;</a>
              </div>
              <p>if no more ancestry, wrap in generic div</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            parent = dom.create(<span class="hljs-string">'div'</span>);
            parent.appendChild(elm);
          }

          Tools.each(siblings, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sibling</span>) </span>{
            <span class="hljs-keyword">var</span> siblingElm = createElement(sibling);
            parent.insertBefore(siblingElm, elm);
          });
        }

        <span class="hljs-keyword">return</span> wrapInHtml(parent, ancestry, parentCandidate &amp;&amp; parentCandidate.siblings);
      }

      <span class="hljs-keyword">if</span> (ancestry &amp;&amp; ancestry.length) {
        item = ancestry[<span class="hljs-number">0</span>];
        elm = createElement(item);
        fragment = dom.create(<span class="hljs-string">'div'</span>);
        fragment.appendChild(wrapInHtml(elm, ancestry.slice(<span class="hljs-number">1</span>), item.siblings));
        <span class="hljs-keyword">return</span> fragment;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
      }
    }


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectorToHtml</span>(<span class="hljs-params">selector, editor</span>) </span>{
      <span class="hljs-keyword">return</span> parsedSelectorToHtml(parseSelector(selector), editor);
    }


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseSelectorItem</span>(<span class="hljs-params">item</span>) </span>{
      <span class="hljs-keyword">var</span> tagName;
      <span class="hljs-keyword">var</span> obj = {
        <span class="hljs-attr">classes</span>: [],
        <span class="hljs-attr">attrs</span>: {}
      };

      item = obj.selector = Tools.trim(item);

      <span class="hljs-keyword">if</span> (item !== <span class="hljs-string">'*'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-948">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-948">&#182;</a>
              </div>
              <p>matching IDs, CLASSes, ATTRIBUTES and PSEUDOs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        tagName = item.replace(<span class="hljs-regexp">/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$<span class="hljs-number">0</span>, $<span class="hljs-number">1</span>, $<span class="hljs-number">2</span>, $<span class="hljs-number">3</span>, $<span class="hljs-number">4</span></span>) </span>{
          <span class="hljs-keyword">switch</span> ($<span class="hljs-number">1</span>) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">'#'</span>:
              obj.attrs.id = $<span class="hljs-number">2</span>;
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">'.'</span>:
              obj.classes.push($<span class="hljs-number">2</span>);
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">':'</span>:
              <span class="hljs-keyword">if</span> (Tools.inArray(<span class="hljs-string">'checked disabled enabled read-only required'</span>.split(<span class="hljs-string">' '</span>), $<span class="hljs-number">2</span>) !== <span class="hljs-number">-1</span>) {
                obj.attrs[$<span class="hljs-number">2</span>] = $<span class="hljs-number">2</span>;
              }
              <span class="hljs-keyword">break</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-949">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-949">&#182;</a>
              </div>
              <p>atribute matched</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> ($<span class="hljs-number">3</span> == <span class="hljs-string">'['</span>) {
            <span class="hljs-keyword">var</span> m = $<span class="hljs-number">4.</span>match(<span class="hljs-regexp">/([\w\-]+)(?:\=\"([^\"]+))?/</span>);
            <span class="hljs-keyword">if</span> (m) {
              obj.attrs[m[<span class="hljs-number">1</span>]] = m[<span class="hljs-number">2</span>];
            }
          }

          <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
        });
      }

      obj.name = tagName || <span class="hljs-string">'div'</span>;
      <span class="hljs-keyword">return</span> obj;
    }


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseSelector</span>(<span class="hljs-params">selector</span>) </span>{
      <span class="hljs-keyword">if</span> (!selector || <span class="hljs-keyword">typeof</span> selector !== <span class="hljs-string">'string'</span>) {
        <span class="hljs-keyword">return</span> [];
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-950">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-950">&#182;</a>
              </div>
              <p>take into account only first one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      selector = selector.split(<span class="hljs-regexp">/\s*,\s*/</span>)[<span class="hljs-number">0</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-951">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-951">&#182;</a>
              </div>
              <p>tighten</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      selector = selector.replace(<span class="hljs-regexp">/\s*(~\+|~|\+|&gt;)\s*/g</span>, <span class="hljs-string">'$1'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-952">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-952">&#182;</a>
              </div>
              <p>split either on &gt; or on space, but not the one inside brackets</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> Tools.map(selector.split(<span class="hljs-regexp">/(?:&gt;|\s+(?![^\[\]]+\]))/</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-953">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-953">&#182;</a>
              </div>
              <p>process each sibling selector separately</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> siblings = Tools.map(item.split(<span class="hljs-regexp">/(?:~\+|~|\+)/</span>), parseSelectorItem);
        <span class="hljs-keyword">var</span> obj = siblings.pop(); <span class="hljs-comment">// the last one is our real target</span>

        <span class="hljs-keyword">if</span> (siblings.length) {
          obj.siblings = siblings;
        }
        <span class="hljs-keyword">return</span> obj;
      }).reverse();
    }


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCssText</span>(<span class="hljs-params">editor, format</span>) </span>{
      <span class="hljs-keyword">var</span> name, previewFrag, previewElm, items;
      <span class="hljs-keyword">var</span> previewCss = <span class="hljs-string">''</span>, parentFontSize, previewStyles;

      previewStyles = editor.settings.preview_styles;</pre></div></div>
            
        </li>
        
        
        <li id="section-954">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-954">&#182;</a>
              </div>
              <p>No preview forced</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (previewStyles === <span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-955">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-955">&#182;</a>
              </div>
              <p>Default preview</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> previewStyles !== <span class="hljs-string">'string'</span>) {
        previewStyles = <span class="hljs-string">'font-family font-size font-weight font-style text-decoration '</span> +
          <span class="hljs-string">'text-transform color background-color border border-radius outline text-shadow'</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-956">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-956">&#182;</a>
              </div>
              <p>Removes any variables since these cant be previewed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeVars</span>(<span class="hljs-params">val</span>) </span>{
        <span class="hljs-keyword">return</span> val.replace(<span class="hljs-regexp">/%(\w+)/g</span>, <span class="hljs-string">''</span>);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-957">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-957">&#182;</a>
              </div>
              <p>Create block/inline element to use for preview</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> format == <span class="hljs-string">"string"</span>) {
        format = editor.formatter.get(format);
        <span class="hljs-keyword">if</span> (!format) {
          <span class="hljs-keyword">return</span>;
        }

        format = format[<span class="hljs-number">0</span>];
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-958">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-958">&#182;</a>
              </div>
              <p>Format specific preview override
TODO: This should probably be further reduced by the previewStyles option</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-string">'preview'</span> <span class="hljs-keyword">in</span> format) {
        previewStyles = format.preview;
        <span class="hljs-keyword">if</span> (previewStyles === <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
        }
      }

      name = format.block || format.inline || <span class="hljs-string">'span'</span>;

      items = parseSelector(format.selector);
      <span class="hljs-keyword">if</span> (items.length) {
        <span class="hljs-keyword">if</span> (!items[<span class="hljs-number">0</span>].name) { <span class="hljs-comment">// e.g. something like ul &gt; .someClass was provided</span>
          items[<span class="hljs-number">0</span>].name = name;
        }
        name = format.selector;
        previewFrag = parsedSelectorToHtml(items, editor);
      } <span class="hljs-keyword">else</span> {
        previewFrag = parsedSelectorToHtml([name], editor);
      }

      previewElm = dom.select(name, previewFrag)[<span class="hljs-number">0</span>] || previewFrag.firstChild;</pre></div></div>
            
        </li>
        
        
        <li id="section-959">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-959">&#182;</a>
              </div>
              <p>Add format styles to preview element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      each(format.styles, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, name</span>) </span>{
        value = removeVars(value);

        <span class="hljs-keyword">if</span> (value) {
          dom.setStyle(previewElm, name, value);
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-960">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-960">&#182;</a>
              </div>
              <p>Add attributes to preview element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      each(format.attributes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, name</span>) </span>{
        value = removeVars(value);

        <span class="hljs-keyword">if</span> (value) {
          dom.setAttrib(previewElm, name, value);
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-961">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-961">&#182;</a>
              </div>
              <p>Add classes to preview element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      each(format.classes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        value = removeVars(value);

        <span class="hljs-keyword">if</span> (!dom.hasClass(previewElm, value)) {
          dom.addClass(previewElm, value);
        }
      });

      editor.fire(<span class="hljs-string">'PreviewFormats'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-962">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-962">&#182;</a>
              </div>
              <p>Add the previewElm outside the visual area</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      dom.setStyles(previewFrag, { <span class="hljs-attr">position</span>: <span class="hljs-string">'absolute'</span>, <span class="hljs-attr">left</span>: <span class="hljs-number">-0xFFFF</span> });
      editor.getBody().appendChild(previewFrag);</pre></div></div>
            
        </li>
        
        
        <li id="section-963">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-963">&#182;</a>
              </div>
              <p>Get parent container font size so we can compute px values out of em/% for older IE:s</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      parentFontSize = dom.getStyle(editor.getBody(), <span class="hljs-string">'fontSize'</span>, <span class="hljs-literal">true</span>);
      parentFontSize = <span class="hljs-regexp">/px$/</span>.test(parentFontSize) ? <span class="hljs-built_in">parseInt</span>(parentFontSize, <span class="hljs-number">10</span>) : <span class="hljs-number">0</span>;

      each(previewStyles.split(<span class="hljs-string">' '</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">var</span> value = dom.getStyle(previewElm, name, <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-964">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-964">&#182;</a>
              </div>
              <p>If background is transparent then check if the body has a background color we can use</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">'background-color'</span> &amp;&amp; <span class="hljs-regexp">/transparent|rgba\s*\([^)]+,\s*0\)/</span>.test(value)) {
          value = dom.getStyle(editor.getBody(), name, <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-965">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-965">&#182;</a>
              </div>
              <p>Ignore white since its the default color, not the nicest fix
TODO: Fix this by detecting runtime style</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (dom.toHex(value).toLowerCase() == <span class="hljs-string">'#ffffff'</span>) {
            <span class="hljs-keyword">return</span>;
          }
        }

        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">'color'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-966">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-966">&#182;</a>
              </div>
              <p>Ignore black since its the default color, not the nicest fix
TODO: Fix this by detecting runtime style</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (dom.toHex(value).toLowerCase() == <span class="hljs-string">'#000000'</span>) {
            <span class="hljs-keyword">return</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-967">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-967">&#182;</a>
              </div>
              <p>Old IE wont calculate the font size so we need to do that manually</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">'font-size'</span>) {
          <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/em|%$/</span>.test(value)) {
            <span class="hljs-keyword">if</span> (parentFontSize === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-968">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-968">&#182;</a>
              </div>
              <p>Convert font size from em/% to px</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            value = <span class="hljs-built_in">parseFloat</span>(value, <span class="hljs-number">10</span>) / (<span class="hljs-regexp">/%$/</span>.test(value) ? <span class="hljs-number">100</span> : <span class="hljs-number">1</span>);
            value = (value * parentFontSize) + <span class="hljs-string">'px'</span>;
          }
        }

        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">"border"</span> &amp;&amp; value) {
          previewCss += <span class="hljs-string">'padding:0 2px;'</span>;
        }

        previewCss += name + <span class="hljs-string">':'</span> + value + <span class="hljs-string">';'</span>;
      });

      editor.fire(<span class="hljs-string">'AfterPreviewFormats'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-969">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-969">&#182;</a>
              </div>
              <p>previewCss += line-height:normal;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      dom.remove(previewFrag);

      <span class="hljs-keyword">return</span> previewCss;
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">getCssText</span>: getCssText,
      <span class="hljs-attr">parseSelector</span>: parseSelector,
      <span class="hljs-attr">selectorToHtml</span>: selectorToHtml
    };
  }
);

<span class="hljs-comment">/**
 * Hooks.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Internal class for overriding formatting.
 *
 * @private
 * @class tinymce.fmt.Hooks
 */</span>
define(
  <span class="hljs-string">'tinymce.core.fmt.Hooks'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Arr"</span>,
    <span class="hljs-string">"tinymce.core.dom.NodeType"</span>,
    <span class="hljs-string">"tinymce.core.dom.DomQuery"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, NodeType, $</span>) </span>{
    <span class="hljs-keyword">var</span> postProcessHooks = {}, filter = Arr.filter, each = Arr.each;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addPostProcessHook</span>(<span class="hljs-params">name, hook</span>) </span>{
      <span class="hljs-keyword">var</span> hooks = postProcessHooks[name];

      <span class="hljs-keyword">if</span> (!hooks) {
        postProcessHooks[name] = hooks = [];
      }

      postProcessHooks[name].push(hook);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postProcess</span>(<span class="hljs-params">name, editor</span>) </span>{
      each(postProcessHooks[name], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hook</span>) </span>{
        hook(editor);
      });
    }

    addPostProcessHook(<span class="hljs-string">"pre"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> rng = editor.selection.getRng(), isPre, blocks;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasPreSibling</span>(<span class="hljs-params">pre</span>) </span>{
        <span class="hljs-keyword">return</span> isPre(pre.previousSibling) &amp;&amp; Arr.indexOf(blocks, pre.previousSibling) != <span class="hljs-number">-1</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">joinPre</span>(<span class="hljs-params">pre1, pre2</span>) </span>{
        $(pre2).remove();
        $(pre1).append(<span class="hljs-string">'&lt;br&gt;&lt;br&gt;'</span>).append(pre2.childNodes);
      }

      isPre = NodeType.matchNodeNames(<span class="hljs-string">'pre'</span>);

      <span class="hljs-keyword">if</span> (!rng.collapsed) {
        blocks = editor.selection.getSelectedBlocks();

        each(filter(filter(blocks, isPre), hasPreSibling), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pre</span>) </span>{
          joinPre(pre.previousSibling, pre);
        });
      }
    });

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">postProcess</span>: postProcess
    };
  }
);

<span class="hljs-comment">/**
 * Formatter.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Text formatter engine class. This class is used to apply formats like bold, italic, font size
 * etc to the current selection or specific nodes. This engine was built to replace the browser's
 * default formatting logic for execCommand due to its inconsistent and buggy behavior.
 *
 * @class tinymce.Formatter
 * @example
 *  tinymce.activeEditor.formatter.register('mycustomformat', {
 *    inline: 'span',
 *    styles: {color: '#ff0000'}
 *  });
 *
 *  tinymce.activeEditor.formatter.apply('mycustomformat');
 */</span>
define(
  <span class="hljs-string">'tinymce.core.Formatter'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.TreeWalker"</span>,
    <span class="hljs-string">"tinymce.core.dom.RangeUtils"</span>,
    <span class="hljs-string">"tinymce.core.dom.BookmarkManager"</span>,
    <span class="hljs-string">"tinymce.core.dom.ElementUtils"</span>,
    <span class="hljs-string">"tinymce.core.dom.NodeType"</span>,
    <span class="hljs-string">"tinymce.core.util.Fun"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.fmt.Preview"</span>,
    <span class="hljs-string">"tinymce.core.fmt.Hooks"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">TreeWalker, RangeUtils, BookmarkManager, ElementUtils, NodeType, Fun, Tools, Preview, Hooks</span>) </span>{
    <span class="hljs-comment">/**
     * Constructs a new formatter instance.
     *
     * @constructor Formatter
     * @param {tinymce.Editor} ed Editor instance to construct the formatter engine to.
     */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ed</span>) </span>{
      <span class="hljs-keyword">var</span> formats = {},
        dom = ed.dom,
        selection = ed.selection,
        rangeUtils = <span class="hljs-keyword">new</span> RangeUtils(dom),
        isValid = ed.schema.isValidChild,
        isBlock = dom.isBlock,
        forcedRootBlock = ed.settings.forced_root_block,
        nodeIndex = dom.nodeIndex,
        INVISIBLE_CHAR = <span class="hljs-string">'\uFEFF'</span>,
        MCE_ATTR_RE = <span class="hljs-regexp">/^(src|href|style)$/</span>,
        FALSE = <span class="hljs-literal">false</span>,
        TRUE = <span class="hljs-literal">true</span>,
        formatChangeData,
        undef,
        getContentEditable = dom.getContentEditable,
        disableCaretContainer,
        markCaretContainersBogus,
        isBookmarkNode = BookmarkManager.isBookmarkNode;

      <span class="hljs-keyword">var</span> each = Tools.each,
        grep = Tools.grep,
        walk = Tools.walk,
        extend = Tools.extend;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTextBlock</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">if</span> (name.nodeType) {
          name = name.nodeName;
        }

        <span class="hljs-keyword">return</span> !!ed.schema.getTextBlockElements()[name.toLowerCase()];
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTableCell</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^(TH|TD)$/</span>.test(node.nodeName);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isInlineBlock</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> node &amp;&amp; <span class="hljs-regexp">/^(IMG)$/</span>.test(node.nodeName);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParents</span>(<span class="hljs-params">node, selector</span>) </span>{
        <span class="hljs-keyword">return</span> dom.getParents(node, selector, dom.getRoot());
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCaretNode</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> node.nodeType === <span class="hljs-number">1</span> &amp;&amp; node.id === <span class="hljs-string">'_mce_caret'</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultFormats</span>(<span class="hljs-params"></span>) </span>{
        register({
          <span class="hljs-attr">valigntop</span>: [
            { <span class="hljs-attr">selector</span>: <span class="hljs-string">'td,th'</span>, <span class="hljs-attr">styles</span>: { <span class="hljs-string">'verticalAlign'</span>: <span class="hljs-string">'top'</span> } }
          ],

          <span class="hljs-attr">valignmiddle</span>: [
            { <span class="hljs-attr">selector</span>: <span class="hljs-string">'td,th'</span>, <span class="hljs-attr">styles</span>: { <span class="hljs-string">'verticalAlign'</span>: <span class="hljs-string">'middle'</span> } }
          ],

          <span class="hljs-attr">valignbottom</span>: [
            { <span class="hljs-attr">selector</span>: <span class="hljs-string">'td,th'</span>, <span class="hljs-attr">styles</span>: { <span class="hljs-string">'verticalAlign'</span>: <span class="hljs-string">'bottom'</span> } }
          ],

          <span class="hljs-attr">alignleft</span>: [
            {
              <span class="hljs-attr">selector</span>: <span class="hljs-string">'figure.image'</span>,
              <span class="hljs-attr">collapsed</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">classes</span>: <span class="hljs-string">'align-left'</span>,
              <span class="hljs-attr">ceFalseOverride</span>: <span class="hljs-literal">true</span>,
              <span class="hljs-attr">preview</span>: <span class="hljs-string">'font-family font-size'</span>
            },
            {
              <span class="hljs-attr">selector</span>: <span class="hljs-string">'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li'</span>,
              <span class="hljs-attr">styles</span>: {
                <span class="hljs-attr">textAlign</span>: <span class="hljs-string">'left'</span>
              },
              <span class="hljs-attr">inherit</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">preview</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">defaultBlock</span>: <span class="hljs-string">'div'</span>
            },
            { <span class="hljs-attr">selector</span>: <span class="hljs-string">'img,table'</span>, <span class="hljs-attr">collapsed</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">styles</span>: { <span class="hljs-string">'float'</span>: <span class="hljs-string">'left'</span> }, <span class="hljs-attr">preview</span>: <span class="hljs-string">'font-family font-size'</span> }
          ],

          <span class="hljs-attr">aligncenter</span>: [
            {
              <span class="hljs-attr">selector</span>: <span class="hljs-string">'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li'</span>,
              <span class="hljs-attr">styles</span>: {
                <span class="hljs-attr">textAlign</span>: <span class="hljs-string">'center'</span>
              },
              <span class="hljs-attr">inherit</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">preview</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">defaultBlock</span>: <span class="hljs-string">'div'</span>
            },
            {
              <span class="hljs-attr">selector</span>: <span class="hljs-string">'figure.image'</span>,
              <span class="hljs-attr">collapsed</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">classes</span>: <span class="hljs-string">'align-center'</span>,
              <span class="hljs-attr">ceFalseOverride</span>: <span class="hljs-literal">true</span>,
              <span class="hljs-attr">preview</span>: <span class="hljs-string">'font-family font-size'</span>
            },
            {
              <span class="hljs-attr">selector</span>: <span class="hljs-string">'img'</span>,
              <span class="hljs-attr">collapsed</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">styles</span>: {
                <span class="hljs-attr">display</span>: <span class="hljs-string">'block'</span>,
                <span class="hljs-attr">marginLeft</span>: <span class="hljs-string">'auto'</span>,
                <span class="hljs-attr">marginRight</span>: <span class="hljs-string">'auto'</span>
              },
              <span class="hljs-attr">preview</span>: <span class="hljs-literal">false</span>
            },
            {
              <span class="hljs-attr">selector</span>: <span class="hljs-string">'table'</span>,
              <span class="hljs-attr">collapsed</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">styles</span>: {
                <span class="hljs-attr">marginLeft</span>: <span class="hljs-string">'auto'</span>,
                <span class="hljs-attr">marginRight</span>: <span class="hljs-string">'auto'</span>
              },
              <span class="hljs-attr">preview</span>: <span class="hljs-string">'font-family font-size'</span>
            }
          ],

          <span class="hljs-attr">alignright</span>: [
            {
              <span class="hljs-attr">selector</span>: <span class="hljs-string">'figure.image'</span>,
              <span class="hljs-attr">collapsed</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">classes</span>: <span class="hljs-string">'align-right'</span>,
              <span class="hljs-attr">ceFalseOverride</span>: <span class="hljs-literal">true</span>,
              <span class="hljs-attr">preview</span>: <span class="hljs-string">'font-family font-size'</span>
            },
            {
              <span class="hljs-attr">selector</span>: <span class="hljs-string">'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li'</span>,
              <span class="hljs-attr">styles</span>: {
                <span class="hljs-attr">textAlign</span>: <span class="hljs-string">'right'</span>
              },
              <span class="hljs-attr">inherit</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">preview</span>: <span class="hljs-string">'font-family font-size'</span>,
              <span class="hljs-attr">defaultBlock</span>: <span class="hljs-string">'div'</span>
            },
            {
              <span class="hljs-attr">selector</span>: <span class="hljs-string">'img,table'</span>,
              <span class="hljs-attr">collapsed</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">styles</span>: {
                <span class="hljs-string">'float'</span>: <span class="hljs-string">'right'</span>
              },
              <span class="hljs-attr">preview</span>: <span class="hljs-string">'font-family font-size'</span>
            }
          ],

          <span class="hljs-attr">alignjustify</span>: [
            {
              <span class="hljs-attr">selector</span>: <span class="hljs-string">'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li'</span>,
              <span class="hljs-attr">styles</span>: {
                <span class="hljs-attr">textAlign</span>: <span class="hljs-string">'justify'</span>
              },
              <span class="hljs-attr">inherit</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">defaultBlock</span>: <span class="hljs-string">'div'</span>,
              <span class="hljs-attr">preview</span>: <span class="hljs-string">'font-family font-size'</span>
            }
          ],

          <span class="hljs-attr">bold</span>: [
            { <span class="hljs-attr">inline</span>: <span class="hljs-string">'strong'</span>, <span class="hljs-attr">remove</span>: <span class="hljs-string">'all'</span> },
            { <span class="hljs-attr">inline</span>: <span class="hljs-string">'span'</span>, <span class="hljs-attr">styles</span>: { <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">'bold'</span> } },
            { <span class="hljs-attr">inline</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">remove</span>: <span class="hljs-string">'all'</span> }
          ],

          <span class="hljs-attr">italic</span>: [
            { <span class="hljs-attr">inline</span>: <span class="hljs-string">'em'</span>, <span class="hljs-attr">remove</span>: <span class="hljs-string">'all'</span> },
            { <span class="hljs-attr">inline</span>: <span class="hljs-string">'span'</span>, <span class="hljs-attr">styles</span>: { <span class="hljs-attr">fontStyle</span>: <span class="hljs-string">'italic'</span> } },
            { <span class="hljs-attr">inline</span>: <span class="hljs-string">'i'</span>, <span class="hljs-attr">remove</span>: <span class="hljs-string">'all'</span> }
          ],

          <span class="hljs-attr">underline</span>: [
            { <span class="hljs-attr">inline</span>: <span class="hljs-string">'span'</span>, <span class="hljs-attr">styles</span>: { <span class="hljs-attr">textDecoration</span>: <span class="hljs-string">'underline'</span> }, <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span> },
            { <span class="hljs-attr">inline</span>: <span class="hljs-string">'u'</span>, <span class="hljs-attr">remove</span>: <span class="hljs-string">'all'</span> }
          ],

          <span class="hljs-attr">strikethrough</span>: [
            { <span class="hljs-attr">inline</span>: <span class="hljs-string">'span'</span>, <span class="hljs-attr">styles</span>: { <span class="hljs-attr">textDecoration</span>: <span class="hljs-string">'line-through'</span> }, <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span> },
            { <span class="hljs-attr">inline</span>: <span class="hljs-string">'strike'</span>, <span class="hljs-attr">remove</span>: <span class="hljs-string">'all'</span> }
          ],

          <span class="hljs-attr">forecolor</span>: { <span class="hljs-attr">inline</span>: <span class="hljs-string">'span'</span>, <span class="hljs-attr">styles</span>: { <span class="hljs-attr">color</span>: <span class="hljs-string">'%value'</span> }, <span class="hljs-attr">links</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">remove_similar</span>: <span class="hljs-literal">true</span> },
          <span class="hljs-attr">hilitecolor</span>: { <span class="hljs-attr">inline</span>: <span class="hljs-string">'span'</span>, <span class="hljs-attr">styles</span>: { <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'%value'</span> }, <span class="hljs-attr">links</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">remove_similar</span>: <span class="hljs-literal">true</span> },
          <span class="hljs-attr">fontname</span>: { <span class="hljs-attr">inline</span>: <span class="hljs-string">'span'</span>, <span class="hljs-attr">styles</span>: { <span class="hljs-attr">fontFamily</span>: <span class="hljs-string">'%value'</span> } },
          <span class="hljs-attr">fontsize</span>: { <span class="hljs-attr">inline</span>: <span class="hljs-string">'span'</span>, <span class="hljs-attr">styles</span>: { <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'%value'</span> } },
          <span class="hljs-attr">fontsize_class</span>: { <span class="hljs-attr">inline</span>: <span class="hljs-string">'span'</span>, <span class="hljs-attr">attributes</span>: { <span class="hljs-string">'class'</span>: <span class="hljs-string">'%value'</span> } },
          <span class="hljs-attr">blockquote</span>: { <span class="hljs-attr">block</span>: <span class="hljs-string">'blockquote'</span>, <span class="hljs-attr">wrapper</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">remove</span>: <span class="hljs-string">'all'</span> },
          <span class="hljs-attr">subscript</span>: { <span class="hljs-attr">inline</span>: <span class="hljs-string">'sub'</span> },
          <span class="hljs-attr">superscript</span>: { <span class="hljs-attr">inline</span>: <span class="hljs-string">'sup'</span> },
          <span class="hljs-attr">code</span>: { <span class="hljs-attr">inline</span>: <span class="hljs-string">'code'</span> },

          <span class="hljs-attr">link</span>: {
            <span class="hljs-attr">inline</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">selector</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">remove</span>: <span class="hljs-string">'all'</span>, <span class="hljs-attr">split</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">onmatch</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            },

            <span class="hljs-attr">onformat</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, fmt, vars</span>) </span>{
              each(vars, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, key</span>) </span>{
                dom.setAttrib(elm, key, value);
              });
            }
          },

          <span class="hljs-attr">removeformat</span>: [
            {
              <span class="hljs-attr">selector</span>: <span class="hljs-string">'b,strong,em,i,font,u,strike,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins'</span>,
              <span class="hljs-attr">remove</span>: <span class="hljs-string">'all'</span>,
              <span class="hljs-attr">split</span>: <span class="hljs-literal">true</span>,
              <span class="hljs-attr">expand</span>: <span class="hljs-literal">false</span>,
              <span class="hljs-attr">block_expand</span>: <span class="hljs-literal">true</span>,
              <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>
            },
            { <span class="hljs-attr">selector</span>: <span class="hljs-string">'span'</span>, <span class="hljs-attr">attributes</span>: [<span class="hljs-string">'style'</span>, <span class="hljs-string">'class'</span>], <span class="hljs-attr">remove</span>: <span class="hljs-string">'empty'</span>, <span class="hljs-attr">split</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">expand</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> },
            { <span class="hljs-attr">selector</span>: <span class="hljs-string">'*'</span>, <span class="hljs-attr">attributes</span>: [<span class="hljs-string">'style'</span>, <span class="hljs-string">'class'</span>], <span class="hljs-attr">split</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">expand</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> }
          ]
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-970">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-970">&#182;</a>
              </div>
              <p>Register default block formats</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        each(<span class="hljs-string">'p h1 h2 h3 h4 h5 h6 div address pre div dt dd samp'</span>.split(<span class="hljs-regexp">/\s/</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          register(name, { <span class="hljs-attr">block</span>: name, <span class="hljs-attr">remove</span>: <span class="hljs-string">'all'</span> });
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-971">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-971">&#182;</a>
              </div>
              <p>Register user defined formats</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        register(ed.settings.formats);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addKeyboardShortcuts</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-972">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-972">&#182;</a>
              </div>
              <p>Add some inline shortcuts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        ed.addShortcut(<span class="hljs-string">'meta+b'</span>, <span class="hljs-string">'bold_desc'</span>, <span class="hljs-string">'Bold'</span>);
        ed.addShortcut(<span class="hljs-string">'meta+i'</span>, <span class="hljs-string">'italic_desc'</span>, <span class="hljs-string">'Italic'</span>);
        ed.addShortcut(<span class="hljs-string">'meta+u'</span>, <span class="hljs-string">'underline_desc'</span>, <span class="hljs-string">'Underline'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-973">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-973">&#182;</a>
              </div>
              <p>BlockFormat shortcuts keys</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) {
          ed.addShortcut(<span class="hljs-string">'access+'</span> + i, <span class="hljs-string">''</span>, [<span class="hljs-string">'FormatBlock'</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">'h'</span> + i]);
        }

        ed.addShortcut(<span class="hljs-string">'access+7'</span>, <span class="hljs-string">''</span>, [<span class="hljs-string">'FormatBlock'</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">'p'</span>]);
        ed.addShortcut(<span class="hljs-string">'access+8'</span>, <span class="hljs-string">''</span>, [<span class="hljs-string">'FormatBlock'</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">'div'</span>]);
        ed.addShortcut(<span class="hljs-string">'access+9'</span>, <span class="hljs-string">''</span>, [<span class="hljs-string">'FormatBlock'</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">'address'</span>]);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-974">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-974">&#182;</a>
              </div>
              <p>Public functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Returns the format by name or all formats if no name is specified.
       *
       * @method get
       * @param {String} name Optional name to retrieve by.
       * @return {Array/Object} Array/Object with all registered formats or a specific format.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> name ? formats[name] : formats;
      }

      <span class="hljs-comment">/**
       * Registers a specific format by name.
       *
       * @method register
       * @param {Object/String} name Name of the format for example "bold".
       * @param {Object/Array} format Optional format object or array of format variants
       * can only be omitted if the first arg is an object.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span>(<span class="hljs-params">name, format</span>) </span>{
        <span class="hljs-keyword">if</span> (name) {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name !== <span class="hljs-string">'string'</span>) {
            each(name, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">format, name</span>) </span>{
              register(name, format);
            });
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-975">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-975">&#182;</a>
              </div>
              <p>Force format into array and add it to internal collection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            format = format.length ? format : [format];

            each(format, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">format</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-976">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-976">&#182;</a>
              </div>
              <p>Set deep to false by default on selector formats this to avoid removing
alignment on images inside paragraphs when alignment is changed on paragraphs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (format.deep === undef) {
                format.deep = !format.selector;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-977">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-977">&#182;</a>
              </div>
              <p>Default to true</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (format.split === undef) {
                format.split = !format.selector || format.inline;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-978">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-978">&#182;</a>
              </div>
              <p>Default to true</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (format.remove === undef &amp;&amp; format.selector &amp;&amp; !format.inline) {
                format.remove = <span class="hljs-string">'none'</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-979">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-979">&#182;</a>
              </div>
              <p>Mark format as a mixed format inline + block level</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (format.selector &amp;&amp; format.inline) {
                format.mixed = <span class="hljs-literal">true</span>;
                format.block_expand = <span class="hljs-literal">true</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-980">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-980">&#182;</a>
              </div>
              <p>Split classes if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> format.classes === <span class="hljs-string">'string'</span>) {
                format.classes = format.classes.split(<span class="hljs-regexp">/\s+/</span>);
              }
            });

            formats[name] = format;
          }
        }
      }

      <span class="hljs-comment">/**
       * Unregister a specific format by name.
       *
       * @method unregister
       * @param {String} name Name of the format for example "bold".
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unregister</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">if</span> (name &amp;&amp; formats[name]) {
          <span class="hljs-keyword">delete</span> formats[name];
        }

        <span class="hljs-keyword">return</span> formats;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchesUnInheritedFormatSelector</span>(<span class="hljs-params">node, name</span>) </span>{
        <span class="hljs-keyword">var</span> formatList = get(name);

        <span class="hljs-keyword">if</span> (formatList) {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; formatList.length; i++) {
            <span class="hljs-keyword">if</span> (formatList[i].inherit === <span class="hljs-literal">false</span> &amp;&amp; dom.is(node, formatList[i].selector)) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTextDecoration</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> decoration;

        ed.dom.getParent(node, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>{
          decoration = ed.dom.getStyle(n, <span class="hljs-string">'text-decoration'</span>);
          <span class="hljs-keyword">return</span> decoration &amp;&amp; decoration !== <span class="hljs-string">'none'</span>;
        });

        <span class="hljs-keyword">return</span> decoration;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processUnderlineAndColor</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> textDecoration;
        <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span> &amp;&amp; node.parentNode &amp;&amp; node.parentNode.nodeType === <span class="hljs-number">1</span>) {
          textDecoration = getTextDecoration(node.parentNode);
          <span class="hljs-keyword">if</span> (ed.dom.getStyle(node, <span class="hljs-string">'color'</span>) &amp;&amp; textDecoration) {
            ed.dom.setStyle(node, <span class="hljs-string">'text-decoration'</span>, textDecoration);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ed.dom.getStyle(node, <span class="hljs-string">'text-decoration'</span>) === textDecoration) {
            ed.dom.setStyle(node, <span class="hljs-string">'text-decoration'</span>, <span class="hljs-literal">null</span>);
          }
        }
      }

      <span class="hljs-comment">/**
       * Applies the specified format to the current selection or specified node.
       *
       * @method apply
       * @param {String} name Name of format to apply.
       * @param {Object} vars Optional list of variables to replace within format before applying it.
       * @param {Node} node Optional node to apply the format to defaults to current selection.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">apply</span>(<span class="hljs-params">name, vars, node</span>) </span>{
        <span class="hljs-keyword">var</span> formatList = get(name), format = formatList[<span class="hljs-number">0</span>], bookmark, rng, isCollapsed = !node &amp;&amp; selection.isCollapsed();

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setElementFormat</span>(<span class="hljs-params">elm, fmt</span>) </span>{
          fmt = fmt || format;

          <span class="hljs-keyword">if</span> (elm) {
            <span class="hljs-keyword">if</span> (fmt.onformat) {
              fmt.onformat(elm, fmt, vars, node);
            }

            each(fmt.styles, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, name</span>) </span>{
              dom.setStyle(elm, name, replaceVars(value, vars));
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-981">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-981">&#182;</a>
              </div>
              <p>Needed for the WebKit span spam bug
TODO: Remove this once WebKit/Blink fixes this</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (fmt.styles) {
              <span class="hljs-keyword">var</span> styleVal = dom.getAttrib(elm, <span class="hljs-string">'style'</span>);

              <span class="hljs-keyword">if</span> (styleVal) {
                elm.setAttribute(<span class="hljs-string">'data-mce-style'</span>, styleVal);
              }
            }

            each(fmt.attributes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, name</span>) </span>{
              dom.setAttrib(elm, name, replaceVars(value, vars));
            });

            each(fmt.classes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
              value = replaceVars(value, vars);

              <span class="hljs-keyword">if</span> (!dom.hasClass(elm, value)) {
                dom.addClass(elm, value);
              }
            });
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyNodeStyle</span>(<span class="hljs-params">formatList, node</span>) </span>{
          <span class="hljs-keyword">var</span> found = <span class="hljs-literal">false</span>;

          <span class="hljs-keyword">if</span> (!format.selector) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-982">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-982">&#182;</a>
              </div>
              <p>Look for matching formats</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          each(formatList, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">format</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-983">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-983">&#182;</a>
              </div>
              <p>Check collapsed state if it exists</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-string">'collapsed'</span> <span class="hljs-keyword">in</span> format &amp;&amp; format.collapsed !== isCollapsed) {
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (dom.is(node, format.selector) &amp;&amp; !isCaretNode(node)) {
              setElementFormat(node, format);
              found = <span class="hljs-literal">true</span>;
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          });

          <span class="hljs-keyword">return</span> found;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-984">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-984">&#182;</a>
              </div>
              <p>This converts: <p>[a</p><p>]b</p> -&gt; <p>[a]</p><p>b</p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adjustSelectionToVisibleSelection</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSelectionEnd</span>(<span class="hljs-params">start, end</span>) </span>{
            <span class="hljs-keyword">var</span> walker = <span class="hljs-keyword">new</span> TreeWalker(end);
            <span class="hljs-keyword">for</span> (node = walker.prev2(); node; node = walker.prev2()) {
              <span class="hljs-keyword">if</span> (node.nodeType == <span class="hljs-number">3</span> &amp;&amp; node.data.length &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">return</span> node;
              }

              <span class="hljs-keyword">if</span> (node.childNodes.length &gt; <span class="hljs-number">1</span> || node == start || node.tagName == <span class="hljs-string">'BR'</span>) {
                <span class="hljs-keyword">return</span> node;
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-985">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-985">&#182;</a>
              </div>
              <p>Adjust selection so that a end container with a end offset of zero is not included in the selection
as this isnt visible to the user.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> rng = ed.selection.getRng();
          <span class="hljs-keyword">var</span> start = rng.startContainer;
          <span class="hljs-keyword">var</span> end = rng.endContainer;

          <span class="hljs-keyword">if</span> (start != end &amp;&amp; rng.endOffset === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">var</span> newEnd = findSelectionEnd(start, end);
            <span class="hljs-keyword">var</span> endOffset = newEnd.nodeType == <span class="hljs-number">3</span> ? newEnd.data.length : newEnd.childNodes.length;

            rng.setEnd(newEnd, endOffset);
          }

          <span class="hljs-keyword">return</span> rng;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyRngStyle</span>(<span class="hljs-params">rng, bookmark, nodeSpecific</span>) </span>{
          <span class="hljs-keyword">var</span> newWrappers = [], wrapName, wrapElm, contentEditable = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-986">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-986">&#182;</a>
              </div>
              <p>Setup wrapper element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          wrapName = format.inline || format.block;
          wrapElm = dom.create(wrapName);
          setElementFormat(wrapElm);

          rangeUtils.walk(rng, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
            <span class="hljs-keyword">var</span> currentWrapElm;

            <span class="hljs-comment">/**
             * Process a list of nodes wrap them.
             */</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">process</span>(<span class="hljs-params">node</span>) </span>{
              <span class="hljs-keyword">var</span> nodeName, parentName, hasContentEditableState, lastContentEditable;

              lastContentEditable = contentEditable;
              nodeName = node.nodeName.toLowerCase();
              parentName = node.parentNode.nodeName.toLowerCase();</pre></div></div>
            
        </li>
        
        
        <li id="section-987">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-987">&#182;</a>
              </div>
              <p>Node has a contentEditable value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span> &amp;&amp; getContentEditable(node)) {
                lastContentEditable = contentEditable;
                contentEditable = getContentEditable(node) === <span class="hljs-string">"true"</span>;
                hasContentEditableState = <span class="hljs-literal">true</span>; <span class="hljs-comment">// We don't want to wrap the container only it's children</span>
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-988">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-988">&#182;</a>
              </div>
              <p>Stop wrapping on br elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (isEq(nodeName, <span class="hljs-string">'br'</span>)) {
                currentWrapElm = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-989">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-989">&#182;</a>
              </div>
              <p>Remove any br elements when we wrap things</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (format.block) {
                  dom.remove(node);
                }

                <span class="hljs-keyword">return</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-990">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-990">&#182;</a>
              </div>
              <p>If node is wrapper type</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (format.wrapper &amp;&amp; matchNode(node, name, vars)) {
                currentWrapElm = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">return</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-991">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-991">&#182;</a>
              </div>
              <p>Can we rename the block
TODO: Break this if up, too complex</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (contentEditable &amp;&amp; !hasContentEditableState &amp;&amp; format.block &amp;&amp;
                !format.wrapper &amp;&amp; isTextBlock(nodeName) &amp;&amp; isValid(parentName, wrapName)) {
                node = dom.rename(node, wrapName);
                setElementFormat(node);
                newWrappers.push(node);
                currentWrapElm = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">return</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-992">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-992">&#182;</a>
              </div>
              <p>Handle selector patterns</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (format.selector) {
                <span class="hljs-keyword">var</span> found = applyNodeStyle(formatList, node);</pre></div></div>
            
        </li>
        
        
        <li id="section-993">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-993">&#182;</a>
              </div>
              <p>Continue processing if a selector match wasnt found and a inline element is defined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (!format.inline || found) {
                  currentWrapElm = <span class="hljs-number">0</span>;
                  <span class="hljs-keyword">return</span>;
                }
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-994">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-994">&#182;</a>
              </div>
              <p>Is it valid to wrap this item
TODO: Break this if up, too complex</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (contentEditable &amp;&amp; !hasContentEditableState &amp;&amp; isValid(wrapName, nodeName) &amp;&amp; isValid(parentName, wrapName) &amp;&amp;
                !(!nodeSpecific &amp;&amp; node.nodeType === <span class="hljs-number">3</span> &amp;&amp;
                  node.nodeValue.length === <span class="hljs-number">1</span> &amp;&amp;
                  node.nodeValue.charCodeAt(<span class="hljs-number">0</span>) === <span class="hljs-number">65279</span>) &amp;&amp;
                !isCaretNode(node) &amp;&amp;
                (!format.inline || !isBlock(node))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-995">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-995">&#182;</a>
              </div>
              <p>Start wrapping</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (!currentWrapElm) {</pre></div></div>
            
        </li>
        
        
        <li id="section-996">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-996">&#182;</a>
              </div>
              <p>Wrap the node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  currentWrapElm = dom.clone(wrapElm, FALSE);
                  node.parentNode.insertBefore(currentWrapElm, node);
                  newWrappers.push(currentWrapElm);
                }

                currentWrapElm.appendChild(node);
              } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-997">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-997">&#182;</a>
              </div>
              <p>Start a new wrapper for possible children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                currentWrapElm = <span class="hljs-number">0</span>;

                each(grep(node.childNodes), process);

                <span class="hljs-keyword">if</span> (hasContentEditableState) {
                  contentEditable = lastContentEditable; <span class="hljs-comment">// Restore last contentEditable state from stack</span>
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-998">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-998">&#182;</a>
              </div>
              <p>End the last wrapper</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                currentWrapElm = <span class="hljs-number">0</span>;
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-999">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-999">&#182;</a>
              </div>
              <p>Process siblings from range</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            each(nodes, process);
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-1000">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1000">&#182;</a>
              </div>
              <p>Apply formats to links as well to get the color of the underline to change as well</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (format.links === <span class="hljs-literal">true</span>) {
            each(newWrappers, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
              <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">process</span>(<span class="hljs-params">node</span>) </span>{
                <span class="hljs-keyword">if</span> (node.nodeName === <span class="hljs-string">'A'</span>) {
                  setElementFormat(node, format);
                }

                each(grep(node.childNodes), process);
              }

              process(node);
            });
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1001">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1001">&#182;</a>
              </div>
              <p>Cleanup</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          each(newWrappers, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">var</span> childCount;

            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChildCount</span>(<span class="hljs-params">node</span>) </span>{
              <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;

              each(node.childNodes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
                <span class="hljs-keyword">if</span> (!isWhiteSpaceNode(node) &amp;&amp; !isBookmarkNode(node)) {
                  count++;
                }
              });

              <span class="hljs-keyword">return</span> count;
            }

            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChildElementNode</span>(<span class="hljs-params">root</span>) </span>{
              <span class="hljs-keyword">var</span> child = <span class="hljs-literal">false</span>;
              each(root.childNodes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
                <span class="hljs-keyword">if</span> (isElementNode(node)) {
                  child = node;
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// break loop</span>
                }
              });
              <span class="hljs-keyword">return</span> child;
            }

            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchNestedWrapper</span>(<span class="hljs-params">node, filter</span>) </span>{
              <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> (getChildCount(node) !== <span class="hljs-number">1</span>) {
                  <span class="hljs-keyword">break</span>;
                }

                node = getChildElementNode(node);
                <span class="hljs-keyword">if</span> (!node) {
                  <span class="hljs-keyword">break</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (filter(node)) {
                  <span class="hljs-keyword">return</span> node;
                }
              } <span class="hljs-keyword">while</span> (node);

              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }

            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeStyles</span>(<span class="hljs-params">node</span>) </span>{
              <span class="hljs-keyword">var</span> child, clone;

              child = getChildElementNode(node);</pre></div></div>
            
        </li>
        
        
        <li id="section-1002">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1002">&#182;</a>
              </div>
              <p>If child was found and of the same type as the current node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (child &amp;&amp; !isBookmarkNode(child) &amp;&amp; matchName(child, format)) {
                clone = dom.clone(child, FALSE);
                setElementFormat(clone);

                dom.replace(clone, node, TRUE);
                dom.remove(child, <span class="hljs-number">1</span>);
              }

              <span class="hljs-keyword">return</span> clone || node;
            }

            childCount = getChildCount(node);</pre></div></div>
            
        </li>
        
        
        <li id="section-1003">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1003">&#182;</a>
              </div>
              <p>Remove empty nodes but only if there is multiple wrappers and they are not block
elements so never remove single <h1></h1> since that would remove the
current empty block element where the caret is at</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ((newWrappers.length &gt; <span class="hljs-number">1</span> || !isBlock(node)) &amp;&amp; childCount === <span class="hljs-number">0</span>) {
              dom.remove(node, <span class="hljs-number">1</span>);
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (format.inline || format.wrapper) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1004">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1004">&#182;</a>
              </div>
              <p>Merges the current node with its children of similar type to reduce the number of elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (!format.exact &amp;&amp; childCount === <span class="hljs-number">1</span>) {
                node = mergeStyles(node);
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-1005">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1005">&#182;</a>
              </div>
              <p>Remove/merge children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              each(formatList, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">format</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1006">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1006">&#182;</a>
              </div>
              <p>Merge all children of similar type will move styles from child to parent
this: <span style="color:red"><b><span style="color:red; font-size:10px">text</span></b></span>
will become: <span style="color:red"><b><span style="font-size:10px">text</span></b></span></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                each(dom.select(format.inline, node), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) </span>{
                  <span class="hljs-keyword">if</span> (!isElementNode(child)) {
                    <span class="hljs-keyword">return</span>;
                  }

                  removeFormat(format, vars, child, format.exact ? child : <span class="hljs-literal">null</span>);
                });
              });</pre></div></div>
            
        </li>
        
        
        <li id="section-1007">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1007">&#182;</a>
              </div>
              <p>Remove format if direct parent already has the same format</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (matchNode(node.parentNode, name, vars)) {
                <span class="hljs-keyword">if</span> (removeFormat(format, vars, node)) {
                  node = <span class="hljs-number">0</span>;
                }
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-1008">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1008">&#182;</a>
              </div>
              <p>Remove format if any ancestor already has the same format</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (format.merge_with_parents) {
                dom.getParent(node.parentNode, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent</span>) </span>{
                  <span class="hljs-keyword">if</span> (matchNode(parent, name, vars)) {
                    <span class="hljs-keyword">if</span> (removeFormat(format, vars, node)) {
                      node = <span class="hljs-number">0</span>;
                    }
                    <span class="hljs-keyword">return</span> TRUE;
                  }
                });
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-1009">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1009">&#182;</a>
              </div>
              <p>fontSize defines the line height for the whole branch of nested style wrappers,
therefore it should be set on the outermost wrapper</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (node &amp;&amp; !isBlock(node) &amp;&amp; !getStyle(node, <span class="hljs-string">'fontSize'</span>)) {
                <span class="hljs-keyword">var</span> styleNode = matchNestedWrapper(node, hasStyle(<span class="hljs-string">'fontSize'</span>));
                <span class="hljs-keyword">if</span> (styleNode) {
                  apply(<span class="hljs-string">'fontsize'</span>, { <span class="hljs-attr">value</span>: getStyle(styleNode, <span class="hljs-string">'fontSize'</span>) }, node);
                }
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-1010">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1010">&#182;</a>
              </div>
              <p>Merge next and previous siblings if they are similar <b>text</b><b>text</b> becomes <b>texttext</b></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (node &amp;&amp; format.merge_siblings !== <span class="hljs-literal">false</span>) {
                node = mergeSiblings(getNonWhiteSpaceSibling(node), node);
                node = mergeSiblings(node, getNonWhiteSpaceSibling(node, TRUE));
              }
            }
          });
        }

        <span class="hljs-keyword">if</span> (getContentEditable(selection.getNode()) === <span class="hljs-string">"false"</span>) {
          node = selection.getNode();
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = formatList.length; i &lt; l; i++) {
            <span class="hljs-keyword">if</span> (formatList[i].ceFalseOverride &amp;&amp; dom.is(node, formatList[i].selector)) {
              setElementFormat(node, formatList[i]);
              <span class="hljs-keyword">return</span>;
            }
          }

          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (format) {
          <span class="hljs-keyword">if</span> (node) {
            <span class="hljs-keyword">if</span> (node.nodeType) {
              <span class="hljs-keyword">if</span> (!applyNodeStyle(formatList, node)) {
                rng = dom.createRng();
                rng.setStartBefore(node);
                rng.setEndAfter(node);
                applyRngStyle(expandRng(rng, formatList), <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
              }
            } <span class="hljs-keyword">else</span> {
              applyRngStyle(node, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (!isCollapsed || !format.inline || dom.select(<span class="hljs-string">'td[data-mce-selected],th[data-mce-selected]'</span>).length) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1011">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1011">&#182;</a>
              </div>
              <p>Obtain selection node before selection is unselected by applyRngStyle()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> curSelNode = ed.selection.getNode();</pre></div></div>
            
        </li>
        
        
        <li id="section-1012">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1012">&#182;</a>
              </div>
              <p>If the formats have a default block and we cant find a parent block then
start wrapping it with a DIV this is for forced_root_blocks: false
Its kind of a hack but people should be using the default block type P since all desktop editors work that way</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (!forcedRootBlock &amp;&amp; formatList[<span class="hljs-number">0</span>].defaultBlock &amp;&amp; !dom.getParent(curSelNode, dom.isBlock)) {
                apply(formatList[<span class="hljs-number">0</span>].defaultBlock);
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-1013">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1013">&#182;</a>
              </div>
              <p>Apply formatting to selection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              ed.selection.setRng(adjustSelectionToVisibleSelection());
              bookmark = selection.getBookmark();
              applyRngStyle(expandRng(selection.getRng(TRUE), formatList), bookmark);

              <span class="hljs-keyword">if</span> (format.styles) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1014">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1014">&#182;</a>
              </div>
              <p>Colored nodes should be underlined so that the color of the underline matches the text color.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (format.styles.color || format.styles.textDecoration) {
                  walk(curSelNode, processUnderlineAndColor, <span class="hljs-string">'childNodes'</span>);
                  processUnderlineAndColor(curSelNode);
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-1015">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1015">&#182;</a>
              </div>
              <p>nodes with font-size should have their own background color as well to fit the line-height (see TINY-882)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (format.styles.backgroundColor) {
                  processChildElements(curSelNode,
                    hasStyle(<span class="hljs-string">'fontSize'</span>),
                    applyStyle(<span class="hljs-string">'backgroundColor'</span>, replaceVars(format.styles.backgroundColor, vars))
                  );
                }
              }

              selection.moveToBookmark(bookmark);
              moveStart(selection.getRng(TRUE));
              ed.nodeChanged();
            } <span class="hljs-keyword">else</span> {
              performCaretAction(<span class="hljs-string">'apply'</span>, name, vars);
            }
          }

          Hooks.postProcess(name, ed);
        }
      }

      <span class="hljs-comment">/**
       * Removes the specified format from the current selection or specified node.
       *
       * @method remove
       * @param {String} name Name of format to remove.
       * @param {Object} vars Optional list of variables to replace within format before removing it.
       * @param {Node/Range} node Optional node or DOM range to remove the format from defaults to current selection.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span>(<span class="hljs-params">name, vars, node, similar</span>) </span>{
        <span class="hljs-keyword">var</span> formatList = get(name), format = formatList[<span class="hljs-number">0</span>], bookmark, rng, contentEditable = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1016">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1016">&#182;</a>
              </div>
              <p>Merges the styles for each node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">process</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> children, i, l, lastContentEditable, hasContentEditableState;</pre></div></div>
            
        </li>
        
        
        <li id="section-1017">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1017">&#182;</a>
              </div>
              <p>Node has a contentEditable value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span> &amp;&amp; getContentEditable(node)) {
            lastContentEditable = contentEditable;
            contentEditable = getContentEditable(node) === <span class="hljs-string">"true"</span>;
            hasContentEditableState = <span class="hljs-literal">true</span>; <span class="hljs-comment">// We don't want to wrap the container only it's children</span>
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1018">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1018">&#182;</a>
              </div>
              <p>Grab the children first since the nodelist might be changed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          children = grep(node.childNodes);</pre></div></div>
            
        </li>
        
        
        <li id="section-1019">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1019">&#182;</a>
              </div>
              <p>Process current node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (contentEditable &amp;&amp; !hasContentEditableState) {
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = formatList.length; i &lt; l; i++) {
              <span class="hljs-keyword">if</span> (removeFormat(formatList[i], vars, node, node)) {
                <span class="hljs-keyword">break</span>;
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1020">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1020">&#182;</a>
              </div>
              <p>Process the children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (format.deep) {
            <span class="hljs-keyword">if</span> (children.length) {
              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = children.length; i &lt; l; i++) {
                process(children[i]);
              }

              <span class="hljs-keyword">if</span> (hasContentEditableState) {
                contentEditable = lastContentEditable; <span class="hljs-comment">// Restore last contentEditable state from stack</span>
              }
            }
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFormatRoot</span>(<span class="hljs-params">container</span>) </span>{
          <span class="hljs-keyword">var</span> formatRoot;</pre></div></div>
            
        </li>
        
        
        <li id="section-1021">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1021">&#182;</a>
              </div>
              <p>Find format root</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          each(getParents(container.parentNode).reverse(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent</span>) </span>{
            <span class="hljs-keyword">var</span> format;</pre></div></div>
            
        </li>
        
        
        <li id="section-1022">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1022">&#182;</a>
              </div>
              <p>Find format root element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!formatRoot &amp;&amp; parent.id != <span class="hljs-string">'_start'</span> &amp;&amp; parent.id != <span class="hljs-string">'_end'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1023">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1023">&#182;</a>
              </div>
              <p>Is the node matching the format we are looking for</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              format = matchNode(parent, name, vars, similar);
              <span class="hljs-keyword">if</span> (format &amp;&amp; format.split !== <span class="hljs-literal">false</span>) {
                formatRoot = parent;
              }
            }
          });

          <span class="hljs-keyword">return</span> formatRoot;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapAndSplit</span>(<span class="hljs-params">formatRoot, container, target, split</span>) </span>{
          <span class="hljs-keyword">var</span> parent, clone, lastClone, firstClone, i, formatRootParent;</pre></div></div>
            
        </li>
        
        
        <li id="section-1024">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1024">&#182;</a>
              </div>
              <p>Format root found then clone formats and split it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (formatRoot) {
            formatRootParent = formatRoot.parentNode;

            <span class="hljs-keyword">for</span> (parent = container.parentNode; parent &amp;&amp; parent != formatRootParent; parent = parent.parentNode) {
              clone = dom.clone(parent, FALSE);

              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; formatList.length; i++) {
                <span class="hljs-keyword">if</span> (removeFormat(formatList[i], vars, clone, clone)) {
                  clone = <span class="hljs-number">0</span>;
                  <span class="hljs-keyword">break</span>;
                }
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-1025">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1025">&#182;</a>
              </div>
              <p>Build wrapper node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (clone) {
                <span class="hljs-keyword">if</span> (lastClone) {
                  clone.appendChild(lastClone);
                }

                <span class="hljs-keyword">if</span> (!firstClone) {
                  firstClone = clone;
                }

                lastClone = clone;
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1026">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1026">&#182;</a>
              </div>
              <p>Never split block elements if the format is mixed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (split &amp;&amp; (!format.mixed || !isBlock(formatRoot))) {
              container = dom.split(formatRoot, container);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1027">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1027">&#182;</a>
              </div>
              <p>Wrap container in cloned formats</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (lastClone) {
              target.parentNode.insertBefore(lastClone, target);
              firstClone.appendChild(target);
            }
          }

          <span class="hljs-keyword">return</span> container;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">splitToFormatRoot</span>(<span class="hljs-params">container</span>) </span>{
          <span class="hljs-keyword">return</span> wrapAndSplit(findFormatRoot(container), container, container, <span class="hljs-literal">true</span>);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unwrap</span>(<span class="hljs-params">start</span>) </span>{
          <span class="hljs-keyword">var</span> node = dom.get(start ? <span class="hljs-string">'_start'</span> : <span class="hljs-string">'_end'</span>),
            out = node[start ? <span class="hljs-string">'firstChild'</span> : <span class="hljs-string">'lastChild'</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-1028">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1028">&#182;</a>
              </div>
              <p>If the end is placed within the start the result will be removed
So this checks if the out node is a bookmark node if it is it
checks for another more suitable node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (isBookmarkNode(out)) {
            out = out[start ? <span class="hljs-string">'firstChild'</span> : <span class="hljs-string">'lastChild'</span>];
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1029">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1029">&#182;</a>
              </div>
              <p>Since dom.remove removes empty text nodes then we need to try to find a better node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (out.nodeType == <span class="hljs-number">3</span> &amp;&amp; out.data.length === <span class="hljs-number">0</span>) {
            out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;
          }

          dom.remove(node, <span class="hljs-literal">true</span>);

          <span class="hljs-keyword">return</span> out;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeRngStyle</span>(<span class="hljs-params">rng</span>) </span>{
          <span class="hljs-keyword">var</span> startContainer, endContainer;
          <span class="hljs-keyword">var</span> commonAncestorContainer = rng.commonAncestorContainer;

          rng = expandRng(rng, formatList, TRUE);

          <span class="hljs-keyword">if</span> (format.split) {
            startContainer = getContainer(rng, TRUE);
            endContainer = getContainer(rng);

            <span class="hljs-keyword">if</span> (startContainer != endContainer) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1030">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1030">&#182;</a>
              </div>
              <p>WebKit will render the table incorrectly if we wrap a TH or TD in a SPAN
so lets see if we can use the first child instead
This will happen if you triple click a table cell and use remove formatting</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(TR|TH|TD)$/</span>.test(startContainer.nodeName) &amp;&amp; startContainer.firstChild) {
                <span class="hljs-keyword">if</span> (startContainer.nodeName == <span class="hljs-string">"TR"</span>) {
                  startContainer = startContainer.firstChild.firstChild || startContainer;
                } <span class="hljs-keyword">else</span> {
                  startContainer = startContainer.firstChild || startContainer;
                }
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-1031">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1031">&#182;</a>
              </div>
              <p>Try to adjust endContainer as well if cells on the same row were selected - bug #6410</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (commonAncestorContainer &amp;&amp;
                <span class="hljs-regexp">/^T(HEAD|BODY|FOOT|R)$/</span>.test(commonAncestorContainer.nodeName) &amp;&amp;
                isTableCell(endContainer) &amp;&amp; endContainer.firstChild) {
                endContainer = endContainer.firstChild || endContainer;
              }

              <span class="hljs-keyword">if</span> (dom.isChildOf(startContainer, endContainer) &amp;&amp; !isBlock(endContainer) &amp;&amp;
                !isTableCell(startContainer) &amp;&amp; !isTableCell(endContainer)) {
                startContainer = wrap(startContainer, <span class="hljs-string">'span'</span>, { <span class="hljs-attr">id</span>: <span class="hljs-string">'_start'</span>, <span class="hljs-string">'data-mce-type'</span>: <span class="hljs-string">'bookmark'</span> });
                splitToFormatRoot(startContainer);
                startContainer = unwrap(TRUE);
                <span class="hljs-keyword">return</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-1032">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1032">&#182;</a>
              </div>
              <p>Wrap start/end nodes in span element since these might be cloned/moved</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              startContainer = wrap(startContainer, <span class="hljs-string">'span'</span>, { <span class="hljs-attr">id</span>: <span class="hljs-string">'_start'</span>, <span class="hljs-string">'data-mce-type'</span>: <span class="hljs-string">'bookmark'</span> });
              endContainer = wrap(endContainer, <span class="hljs-string">'span'</span>, { <span class="hljs-attr">id</span>: <span class="hljs-string">'_end'</span>, <span class="hljs-string">'data-mce-type'</span>: <span class="hljs-string">'bookmark'</span> });</pre></div></div>
            
        </li>
        
        
        <li id="section-1033">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1033">&#182;</a>
              </div>
              <p>Split start/end</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              splitToFormatRoot(startContainer);
              splitToFormatRoot(endContainer);</pre></div></div>
            
        </li>
        
        
        <li id="section-1034">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1034">&#182;</a>
              </div>
              <p>Unwrap start/end to get real elements again</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              startContainer = unwrap(TRUE);
              endContainer = unwrap();
            } <span class="hljs-keyword">else</span> {
              startContainer = endContainer = splitToFormatRoot(startContainer);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1035">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1035">&#182;</a>
              </div>
              <p>Update range positions since they might have changed after the split operations</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            rng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
            rng.startOffset = nodeIndex(startContainer);
            rng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
            rng.endOffset = nodeIndex(endContainer) + <span class="hljs-number">1</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1036">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1036">&#182;</a>
              </div>
              <p>Remove items between start/end</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          rangeUtils.walk(rng, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
            each(nodes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
              process(node);</pre></div></div>
            
        </li>
        
        
        <li id="section-1037">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1037">&#182;</a>
              </div>
              <p>Remove parent span if it only contains text-decoration: underline, yet a parent node is also underlined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span> &amp;&amp; ed.dom.getStyle(node, <span class="hljs-string">'text-decoration'</span>) === <span class="hljs-string">'underline'</span> &amp;&amp;
                node.parentNode &amp;&amp; getTextDecoration(node.parentNode) === <span class="hljs-string">'underline'</span>) {
                removeFormat({
                  <span class="hljs-string">'deep'</span>: <span class="hljs-literal">false</span>,
                  <span class="hljs-string">'exact'</span>: <span class="hljs-literal">true</span>,
                  <span class="hljs-string">'inline'</span>: <span class="hljs-string">'span'</span>,
                  <span class="hljs-string">'styles'</span>: {
                    <span class="hljs-string">'textDecoration'</span>: <span class="hljs-string">'underline'</span>
                  }
                }, <span class="hljs-literal">null</span>, node);
              }
            });
          });
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1038">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1038">&#182;</a>
              </div>
              <p>Handle node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (node) {
          <span class="hljs-keyword">if</span> (node.nodeType) {
            rng = dom.createRng();
            rng.setStartBefore(node);
            rng.setEndAfter(node);
            removeRngStyle(rng);
          } <span class="hljs-keyword">else</span> {
            removeRngStyle(node);
          }

          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (getContentEditable(selection.getNode()) === <span class="hljs-string">"false"</span>) {
          node = selection.getNode();
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = formatList.length; i &lt; l; i++) {
            <span class="hljs-keyword">if</span> (formatList[i].ceFalseOverride) {
              <span class="hljs-keyword">if</span> (removeFormat(formatList[i], vars, node, node)) {
                <span class="hljs-keyword">break</span>;
              }
            }
          }

          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (!selection.isCollapsed() || !format.inline || dom.select(<span class="hljs-string">'td[data-mce-selected],th[data-mce-selected]'</span>).length) {
          bookmark = selection.getBookmark();
          removeRngStyle(selection.getRng(TRUE));
          selection.moveToBookmark(bookmark);</pre></div></div>
            
        </li>
        
        
        <li id="section-1039">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1039">&#182;</a>
              </div>
              <p>Check if start element still has formatting then we are at: <b>text|</b>text
and need to move the start into the next text node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (format.inline &amp;&amp; match(name, vars, selection.getStart())) {
            moveStart(selection.getRng(<span class="hljs-literal">true</span>));
          }

          ed.nodeChanged();
        } <span class="hljs-keyword">else</span> {
          performCaretAction(<span class="hljs-string">'remove'</span>, name, vars, similar);
        }
      }

      <span class="hljs-comment">/**
       * Toggles the specified format on/off.
       *
       * @method toggle
       * @param {String} name Name of format to apply/remove.
       * @param {Object} vars Optional list of variables to replace within format before applying/removing it.
       * @param {Node} node Optional node to apply the format to or remove from. Defaults to current selection.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggle</span>(<span class="hljs-params">name, vars, node</span>) </span>{
        <span class="hljs-keyword">var</span> fmt = get(name);

        <span class="hljs-keyword">if</span> (match(name, vars, node) &amp;&amp; (!(<span class="hljs-string">'toggle'</span> <span class="hljs-keyword">in</span> fmt[<span class="hljs-number">0</span>]) || fmt[<span class="hljs-number">0</span>].toggle)) {
          remove(name, vars, node);
        } <span class="hljs-keyword">else</span> {
          apply(name, vars, node);
        }
      }

      <span class="hljs-comment">/**
       * Return true/false if the specified node has the specified format.
       *
       * @method matchNode
       * @param {Node} node Node to check the format on.
       * @param {String} name Format name to check.
       * @param {Object} vars Optional list of variables to replace before checking it.
       * @param {Boolean} similar Match format that has similar properties.
       * @return {Object} Returns the format object it matches or undefined if it doesn't match.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchNode</span>(<span class="hljs-params">node, name, vars, similar</span>) </span>{
        <span class="hljs-keyword">var</span> formatList = get(name), format, i, classes;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchItems</span>(<span class="hljs-params">node, format, itemName</span>) </span>{
          <span class="hljs-keyword">var</span> key, value, items = format[itemName], i;</pre></div></div>
            
        </li>
        
        
        <li id="section-1040">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1040">&#182;</a>
              </div>
              <p>Custom match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (format.onmatch) {
            <span class="hljs-keyword">return</span> format.onmatch(node, format, itemName);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1041">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1041">&#182;</a>
              </div>
              <p>Check all items</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (items) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1042">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1042">&#182;</a>
              </div>
              <p>Non indexed object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (items.length === undef) {
              <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> items) {
                <span class="hljs-keyword">if</span> (items.hasOwnProperty(key)) {
                  <span class="hljs-keyword">if</span> (itemName === <span class="hljs-string">'attributes'</span>) {
                    value = dom.getAttrib(node, key);
                  } <span class="hljs-keyword">else</span> {
                    value = getStyle(node, key);
                  }

                  <span class="hljs-keyword">if</span> (similar &amp;&amp; !value &amp;&amp; !format.exact) {
                    <span class="hljs-keyword">return</span>;
                  }

                  <span class="hljs-keyword">if</span> ((!similar || format.exact) &amp;&amp; !isEq(value, normalizeStyleValue(replaceVars(items[key], vars), key))) {
                    <span class="hljs-keyword">return</span>;
                  }
                }
              }
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1043">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1043">&#182;</a>
              </div>
              <p>Only one match needed for indexed arrays</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; items.length; i++) {
                <span class="hljs-keyword">if</span> (itemName === <span class="hljs-string">'attributes'</span> ? dom.getAttrib(node, items[i]) : getStyle(node, items[i])) {
                  <span class="hljs-keyword">return</span> format;
                }
              }
            }
          }

          <span class="hljs-keyword">return</span> format;
        }

        <span class="hljs-keyword">if</span> (formatList &amp;&amp; node) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1044">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1044">&#182;</a>
              </div>
              <p>Check each format in list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; formatList.length; i++) {
            format = formatList[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-1045">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1045">&#182;</a>
              </div>
              <p>Name name, attributes, styles and classes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (matchName(node, format) &amp;&amp; matchItems(node, format, <span class="hljs-string">'attributes'</span>) &amp;&amp; matchItems(node, format, <span class="hljs-string">'styles'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1046">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1046">&#182;</a>
              </div>
              <p>Match classes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> ((classes = format.classes)) {
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; classes.length; i++) {
                  <span class="hljs-keyword">if</span> (!dom.hasClass(node, classes[i])) {
                    <span class="hljs-keyword">return</span>;
                  }
                }
              }

              <span class="hljs-keyword">return</span> format;
            }
          }
        }
      }

      <span class="hljs-comment">/**
       * Matches the current selection or specified node against the specified format name.
       *
       * @method match
       * @param {String} name Name of format to match.
       * @param {Object} vars Optional list of variables to replace before checking it.
       * @param {Node} node Optional node to check.
       * @return {boolean} true/false if the specified selection/node matches the format.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">match</span>(<span class="hljs-params">name, vars, node</span>) </span>{
        <span class="hljs-keyword">var</span> startNode;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchParents</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> root = dom.getRoot();

          <span class="hljs-keyword">if</span> (node === root) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1047">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1047">&#182;</a>
              </div>
              <p>Find first node with similar format settings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          node = dom.getParent(node, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">if</span> (matchesUnInheritedFormatSelector(node, name)) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">return</span> node.parentNode === root || !!matchNode(node, name, vars, <span class="hljs-literal">true</span>);
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-1048">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1048">&#182;</a>
              </div>
              <p>Do an exact check on the similar format element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> matchNode(node, name, vars);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1049">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1049">&#182;</a>
              </div>
              <p>Check specified node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (node) {
          <span class="hljs-keyword">return</span> matchParents(node);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1050">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1050">&#182;</a>
              </div>
              <p>Check selected node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        node = selection.getNode();
        <span class="hljs-keyword">if</span> (matchParents(node)) {
          <span class="hljs-keyword">return</span> TRUE;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1051">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1051">&#182;</a>
              </div>
              <p>Check start node if its different</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        startNode = selection.getStart();
        <span class="hljs-keyword">if</span> (startNode != node) {
          <span class="hljs-keyword">if</span> (matchParents(startNode)) {
            <span class="hljs-keyword">return</span> TRUE;
          }
        }

        <span class="hljs-keyword">return</span> FALSE;
      }

      <span class="hljs-comment">/**
       * Matches the current selection against the array of formats and returns a new array with matching formats.
       *
       * @method matchAll
       * @param {Array} names Name of format to match.
       * @param {Object} vars Optional list of variables to replace before checking it.
       * @return {Array} Array with matched formats.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchAll</span>(<span class="hljs-params">names, vars</span>) </span>{
        <span class="hljs-keyword">var</span> startElement, matchedFormatNames = [], checkedMap = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-1052">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1052">&#182;</a>
              </div>
              <p>Check start of selection for formats</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        startElement = selection.getStart();
        dom.getParent(startElement, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> i, name;

          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; names.length; i++) {
            name = names[i];

            <span class="hljs-keyword">if</span> (!checkedMap[name] &amp;&amp; matchNode(node, name, vars)) {
              checkedMap[name] = <span class="hljs-literal">true</span>;
              matchedFormatNames.push(name);
            }
          }
        }, dom.getRoot());

        <span class="hljs-keyword">return</span> matchedFormatNames;
      }

      <span class="hljs-comment">/**
       * Returns true/false if the specified format can be applied to the current selection or not. It
       * will currently only check the state for selector formats, it returns true on all other format types.
       *
       * @method canApply
       * @param {String} name Name of format to check.
       * @return {boolean} true/false if the specified format can be applied to the current selection/node.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canApply</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">var</span> formatList = get(name), startNode, parents, i, x, selector;

        <span class="hljs-keyword">if</span> (formatList) {
          startNode = selection.getStart();
          parents = getParents(startNode);

          <span class="hljs-keyword">for</span> (x = formatList.length - <span class="hljs-number">1</span>; x &gt;= <span class="hljs-number">0</span>; x--) {
            selector = formatList[x].selector;</pre></div></div>
            
        </li>
        
        
        <li id="section-1053">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1053">&#182;</a>
              </div>
              <p>Format is not selector based then always return TRUE
Is it has a defaultBlock then its likely it can be applied for example align on a non block element line</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!selector || formatList[x].defaultBlock) {
              <span class="hljs-keyword">return</span> TRUE;
            }

            <span class="hljs-keyword">for</span> (i = parents.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
              <span class="hljs-keyword">if</span> (dom.is(parents[i], selector)) {
                <span class="hljs-keyword">return</span> TRUE;
              }
            }
          }
        }

        <span class="hljs-keyword">return</span> FALSE;
      }

      <span class="hljs-comment">/**
       * Executes the specified callback when the current selection matches the formats or not.
       *
       * @method formatChanged
       * @param {String} formats Comma separated list of formats to check for.
       * @param {function} callback Callback with state and args when the format is changed/toggled on/off.
       * @param {Boolean} similar True/false state if the match should handle similar or exact formats.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatChanged</span>(<span class="hljs-params">formats, callback, similar</span>) </span>{
        <span class="hljs-keyword">var</span> currentFormats;</pre></div></div>
            
        </li>
        
        
        <li id="section-1054">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1054">&#182;</a>
              </div>
              <p>Setup format node change logic</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!formatChangeData) {
          formatChangeData = {};
          currentFormats = {};

          ed.on(<span class="hljs-string">'NodeChange'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">var</span> parents = getParents(e.element), matchedFormats = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-1055">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1055">&#182;</a>
              </div>
              <p>Ignore bogus nodes like the <a> tag created by moveStart()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            parents = Tools.grep(parents, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
              <span class="hljs-keyword">return</span> node.nodeType == <span class="hljs-number">1</span> &amp;&amp; !node.getAttribute(<span class="hljs-string">'data-mce-bogus'</span>);
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-1056">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1056">&#182;</a>
              </div>
              <p>Check for new formats</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            each(formatChangeData, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callbacks, format</span>) </span>{
              each(parents, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
                <span class="hljs-keyword">if</span> (matchNode(node, format, {}, callbacks.similar)) {
                  <span class="hljs-keyword">if</span> (!currentFormats[format]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1057">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1057">&#182;</a>
              </div>
              <p>Execute callbacks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    each(callbacks, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
                      callback(<span class="hljs-literal">true</span>, { <span class="hljs-attr">node</span>: node, <span class="hljs-attr">format</span>: format, <span class="hljs-attr">parents</span>: parents });
                    });

                    currentFormats[format] = callbacks;
                  }

                  matchedFormats[format] = callbacks;
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }

                <span class="hljs-keyword">if</span> (matchesUnInheritedFormatSelector(node, format)) {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
              });
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-1058">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1058">&#182;</a>
              </div>
              <p>Check if current formats still match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            each(currentFormats, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callbacks, format</span>) </span>{
              <span class="hljs-keyword">if</span> (!matchedFormats[format]) {
                <span class="hljs-keyword">delete</span> currentFormats[format];

                each(callbacks, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
                  callback(<span class="hljs-literal">false</span>, { <span class="hljs-attr">node</span>: e.element, <span class="hljs-attr">format</span>: format, <span class="hljs-attr">parents</span>: parents });
                });
              }
            });
          });
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1059">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1059">&#182;</a>
              </div>
              <p>Add format listeners</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        each(formats.split(<span class="hljs-string">','</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">format</span>) </span>{
          <span class="hljs-keyword">if</span> (!formatChangeData[format]) {
            formatChangeData[format] = [];
            formatChangeData[format].similar = similar;
          }

          formatChangeData[format].push(callback);
        });

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      }

      <span class="hljs-comment">/**
       * Returns a preview css text for the specified format.
       *
       * @method getCssText
       * @param {String/Object} format Format to generate preview css text for.
       * @return {String} Css text for the specified format.
       * @example
       * var cssText1 = editor.formatter.getCssText('bold');
       * var cssText2 = editor.formatter.getCssText({inline: 'b'});
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCssText</span>(<span class="hljs-params">format</span>) </span>{
        <span class="hljs-keyword">return</span> Preview.getCssText(ed, format);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1060">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1060">&#182;</a>
              </div>
              <p>Expose to public</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      extend(<span class="hljs-keyword">this</span>, {
        <span class="hljs-attr">get</span>: get,
        <span class="hljs-attr">register</span>: register,
        <span class="hljs-attr">unregister</span>: unregister,
        <span class="hljs-attr">apply</span>: apply,
        <span class="hljs-attr">remove</span>: remove,
        <span class="hljs-attr">toggle</span>: toggle,
        <span class="hljs-attr">match</span>: match,
        <span class="hljs-attr">matchAll</span>: matchAll,
        <span class="hljs-attr">matchNode</span>: matchNode,
        <span class="hljs-attr">canApply</span>: canApply,
        <span class="hljs-attr">formatChanged</span>: formatChanged,
        <span class="hljs-attr">getCssText</span>: getCssText
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-1061">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1061">&#182;</a>
              </div>
              <p>Initialize</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      defaultFormats();
      addKeyboardShortcuts();
      ed.on(<span class="hljs-string">'BeforeGetContent'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (markCaretContainersBogus &amp;&amp; e.format != <span class="hljs-string">'raw'</span>) {
          markCaretContainersBogus();
        }
      });
      ed.on(<span class="hljs-string">'mouseup keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (disableCaretContainer) {
          disableCaretContainer(e);
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-1062">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1062">&#182;</a>
              </div>
              <p>Private functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Checks if the specified nodes name matches the format inline/block or selector.
       *
       * @private
       * @param {Node} node Node to match against the specified format.
       * @param {Object} format Format object o match with.
       * @return {boolean} true/false if the format matches.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchName</span>(<span class="hljs-params">node, format</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1063">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1063">&#182;</a>
              </div>
              <p>Check for inline match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (isEq(node, format.inline)) {
          <span class="hljs-keyword">return</span> TRUE;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1064">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1064">&#182;</a>
              </div>
              <p>Check for block match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (isEq(node, format.block)) {
          <span class="hljs-keyword">return</span> TRUE;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1065">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1065">&#182;</a>
              </div>
              <p>Check for selector match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (format.selector) {
          <span class="hljs-keyword">return</span> node.nodeType == <span class="hljs-number">1</span> &amp;&amp; dom.is(node, format.selector);
        }
      }

      <span class="hljs-comment">/**
       * Compares two string/nodes regardless of their case.
       *
       * @private
       * @param {String/Node} str1 Node or string to compare.
       * @param {String/Node} str2 Node or string to compare.
       * @return {boolean} True/false if they match.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEq</span>(<span class="hljs-params">str1, str2</span>) </span>{
        str1 = str1 || <span class="hljs-string">''</span>;
        str2 = str2 || <span class="hljs-string">''</span>;

        str1 = <span class="hljs-string">''</span> + (str1.nodeName || str1);
        str2 = <span class="hljs-string">''</span> + (str2.nodeName || str2);

        <span class="hljs-keyword">return</span> str1.toLowerCase() == str2.toLowerCase();
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processChildElements</span>(<span class="hljs-params">node, filter, process</span>) </span>{
        each(node.childNodes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">if</span> (isElementNode(node)) {
            <span class="hljs-keyword">if</span> (filter(node)) {
              process(node);
            }
            <span class="hljs-keyword">if</span> (node.hasChildNodes()) {
              processChildElements(node, filter, process);
            }
          }
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isElementNode</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> node &amp;&amp; node.nodeType === <span class="hljs-number">1</span> &amp;&amp; !isBookmarkNode(node) &amp;&amp; !isCaretNode(node) &amp;&amp; !NodeType.isBogus(node);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasStyle</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> Fun.curry(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, node</span>) </span>{
          <span class="hljs-keyword">return</span> !!(node &amp;&amp; getStyle(node, name));
        }, name);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyStyle</span>(<span class="hljs-params">name, value</span>) </span>{
        <span class="hljs-keyword">return</span> Fun.curry(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value, node</span>) </span>{
          dom.setStyle(node, name, value);
        }, name, value);
      }

      <span class="hljs-comment">/**
       * Returns the style by name on the specified node. This method modifies the style
       * contents to make it more easy to match. This will resolve a few browser issues.
       *
       * @private
       * @param {Node} node to get style from.
       * @param {String} name Style name to get.
       * @return {String} Style item value.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span>(<span class="hljs-params">node, name</span>) </span>{
        <span class="hljs-keyword">return</span> normalizeStyleValue(dom.getStyle(node, name), name);
      }

      <span class="hljs-comment">/**
       * Normalize style value by name. This method modifies the style contents
       * to make it more easy to match. This will resolve a few browser issues.
       *
       * @private
       * @param {String} value Value to get style from.
       * @param {String} name Style name to get.
       * @return {String} Style item value.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeStyleValue</span>(<span class="hljs-params">value, name</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1066">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1066">&#182;</a>
              </div>
              <p>Force the format to hex</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">'color'</span> || name == <span class="hljs-string">'backgroundColor'</span>) {
          value = dom.toHex(value);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1067">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1067">&#182;</a>
              </div>
              <p>Opera will return bold as 700</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">'fontWeight'</span> &amp;&amp; value == <span class="hljs-number">700</span>) {
          value = <span class="hljs-string">'bold'</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1068">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1068">&#182;</a>
              </div>
              <p>Normalize fontFamily so Font name, Font becomes: Font name,Font</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">'fontFamily'</span>) {
          value = value.replace(<span class="hljs-regexp">/[\'\"]/g</span>, <span class="hljs-string">''</span>).replace(<span class="hljs-regexp">/,\s+/g</span>, <span class="hljs-string">','</span>);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span> + value;
      }

      <span class="hljs-comment">/**
       * Replaces variables in the value. The variable format is %var.
       *
       * @private
       * @param {String} value Value to replace variables in.
       * @param {Object} vars Name/value array with variables to replace.
       * @return {String} New value with replaced variables.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceVars</span>(<span class="hljs-params">value, vars</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value != <span class="hljs-string">"string"</span>) {
          value = value(vars);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vars) {
          value = value.replace(<span class="hljs-regexp">/%(\w+)/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str, name</span>) </span>{
            <span class="hljs-keyword">return</span> vars[name] || str;
          });
        }

        <span class="hljs-keyword">return</span> value;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isWhiteSpaceNode</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> node &amp;&amp; node.nodeType === <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-regexp">/^([\t \r\n]+|)$/</span>.test(node.nodeValue);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span>(<span class="hljs-params">node, name, attrs</span>) </span>{
        <span class="hljs-keyword">var</span> wrapper = dom.create(name, attrs);

        node.parentNode.insertBefore(wrapper, node);
        wrapper.appendChild(node);

        <span class="hljs-keyword">return</span> wrapper;
      }

      <span class="hljs-comment">/**
       * Expands the specified range like object to depending on format.
       *
       * For example on block formats it will move the start/end position
       * to the beginning of the current block.
       *
       * @private
       * @param {Object} rng Range like object.
       * @param {Array} format Array with formats to expand by.
       * @param {Boolean} remove
       * @return {Object} Expanded range like object.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expandRng</span>(<span class="hljs-params">rng, format, remove</span>) </span>{
        <span class="hljs-keyword">var</span> lastIdx, leaf, endPoint,
          startContainer = rng.startContainer,
          startOffset = rng.startOffset,
          endContainer = rng.endContainer,
          endOffset = rng.endOffset;</pre></div></div>
            
        </li>
        
        
        <li id="section-1069">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1069">&#182;</a>
              </div>
              <p>This function walks up the tree if there is no siblings before/after the node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findParentContainer</span>(<span class="hljs-params">start</span>) </span>{
          <span class="hljs-keyword">var</span> container, parent, sibling, siblingName, root;

          container = parent = start ? startContainer : endContainer;
          siblingName = start ? <span class="hljs-string">'previousSibling'</span> : <span class="hljs-string">'nextSibling'</span>;
          root = dom.getRoot();

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBogusBr</span>(<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">return</span> node.nodeName == <span class="hljs-string">"BR"</span> &amp;&amp; node.getAttribute(<span class="hljs-string">'data-mce-bogus'</span>) &amp;&amp; !node.nextSibling;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1070">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1070">&#182;</a>
              </div>
              <p>If its a text node and the offset is inside the text</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">3</span> &amp;&amp; !isWhiteSpaceNode(container)) {
            <span class="hljs-keyword">if</span> (start ? startOffset &gt; <span class="hljs-number">0</span> : endOffset &lt; container.nodeValue.length) {
              <span class="hljs-keyword">return</span> container;
            }
          }

          <span class="hljs-comment">/*eslint no-constant-condition:0 */</span>
          <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1071">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1071">&#182;</a>
              </div>
              <p>Stop expanding on block elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!format[<span class="hljs-number">0</span>].block_expand &amp;&amp; isBlock(parent)) {
              <span class="hljs-keyword">return</span> parent;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1072">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1072">&#182;</a>
              </div>
              <p>Walk left/right</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">for</span> (sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {
              <span class="hljs-keyword">if</span> (!isBookmarkNode(sibling) &amp;&amp; !isWhiteSpaceNode(sibling) &amp;&amp; !isBogusBr(sibling)) {
                <span class="hljs-keyword">return</span> parent;
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1073">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1073">&#182;</a>
              </div>
              <p>Check if we can move up are we at root level or body level</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (parent == root || parent.parentNode == root) {
              container = parent;
              <span class="hljs-keyword">break</span>;
            }

            parent = parent.parentNode;
          }

          <span class="hljs-keyword">return</span> container;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1074">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1074">&#182;</a>
              </div>
              <p>This function walks down the tree to find the leaf at the selection.
The offset is also returned as if node initially a leaf, the offset may be in the middle of the text node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLeaf</span>(<span class="hljs-params">node, offset</span>) </span>{
          <span class="hljs-keyword">if</span> (offset === undef) {
            offset = node.nodeType === <span class="hljs-number">3</span> ? node.length : node.childNodes.length;
          }

          <span class="hljs-keyword">while</span> (node &amp;&amp; node.hasChildNodes()) {
            node = node.childNodes[offset];
            <span class="hljs-keyword">if</span> (node) {
              offset = node.nodeType === <span class="hljs-number">3</span> ? node.length : node.childNodes.length;
            }
          }
          <span class="hljs-keyword">return</span> { <span class="hljs-attr">node</span>: node, <span class="hljs-attr">offset</span>: offset };
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1075">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1075">&#182;</a>
              </div>
              <p>If index based start position then resolve it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (startContainer.nodeType == <span class="hljs-number">1</span> &amp;&amp; startContainer.hasChildNodes()) {
          lastIdx = startContainer.childNodes.length - <span class="hljs-number">1</span>;
          startContainer = startContainer.childNodes[startOffset &gt; lastIdx ? lastIdx : startOffset];

          <span class="hljs-keyword">if</span> (startContainer.nodeType == <span class="hljs-number">3</span>) {
            startOffset = <span class="hljs-number">0</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1076">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1076">&#182;</a>
              </div>
              <p>If index based end position then resolve it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (endContainer.nodeType == <span class="hljs-number">1</span> &amp;&amp; endContainer.hasChildNodes()) {
          lastIdx = endContainer.childNodes.length - <span class="hljs-number">1</span>;
          endContainer = endContainer.childNodes[endOffset &gt; lastIdx ? lastIdx : endOffset - <span class="hljs-number">1</span>];

          <span class="hljs-keyword">if</span> (endContainer.nodeType == <span class="hljs-number">3</span>) {
            endOffset = endContainer.nodeValue.length;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1077">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1077">&#182;</a>
              </div>
              <p>Expands the node to the closes contentEditable false element if it exists</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findParentContentEditable</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> parent = node;

          <span class="hljs-keyword">while</span> (parent) {
            <span class="hljs-keyword">if</span> (parent.nodeType === <span class="hljs-number">1</span> &amp;&amp; getContentEditable(parent)) {
              <span class="hljs-keyword">return</span> getContentEditable(parent) === <span class="hljs-string">"false"</span> ? parent : node;
            }

            parent = parent.parentNode;
          }

          <span class="hljs-keyword">return</span> node;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findWordEndPoint</span>(<span class="hljs-params">container, offset, start</span>) </span>{
          <span class="hljs-keyword">var</span> walker, node, pos, lastTextNode;

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSpace</span>(<span class="hljs-params">node, offset</span>) </span>{
            <span class="hljs-keyword">var</span> pos, pos2, str = node.nodeValue;

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> offset == <span class="hljs-string">"undefined"</span>) {
              offset = start ? str.length : <span class="hljs-number">0</span>;
            }

            <span class="hljs-keyword">if</span> (start) {
              pos = str.lastIndexOf(<span class="hljs-string">' '</span>, offset);
              pos2 = str.lastIndexOf(<span class="hljs-string">'\u00a0'</span>, offset);
              pos = pos &gt; pos2 ? pos : pos2;</pre></div></div>
            
        </li>
        
        
        <li id="section-1078">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1078">&#182;</a>
              </div>
              <p>Include the space on remove to avoid tag soup</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (pos !== <span class="hljs-number">-1</span> &amp;&amp; !remove) {
                pos++;
              }
            } <span class="hljs-keyword">else</span> {
              pos = str.indexOf(<span class="hljs-string">' '</span>, offset);
              pos2 = str.indexOf(<span class="hljs-string">'\u00a0'</span>, offset);
              pos = pos !== <span class="hljs-number">-1</span> &amp;&amp; (pos2 === <span class="hljs-number">-1</span> || pos &lt; pos2) ? pos : pos2;
            }

            <span class="hljs-keyword">return</span> pos;
          }

          <span class="hljs-keyword">if</span> (container.nodeType === <span class="hljs-number">3</span>) {
            pos = findSpace(container, offset);

            <span class="hljs-keyword">if</span> (pos !== <span class="hljs-number">-1</span>) {
              <span class="hljs-keyword">return</span> { <span class="hljs-attr">container</span>: container, <span class="hljs-attr">offset</span>: pos };
            }

            lastTextNode = container;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1079">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1079">&#182;</a>
              </div>
              <p>Walk the nodes inside the block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          walker = <span class="hljs-keyword">new</span> TreeWalker(container, dom.getParent(container, isBlock) || ed.getBody());
          <span class="hljs-keyword">while</span> ((node = walker[start ? <span class="hljs-string">'prev'</span> : <span class="hljs-string">'next'</span>]())) {
            <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">3</span>) {
              lastTextNode = node;
              pos = findSpace(node);

              <span class="hljs-keyword">if</span> (pos !== <span class="hljs-number">-1</span>) {
                <span class="hljs-keyword">return</span> { <span class="hljs-attr">container</span>: node, <span class="hljs-attr">offset</span>: pos };
              }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isBlock(node)) {
              <span class="hljs-keyword">break</span>;
            }
          }

          <span class="hljs-keyword">if</span> (lastTextNode) {
            <span class="hljs-keyword">if</span> (start) {
              offset = <span class="hljs-number">0</span>;
            } <span class="hljs-keyword">else</span> {
              offset = lastTextNode.length;
            }

            <span class="hljs-keyword">return</span> { <span class="hljs-attr">container</span>: lastTextNode, <span class="hljs-attr">offset</span>: offset };
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSelectorEndPoint</span>(<span class="hljs-params">container, siblingName</span>) </span>{
          <span class="hljs-keyword">var</span> parents, i, y, curFormat;

          <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">3</span> &amp;&amp; container.nodeValue.length === <span class="hljs-number">0</span> &amp;&amp; container[siblingName]) {
            container = container[siblingName];
          }

          parents = getParents(container);
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; parents.length; i++) {
            <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; format.length; y++) {
              curFormat = format[y];</pre></div></div>
            
        </li>
        
        
        <li id="section-1080">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1080">&#182;</a>
              </div>
              <p>If collapsed state is set then skip formats that doesnt match that</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (<span class="hljs-string">"collapsed"</span> <span class="hljs-keyword">in</span> curFormat &amp;&amp; curFormat.collapsed !== rng.collapsed) {
                <span class="hljs-keyword">continue</span>;
              }

              <span class="hljs-keyword">if</span> (dom.is(parents[i], curFormat.selector)) {
                <span class="hljs-keyword">return</span> parents[i];
              }
            }
          }

          <span class="hljs-keyword">return</span> container;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findBlockEndPoint</span>(<span class="hljs-params">container, siblingName</span>) </span>{
          <span class="hljs-keyword">var</span> node, root = dom.getRoot();</pre></div></div>
            
        </li>
        
        
        <li id="section-1081">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1081">&#182;</a>
              </div>
              <p>Expand to block of similar type</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!format[<span class="hljs-number">0</span>].wrapper) {
            node = dom.getParent(container, format[<span class="hljs-number">0</span>].block, root);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1082">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1082">&#182;</a>
              </div>
              <p>Expand to first wrappable block element or any block element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!node) {
            node = dom.getParent(container.nodeType == <span class="hljs-number">3</span> ? container.parentNode : container, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1083">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1083">&#182;</a>
              </div>
              <p>Fixes #6183 where it would expand to editable parent element in inline mode</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">return</span> node != root &amp;&amp; isTextBlock(node);
            });
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1084">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1084">&#182;</a>
              </div>
              <p>Exclude inner lists from wrapping</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (node &amp;&amp; format[<span class="hljs-number">0</span>].wrapper) {
            node = getParents(node, <span class="hljs-string">'ul,ol'</span>).reverse()[<span class="hljs-number">0</span>] || node;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1085">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1085">&#182;</a>
              </div>
              <p>Didnt find a block element look for first/last wrappable element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!node) {
            node = container;

            <span class="hljs-keyword">while</span> (node[siblingName] &amp;&amp; !isBlock(node[siblingName])) {
              node = node[siblingName];</pre></div></div>
            
        </li>
        
        
        <li id="section-1086">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1086">&#182;</a>
              </div>
              <p>Break on BR but include it will be removed later on
we cant remove it now since we need to check if it can be wrapped</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (isEq(node, <span class="hljs-string">'br'</span>)) {
                <span class="hljs-keyword">break</span>;
              }
            }
          }

          <span class="hljs-keyword">return</span> node || container;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1087">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1087">&#182;</a>
              </div>
              <p>Expand to closest contentEditable element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        startContainer = findParentContentEditable(startContainer);
        endContainer = findParentContentEditable(endContainer);</pre></div></div>
            
        </li>
        
        
        <li id="section-1088">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1088">&#182;</a>
              </div>
              <p>Exclude bookmark nodes if possible</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (isBookmarkNode(startContainer.parentNode) || isBookmarkNode(startContainer)) {
          startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;
          startContainer = startContainer.nextSibling || startContainer;

          <span class="hljs-keyword">if</span> (startContainer.nodeType == <span class="hljs-number">3</span>) {
            startOffset = <span class="hljs-number">0</span>;
          }
        }

        <span class="hljs-keyword">if</span> (isBookmarkNode(endContainer.parentNode) || isBookmarkNode(endContainer)) {
          endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;
          endContainer = endContainer.previousSibling || endContainer;

          <span class="hljs-keyword">if</span> (endContainer.nodeType == <span class="hljs-number">3</span>) {
            endOffset = endContainer.length;
          }
        }

        <span class="hljs-keyword">if</span> (format[<span class="hljs-number">0</span>].inline) {
          <span class="hljs-keyword">if</span> (rng.collapsed) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1089">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1089">&#182;</a>
              </div>
              <p>Expand left to closest word boundary</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            endPoint = findWordEndPoint(startContainer, startOffset, <span class="hljs-literal">true</span>);
            <span class="hljs-keyword">if</span> (endPoint) {
              startContainer = endPoint.container;
              startOffset = endPoint.offset;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1090">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1090">&#182;</a>
              </div>
              <p>Expand right to closest word boundary</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            endPoint = findWordEndPoint(endContainer, endOffset);
            <span class="hljs-keyword">if</span> (endPoint) {
              endContainer = endPoint.container;
              endOffset = endPoint.offset;
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1091">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1091">&#182;</a>
              </div>
              <p>Avoid applying formatting to a trailing space.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          leaf = findLeaf(endContainer, endOffset);
          <span class="hljs-keyword">if</span> (leaf.node) {
            <span class="hljs-keyword">while</span> (leaf.node &amp;&amp; leaf.offset === <span class="hljs-number">0</span> &amp;&amp; leaf.node.previousSibling) {
              leaf = findLeaf(leaf.node.previousSibling);
            }

            <span class="hljs-keyword">if</span> (leaf.node &amp;&amp; leaf.offset &gt; <span class="hljs-number">0</span> &amp;&amp; leaf.node.nodeType === <span class="hljs-number">3</span> &amp;&amp;
              leaf.node.nodeValue.charAt(leaf.offset - <span class="hljs-number">1</span>) === <span class="hljs-string">' '</span>) {

              <span class="hljs-keyword">if</span> (leaf.offset &gt; <span class="hljs-number">1</span>) {
                endContainer = leaf.node;
                endContainer.splitText(leaf.offset - <span class="hljs-number">1</span>);
              }
            }
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1092">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1092">&#182;</a>
              </div>
              <p>Move start/end point up the tree if the leaves are sharp and if we are in different containers
Example <em> becomes !: !<p><b><i></em>text</i><i>text*</i></b></p>!
This will reduce the number of wrapper elements that needs to be created
Move start point up the tree</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (format[<span class="hljs-number">0</span>].inline || format[<span class="hljs-number">0</span>].block_expand) {
          <span class="hljs-keyword">if</span> (!format[<span class="hljs-number">0</span>].inline || (startContainer.nodeType != <span class="hljs-number">3</span> || startOffset === <span class="hljs-number">0</span>)) {
            startContainer = findParentContainer(<span class="hljs-literal">true</span>);
          }

          <span class="hljs-keyword">if</span> (!format[<span class="hljs-number">0</span>].inline || (endContainer.nodeType != <span class="hljs-number">3</span> || endOffset === endContainer.nodeValue.length)) {
            endContainer = findParentContainer();
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1093">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1093">&#182;</a>
              </div>
              <p>Expand start/end container to matching selector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (format[<span class="hljs-number">0</span>].selector &amp;&amp; format[<span class="hljs-number">0</span>].expand !== FALSE &amp;&amp; !format[<span class="hljs-number">0</span>].inline) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1094">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1094">&#182;</a>
              </div>
              <p>Find new startContainer/endContainer if there is better one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          startContainer = findSelectorEndPoint(startContainer, <span class="hljs-string">'previousSibling'</span>);
          endContainer = findSelectorEndPoint(endContainer, <span class="hljs-string">'nextSibling'</span>);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1095">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1095">&#182;</a>
              </div>
              <p>Expand start/end container to matching block element or text node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (format[<span class="hljs-number">0</span>].block || format[<span class="hljs-number">0</span>].selector) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1096">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1096">&#182;</a>
              </div>
              <p>Find new startContainer/endContainer if there is better one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          startContainer = findBlockEndPoint(startContainer, <span class="hljs-string">'previousSibling'</span>);
          endContainer = findBlockEndPoint(endContainer, <span class="hljs-string">'nextSibling'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1097">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1097">&#182;</a>
              </div>
              <p>Non block element then try to expand up the leaf</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (format[<span class="hljs-number">0</span>].block) {
            <span class="hljs-keyword">if</span> (!isBlock(startContainer)) {
              startContainer = findParentContainer(<span class="hljs-literal">true</span>);
            }

            <span class="hljs-keyword">if</span> (!isBlock(endContainer)) {
              endContainer = findParentContainer();
            }
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1098">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1098">&#182;</a>
              </div>
              <p>Setup index for startContainer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (startContainer.nodeType == <span class="hljs-number">1</span>) {
          startOffset = nodeIndex(startContainer);
          startContainer = startContainer.parentNode;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1099">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1099">&#182;</a>
              </div>
              <p>Setup index for endContainer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (endContainer.nodeType == <span class="hljs-number">1</span>) {
          endOffset = nodeIndex(endContainer) + <span class="hljs-number">1</span>;
          endContainer = endContainer.parentNode;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1100">&#182;</a>
              </div>
              <p>Return new range like object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">startContainer</span>: startContainer,
          <span class="hljs-attr">startOffset</span>: startOffset,
          <span class="hljs-attr">endContainer</span>: endContainer,
          <span class="hljs-attr">endOffset</span>: endOffset
        };
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isColorFormatAndAnchor</span>(<span class="hljs-params">node, format</span>) </span>{
        <span class="hljs-keyword">return</span> format.links &amp;&amp; node.tagName == <span class="hljs-string">'A'</span>;
      }

      <span class="hljs-comment">/**
       * Removes the specified format for the specified node. It will also remove the node if it doesn't have
       * any attributes if the format specifies it to do so.
       *
       * @private
       * @param {Object} format Format object with items to remove from node.
       * @param {Object} vars Name/value object with variables to apply to format.
       * @param {Node} node Node to remove the format styles on.
       * @param {Node} compareNode Optional compare node, if specified the styles will be compared to that node.
       * @return {Boolean} True/false if the node was removed or not.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeFormat</span>(<span class="hljs-params">format, vars, node, compareNode</span>) </span>{
        <span class="hljs-keyword">var</span> i, attrs, stylesModified;</pre></div></div>
            
        </li>
        
        
        <li id="section-1101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1101">&#182;</a>
              </div>
              <p>Check if node matches format</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!matchName(node, format) &amp;&amp; !isColorFormatAndAnchor(node, format)) {
          <span class="hljs-keyword">return</span> FALSE;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1102">&#182;</a>
              </div>
              <p>Should we compare with format attribs and styles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (format.remove != <span class="hljs-string">'all'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1103">&#182;</a>
              </div>
              <p>Remove styles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          each(format.styles, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, name</span>) </span>{
            value = normalizeStyleValue(replaceVars(value, vars), name);</pre></div></div>
            
        </li>
        
        
        <li id="section-1104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1104">&#182;</a>
              </div>
              <p>Indexed array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">'number'</span>) {
              name = value;
              compareNode = <span class="hljs-number">0</span>;
            }

            <span class="hljs-keyword">if</span> (format.remove_similar || (!compareNode || isEq(getStyle(compareNode, name), value))) {
              dom.setStyle(node, name, <span class="hljs-string">''</span>);
            }

            stylesModified = <span class="hljs-number">1</span>;
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-1105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1105">&#182;</a>
              </div>
              <p>Remove style attribute if its empty</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (stylesModified &amp;&amp; dom.getAttrib(node, <span class="hljs-string">'style'</span>) === <span class="hljs-string">''</span>) {
            node.removeAttribute(<span class="hljs-string">'style'</span>);
            node.removeAttribute(<span class="hljs-string">'data-mce-style'</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1106">&#182;</a>
              </div>
              <p>Remove attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          each(format.attributes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, name</span>) </span>{
            <span class="hljs-keyword">var</span> valueOut;

            value = replaceVars(value, vars);</pre></div></div>
            
        </li>
        
        
        <li id="section-1107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1107">&#182;</a>
              </div>
              <p>Indexed array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">'number'</span>) {
              name = value;
              compareNode = <span class="hljs-number">0</span>;
            }

            <span class="hljs-keyword">if</span> (!compareNode || isEq(dom.getAttrib(compareNode, name), value)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1108">&#182;</a>
              </div>
              <p>Keep internal classes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (name == <span class="hljs-string">'class'</span>) {
                value = dom.getAttrib(node, name);
                <span class="hljs-keyword">if</span> (value) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1109">&#182;</a>
              </div>
              <p>Build new class value where everything is removed except the internal prefixed classes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  valueOut = <span class="hljs-string">''</span>;
                  each(value.split(<span class="hljs-regexp">/\s+/</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cls</span>) </span>{
                    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/mce\-\w+/</span>.test(cls)) {
                      valueOut += (valueOut ? <span class="hljs-string">' '</span> : <span class="hljs-string">''</span>) + cls;
                    }
                  });</pre></div></div>
            
        </li>
        
        
        <li id="section-1110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1110">&#182;</a>
              </div>
              <p>We got some internal classes left</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">if</span> (valueOut) {
                    dom.setAttrib(node, name, valueOut);
                    <span class="hljs-keyword">return</span>;
                  }
                }
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-1111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1111">&#182;</a>
              </div>
              <p>IE6 has a bug where the attribute doesnt get removed correctly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (name == <span class="hljs-string">"class"</span>) {
                node.removeAttribute(<span class="hljs-string">'className'</span>);
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-1112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1112">&#182;</a>
              </div>
              <p>Remove mce prefixed attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (MCE_ATTR_RE.test(name)) {
                node.removeAttribute(<span class="hljs-string">'data-mce-'</span> + name);
              }

              node.removeAttribute(name);
            }
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-1113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1113">&#182;</a>
              </div>
              <p>Remove classes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          each(format.classes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
            value = replaceVars(value, vars);

            <span class="hljs-keyword">if</span> (!compareNode || dom.hasClass(compareNode, value)) {
              dom.removeClass(node, value);
            }
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-1114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1114">&#182;</a>
              </div>
              <p>Check for non internal attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          attrs = dom.getAttribs(node);
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; attrs.length; i++) {
            <span class="hljs-keyword">var</span> attrName = attrs[i].nodeName;
            <span class="hljs-keyword">if</span> (attrName.indexOf(<span class="hljs-string">'_'</span>) !== <span class="hljs-number">0</span> &amp;&amp; attrName.indexOf(<span class="hljs-string">'data-'</span>) !== <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> FALSE;
            }
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1115">&#182;</a>
              </div>
              <p>Remove the inline child if its empty for example <b> or <span></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (format.remove != <span class="hljs-string">'none'</span>) {
          removeNode(node, format);
          <span class="hljs-keyword">return</span> TRUE;
        }
      }

      <span class="hljs-comment">/**
       * Removes the node and wrap it's children in paragraphs before doing so or
       * appends BR elements to the beginning/end of the block element if forcedRootBlocks is disabled.
       *
       * If the div in the node below gets removed:
       *  text&lt;div&gt;text&lt;/div&gt;text
       *
       * Output becomes:
       *  text&lt;div&gt;&lt;br /&gt;text&lt;br /&gt;&lt;/div&gt;text
       *
       * So when the div is removed the result is:
       *  text&lt;br /&gt;text&lt;br /&gt;text
       *
       * @private
       * @param {Node} node Node to remove + apply BR/P elements to.
       * @param {Object} format Format rule.
       * @return {Node} Input node.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeNode</span>(<span class="hljs-params">node, format</span>) </span>{
        <span class="hljs-keyword">var</span> parentNode = node.parentNode, rootBlockElm;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">node, next, inc</span>) </span>{
          node = getNonWhiteSpaceSibling(node, next, inc);

          <span class="hljs-keyword">return</span> !node || (node.nodeName == <span class="hljs-string">'BR'</span> || isBlock(node));
        }

        <span class="hljs-keyword">if</span> (format.block) {
          <span class="hljs-keyword">if</span> (!forcedRootBlock) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1116">&#182;</a>
              </div>
              <p>Append BR elements if needed before we remove the block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (isBlock(node) &amp;&amp; !isBlock(parentNode)) {
              <span class="hljs-keyword">if</span> (!find(node, FALSE) &amp;&amp; !find(node.firstChild, TRUE, <span class="hljs-number">1</span>)) {
                node.insertBefore(dom.create(<span class="hljs-string">'br'</span>), node.firstChild);
              }

              <span class="hljs-keyword">if</span> (!find(node, TRUE) &amp;&amp; !find(node.lastChild, FALSE, <span class="hljs-number">1</span>)) {
                node.appendChild(dom.create(<span class="hljs-string">'br'</span>));
              }
            }
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1117">&#182;</a>
              </div>
              <p>Wrap the block in a forcedRootBlock if we are at the root of document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (parentNode == dom.getRoot()) {
              <span class="hljs-keyword">if</span> (!format.list_block || !isEq(node, format.list_block)) {
                each(grep(node.childNodes), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
                  <span class="hljs-keyword">if</span> (isValid(forcedRootBlock, node.nodeName.toLowerCase())) {
                    <span class="hljs-keyword">if</span> (!rootBlockElm) {
                      rootBlockElm = wrap(node, forcedRootBlock);
                      dom.setAttribs(rootBlockElm, ed.settings.forced_root_block_attrs);
                    } <span class="hljs-keyword">else</span> {
                      rootBlockElm.appendChild(node);
                    }
                  } <span class="hljs-keyword">else</span> {
                    rootBlockElm = <span class="hljs-number">0</span>;
                  }
                });
              }
            }
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1118">&#182;</a>
              </div>
              <p>Never remove nodes that isnt the specified inline element if a selector is specified too</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (format.selector &amp;&amp; format.inline &amp;&amp; !isEq(format.inline, node)) {
          <span class="hljs-keyword">return</span>;
        }

        dom.remove(node, <span class="hljs-number">1</span>);
      }

      <span class="hljs-comment">/**
       * Returns the next/previous non whitespace node.
       *
       * @private
       * @param {Node} node Node to start at.
       * @param {boolean} next (Optional) Include next or previous node defaults to previous.
       * @param {boolean} inc (Optional) Include the current node in checking. Defaults to false.
       * @return {Node} Next or previous node or undefined if it wasn't found.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNonWhiteSpaceSibling</span>(<span class="hljs-params">node, next, inc</span>) </span>{
        <span class="hljs-keyword">if</span> (node) {
          next = next ? <span class="hljs-string">'nextSibling'</span> : <span class="hljs-string">'previousSibling'</span>;

          <span class="hljs-keyword">for</span> (node = inc ? node : node[next]; node; node = node[next]) {
            <span class="hljs-keyword">if</span> (node.nodeType == <span class="hljs-number">1</span> || !isWhiteSpaceNode(node)) {
              <span class="hljs-keyword">return</span> node;
            }
          }
        }
      }

      <span class="hljs-comment">/**
       * Merges the next/previous sibling element if they match.
       *
       * @private
       * @param {Node} prev Previous node to compare/merge.
       * @param {Node} next Next node to compare/merge.
       * @return {Node} Next node if we didn't merge and prev node if we did.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSiblings</span>(<span class="hljs-params">prev, next</span>) </span>{
        <span class="hljs-keyword">var</span> sibling, tmpSibling, elementUtils = <span class="hljs-keyword">new</span> ElementUtils(dom);

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findElementSibling</span>(<span class="hljs-params">node, siblingName</span>) </span>{
          <span class="hljs-keyword">for</span> (sibling = node; sibling; sibling = sibling[siblingName]) {
            <span class="hljs-keyword">if</span> (sibling.nodeType == <span class="hljs-number">3</span> &amp;&amp; sibling.nodeValue.length !== <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> node;
            }

            <span class="hljs-keyword">if</span> (sibling.nodeType == <span class="hljs-number">1</span> &amp;&amp; !isBookmarkNode(sibling)) {
              <span class="hljs-keyword">return</span> sibling;
            }
          }

          <span class="hljs-keyword">return</span> node;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1119">&#182;</a>
              </div>
              <p>Check if next/prev exists and that they are elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (prev &amp;&amp; next) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1120">&#182;</a>
              </div>
              <p>If previous sibling is empty then jump over it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          prev = findElementSibling(prev, <span class="hljs-string">'previousSibling'</span>);
          next = findElementSibling(next, <span class="hljs-string">'nextSibling'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1121">&#182;</a>
              </div>
              <p>Compare next and previous nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (elementUtils.compare(prev, next)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1122">&#182;</a>
              </div>
              <p>Append nodes between</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">for</span> (sibling = prev.nextSibling; sibling &amp;&amp; sibling != next;) {
              tmpSibling = sibling;
              sibling = sibling.nextSibling;
              prev.appendChild(tmpSibling);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1123">&#182;</a>
              </div>
              <p>Remove next node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            dom.remove(next);</pre></div></div>
            
        </li>
        
        
        <li id="section-1124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1124">&#182;</a>
              </div>
              <p>Move children into prev node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            each(grep(next.childNodes), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
              prev.appendChild(node);
            });

            <span class="hljs-keyword">return</span> prev;
          }
        }

        <span class="hljs-keyword">return</span> next;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContainer</span>(<span class="hljs-params">rng, start</span>) </span>{
        <span class="hljs-keyword">var</span> container, offset, lastIdx;

        container = rng[start ? <span class="hljs-string">'startContainer'</span> : <span class="hljs-string">'endContainer'</span>];
        offset = rng[start ? <span class="hljs-string">'startOffset'</span> : <span class="hljs-string">'endOffset'</span>];

        <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">1</span>) {
          lastIdx = container.childNodes.length - <span class="hljs-number">1</span>;

          <span class="hljs-keyword">if</span> (!start &amp;&amp; offset) {
            offset--;
          }

          container = container.childNodes[offset &gt; lastIdx ? lastIdx : offset];
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1125">&#182;</a>
              </div>
              <p>If start text node is excluded then walk to the next node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (container.nodeType === <span class="hljs-number">3</span> &amp;&amp; start &amp;&amp; offset &gt;= container.nodeValue.length) {
          container = <span class="hljs-keyword">new</span> TreeWalker(container, ed.getBody()).next() || container;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1126">&#182;</a>
              </div>
              <p>If end text node is excluded then walk to the previous node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (container.nodeType === <span class="hljs-number">3</span> &amp;&amp; !start &amp;&amp; offset === <span class="hljs-number">0</span>) {
          container = <span class="hljs-keyword">new</span> TreeWalker(container, ed.getBody()).prev() || container;
        }

        <span class="hljs-keyword">return</span> container;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performCaretAction</span>(<span class="hljs-params">type, name, vars, similar</span>) </span>{
        <span class="hljs-keyword">var</span> caretContainerId = <span class="hljs-string">'_mce_caret'</span>, debug = ed.settings.caret_debug;</pre></div></div>
            
        </li>
        
        
        <li id="section-1127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1127">&#182;</a>
              </div>
              <p>Creates a caret container bogus element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCaretContainer</span>(<span class="hljs-params">fill</span>) </span>{
          <span class="hljs-keyword">var</span> caretContainer = dom.create(<span class="hljs-string">'span'</span>, { <span class="hljs-attr">id</span>: caretContainerId, <span class="hljs-string">'data-mce-bogus'</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">style</span>: debug ? <span class="hljs-string">'color:red'</span> : <span class="hljs-string">''</span> });

          <span class="hljs-keyword">if</span> (fill) {
            caretContainer.appendChild(ed.getDoc().createTextNode(INVISIBLE_CHAR));
          }

          <span class="hljs-keyword">return</span> caretContainer;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCaretContainerEmpty</span>(<span class="hljs-params">node, nodes</span>) </span>{
          <span class="hljs-keyword">while</span> (node) {
            <span class="hljs-keyword">if</span> ((node.nodeType === <span class="hljs-number">3</span> &amp;&amp; node.nodeValue !== INVISIBLE_CHAR) || node.childNodes.length &gt; <span class="hljs-number">1</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1128">&#182;</a>
              </div>
              <p>Collect nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (nodes &amp;&amp; node.nodeType === <span class="hljs-number">1</span>) {
              nodes.push(node);
            }

            node = node.firstChild;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1129">&#182;</a>
              </div>
              <p>Returns any parent caret container element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParentCaretContainer</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">while</span> (node) {
            <span class="hljs-keyword">if</span> (node.id === caretContainerId) {
              <span class="hljs-keyword">return</span> node;
            }

            node = node.parentNode;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1130">&#182;</a>
              </div>
              <p>Finds the first text node in the specified node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFirstTextNode</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> walker;

          <span class="hljs-keyword">if</span> (node) {
            walker = <span class="hljs-keyword">new</span> TreeWalker(node, node);

            <span class="hljs-keyword">for</span> (node = walker.current(); node; node = walker.next()) {
              <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">3</span>) {
                <span class="hljs-keyword">return</span> node;
              }
            }
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1131">&#182;</a>
              </div>
              <p>Removes the caret container for the specified node or all on the current document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeCaretContainer</span>(<span class="hljs-params">node, moveCaret</span>) </span>{
          <span class="hljs-keyword">var</span> child, rng;

          <span class="hljs-keyword">if</span> (!node) {
            node = getParentCaretContainer(selection.getStart());

            <span class="hljs-keyword">if</span> (!node) {
              <span class="hljs-keyword">while</span> ((node = dom.get(caretContainerId))) {
                removeCaretContainer(node, <span class="hljs-literal">false</span>);
              }
            }
          } <span class="hljs-keyword">else</span> {
            rng = selection.getRng(<span class="hljs-literal">true</span>);

            <span class="hljs-keyword">if</span> (isCaretContainerEmpty(node)) {
              <span class="hljs-keyword">if</span> (moveCaret !== <span class="hljs-literal">false</span>) {
                rng.setStartBefore(node);
                rng.setEndBefore(node);
              }

              dom.remove(node);
            } <span class="hljs-keyword">else</span> {
              child = findFirstTextNode(node);

              <span class="hljs-keyword">if</span> (child.nodeValue.charAt(<span class="hljs-number">0</span>) === INVISIBLE_CHAR) {
                child.deleteData(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1132">&#182;</a>
              </div>
              <p>Fix for bug #6976</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (rng.startContainer == child &amp;&amp; rng.startOffset &gt; <span class="hljs-number">0</span>) {
                  rng.setStart(child, rng.startOffset - <span class="hljs-number">1</span>);
                }

                <span class="hljs-keyword">if</span> (rng.endContainer == child &amp;&amp; rng.endOffset &gt; <span class="hljs-number">0</span>) {
                  rng.setEnd(child, rng.endOffset - <span class="hljs-number">1</span>);
                }
              }

              dom.remove(node, <span class="hljs-number">1</span>);
            }

            selection.setRng(rng);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1133">&#182;</a>
              </div>
              <p>Applies formatting to the caret position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyCaretFormat</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> rng, caretContainer, textNode, offset, bookmark, container, text;

          rng = selection.getRng(<span class="hljs-literal">true</span>);
          offset = rng.startOffset;
          container = rng.startContainer;
          text = container.nodeValue;

          caretContainer = getParentCaretContainer(selection.getStart());
          <span class="hljs-keyword">if</span> (caretContainer) {
            textNode = findFirstTextNode(caretContainer);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1134">&#182;</a>
              </div>
              <p>Expand to word if caret is in the middle of a text node and the char before/after is a alpha numeric character</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> wordcharRegex = <span class="hljs-regexp">/[^\s\u00a0\u00ad\u200b\ufeff]/</span>;
          <span class="hljs-keyword">if</span> (text &amp;&amp; offset &gt; <span class="hljs-number">0</span> &amp;&amp; offset &lt; text.length &amp;&amp;
            wordcharRegex.test(text.charAt(offset)) &amp;&amp; wordcharRegex.test(text.charAt(offset - <span class="hljs-number">1</span>))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1135">&#182;</a>
              </div>
              <p>Get bookmark of caret position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            bookmark = selection.getBookmark();</pre></div></div>
            
        </li>
        
        
        <li id="section-1136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1136">&#182;</a>
              </div>
              <p>Collapse bookmark range (WebKit)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            rng.collapse(<span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1137">&#182;</a>
              </div>
              <p>Expand the range to the closest word and split it at those points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            rng = expandRng(rng, get(name));
            rng = rangeUtils.split(rng);</pre></div></div>
            
        </li>
        
        
        <li id="section-1138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1138">&#182;</a>
              </div>
              <p>Apply the format to the range</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            apply(name, vars, rng);</pre></div></div>
            
        </li>
        
        
        <li id="section-1139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1139">&#182;</a>
              </div>
              <p>Move selection back to caret position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            selection.moveToBookmark(bookmark);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (!caretContainer || textNode.nodeValue !== INVISIBLE_CHAR) {
              caretContainer = createCaretContainer(<span class="hljs-literal">true</span>);
              textNode = caretContainer.firstChild;

              rng.insertNode(caretContainer);
              offset = <span class="hljs-number">1</span>;

              apply(name, vars, caretContainer);
            } <span class="hljs-keyword">else</span> {
              apply(name, vars, caretContainer);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1140">&#182;</a>
              </div>
              <p>Move selection to text node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            selection.setCursorLocation(textNode, offset);
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeCaretFormat</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> rng = selection.getRng(<span class="hljs-literal">true</span>), container, offset, bookmark,
            hasContentAfter, node, formatNode, parents = [], i, caretContainer;

          container = rng.startContainer;
          offset = rng.startOffset;
          node = container;

          <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">3</span>) {
            <span class="hljs-keyword">if</span> (offset != container.nodeValue.length) {
              hasContentAfter = <span class="hljs-literal">true</span>;
            }

            node = node.parentNode;
          }

          <span class="hljs-keyword">while</span> (node) {
            <span class="hljs-keyword">if</span> (matchNode(node, name, vars, similar)) {
              formatNode = node;
              <span class="hljs-keyword">break</span>;
            }

            <span class="hljs-keyword">if</span> (node.nextSibling) {
              hasContentAfter = <span class="hljs-literal">true</span>;
            }

            parents.push(node);
            node = node.parentNode;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1141">&#182;</a>
              </div>
              <p>Node doesnt have the specified format</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!formatNode) {
            <span class="hljs-keyword">return</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1142">&#182;</a>
              </div>
              <p>Is there contents after the caret then remove the format on the element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (hasContentAfter) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1143">&#182;</a>
              </div>
              <p>Get bookmark of caret position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            bookmark = selection.getBookmark();</pre></div></div>
            
        </li>
        
        
        <li id="section-1144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1144">&#182;</a>
              </div>
              <p>Collapse bookmark range (WebKit)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            rng.collapse(<span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1145">&#182;</a>
              </div>
              <p>Expand the range to the closest word and split it at those points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            rng = expandRng(rng, get(name), <span class="hljs-literal">true</span>);
            rng = rangeUtils.split(rng);</pre></div></div>
            
        </li>
        
        
        <li id="section-1146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1146">&#182;</a>
              </div>
              <p>Remove the format from the range</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            remove(name, vars, rng);</pre></div></div>
            
        </li>
        
        
        <li id="section-1147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1147">&#182;</a>
              </div>
              <p>Move selection back to caret position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            selection.moveToBookmark(bookmark);
          } <span class="hljs-keyword">else</span> {
            caretContainer = createCaretContainer();

            node = caretContainer;
            <span class="hljs-keyword">for</span> (i = parents.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
              node.appendChild(dom.clone(parents[i], <span class="hljs-literal">false</span>));
              node = node.firstChild;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1148">&#182;</a>
              </div>
              <p>Insert invisible character into inner most format element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            node.appendChild(dom.doc.createTextNode(INVISIBLE_CHAR));
            node = node.firstChild;

            <span class="hljs-keyword">var</span> block = dom.getParent(formatNode, isTextBlock);

            <span class="hljs-keyword">if</span> (block &amp;&amp; dom.isEmpty(block)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1149">&#182;</a>
              </div>
              <p>Replace formatNode with caretContainer when removing format from empty block like <p><b>|</b></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              formatNode.parentNode.replaceChild(caretContainer, formatNode);
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1150">&#182;</a>
              </div>
              <p>Insert caret container after the formatted node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              dom.insertAfter(caretContainer, formatNode);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1151">&#182;</a>
              </div>
              <p>Move selection to text node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            selection.setCursorLocation(node, <span class="hljs-number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1152">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1152">&#182;</a>
              </div>
              <p>If the formatNode is empty, we can remove it safely.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (dom.isEmpty(formatNode)) {
              dom.remove(formatNode);
            }
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1153">&#182;</a>
              </div>
              <p>Checks if the parent caret container node isnt empty if that is the case it
will remove the bogus state on all children that isnt empty</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unmarkBogusCaretParents</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> caretContainer;

          caretContainer = getParentCaretContainer(selection.getStart());
          <span class="hljs-keyword">if</span> (caretContainer &amp;&amp; !dom.isEmpty(caretContainer)) {
            walk(caretContainer, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
              <span class="hljs-keyword">if</span> (node.nodeType == <span class="hljs-number">1</span> &amp;&amp; node.id !== caretContainerId &amp;&amp; !dom.isEmpty(node)) {
                dom.setAttrib(node, <span class="hljs-string">'data-mce-bogus'</span>, <span class="hljs-literal">null</span>);
              }
            }, <span class="hljs-string">'childNodes'</span>);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1154">&#182;</a>
              </div>
              <p>Only bind the caret events once</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!ed._hasCaretEvents) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1155">&#182;</a>
              </div>
              <p>Mark current caret container elements as bogus when getting the contents so we dont end up with empty elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          markCaretContainersBogus = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> nodes = [], i;

            <span class="hljs-keyword">if</span> (isCaretContainerEmpty(getParentCaretContainer(selection.getStart()), nodes)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1156">&#182;</a>
              </div>
              <p>Mark children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              i = nodes.length;
              <span class="hljs-keyword">while</span> (i--) {
                dom.setAttrib(nodes[i], <span class="hljs-string">'data-mce-bogus'</span>, <span class="hljs-string">'1'</span>);
              }
            }
          };

          disableCaretContainer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">var</span> keyCode = e.keyCode;

            removeCaretContainer();</pre></div></div>
            
        </li>
        
        
        <li id="section-1157">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1157">&#182;</a>
              </div>
              <p>Remove caret container if its empty</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (keyCode == <span class="hljs-number">8</span> &amp;&amp; selection.isCollapsed() &amp;&amp; selection.getStart().innerHTML == INVISIBLE_CHAR) {
              removeCaretContainer(getParentCaretContainer(selection.getStart()));
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1158">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1158">&#182;</a>
              </div>
              <p>Remove caret container on keydown and its left/right arrow keys</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (keyCode == <span class="hljs-number">37</span> || keyCode == <span class="hljs-number">39</span>) {
              removeCaretContainer(getParentCaretContainer(selection.getStart()));
            }

            unmarkBogusCaretParents();
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-1159">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1159">&#182;</a>
              </div>
              <p>Remove bogus state if they got filled by contents using editor.selection.setContent</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          ed.on(<span class="hljs-string">'SetContent'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">if</span> (e.selection) {
              unmarkBogusCaretParents();
            }
          });
          ed._hasCaretEvents = <span class="hljs-literal">true</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1160">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1160">&#182;</a>
              </div>
              <p>Do apply or remove caret format</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"apply"</span>) {
          applyCaretFormat();
        } <span class="hljs-keyword">else</span> {
          removeCaretFormat();
        }
      }

      <span class="hljs-comment">/**
       * Moves the start to the first suitable text node.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveStart</span>(<span class="hljs-params">rng</span>) </span>{
        <span class="hljs-keyword">var</span> container = rng.startContainer,
          offset = rng.startOffset,
          walker, node, nodes;

        <span class="hljs-keyword">if</span> (rng.startContainer == rng.endContainer) {
          <span class="hljs-keyword">if</span> (isInlineBlock(rng.startContainer.childNodes[rng.startOffset])) {
            <span class="hljs-keyword">return</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1161">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1161">&#182;</a>
              </div>
              <p>Convert text node into index if possible</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">3</span> &amp;&amp; offset &gt;= container.nodeValue.length) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1162">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1162">&#182;</a>
              </div>
              <p>Get the parent container location and walk from there</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          offset = nodeIndex(container);
          container = container.parentNode;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1163">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1163">&#182;</a>
              </div>
              <p>Move startContainer/startOffset in to a suitable node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">1</span>) {
          nodes = container.childNodes;
          <span class="hljs-keyword">if</span> (offset &lt; nodes.length) {
            container = nodes[offset];
            walker = <span class="hljs-keyword">new</span> TreeWalker(container, dom.getParent(container, dom.isBlock));
          } <span class="hljs-keyword">else</span> {
            container = nodes[nodes.length - <span class="hljs-number">1</span>];
            walker = <span class="hljs-keyword">new</span> TreeWalker(container, dom.getParent(container, dom.isBlock));
            walker.next(<span class="hljs-literal">true</span>);
          }

          <span class="hljs-keyword">for</span> (node = walker.current(); node; node = walker.next()) {
            <span class="hljs-keyword">if</span> (node.nodeType == <span class="hljs-number">3</span> &amp;&amp; !isWhiteSpaceNode(node)) {
              rng.setStart(node, <span class="hljs-number">0</span>);
              selection.setRng(rng);

              <span class="hljs-keyword">return</span>;
            }
          }
        }
      }
    };
  }
);

<span class="hljs-comment">/**
 * Diff.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * JS Implementation of the O(ND) Difference Algorithm by Eugene W. Myers.
 *
 * @class tinymce.undo.Diff
 * @private
 */</span>
define(
  <span class="hljs-string">'tinymce.core.undo.Diff'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> KEEP = <span class="hljs-number">0</span>, INSERT = <span class="hljs-number">1</span>, DELETE = <span class="hljs-number">2</span>;

    <span class="hljs-keyword">var</span> diff = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">left, right</span>) </span>{
      <span class="hljs-keyword">var</span> size = left.length + right.length + <span class="hljs-number">2</span>;
      <span class="hljs-keyword">var</span> vDown = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(size);
      <span class="hljs-keyword">var</span> vUp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(size);

      <span class="hljs-keyword">var</span> snake = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">start, end, diag</span>) </span>{
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">start</span>: start,
          <span class="hljs-attr">end</span>: end,
          <span class="hljs-attr">diag</span>: diag
        };
      };

      <span class="hljs-keyword">var</span> buildScript = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">start1, end1, start2, end2, script</span>) </span>{
        <span class="hljs-keyword">var</span> middle = getMiddleSnake(start1, end1, start2, end2);

        <span class="hljs-keyword">if</span> (middle === <span class="hljs-literal">null</span> || middle.start === end1 &amp;&amp; middle.diag === end1 - end2 ||
          middle.end === start1 &amp;&amp; middle.diag === start1 - start2) {
          <span class="hljs-keyword">var</span> i = start1;
          <span class="hljs-keyword">var</span> j = start2;
          <span class="hljs-keyword">while</span> (i &lt; end1 || j &lt; end2) {
            <span class="hljs-keyword">if</span> (i &lt; end1 &amp;&amp; j &lt; end2 &amp;&amp; left[i] === right[j]) {
              script.push([KEEP, left[i]]);
              ++i;
              ++j;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">if</span> (end1 - start1 &gt; end2 - start2) {
                script.push([DELETE, left[i]]);
                ++i;
              } <span class="hljs-keyword">else</span> {
                script.push([INSERT, right[j]]);
                ++j;
              }
            }
          }
        } <span class="hljs-keyword">else</span> {
          buildScript(start1, middle.start, start2, middle.start - middle.diag, script);
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i2 = middle.start; i2 &lt; middle.end; ++i2) {
            script.push([KEEP, left[i2]]);
          }
          buildScript(middle.end, end1, middle.end - middle.diag, end2, script);
        }
      };

      <span class="hljs-keyword">var</span> buildSnake = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">start, diag, end1, end2</span>) </span>{
        <span class="hljs-keyword">var</span> end = start;
        <span class="hljs-keyword">while</span> (end - diag &lt; end2 &amp;&amp; end &lt; end1 &amp;&amp; left[end] === right[end - diag]) {
          ++end;
        }
        <span class="hljs-keyword">return</span> snake(start, end, diag);
      };

      <span class="hljs-keyword">var</span> getMiddleSnake = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">start1, end1, start2, end2</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1164">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1164">&#182;</a>
              </div>
              <p>Myers Algorithm
Initialisations</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> m = end1 - start1;
        <span class="hljs-keyword">var</span> n = end2 - start2;
        <span class="hljs-keyword">if</span> (m === <span class="hljs-number">0</span> || n === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">var</span> delta = m - n;
        <span class="hljs-keyword">var</span> sum = n + m;
        <span class="hljs-keyword">var</span> offset = (sum % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? sum : sum + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
        vDown[<span class="hljs-number">1</span> + offset] = start1;
        vUp[<span class="hljs-number">1</span> + offset] = end1 + <span class="hljs-number">1</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> d = <span class="hljs-number">0</span>; d &lt;= offset; ++d) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1165">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1165">&#182;</a>
              </div>
              <p>Down</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k = -d; k &lt;= d; k += <span class="hljs-number">2</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1166">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1166">&#182;</a>
              </div>
              <p>First step</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">var</span> i = k + offset;
            <span class="hljs-keyword">if</span> (k === -d || k != d &amp;&amp; vDown[i - <span class="hljs-number">1</span>] &lt; vDown[i + <span class="hljs-number">1</span>]) {
              vDown[i] = vDown[i + <span class="hljs-number">1</span>];
            } <span class="hljs-keyword">else</span> {
              vDown[i] = vDown[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;
            }

            <span class="hljs-keyword">var</span> x = vDown[i];
            <span class="hljs-keyword">var</span> y = x - start1 + start2 - k;

            <span class="hljs-keyword">while</span> (x &lt; end1 &amp;&amp; y &lt; end2 &amp;&amp; left[x] === right[y]) {
              vDown[i] = ++x;
              ++y;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1167">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1167">&#182;</a>
              </div>
              <p>Second step</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (delta % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> &amp;&amp; delta - d &lt;= k &amp;&amp; k &lt;= delta + d) {
              <span class="hljs-keyword">if</span> (vUp[i - delta] &lt;= vDown[i]) {
                <span class="hljs-keyword">return</span> buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1168">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1168">&#182;</a>
              </div>
              <p>Up</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (k = delta - d; k &lt;= delta + d; k += <span class="hljs-number">2</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1169">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1169">&#182;</a>
              </div>
              <p>First step</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            i = k + offset - delta;
            <span class="hljs-keyword">if</span> (k === delta - d || k != delta + d &amp;&amp; vUp[i + <span class="hljs-number">1</span>] &lt;= vUp[i - <span class="hljs-number">1</span>]) {
              vUp[i] = vUp[i + <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
              vUp[i] = vUp[i - <span class="hljs-number">1</span>];
            }

            x = vUp[i] - <span class="hljs-number">1</span>;
            y = x - start1 + start2 - k;
            <span class="hljs-keyword">while</span> (x &gt;= start1 &amp;&amp; y &gt;= start2 &amp;&amp; left[x] === right[y]) {
              vUp[i] = x--;
              y--;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1170">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1170">&#182;</a>
              </div>
              <p>Second step</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (delta % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> &amp;&amp; -d &lt;= k &amp;&amp; k &lt;= d) {
              <span class="hljs-keyword">if</span> (vUp[i] &lt;= vDown[i + delta]) {
                <span class="hljs-keyword">return</span> buildSnake(vUp[i], k + start1 - start2, end1, end2);
              }
            }
          }
        }
      };

      <span class="hljs-keyword">var</span> script = [];
      buildScript(<span class="hljs-number">0</span>, left.length, <span class="hljs-number">0</span>, right.length, script);
      <span class="hljs-keyword">return</span> script;
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">KEEP</span>: KEEP,
      <span class="hljs-attr">DELETE</span>: DELETE,
      <span class="hljs-attr">INSERT</span>: INSERT,
      <span class="hljs-attr">diff</span>: diff
    };
  }
);
<span class="hljs-comment">/**
 * Fragments.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module reads and applies html fragments from/to dom nodes.
 *
 * @class tinymce.undo.Fragments
 * @private
 */</span>
define(
  <span class="hljs-string">'tinymce.core.undo.Fragments'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Arr"</span>,
    <span class="hljs-string">"tinymce.core.html.Entities"</span>,
    <span class="hljs-string">"tinymce.core.undo.Diff"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Entities, Diff</span>) </span>{
    <span class="hljs-keyword">var</span> getOuterHtml = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">if</span> (elm.nodeType === <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> elm.outerHTML;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elm.nodeType === <span class="hljs-number">3</span>) {
        <span class="hljs-keyword">return</span> Entities.encodeRaw(elm.data, <span class="hljs-literal">false</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elm.nodeType === <span class="hljs-number">8</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;!--'</span> + elm.data + <span class="hljs-string">'--&gt;'</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    };

    <span class="hljs-keyword">var</span> createFragment = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">html</span>) </span>{
      <span class="hljs-keyword">var</span> frag, node, container;

      container = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>);
      frag = <span class="hljs-built_in">document</span>.createDocumentFragment();

      <span class="hljs-keyword">if</span> (html) {
        container.innerHTML = html;
      }

      <span class="hljs-keyword">while</span> ((node = container.firstChild)) {
        frag.appendChild(node);
      }

      <span class="hljs-keyword">return</span> frag;
    };

    <span class="hljs-keyword">var</span> insertAt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, html, index</span>) </span>{
      <span class="hljs-keyword">var</span> fragment = createFragment(html);
      <span class="hljs-keyword">if</span> (elm.hasChildNodes() &amp;&amp; index &lt; elm.childNodes.length) {
        <span class="hljs-keyword">var</span> target = elm.childNodes[index];
        target.parentNode.insertBefore(fragment, target);
      } <span class="hljs-keyword">else</span> {
        elm.appendChild(fragment);
      }
    };

    <span class="hljs-keyword">var</span> removeAt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, index</span>) </span>{
      <span class="hljs-keyword">if</span> (elm.hasChildNodes() &amp;&amp; index &lt; elm.childNodes.length) {
        <span class="hljs-keyword">var</span> target = elm.childNodes[index];
        target.parentNode.removeChild(target);
      }
    };

    <span class="hljs-keyword">var</span> applyDiff = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">diff, elm</span>) </span>{
      <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;
      Arr.each(diff, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action</span>) </span>{
        <span class="hljs-keyword">if</span> (action[<span class="hljs-number">0</span>] === Diff.KEEP) {
          index++;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (action[<span class="hljs-number">0</span>] === Diff.INSERT) {
          insertAt(elm, action[<span class="hljs-number">1</span>], index);
          index++;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (action[<span class="hljs-number">0</span>] === Diff.DELETE) {
          removeAt(elm, index);
        }
      });
    };

    <span class="hljs-keyword">var</span> read = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> Arr.map(elm.childNodes, getOuterHtml);
    };

    <span class="hljs-keyword">var</span> write = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fragments, elm</span>) </span>{
      <span class="hljs-keyword">var</span> currentFragments = Arr.map(elm.childNodes, getOuterHtml);
      applyDiff(Diff.diff(currentFragments, fragments), elm);
      <span class="hljs-keyword">return</span> elm;
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">read</span>: read,
      <span class="hljs-attr">write</span>: write
    };
  }
);
<span class="hljs-comment">/**
 * Levels.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module handles getting/setting undo levels to/from editor instances.
 *
 * @class tinymce.undo.Levels
 * @private
 */</span>
define(
  <span class="hljs-string">'tinymce.core.undo.Levels'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Arr"</span>,
    <span class="hljs-string">"tinymce.core.undo.Fragments"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Fragments</span>) </span>{
    <span class="hljs-keyword">var</span> hasIframes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">html</span>) </span>{
      <span class="hljs-keyword">return</span> html.indexOf(<span class="hljs-string">'&lt;/iframe&gt;'</span>) !== <span class="hljs-number">-1</span>;
    };

    <span class="hljs-keyword">var</span> createFragmentedLevel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fragments</span>) </span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'fragmented'</span>,
        <span class="hljs-attr">fragments</span>: fragments,
        <span class="hljs-attr">content</span>: <span class="hljs-string">''</span>,
        <span class="hljs-attr">bookmark</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">beforeBookmark</span>: <span class="hljs-literal">null</span>
      };
    };

    <span class="hljs-keyword">var</span> createCompleteLevel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">content</span>) </span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'complete'</span>,
        <span class="hljs-attr">fragments</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">content</span>: content,
        <span class="hljs-attr">bookmark</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">beforeBookmark</span>: <span class="hljs-literal">null</span>
      };
    };

    <span class="hljs-keyword">var</span> createFromEditor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> fragments, content, trimmedFragments;

      fragments = Fragments.read(editor.getBody());
      trimmedFragments = Arr.map(fragments, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">html</span>) </span>{
        <span class="hljs-keyword">return</span> editor.serializer.trimContent(html);
      });
      content = trimmedFragments.join(<span class="hljs-string">''</span>);

      <span class="hljs-keyword">return</span> hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);
    };

    <span class="hljs-keyword">var</span> applyToEditor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, level, before</span>) </span>{
      <span class="hljs-keyword">if</span> (level.type === <span class="hljs-string">'fragmented'</span>) {
        Fragments.write(level.fragments, editor.getBody());
      } <span class="hljs-keyword">else</span> {
        editor.setContent(level.content, { <span class="hljs-attr">format</span>: <span class="hljs-string">'raw'</span> });
      }

      editor.selection.moveToBookmark(before ? level.beforeBookmark : level.bookmark);
    };

    <span class="hljs-keyword">var</span> getLevelContent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">level</span>) </span>{
      <span class="hljs-keyword">return</span> level.type === <span class="hljs-string">'fragmented'</span> ? level.fragments.join(<span class="hljs-string">''</span>) : level.content;
    };

    <span class="hljs-keyword">var</span> isEq = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">level1, level2</span>) </span>{
      <span class="hljs-keyword">return</span> getLevelContent(level1) === getLevelContent(level2);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">createFragmentedLevel</span>: createFragmentedLevel,
      <span class="hljs-attr">createCompleteLevel</span>: createCompleteLevel,
      <span class="hljs-attr">createFromEditor</span>: createFromEditor,
      <span class="hljs-attr">applyToEditor</span>: applyToEditor,
      <span class="hljs-attr">isEq</span>: isEq
    };
  }
);
<span class="hljs-comment">/**
 * UndoManager.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class handles the undo/redo history levels for the editor. Since the built-in undo/redo has major drawbacks a custom one was needed.
 *
 * @class tinymce.UndoManager
 */</span>
define(
  <span class="hljs-string">'tinymce.core.UndoManager'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.VK"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.undo.Levels"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">VK, Tools, Levels</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, index = <span class="hljs-number">0</span>, data = [], beforeBookmark, isFirstTypedCharacter, locks = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">var</span> isUnlocked = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> locks === <span class="hljs-number">0</span>;
      };

      <span class="hljs-keyword">var</span> setTyping = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">typing</span>) </span>{
        <span class="hljs-keyword">if</span> (isUnlocked()) {
          self.typing = typing;
        }
      };

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDirty</span>(<span class="hljs-params">state</span>) </span>{
        editor.setDirty(state);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addNonTypingUndoLevel</span>(<span class="hljs-params">e</span>) </span>{
        setTyping(<span class="hljs-literal">false</span>);
        self.add({}, e);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endTyping</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (self.typing) {
          setTyping(<span class="hljs-literal">false</span>);
          self.add();
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1171">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1171">&#182;</a>
              </div>
              <p>Add initial undo level when the editor is initialized</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      editor.on(<span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        self.add();
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-1172">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1172">&#182;</a>
              </div>
              <p>Get position before an execCommand is processed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      editor.on(<span class="hljs-string">'BeforeExecCommand'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> cmd = e.command;

        <span class="hljs-keyword">if</span> (cmd !== <span class="hljs-string">'Undo'</span> &amp;&amp; cmd !== <span class="hljs-string">'Redo'</span> &amp;&amp; cmd !== <span class="hljs-string">'mceRepaint'</span>) {
          endTyping();
          self.beforeChange();
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-1173">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1173">&#182;</a>
              </div>
              <p>Add undo level after an execCommand call was made</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      editor.on(<span class="hljs-string">'ExecCommand'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> cmd = e.command;

        <span class="hljs-keyword">if</span> (cmd !== <span class="hljs-string">'Undo'</span> &amp;&amp; cmd !== <span class="hljs-string">'Redo'</span> &amp;&amp; cmd !== <span class="hljs-string">'mceRepaint'</span>) {
          addNonTypingUndoLevel(e);
        }
      });

      editor.on(<span class="hljs-string">'ObjectResizeStart Cut'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        self.beforeChange();
      });

      editor.on(<span class="hljs-string">'SaveContent ObjectResized blur'</span>, addNonTypingUndoLevel);
      editor.on(<span class="hljs-string">'DragEnd'</span>, addNonTypingUndoLevel);

      editor.on(<span class="hljs-string">'KeyUp'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> keyCode = e.keyCode;</pre></div></div>
            
        </li>
        
        
        <li id="section-1174">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1174">&#182;</a>
              </div>
              <p>If key is prevented then dont add undo level
This would happen on keyboard shortcuts for example</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (e.isDefaultPrevented()) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> ((keyCode &gt;= <span class="hljs-number">33</span> &amp;&amp; keyCode &lt;= <span class="hljs-number">36</span>) || (keyCode &gt;= <span class="hljs-number">37</span> &amp;&amp; keyCode &lt;= <span class="hljs-number">40</span>) || keyCode === <span class="hljs-number">45</span> || e.ctrlKey) {
          addNonTypingUndoLevel();
          editor.nodeChanged();
        }

        <span class="hljs-keyword">if</span> (keyCode === <span class="hljs-number">46</span> || keyCode === <span class="hljs-number">8</span>) {
          editor.nodeChanged();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1175">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1175">&#182;</a>
              </div>
              <p>Fire a TypingUndo/Change event on the first character entered</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (isFirstTypedCharacter &amp;&amp; self.typing &amp;&amp; Levels.isEq(Levels.createFromEditor(editor), data[<span class="hljs-number">0</span>]) === <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">if</span> (editor.isDirty() === <span class="hljs-literal">false</span>) {
            setDirty(<span class="hljs-literal">true</span>);
            editor.fire(<span class="hljs-string">'change'</span>, { <span class="hljs-attr">level</span>: data[<span class="hljs-number">0</span>], <span class="hljs-attr">lastLevel</span>: <span class="hljs-literal">null</span> });
          }

          editor.fire(<span class="hljs-string">'TypingUndo'</span>);
          isFirstTypedCharacter = <span class="hljs-literal">false</span>;
          editor.nodeChanged();
        }
      });

      editor.on(<span class="hljs-string">'KeyDown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> keyCode = e.keyCode;</pre></div></div>
            
        </li>
        
        
        <li id="section-1176">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1176">&#182;</a>
              </div>
              <p>If key is prevented then dont add undo level
This would happen on keyboard shortcuts for example</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (e.isDefaultPrevented()) {
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1177">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1177">&#182;</a>
              </div>
              <p>Is character position keys left,right,up,down,home,end,pgdown,pgup,enter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((keyCode &gt;= <span class="hljs-number">33</span> &amp;&amp; keyCode &lt;= <span class="hljs-number">36</span>) || (keyCode &gt;= <span class="hljs-number">37</span> &amp;&amp; keyCode &lt;= <span class="hljs-number">40</span>) || keyCode === <span class="hljs-number">45</span>) {
          <span class="hljs-keyword">if</span> (self.typing) {
            addNonTypingUndoLevel(e);
          }

          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1178">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1178">&#182;</a>
              </div>
              <p>If key isnt Ctrl+Alt/AltGr</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> modKey = (e.ctrlKey &amp;&amp; !e.altKey) || e.metaKey;
        <span class="hljs-keyword">if</span> ((keyCode &lt; <span class="hljs-number">16</span> || keyCode &gt; <span class="hljs-number">20</span>) &amp;&amp; keyCode !== <span class="hljs-number">224</span> &amp;&amp; keyCode !== <span class="hljs-number">91</span> &amp;&amp; !self.typing &amp;&amp; !modKey) {
          self.beforeChange();
          setTyping(<span class="hljs-literal">true</span>);
          self.add({}, e);
          isFirstTypedCharacter = <span class="hljs-literal">true</span>;
        }
      });

      editor.on(<span class="hljs-string">'MouseDown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (self.typing) {
          addNonTypingUndoLevel(e);
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-1179">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1179">&#182;</a>
              </div>
              <p>Add keyboard shortcuts for undo/redo keys</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      editor.addShortcut(<span class="hljs-string">'meta+z'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'Undo'</span>);
      editor.addShortcut(<span class="hljs-string">'meta+y,meta+shift+z'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'Redo'</span>);

      editor.on(<span class="hljs-string">'AddUndo Undo Redo ClearUndos'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (!e.isDefaultPrevented()) {
          editor.nodeChanged();
        }
      });

      <span class="hljs-comment">/*eslint consistent-this:0 */</span>
      self = {</pre></div></div>
            
        </li>
        
        
        <li id="section-1180">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1180">&#182;</a>
              </div>
              <p>Explode for debugging reasons</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        data: data,

        <span class="hljs-comment">/**
         * State if the user is currently typing or not. This will add a typing operation into one undo
         * level instead of one new level for each keystroke.
         *
         * @field {Boolean} typing
         */</span>
        typing: <span class="hljs-literal">false</span>,

        <span class="hljs-comment">/**
         * Stores away a bookmark to be used when performing an undo action so that the selection is before
         * the change has been made.
         *
         * @method beforeChange
         */</span>
        beforeChange: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (isUnlocked()) {
            beforeBookmark = editor.selection.getBookmark(<span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);
          }
        },

        <span class="hljs-comment">/**
         * Adds a new undo level/snapshot to the undo list.
         *
         * @method add
         * @param {Object} level Optional undo level object to add.
         * @param {DOMEvent} event Optional event responsible for the creation of the undo level.
         * @return {Object} Undo level that got added or null it a level wasn't needed.
         */</span>
        add: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">level, event</span>) </span>{
          <span class="hljs-keyword">var</span> i, settings = editor.settings, lastLevel, currentLevel;

          currentLevel = Levels.createFromEditor(editor);
          level = level || {};
          level = Tools.extend(level, currentLevel);

          <span class="hljs-keyword">if</span> (isUnlocked() === <span class="hljs-literal">false</span> || editor.removed) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          lastLevel = data[index];
          <span class="hljs-keyword">if</span> (editor.fire(<span class="hljs-string">'BeforeAddUndo'</span>, { <span class="hljs-attr">level</span>: level, <span class="hljs-attr">lastLevel</span>: lastLevel, <span class="hljs-attr">originalEvent</span>: event }).isDefaultPrevented()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1181">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1181">&#182;</a>
              </div>
              <p>Add undo level if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (lastLevel &amp;&amp; Levels.isEq(lastLevel, level)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1182">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1182">&#182;</a>
              </div>
              <p>Set before bookmark on previous level</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (data[index]) {
            data[index].beforeBookmark = beforeBookmark;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1183">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1183">&#182;</a>
              </div>
              <p>Time to compress</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (settings.custom_undo_redo_levels) {
            <span class="hljs-keyword">if</span> (data.length &gt; settings.custom_undo_redo_levels) {
              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; data.length - <span class="hljs-number">1</span>; i++) {
                data[i] = data[i + <span class="hljs-number">1</span>];
              }

              data.length--;
              index = data.length;
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1184">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1184">&#182;</a>
              </div>
              <p>Get a non intrusive normalized bookmark</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          level.bookmark = editor.selection.getBookmark(<span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1185">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1185">&#182;</a>
              </div>
              <p>Crop array if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (index &lt; data.length - <span class="hljs-number">1</span>) {
            data.length = index + <span class="hljs-number">1</span>;
          }

          data.push(level);
          index = data.length - <span class="hljs-number">1</span>;

          <span class="hljs-keyword">var</span> args = { <span class="hljs-attr">level</span>: level, <span class="hljs-attr">lastLevel</span>: lastLevel, <span class="hljs-attr">originalEvent</span>: event };

          editor.fire(<span class="hljs-string">'AddUndo'</span>, args);

          <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span>) {
            setDirty(<span class="hljs-literal">true</span>);
            editor.fire(<span class="hljs-string">'change'</span>, args);
          }

          <span class="hljs-keyword">return</span> level;
        },

        <span class="hljs-comment">/**
         * Undoes the last action.
         *
         * @method undo
         * @return {Object} Undo level or null if no undo was performed.
         */</span>
        undo: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> level;

          <span class="hljs-keyword">if</span> (self.typing) {
            self.add();
            self.typing = <span class="hljs-literal">false</span>;
            setTyping(<span class="hljs-literal">false</span>);
          }

          <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span>) {
            level = data[--index];
            Levels.applyToEditor(editor, level, <span class="hljs-literal">true</span>);
            setDirty(<span class="hljs-literal">true</span>);
            editor.fire(<span class="hljs-string">'undo'</span>, { <span class="hljs-attr">level</span>: level });
          }

          <span class="hljs-keyword">return</span> level;
        },

        <span class="hljs-comment">/**
         * Redoes the last action.
         *
         * @method redo
         * @return {Object} Redo level or null if no redo was performed.
         */</span>
        redo: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> level;

          <span class="hljs-keyword">if</span> (index &lt; data.length - <span class="hljs-number">1</span>) {
            level = data[++index];
            Levels.applyToEditor(editor, level, <span class="hljs-literal">false</span>);
            setDirty(<span class="hljs-literal">true</span>);
            editor.fire(<span class="hljs-string">'redo'</span>, { <span class="hljs-attr">level</span>: level });
          }

          <span class="hljs-keyword">return</span> level;
        },

        <span class="hljs-comment">/**
         * Removes all undo levels.
         *
         * @method clear
         */</span>
        clear: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          data = [];
          index = <span class="hljs-number">0</span>;
          self.typing = <span class="hljs-literal">false</span>;
          self.data = data;
          editor.fire(<span class="hljs-string">'ClearUndos'</span>);
        },

        <span class="hljs-comment">/**
         * Returns true/false if the undo manager has any undo levels.
         *
         * @method hasUndo
         * @return {Boolean} true/false if the undo manager has any undo levels.
         */</span>
        hasUndo: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1186">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1186">&#182;</a>
              </div>
              <p>Has undo levels or typing and content isnt the same as the initial level</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> index &gt; <span class="hljs-number">0</span> || (self.typing &amp;&amp; data[<span class="hljs-number">0</span>] &amp;&amp; !Levels.isEq(Levels.createFromEditor(editor), data[<span class="hljs-number">0</span>]));
        },

        <span class="hljs-comment">/**
         * Returns true/false if the undo manager has any redo levels.
         *
         * @method hasRedo
         * @return {Boolean} true/false if the undo manager has any redo levels.
         */</span>
        hasRedo: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> index &lt; data.length - <span class="hljs-number">1</span> &amp;&amp; !self.typing;
        },

        <span class="hljs-comment">/**
         * Executes the specified mutator function as an undo transaction. The selection
         * before the modification will be stored to the undo stack and if the DOM changes
         * it will add a new undo level. Any logic within the translation that adds undo levels will
         * be ignored. So a translation can include calls to execCommand or editor.insertContent.
         *
         * @method transact
         * @param {function} callback Function that gets executed and has dom manipulation logic in it.
         * @return {Object} Undo level that got added or null it a level wasn't needed.
         */</span>
        transact: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
          endTyping();
          self.beforeChange();
          self.ignore(callback);
          <span class="hljs-keyword">return</span> self.add();
        },

        <span class="hljs-comment">/**
         * Executes the specified mutator function as an undo transaction. But without adding an undo level.
         * Any logic within the translation that adds undo levels will be ignored. So a translation can
         * include calls to execCommand or editor.insertContent.
         *
         * @method ignore
         * @param {function} callback Function that gets executed and has dom manipulation logic in it.
         * @return {Object} Undo level that got added or null it a level wasn't needed.
         */</span>
        ignore: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
          <span class="hljs-keyword">try</span> {
            locks++;
            callback();
          } <span class="hljs-keyword">finally</span> {
            locks--;
          }
        },

        <span class="hljs-comment">/**
         * Adds an extra "hidden" undo level by first applying the first mutation and store that to the undo stack
         * then roll back that change and do the second mutation on top of the stack. This will produce an extra
         * undo level that the user doesn't see until they undo.
         *
         * @method extra
         * @param {function} callback1 Function that does mutation but gets stored as a "hidden" extra undo level.
         * @param {function} callback2 Function that does mutation but gets displayed to the user.
         */</span>
        extra: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback1, callback2</span>) </span>{
          <span class="hljs-keyword">var</span> lastLevel, bookmark;

          <span class="hljs-keyword">if</span> (self.transact(callback1)) {
            bookmark = data[index].bookmark;
            lastLevel = data[index - <span class="hljs-number">1</span>];
            Levels.applyToEditor(editor, lastLevel, <span class="hljs-literal">true</span>);

            <span class="hljs-keyword">if</span> (self.transact(callback2)) {
              data[index - <span class="hljs-number">1</span>].beforeBookmark = bookmark;
            }
          }
        }
      };

      <span class="hljs-keyword">return</span> self;
    };
  }
);

define(
  <span class="hljs-string">'ephox.katamari.api.Options'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Option'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Option</span>) </span>{
    <span class="hljs-comment">/** cat :: [Option a] -&gt; [a] */</span>
    <span class="hljs-keyword">var</span> cat = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>{
      <span class="hljs-keyword">var</span> r = [];
      <span class="hljs-keyword">var</span> push = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
        r.push(x);
      };
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
        arr[i].each(push);
      }
      <span class="hljs-keyword">return</span> r;
    };

    <span class="hljs-comment">/** findMap :: ([a], (a, Int -&gt; Option b)) -&gt; Option b */</span>
    <span class="hljs-keyword">var</span> findMap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr, f</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
        <span class="hljs-keyword">var</span> r = f(arr[i], i);
        <span class="hljs-keyword">if</span> (r.isSome()) {
          <span class="hljs-keyword">return</span> r;
        }
      }
      <span class="hljs-keyword">return</span> Option.none();
    };

    <span class="hljs-comment">/**
     * if all elements in arr are 'some', their inner values are passed as arguments to f
     * f must have arity arr.length
    */</span>
    <span class="hljs-keyword">var</span> liftN = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, f</span>) </span>{
      <span class="hljs-keyword">var</span> r = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
        <span class="hljs-keyword">var</span> x = arr[i];
        <span class="hljs-keyword">if</span> (x.isSome()) {
          r.push(x.getOrDie());
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> Option.none();
        }
      }
      <span class="hljs-keyword">return</span> Option.some(f.apply(<span class="hljs-literal">null</span>, r));
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">cat</span>: cat,
      <span class="hljs-attr">findMap</span>: findMap,
      <span class="hljs-attr">liftN</span>: liftN
    };
  }
);

define(
  <span class="hljs-string">'ephox.katamari.data.Immutable'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'global!Array'</span>,
    <span class="hljs-string">'global!Error'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Fun, Array, Error</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> fields = <span class="hljs-built_in">arguments</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-regexp">/* values */</span></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1187">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1187">&#182;</a>
              </div>
              <p> Dont use array slice(arguments), makes the whole function unoptimisable on Chrome</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> values = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">arguments</span>.length);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) values[i] = <span class="hljs-built_in">arguments</span>[i];

        <span class="hljs-keyword">if</span> (fields.length !== values.length)
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Wrong number of arguments to struct. Expected "['</span> + fields.length + <span class="hljs-string">']", got '</span> + values.length + <span class="hljs-string">' arguments'</span>);

        <span class="hljs-keyword">var</span> struct = {};
        Arr.each(fields, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, i</span>) </span>{
          struct[name] = Fun.constant(values[i]);
        });
        <span class="hljs-keyword">return</span> struct;
      };
    };
  }
);

define(
  <span class="hljs-string">'ephox.katamari.api.Obj'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'global!Object'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Option, Object</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1188">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1188">&#182;</a>
              </div>
              <p>There are many variations of Object iteration that are faster than the for-in style:
<a href="http://jsperf.com/object-keys-iteration/107">http://jsperf.com/object-keys-iteration/107</a></p>
<p>Use the native keys if it is available (IE9+), otherwise fall back to manually filtering</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> keys = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> fastKeys = <span class="hljs-built_in">Object</span>.keys;</pre></div></div>
            
        </li>
        
        
        <li id="section-1189">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1189">&#182;</a>
              </div>
              <p>This technically means that each and find on IE8 iterate through the object twice.
This code doesnt run on IE8 much, so its an acceptable tradeoff.
If it becomes a problem we can always duplicate the feature detection inside each and find as well.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> slowKeys = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>{
        <span class="hljs-keyword">var</span> r = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> o) {
          <span class="hljs-keyword">if</span> (o.hasOwnProperty(i)) {
            r.push(i);
          }
        }
        <span class="hljs-keyword">return</span> r;
      };

      <span class="hljs-keyword">return</span> fastKeys === <span class="hljs-literal">undefined</span> ? slowKeys : fastKeys;
    })();


    <span class="hljs-keyword">var</span> each = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, f</span>) </span>{
      <span class="hljs-keyword">var</span> props = keys(obj);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>, len = props.length; k &lt; len; k++) {
        <span class="hljs-keyword">var</span> i = props[k];
        <span class="hljs-keyword">var</span> x = obj[i];
        f(x, i, obj);
      }
    };

    <span class="hljs-comment">/** objectMap :: (JsObj(k, v), (v, k, JsObj(k, v) -&gt; x)) -&gt; JsObj(k, x) */</span>
    <span class="hljs-keyword">var</span> objectMap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, f</span>) </span>{
      <span class="hljs-keyword">return</span> tupleMap(obj, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, i, obj</span>) </span>{
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">k</span>: i,
          <span class="hljs-attr">v</span>: f(x, i, obj)
        };
      });
    };

    <span class="hljs-comment">/** tupleMap :: (JsObj(k, v), (v, k, JsObj(k, v) -&gt; { k: x, v: y })) -&gt; JsObj(x, y) */</span>
    <span class="hljs-keyword">var</span> tupleMap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, f</span>) </span>{
      <span class="hljs-keyword">var</span> r = {};
      each(obj, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, i</span>) </span>{
        <span class="hljs-keyword">var</span> tuple = f(x, i, obj);
        r[tuple.k] = tuple.v;
      });
      <span class="hljs-keyword">return</span> r;
    };

    <span class="hljs-comment">/** bifilter :: (JsObj(k, v), (v, k -&gt; Bool)) -&gt; { t: JsObj(k, v), f: JsObj(k, v) } */</span>
    <span class="hljs-keyword">var</span> bifilter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, pred</span>) </span>{
      <span class="hljs-keyword">var</span> t = {};
      <span class="hljs-keyword">var</span> f = {};
      each(obj, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, i</span>) </span>{
        <span class="hljs-keyword">var</span> branch = pred(x, i) ? t : f;
        branch[i] = x;
      });
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">t</span>: t,
        <span class="hljs-attr">f</span>: f
      };
    };

    <span class="hljs-comment">/** mapToArray :: (JsObj(k, v), (v, k -&gt; a)) -&gt; [a] */</span>
    <span class="hljs-keyword">var</span> mapToArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, f</span>) </span>{
      <span class="hljs-keyword">var</span> r = [];
      each(obj, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, name</span>) </span>{
        r.push(f(value, name));
      });
      <span class="hljs-keyword">return</span> r;
    };

    <span class="hljs-comment">/** find :: (JsObj(k, v), (v, k, JsObj(k, v) -&gt; Bool)) -&gt; Option v */</span>
    <span class="hljs-keyword">var</span> find = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, pred</span>) </span>{
      <span class="hljs-keyword">var</span> props = keys(obj);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>, len = props.length; k &lt; len; k++) {
        <span class="hljs-keyword">var</span> i = props[k];
        <span class="hljs-keyword">var</span> x = obj[i];
        <span class="hljs-keyword">if</span> (pred(x, i, obj)) {
          <span class="hljs-keyword">return</span> Option.some(x);
        }
      }
      <span class="hljs-keyword">return</span> Option.none();
    };

    <span class="hljs-comment">/** values :: JsObj(k, v) -&gt; [v] */</span>
    <span class="hljs-keyword">var</span> values = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
      <span class="hljs-keyword">return</span> mapToArray(obj, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
        <span class="hljs-keyword">return</span> v;
      });
    };

    <span class="hljs-keyword">var</span> size = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
      <span class="hljs-keyword">return</span> values(obj).length;
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">bifilter</span>: bifilter,
      <span class="hljs-attr">each</span>: each,
      <span class="hljs-attr">map</span>: objectMap,
      <span class="hljs-attr">mapToArray</span>: mapToArray,
      <span class="hljs-attr">tupleMap</span>: tupleMap,
      <span class="hljs-attr">find</span>: find,
      <span class="hljs-attr">keys</span>: keys,
      <span class="hljs-attr">values</span>: values,
      <span class="hljs-attr">size</span>: size
    };
  }
);
define(
  <span class="hljs-string">'ephox.katamari.api.Type'</span>,

  [
    <span class="hljs-string">'global!Array'</span>,
    <span class="hljs-string">'global!String'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Array, String</span>) </span>{
    <span class="hljs-keyword">var</span> typeOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
      <span class="hljs-keyword">if</span> (x === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'null'</span>;
      <span class="hljs-keyword">var</span> t = <span class="hljs-keyword">typeof</span> x;
      <span class="hljs-keyword">if</span> (t === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-built_in">Array</span>.prototype.isPrototypeOf(x)) <span class="hljs-keyword">return</span> <span class="hljs-string">'array'</span>;
      <span class="hljs-keyword">if</span> (t === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-built_in">String</span>.prototype.isPrototypeOf(x)) <span class="hljs-keyword">return</span> <span class="hljs-string">'string'</span>;
      <span class="hljs-keyword">return</span> t;
    };

    <span class="hljs-keyword">var</span> isType = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> typeOf(value) === type;
      };
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">isString</span>: isType(<span class="hljs-string">'string'</span>),
      <span class="hljs-attr">isObject</span>: isType(<span class="hljs-string">'object'</span>),
      <span class="hljs-attr">isArray</span>: isType(<span class="hljs-string">'array'</span>),
      <span class="hljs-attr">isNull</span>: isType(<span class="hljs-string">'null'</span>),
      <span class="hljs-attr">isBoolean</span>: isType(<span class="hljs-string">'boolean'</span>),
      <span class="hljs-attr">isUndefined</span>: isType(<span class="hljs-string">'undefined'</span>),
      <span class="hljs-attr">isFunction</span>: isType(<span class="hljs-string">'function'</span>),
      <span class="hljs-attr">isNumber</span>: isType(<span class="hljs-string">'number'</span>)
    };
  }
);


define(
  <span class="hljs-string">'ephox.katamari.util.BagUtils'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Type'</span>,
    <span class="hljs-string">'global!Error'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Type, Error</span>) </span>{
    <span class="hljs-keyword">var</span> sort = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>{
      <span class="hljs-keyword">return</span> arr.slice(<span class="hljs-number">0</span>).sort();
    };

    <span class="hljs-keyword">var</span> reqMessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">required, keys</span>) </span>{
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'All required keys ('</span> + sort(required).join(<span class="hljs-string">', '</span>) + <span class="hljs-string">') were not specified. Specified keys were: '</span> + sort(keys).join(<span class="hljs-string">', '</span>) + <span class="hljs-string">'.'</span>);
    };

    <span class="hljs-keyword">var</span> unsuppMessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">unsupported</span>) </span>{
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unsupported keys for object: '</span> + sort(unsupported).join(<span class="hljs-string">', '</span>));
    };

    <span class="hljs-keyword">var</span> validateStrArr = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">label, array</span>) </span>{
      <span class="hljs-keyword">if</span> (!Type.isArray(array)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'The '</span> + label + <span class="hljs-string">' fields must be an array. Was: '</span> + array + <span class="hljs-string">'.'</span>);
      Arr.each(array, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
        <span class="hljs-keyword">if</span> (!Type.isString(a)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'The value '</span> + a + <span class="hljs-string">' in the '</span> + label + <span class="hljs-string">' fields was not a string.'</span>);
      });
    };

    <span class="hljs-keyword">var</span> invalidTypeMessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">incorrect, type</span>) </span>{
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'All values need to be of type: '</span> + type + <span class="hljs-string">'. Keys ('</span> + sort(incorrect).join(<span class="hljs-string">', '</span>) + <span class="hljs-string">') were not.'</span>);
    };

    <span class="hljs-keyword">var</span> checkDupes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">everything</span>) </span>{
      <span class="hljs-keyword">var</span> sorted = sort(everything);
      <span class="hljs-keyword">var</span> dupe = Arr.find(sorted, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s, i</span>) </span>{
        <span class="hljs-keyword">return</span> i &lt; sorted.length <span class="hljs-number">-1</span> &amp;&amp; s === sorted[i + <span class="hljs-number">1</span>];
      });

      dupe.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'The field: '</span> + d + <span class="hljs-string">' occurs more than once in the combined fields: ['</span> + sorted.join(<span class="hljs-string">', '</span>) + <span class="hljs-string">'].'</span>);
      });
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">sort</span>: sort,
      <span class="hljs-attr">reqMessage</span>: reqMessage,
      <span class="hljs-attr">unsuppMessage</span>: unsuppMessage,
      <span class="hljs-attr">validateStrArr</span>: validateStrArr,
      <span class="hljs-attr">invalidTypeMessage</span>: invalidTypeMessage,
      <span class="hljs-attr">checkDupes</span>: checkDupes
    };
  }
);
define(
  <span class="hljs-string">'ephox.katamari.data.MixedBag'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.katamari.api.Obj'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'ephox.katamari.util.BagUtils'</span>,
    <span class="hljs-string">'global!Error'</span>,
    <span class="hljs-string">'global!Object'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Fun, Obj, Option, BagUtils, Error, Object</span>) </span>{
    
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">required, optional</span>) </span>{
      <span class="hljs-keyword">var</span> everything = required.concat(optional);
      <span class="hljs-keyword">if</span> (everything.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'You must specify at least one required or optional field.'</span>);

      BagUtils.validateStrArr(<span class="hljs-string">'required'</span>, required);
      BagUtils.validateStrArr(<span class="hljs-string">'optional'</span>, optional);

      BagUtils.checkDupes(everything);

      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
        <span class="hljs-keyword">var</span> keys = Obj.keys(obj);</pre></div></div>
            
        </li>
        
        
        <li id="section-1190">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1190">&#182;</a>
              </div>
              <p>Ensure all required keys are present.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> allReqd = Arr.forall(required, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req</span>) </span>{
          <span class="hljs-keyword">return</span> Arr.contains(keys, req);
        });

        <span class="hljs-keyword">if</span> (! allReqd) BagUtils.reqMessage(required, keys);

        <span class="hljs-keyword">var</span> unsupported = Arr.filter(keys, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
          <span class="hljs-keyword">return</span> !Arr.contains(everything, key);
        });

        <span class="hljs-keyword">if</span> (unsupported.length &gt; <span class="hljs-number">0</span>) BagUtils.unsuppMessage(unsupported);

        <span class="hljs-keyword">var</span> r = {};
        Arr.each(required, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req</span>) </span>{
          r[req] = Fun.constant(obj[req]);
        });

        Arr.each(optional, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">opt</span>) </span>{
          r[opt] = Fun.constant(<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, opt) ? Option.some(obj[opt]): Option.none());
        });

        <span class="hljs-keyword">return</span> r;
      };
    };
  }
);
define(
  <span class="hljs-string">'ephox.katamari.api.Struct'</span>,

  [
    <span class="hljs-string">'ephox.katamari.data.Immutable'</span>,
    <span class="hljs-string">'ephox.katamari.data.MixedBag'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Immutable, MixedBag</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">immutable</span>: Immutable,
      <span class="hljs-attr">immutableBag</span>: MixedBag
    };
  }
);

define(
  <span class="hljs-string">'ephox.katamari.api.Global'</span>,

  [
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">'return this;'</span>)();
  }
);


define(
  <span class="hljs-string">'ephox.katamari.api.Resolve'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Global'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Global</span>) </span>{
    <span class="hljs-comment">/** path :: ([String], JsObj?) -&gt; JsObj */</span>
    <span class="hljs-keyword">var</span> path = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parts, scope</span>) </span>{
      <span class="hljs-keyword">var</span> o = scope !== <span class="hljs-literal">undefined</span> ? scope : Global;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; parts.length &amp;&amp; o !== <span class="hljs-literal">undefined</span> &amp;&amp; o !== <span class="hljs-literal">null</span>; ++i)
        o = o[parts[i]];
      <span class="hljs-keyword">return</span> o;
    };

    <span class="hljs-comment">/** resolve :: (String, JsObj?) -&gt; JsObj */</span>
    <span class="hljs-keyword">var</span> resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">p, scope</span>) </span>{
      <span class="hljs-keyword">var</span> parts = p.split(<span class="hljs-string">'.'</span>);
      <span class="hljs-keyword">return</span> path(parts, scope);
    };

    <span class="hljs-comment">/** step :: (JsObj, String) -&gt; JsObj */</span>
    <span class="hljs-keyword">var</span> step = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o, part</span>) </span>{
      <span class="hljs-keyword">if</span> (o[part] === <span class="hljs-literal">undefined</span> || o[part] === <span class="hljs-literal">null</span>)
        o[part] = {};
      <span class="hljs-keyword">return</span> o[part];
    };

    <span class="hljs-comment">/** forge :: ([String], JsObj?) -&gt; JsObj */</span>
    <span class="hljs-keyword">var</span> forge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parts, target</span>) </span>{
      <span class="hljs-keyword">var</span> o = target !== <span class="hljs-literal">undefined</span> ? target : Global;      
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; parts.length; ++i)
        o = step(o, parts[i]);
      <span class="hljs-keyword">return</span> o;
    };

    <span class="hljs-comment">/** namespace :: (String, JsObj?) -&gt; JsObj */</span>
    <span class="hljs-keyword">var</span> namespace = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, target</span>) </span>{
      <span class="hljs-keyword">var</span> parts = name.split(<span class="hljs-string">'.'</span>);
      <span class="hljs-keyword">return</span> forge(parts, target);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">path</span>: path,
      <span class="hljs-attr">resolve</span>: resolve,
      <span class="hljs-attr">forge</span>: forge,
      <span class="hljs-attr">namespace</span>: namespace
    };
  }
);


define(
  <span class="hljs-string">'ephox.sand.util.Global'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Resolve'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Resolve</span>) </span>{
    <span class="hljs-keyword">var</span> unsafe = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, scope</span>) </span>{
      <span class="hljs-keyword">return</span> Resolve.resolve(name, scope);
    };

    <span class="hljs-keyword">var</span> getOrDie = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, scope</span>) </span>{
      <span class="hljs-keyword">var</span> actual = unsafe(name, scope);

      <span class="hljs-keyword">if</span> (actual === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">throw</span> name + <span class="hljs-string">' not available on this browser'</span>;
      <span class="hljs-keyword">return</span> actual;
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">getOrDie</span>: getOrDie
    };
  }
);
define(
  <span class="hljs-string">'ephox.sand.api.Node'</span>,

  [
    <span class="hljs-string">'ephox.sand.util.Global'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Global</span>) </span>{
    <span class="hljs-comment">/*
     * MDN says (yes) for IE, but it's undefined on IE8
     */</span>
    <span class="hljs-keyword">var</span> node = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> f = Global.getOrDie(<span class="hljs-string">'Node'</span>);
      <span class="hljs-keyword">return</span> f;
    };

    <span class="hljs-comment">/*
     * Most of numerosity doesn't alter the methods on the object.
     * We're making an exception for Node, because bitwise and is so easy to get wrong.
     *
     * Might be nice to ADT this at some point instead of having individual methods.
     */</span>

    <span class="hljs-keyword">var</span> compareDocumentPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, match</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1191">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1191">&#182;</a>
              </div>
              <p>Returns: 0 if e1 and e2 are the same node, or a bitmask comparing the positions
of nodes e1 and e2 in their documents. See the URL below for bitmask interpretation
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition">https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> (a.compareDocumentPosition(b) &amp; match) !== <span class="hljs-number">0</span>;
    };

    <span class="hljs-keyword">var</span> documentPositionPreceding = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
      <span class="hljs-keyword">return</span> compareDocumentPosition(a, b, node().DOCUMENT_POSITION_PRECEDING);
    };

    <span class="hljs-keyword">var</span> documentPositionContainedBy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
      <span class="hljs-keyword">return</span> compareDocumentPosition(a, b, node().DOCUMENT_POSITION_CONTAINED_BY);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">documentPositionPreceding</span>: documentPositionPreceding,
      <span class="hljs-attr">documentPositionContainedBy</span>: documentPositionContainedBy
    };
  }
);
define(
  <span class="hljs-string">'ephox.katamari.api.Thunk'</span>,

  [
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">var</span> cached = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
      <span class="hljs-keyword">var</span> called = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> r;
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!called) {
          called = <span class="hljs-literal">true</span>;
          r = f.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>);
        }
        <span class="hljs-keyword">return</span> r;
      };
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">cached</span>: cached
    };
  }
);

defineGlobal(<span class="hljs-string">"global!Number"</span>, <span class="hljs-built_in">Number</span>);
define(
  <span class="hljs-string">'ephox.sand.detect.Version'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'global!Number'</span>,
    <span class="hljs-string">'global!String'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Number, String</span>) </span>{
    <span class="hljs-keyword">var</span> firstMatch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">regexes, s</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; regexes.length; i++) {
        <span class="hljs-keyword">var</span> x = regexes[i];
        <span class="hljs-keyword">if</span> (x.test(s)) <span class="hljs-keyword">return</span> x;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    };

    <span class="hljs-keyword">var</span> find = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">regexes, agent</span>) </span>{
      <span class="hljs-keyword">var</span> r = firstMatch(regexes, agent);
      <span class="hljs-keyword">if</span> (!r) <span class="hljs-keyword">return</span> { <span class="hljs-attr">major</span> : <span class="hljs-number">0</span>, <span class="hljs-attr">minor</span> : <span class="hljs-number">0</span> };
      <span class="hljs-keyword">var</span> group = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(agent.replace(r, <span class="hljs-string">'$'</span> + i));
      };
      <span class="hljs-keyword">return</span> nu(group(<span class="hljs-number">1</span>), group(<span class="hljs-number">2</span>));
    };

    <span class="hljs-keyword">var</span> detect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">versionRegexes, agent</span>) </span>{
      <span class="hljs-keyword">var</span> cleanedAgent = <span class="hljs-built_in">String</span>(agent).toLowerCase();

      <span class="hljs-keyword">if</span> (versionRegexes.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> unknown();
      <span class="hljs-keyword">return</span> find(versionRegexes, cleanedAgent);
    };

    <span class="hljs-keyword">var</span> unknown = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> nu(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    };

    <span class="hljs-keyword">var</span> nu = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">major, minor</span>) </span>{
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">major</span>: major, <span class="hljs-attr">minor</span>: minor };
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">nu</span>: nu,
      <span class="hljs-attr">detect</span>: detect,
      <span class="hljs-attr">unknown</span>: unknown
    };
  }
);
define(
  <span class="hljs-string">'ephox.sand.core.Browser'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.sand.detect.Version'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, Version</span>) </span>{
    <span class="hljs-keyword">var</span> edge = <span class="hljs-string">'Edge'</span>;
    <span class="hljs-keyword">var</span> chrome = <span class="hljs-string">'Chrome'</span>;
    <span class="hljs-keyword">var</span> ie = <span class="hljs-string">'IE'</span>;
    <span class="hljs-keyword">var</span> opera = <span class="hljs-string">'Opera'</span>;
    <span class="hljs-keyword">var</span> firefox = <span class="hljs-string">'Firefox'</span>;
    <span class="hljs-keyword">var</span> safari = <span class="hljs-string">'Safari'</span>;

    <span class="hljs-keyword">var</span> isBrowser = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, current</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> current === name;
      };
    };

    <span class="hljs-keyword">var</span> unknown = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> nu({
        <span class="hljs-attr">current</span>: <span class="hljs-literal">undefined</span>,
        <span class="hljs-attr">version</span>: Version.unknown()
      });
    };

    <span class="hljs-keyword">var</span> nu = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">info</span>) </span>{
      <span class="hljs-keyword">var</span> current = info.current;
      <span class="hljs-keyword">var</span> version = info.version;

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">current</span>: current,
        <span class="hljs-attr">version</span>: version,</pre></div></div>
            
        </li>
        
        
        <li id="section-1192">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1192">&#182;</a>
              </div>
              <p>INVESTIGATE: Rename to Edge ?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        isEdge: isBrowser(edge, current),
        <span class="hljs-attr">isChrome</span>: isBrowser(chrome, current),</pre></div></div>
            
        </li>
        
        
        <li id="section-1193">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1193">&#182;</a>
              </div>
              <p>NOTE: isIe just looks too weird</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        isIE: isBrowser(ie, current),
        <span class="hljs-attr">isOpera</span>: isBrowser(opera, current),
        <span class="hljs-attr">isFirefox</span>: isBrowser(firefox, current),
        <span class="hljs-attr">isSafari</span>: isBrowser(safari, current)
      };
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">unknown</span>: unknown,
      <span class="hljs-attr">nu</span>: nu,
      <span class="hljs-attr">edge</span>: Fun.constant(edge),
      <span class="hljs-attr">chrome</span>: Fun.constant(chrome),
      <span class="hljs-attr">ie</span>: Fun.constant(ie),
      <span class="hljs-attr">opera</span>: Fun.constant(opera),
      <span class="hljs-attr">firefox</span>: Fun.constant(firefox),
      <span class="hljs-attr">safari</span>: Fun.constant(safari)
    };
  }
);
define(
  <span class="hljs-string">'ephox.sand.core.OperatingSystem'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.sand.detect.Version'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, Version</span>) </span>{
    <span class="hljs-keyword">var</span> windows = <span class="hljs-string">'Windows'</span>;
    <span class="hljs-keyword">var</span> ios = <span class="hljs-string">'iOS'</span>;
    <span class="hljs-keyword">var</span> android = <span class="hljs-string">'Android'</span>;
    <span class="hljs-keyword">var</span> linux = <span class="hljs-string">'Linux'</span>;
    <span class="hljs-keyword">var</span> osx = <span class="hljs-string">'OSX'</span>;
    <span class="hljs-keyword">var</span> solaris = <span class="hljs-string">'Solaris'</span>;
    <span class="hljs-keyword">var</span> freebsd = <span class="hljs-string">'FreeBSD'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1194">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1194">&#182;</a>
              </div>
              <p>Though there is a bit of dupe with this and Browser, trying to 
reuse code makes it much harder to follow and change.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> isOS = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, current</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> current === name;
      };
    };

    <span class="hljs-keyword">var</span> unknown = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> nu({
        <span class="hljs-attr">current</span>: <span class="hljs-literal">undefined</span>,
        <span class="hljs-attr">version</span>: Version.unknown()
      });
    };

    <span class="hljs-keyword">var</span> nu = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">info</span>) </span>{
      <span class="hljs-keyword">var</span> current = info.current;
      <span class="hljs-keyword">var</span> version = info.version;

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">current</span>: current,
        <span class="hljs-attr">version</span>: version,

        <span class="hljs-attr">isWindows</span>: isOS(windows, current),</pre></div></div>
            
        </li>
        
        
        <li id="section-1195">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1195">&#182;</a>
              </div>
              <p>TODO: Fix capitalisation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        isiOS: isOS(ios, current),
        <span class="hljs-attr">isAndroid</span>: isOS(android, current),
        <span class="hljs-attr">isOSX</span>: isOS(osx, current),
        <span class="hljs-attr">isLinux</span>: isOS(linux, current),
        <span class="hljs-attr">isSolaris</span>: isOS(solaris, current),
        <span class="hljs-attr">isFreeBSD</span>: isOS(freebsd, current)
      };
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">unknown</span>: unknown,
      <span class="hljs-attr">nu</span>: nu,

      <span class="hljs-attr">windows</span>: Fun.constant(windows),
      <span class="hljs-attr">ios</span>: Fun.constant(ios),
      <span class="hljs-attr">android</span>: Fun.constant(android),
      <span class="hljs-attr">linux</span>: Fun.constant(linux),
      <span class="hljs-attr">osx</span>: Fun.constant(osx),
      <span class="hljs-attr">solaris</span>: Fun.constant(solaris),
      <span class="hljs-attr">freebsd</span>: Fun.constant(freebsd)
    };
  }
);
define(
  <span class="hljs-string">'ephox.sand.detect.DeviceType'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">os, browser, userAgent</span>) </span>{
      <span class="hljs-keyword">var</span> isiPad = os.isiOS() &amp;&amp; <span class="hljs-regexp">/ipad/i</span>.test(userAgent) === <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">var</span> isiPhone = os.isiOS() &amp;&amp; !isiPad;
      <span class="hljs-keyword">var</span> isAndroid3 = os.isAndroid() &amp;&amp; os.version.major === <span class="hljs-number">3</span>;
      <span class="hljs-keyword">var</span> isAndroid4 = os.isAndroid() &amp;&amp; os.version.major === <span class="hljs-number">4</span>;
      <span class="hljs-keyword">var</span> isTablet = isiPad || isAndroid3 || ( isAndroid4 &amp;&amp; <span class="hljs-regexp">/mobile/i</span>.test(userAgent) === <span class="hljs-literal">true</span> );
      <span class="hljs-keyword">var</span> isTouch = os.isiOS() || os.isAndroid();
      <span class="hljs-keyword">var</span> isPhone = isTouch &amp;&amp; !isTablet;

      <span class="hljs-keyword">var</span> iOSwebview = browser.isSafari() &amp;&amp; os.isiOS() &amp;&amp; <span class="hljs-regexp">/safari/i</span>.test(userAgent) === <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">isiPad</span> : Fun.constant(isiPad),
        <span class="hljs-attr">isiPhone</span>: Fun.constant(isiPhone),
        <span class="hljs-attr">isTablet</span>: Fun.constant(isTablet),
        <span class="hljs-attr">isPhone</span>: Fun.constant(isPhone),
        <span class="hljs-attr">isTouch</span>: Fun.constant(isTouch),
        <span class="hljs-attr">isAndroid</span>: os.isAndroid,
        <span class="hljs-attr">isiOS</span>: os.isiOS,
        <span class="hljs-attr">isWebView</span>: Fun.constant(iOSwebview)
      };
    };
  }
);
define(
  <span class="hljs-string">'ephox.sand.detect.UaString'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.sand.detect.Version'</span>,
    <span class="hljs-string">'global!String'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Version, String</span>) </span>{
    <span class="hljs-keyword">var</span> detect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">candidates, userAgent</span>) </span>{
      <span class="hljs-keyword">var</span> agent = <span class="hljs-built_in">String</span>(userAgent).toLowerCase();
      <span class="hljs-keyword">return</span> Arr.find(candidates, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">candidate</span>) </span>{
        <span class="hljs-keyword">return</span> candidate.search(agent);
      });
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-1196">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1196">&#182;</a>
              </div>
              <p>They (browser and os) are the same at the moment, but they might
not stay that way.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    var detectBrowser = function (browsers, userAgent) {
      return detect(browsers, userAgent).map(function (browser) {
        var version = Version.detect(browser.versionRegexes, userAgent);
        return {
          current: browser.name,
          version: version
        };
      });
    };

    var detectOs = function (oses, userAgent) {
      return detect(oses, userAgent).map(function (os) {
        var version = Version.detect(os.versionRegexes, userAgent);
        return {
          current: os.name,
          version: version
        };
      });
    };

    return {
      detectBrowser: detectBrowser,
      detectOs: detectOs
    };
  }
);
define(
  'ephox.katamari.str.StrAppend',

  [

  ],

  function () {
    var addToStart = function (str, prefix) {
      return prefix + str;
    };

    var addToEnd = function (str, suffix) {
      return str + suffix;
    };

    var removeFromStart = function (str, numChars) {
      return str.substring(numChars);
    };

    var removeFromEnd = function (str, numChars) {
      return str.substring(0, str.length - numChars);
    };
 
    return {
      addToStart: addToStart,
      addToEnd: addToEnd,
      removeFromStart: removeFromStart,
      removeFromEnd: removeFromEnd
    };
  }
);
define(
  'ephox.katamari.str.StringParts',

  [
    'ephox.katamari.api.Option',
    'global!Error'
  ],

  function (Option, Error) {
    /** Return the first 'count' letters from 'str'.
-     *  e.g. first("abcde", 2) === "ab"
-     */
    var first = function(str, count) {
     return str.substr(0, count);
    };

    /** Return the last 'count' letters from 'str'.
    *  e.g. last("abcde", 2) === "de"
    */
    var last = function(str, count) {
     return str.substr(str.length - count, str.length);
    };

    var head = function(str) {
      return str === '' ? Option.none() : Option.some(str.substr(0, 1));
    };

    var tail = function(str) {
      return str === '' ? Option.none() : Option.some(str.substring(1));
    };

    return {
      first: first,
      last: last,
      head: head,
      tail: tail
    };
  }
);
define(
  'ephox.katamari.api.Strings',

  [
    'ephox.katamari.str.StrAppend',
    'ephox.katamari.str.StringParts',
    'global!Error'
  ],

  function (StrAppend, StringParts, Error) {
    var checkRange = function(str, substr, start) {
      if (substr === '') return true;
      if (str.length &lt; substr.length) return false;
      var x = str.substr(start, start + substr.length);
      return x === substr;
    };

    /** Given a string and object, perform template-replacements on the string, as specified by the object.
     * Any template fields of the form ${name} are replaced by the string or number specified as obj["name"]
     * Based on Douglas Crockford's 'supplant' method for template-replace of strings. Uses different template format.
     */
    var supplant = function(str, obj) {
      var isStringOrNumber = function(a) {
        var t = typeof a;
        return t === 'string' || t === 'number';
      };

      return str.replace(/\${([^{}]*)}/g,
        function (a, b) {
          var value = obj[b];
          return isStringOrNumber(value) ? value : a;
        }
      );
    };

    var removeLeading = function (str, prefix) {
      return startsWith(str, prefix) ? StrAppend.removeFromStart(str, prefix.length) : str;
    };

    var removeTrailing = function (str, prefix) {
      return endsWith(str, prefix) ? StrAppend.removeFromEnd(str, prefix.length) : str;
    };

    var ensureLeading = function (str, prefix) {
      return startsWith(str, prefix) ? str : StrAppend.addToStart(str, prefix);
    };

    var ensureTrailing = function (str, prefix) {
      return endsWith(str, prefix) ? str : StrAppend.addToEnd(str, prefix);
    };
 
    var contains = function(str, substr) {
      return str.indexOf(substr) !== -1;
    };

    var capitalize = function(str) {
      return StringParts.head(str).bind(function (head) {
        return StringParts.tail(str).map(function (tail) {
          return head.toUpperCase() + tail;
        });
      }).getOr(str);
    };

    /** Does 'str' start with 'prefix'?
     *  Note: all strings start with the empty string.
     *        More formally, for all strings x, startsWith(x, "").
     *        This is so that for all strings x and y, startsWith(y + x, y)
     */
    var startsWith = function(str, prefix) {
      return checkRange(str, prefix, 0);
    };

    /** Does 'str' end with 'suffix'?
     *  Note: all strings end with the empty string.
     *        More formally, for all strings x, endsWith(x, "").
     *        This is so that for all strings x and y, endsWith(x + y, y)
     */
    var endsWith = function(str, suffix) {
      return checkRange(str, suffix, str.length - suffix.length);
    };

   
    /** removes all leading and trailing spaces */
    var trim = function(str) {
      return str.replace(/^\s+|\s+$/g, '');
    };

    var lTrim = function(str) {
      return str.replace(/^\s+/g, '');
    };

    var rTrim = function(str) {
      return str.replace(/\s+$/g, '');
    };

    return {
      supplant: supplant,
      startsWith: startsWith,
      removeLeading: removeLeading,
      removeTrailing: removeTrailing,
      ensureLeading: ensureLeading,
      ensureTrailing: ensureTrailing,
      endsWith: endsWith,
      contains: contains,
      trim: trim,
      lTrim: lTrim,
      rTrim: rTrim,
      capitalize: capitalize
    };
  }
);

define(
  'ephox.sand.info.PlatformInfo',

  [
    'ephox.katamari.api.Fun',
    'ephox.katamari.api.Strings'
  ],

  function (Fun, Strings) {
    var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;

    var checkContains = function (target) {
      return function (uastring) {
        return Strings.contains(uastring, target);
      };
    };

    var browsers = [
      {
        name : 'Edge',
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: function (uastring) {
          var monstrosity = Strings.contains(uastring, 'edge/') &amp;&amp; Strings.contains(uastring, 'chrome') &amp;&amp; Strings.contains(uastring, 'safari') &amp;&amp; Strings.contains(uastring, 'applewebkit');
          return monstrosity;
        }
      },
      {
        name : 'Chrome',
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, normalVersionRegex],
        search : function (uastring) {
          return Strings.contains(uastring, 'chrome') &amp;&amp; !Strings.contains(uastring, 'chromeframe');
        }
      },
      {
        name : 'IE',
        versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
        search: function (uastring) {
          return Strings.contains(uastring, 'msie') || Strings.contains(uastring, 'trident');
        }
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-1197">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1197">&#182;</a>
              </div>
              <p>INVESTIGATE: Is this still the Opera user agent?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      {
        name : 'Opera',
        versionRegexes: [normalVersionRegex, /.*?opera\/([0-9]+)\.([0-9]+).*/],
        search : checkContains('opera')
      },
      {
        name : 'Firefox',
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search : checkContains('firefox')
      },
      {
        name : 'Safari',
        versionRegexes: [normalVersionRegex, /.*?cpu os ([0-9]+)_([0-9]+).*/],
        search : function (uastring) {
          return (Strings.contains(uastring, 'safari') || Strings.contains(uastring, 'mobile/')) &amp;&amp; Strings.contains(uastring, 'applewebkit');
        }
      }
    ];

    var oses = [
      {
        name : 'Windows',
        search : checkContains('win'),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name : 'iOS',
        search : function (uastring) {
          return Strings.contains(uastring, 'iphone') || Strings.contains(uastring, 'ipad');
        },
        versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
      },
      {
        name : 'Android',
        search : checkContains('android'),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name : 'OSX',
        search : checkContains('os x'),
        versionRegexes: [/.*?os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name : 'Linux',
        search : checkContains('linux'),
        versionRegexes: [ ]
      },
      { name : 'Solaris',
        search : checkContains('sunos'),
        versionRegexes: [ ]
      },
      {
       name : 'FreeBSD',
       search : checkContains('freebsd'),
       versionRegexes: [ ]
      }
    ];

    return {
      browsers: Fun.constant(browsers),
      oses: Fun.constant(oses)
    };
  }
);
define(
  'ephox.sand.core.PlatformDetection',

  [
    'ephox.sand.core.Browser',
    'ephox.sand.core.OperatingSystem',
    'ephox.sand.detect.DeviceType',
    'ephox.sand.detect.UaString',
    'ephox.sand.info.PlatformInfo'
  ],

  function (Browser, OperatingSystem, DeviceType, UaString, PlatformInfo) {
    var detect = function (userAgent) {
      var browsers = PlatformInfo.browsers();
      var oses = PlatformInfo.oses();

      var browser = UaString.detectBrowser(browsers, userAgent).fold(
        Browser.unknown,
        Browser.nu
      );
      var os = UaString.detectOs(oses, userAgent).fold(
        OperatingSystem.unknown,
        OperatingSystem.nu
      );
      var deviceType = DeviceType(os, browser, userAgent);

      return {
        browser: browser,
        os: os,
        deviceType: deviceType
      };
    };

    return {
      detect: detect
    };
  }
);
defineGlobal("global!navigator", navigator);
define(
  'ephox.sand.api.PlatformDetection',

  [
    'ephox.katamari.api.Thunk',
    'ephox.sand.core.PlatformDetection',
    'global!navigator'
  ],

  function (Thunk, PlatformDetection, navigator) {
    var detect = Thunk.cached(function () {
      var userAgent = navigator.userAgent;
      return PlatformDetection.detect(userAgent);
    });

    return {
      detect: detect
    };
  }
);
define("global!console", [], function () { if (typeof console === "undefined") console = { log: function () {} }; return console; });
defineGlobal("global!document", document);
define(
  'ephox.sugar.api.node.Element',

  [
    'ephox.katamari.api.Fun',
    'global!Error',
    'global!console',
    'global!document'
  ],

  function (Fun, Error, console, document) {
    var fromHtml = function (html, scope) {
      var doc = scope || document;
      var div = doc.createElement('div');
      div.innerHTML = html;
      if (!div.hasChildNodes() || div.childNodes.length &gt; 1) {
        console.error('HTML does not have a single root node', html);
        throw 'HTML must have a single root node';
      }
      return fromDom(div.childNodes[0]);
    };

    var fromTag = function (tag, scope) {
      var doc = scope || document;
      var node = doc.createElement(tag);
      return fromDom(node);
    };

    var fromText = function (text, scope) {
      var doc = scope || document;
      var node = doc.createTextNode(text);
      return fromDom(node);
    };

    var fromDom = function (node) {
      if (node === null || node === undefined) throw new Error('Node cannot be null or undefined');
      return {
        dom: Fun.constant(node)
      };
    };

    return {
      fromHtml: fromHtml,
      fromTag: fromTag,
      fromText: fromText,
      fromDom: fromDom
    };
  }
);

define(
  'ephox.sugar.api.node.NodeTypes',

  [

  ],

  function () {
    return {
      ATTRIBUTE:              2,
      CDATA_SECTION:          4,
      COMMENT:                8,
      DOCUMENT:               9,
      DOCUMENT_TYPE:          10,
      DOCUMENT_FRAGMENT:      11,
      ELEMENT:                1,
      TEXT:                   3,
      PROCESSING_INSTRUCTION: 7,
      ENTITY_REFERENCE:       5,
      ENTITY:                 6,
      NOTATION:               12
    };
  }
);
define(
  'ephox.sugar.api.search.Selectors',

  [
    'ephox.katamari.api.Arr',
    'ephox.katamari.api.Option',
    'ephox.sugar.api.node.Element',
    'ephox.sugar.api.node.NodeTypes',
    'global!Error',
    'global!document'
  ],

  function (Arr, Option, Element, NodeTypes, Error, document) {
    /*
     * There's a lot of code here; the aim is to allow the browser to optimise constant comparisons,
     * instead of doing object lookup feature detection on every call
     */
    var STANDARD = 0;
    var MSSTANDARD = 1;
    var WEBKITSTANDARD = 2;
    var FIREFOXSTANDARD = 3;

    var selectorType = (function () {
      var test = document.createElement('span');</pre></div></div>
            
        </li>
        
        
        <li id="section-1198">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1198">&#182;</a>
              </div>
              <p>As of Chrome 34 / Safari 7.1 / FireFox 34, everyone except IE has the unprefixed function.
Still check for the others, but do it last.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> test.matches !== <span class="hljs-literal">undefined</span> ? STANDARD :
             test.msMatchesSelector !== <span class="hljs-literal">undefined</span> ? MSSTANDARD :
             test.webkitMatchesSelector !== <span class="hljs-literal">undefined</span> ? WEBKITSTANDARD :
             test.mozMatchesSelector !== <span class="hljs-literal">undefined</span> ? FIREFOXSTANDARD :
             <span class="hljs-number">-1</span>;
    })();


    <span class="hljs-keyword">var</span> ELEMENT = NodeTypes.ELEMENT;
    <span class="hljs-keyword">var</span> DOCUMENT = NodeTypes.DOCUMENT;

    <span class="hljs-keyword">var</span> is = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, selector</span>) </span>{
      <span class="hljs-keyword">var</span> elem = element.dom();
      <span class="hljs-keyword">if</span> (elem.nodeType !== ELEMENT) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// documents have querySelector but not matches</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1199">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1199">&#182;</a>
              </div>
              <p>As of Chrome 34 / Safari 7.1 / FireFox 34, everyone except IE has the unprefixed function.
Still check for the others, but do it last.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectorType === STANDARD) <span class="hljs-keyword">return</span> elem.matches(selector);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectorType === MSSTANDARD) <span class="hljs-keyword">return</span> elem.msMatchesSelector(selector);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectorType === WEBKITSTANDARD) <span class="hljs-keyword">return</span> elem.webkitMatchesSelector(selector);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectorType === FIREFOXSTANDARD) <span class="hljs-keyword">return</span> elem.mozMatchesSelector(selector);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Browser lacks native selectors'</span>); <span class="hljs-comment">// unfortunately we can't throw this on startup :(</span>
    };

    <span class="hljs-keyword">var</span> bypassSelector = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dom</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1200">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1200">&#182;</a>
              </div>
              <p>Only elements and documents support querySelector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> dom.nodeType !== ELEMENT &amp;&amp; dom.nodeType !== DOCUMENT ||</pre></div></div>
            
        </li>
        
        
        <li id="section-1201">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1201">&#182;</a>
              </div>
              <p>IE fix for complex queries on empty nodes: <a href="http://jsfiddle.net/spyder/fv9ptr5L/">http://jsfiddle.net/spyder/fv9ptr5L/</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              dom.childElementCount === <span class="hljs-number">0</span>;
    };

    <span class="hljs-keyword">var</span> all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector, scope</span>) </span>{
      <span class="hljs-keyword">var</span> base = scope === <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">document</span> : scope.dom();
      <span class="hljs-keyword">return</span> bypassSelector(base) ? [] : Arr.map(base.querySelectorAll(selector), Element.fromDom);
    };

    <span class="hljs-keyword">var</span> one = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector, scope</span>) </span>{
      <span class="hljs-keyword">var</span> base = scope === <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">document</span> : scope.dom();
      <span class="hljs-keyword">return</span> bypassSelector(base) ? Option.none() : Option.from(base.querySelector(selector)).map(Element.fromDom);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">all</span>: all,
      <span class="hljs-attr">is</span>: is,
      <span class="hljs-attr">one</span>: one
    };
  }
);

define(
  <span class="hljs-string">'ephox.sugar.api.dom.Compare'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.sand.api.Node'</span>,
    <span class="hljs-string">'ephox.sand.api.PlatformDetection'</span>,
    <span class="hljs-string">'ephox.sugar.api.search.Selectors'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Fun, Node, PlatformDetection, Selectors</span>) </span>{

    <span class="hljs-keyword">var</span> eq = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e1, e2</span>) </span>{
      <span class="hljs-keyword">return</span> e1.dom() === e2.dom();
    };

    <span class="hljs-keyword">var</span> isEqualNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e1, e2</span>) </span>{
      <span class="hljs-keyword">return</span> e1.dom().isEqualNode(e2.dom());
    };

    <span class="hljs-keyword">var</span> member = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, elements</span>) </span>{
      <span class="hljs-keyword">return</span> Arr.exists(elements, Fun.curry(eq, element));
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-1202">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1202">&#182;</a>
              </div>
              <p>DOM contains() method returns true if e1===e2, we define our contains() to return false (a node does not contain itself).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> regularContains = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e1, e2</span>) </span>{
      <span class="hljs-keyword">var</span> d1 = e1.dom(), d2 = e2.dom();
      <span class="hljs-keyword">return</span> d1 === d2 ? <span class="hljs-literal">false</span> : d1.contains(d2);
    };

    <span class="hljs-keyword">var</span> ieContains = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e1, e2</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1203">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1203">&#182;</a>
              </div>
              <p>IE only implements the contains() method for Element nodes.
It fails for Text nodes, so implement it using compareDocumentPosition()
<a href="https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect">https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect</a>
Note that compareDocumentPosition returns CONTAINED_BY if e2 <em>is_contained_by</em> e1:
Also, compareDocumentPosition defines a node containing itself as false.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> Node.documentPositionContainedBy(e1.dom(), e2.dom());
    };

    <span class="hljs-keyword">var</span> browser = PlatformDetection.detect().browser;</pre></div></div>
            
        </li>
        
        
        <li id="section-1204">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1204">&#182;</a>
              </div>
              <p>Returns: true if node e1 contains e2, otherwise false.
(returns false if e1===e2: A node does not contain itself).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> contains = browser.isIE() ? ieContains : regularContains;

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">eq</span>: eq,
      <span class="hljs-attr">isEqualNode</span>: isEqualNode,
      <span class="hljs-attr">member</span>: member,
      <span class="hljs-attr">contains</span>: contains,</pre></div></div>
            
        </li>
        
        
        <li id="section-1205">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1205">&#182;</a>
              </div>
              <p>Only used by DomUniverse. Remove (or should Selectors.is move here?)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      is: Selectors.is
    };
  }
);

define(
  <span class="hljs-string">'ephox.sugar.api.node.Node'</span>,

  [
    <span class="hljs-string">'ephox.sugar.api.node.NodeTypes'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">NodeTypes</span>) </span>{
    <span class="hljs-keyword">var</span> name = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">var</span> r = element.dom().nodeName;
      <span class="hljs-keyword">return</span> r.toLowerCase();
    };

    <span class="hljs-keyword">var</span> type = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">return</span> element.dom().nodeType;
    };

    <span class="hljs-keyword">var</span> value = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">return</span> element.dom().nodeValue;
    };

    <span class="hljs-keyword">var</span> isType = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
        <span class="hljs-keyword">return</span> type(element) === t;
      };
    };

    <span class="hljs-keyword">var</span> isComment = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">return</span> type(element) === NodeTypes.COMMENT || name(element) === <span class="hljs-string">'#comment'</span>;
    };

    <span class="hljs-keyword">var</span> isElement = isType(NodeTypes.ELEMENT);
    <span class="hljs-keyword">var</span> isText = isType(NodeTypes.TEXT);
    <span class="hljs-keyword">var</span> isDocument = isType(NodeTypes.DOCUMENT);

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">name</span>: name,
      <span class="hljs-attr">type</span>: type,
      <span class="hljs-attr">value</span>: value,
      <span class="hljs-attr">isElement</span>: isElement,
      <span class="hljs-attr">isText</span>: isText,
      <span class="hljs-attr">isDocument</span>: isDocument,
      <span class="hljs-attr">isComment</span>: isComment
    };
  }
);

define(
  <span class="hljs-string">'ephox.sugar.api.node.Body'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Thunk'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Element'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Node'</span>,
    <span class="hljs-string">'global!document'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Thunk, Element, Node, document</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1206">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1206">&#182;</a>
              </div>
              <p>Node.contains() is very, very, very good performance
<a href="http://jsperf.com/closest-vs-contains/5">http://jsperf.com/closest-vs-contains/5</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> inBody = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1207">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1207">&#182;</a>
              </div>
              <p>Technically this is only required on IE, where contains() returns false for text nodes.
But its cheap enough to run everywhere and Sugar doesnt have platform detection (yet).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> dom = Node.isText(element) ? element.dom().parentNode : element.dom();</pre></div></div>
            
        </li>
        
        
        <li id="section-1208">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1208">&#182;</a>
              </div>
              <p>use ownerDocument.body to ensure this works inside iframes.
Normally contains is bad because an element contains itself, but here we want that.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> dom !== <span class="hljs-literal">undefined</span> &amp;&amp; dom !== <span class="hljs-literal">null</span> &amp;&amp; dom.ownerDocument.body.contains(dom);
    };

    <span class="hljs-keyword">var</span> body = Thunk.cached(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> getBody(Element.fromDom(<span class="hljs-built_in">document</span>));
    });

    <span class="hljs-keyword">var</span> getBody = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
      <span class="hljs-keyword">var</span> body = doc.dom().body;
      <span class="hljs-keyword">if</span> (body === <span class="hljs-literal">null</span> || body === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">'Body is not available yet'</span>;
      <span class="hljs-keyword">return</span> Element.fromDom(body);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">body</span>: body,
      <span class="hljs-attr">getBody</span>: getBody,
      <span class="hljs-attr">inBody</span>: inBody
    };
  }
);

define(
  <span class="hljs-string">'ephox.sugar.impl.ClosestOrAncestor'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Type'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Type, Option</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">is, ancestor, scope, a, isRoot</span>) </span>{
      <span class="hljs-keyword">return</span> is(scope, a) ?
              Option.some(scope) :
              Type.isFunction(isRoot) &amp;&amp; isRoot(scope) ?
                  Option.none() :
                  ancestor(scope, a, isRoot);
    };
  }
);
define(
  <span class="hljs-string">'ephox.sugar.api.search.PredicateFind'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Type'</span>,
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Body'</span>,
    <span class="hljs-string">'ephox.sugar.api.dom.Compare'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Element'</span>,
    <span class="hljs-string">'ephox.sugar.impl.ClosestOrAncestor'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Type, Arr, Fun, Option, Body, Compare, Element, ClosestOrAncestor</span>) </span>{
    <span class="hljs-keyword">var</span> first = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">predicate</span>) </span>{
      <span class="hljs-keyword">return</span> descendant(Body.body(), predicate);
    };

    <span class="hljs-keyword">var</span> ancestor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, predicate, isRoot</span>) </span>{
      <span class="hljs-keyword">var</span> element = scope.dom();
      <span class="hljs-keyword">var</span> stop = Type.isFunction(isRoot) ? isRoot : Fun.constant(<span class="hljs-literal">false</span>);

      <span class="hljs-keyword">while</span> (element.parentNode) {
        element = element.parentNode;
        <span class="hljs-keyword">var</span> el = Element.fromDom(element);

        <span class="hljs-keyword">if</span> (predicate(el)) <span class="hljs-keyword">return</span> Option.some(el);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stop(el)) <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">return</span> Option.none();
    };

    <span class="hljs-keyword">var</span> closest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, predicate, isRoot</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1209">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1209">&#182;</a>
              </div>
              <p>This is required to avoid ClosestOrAncestor passing the predicate to itself</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> is = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope</span>) </span>{
        <span class="hljs-keyword">return</span> predicate(scope);
      };
      <span class="hljs-keyword">return</span> ClosestOrAncestor(is, ancestor, scope, predicate, isRoot);
    };

    <span class="hljs-keyword">var</span> sibling = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, predicate</span>) </span>{
      <span class="hljs-keyword">var</span> element = scope.dom();
      <span class="hljs-keyword">if</span> (!element.parentNode) <span class="hljs-keyword">return</span> Option.none();

      <span class="hljs-keyword">return</span> child(Element.fromDom(element.parentNode), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
        <span class="hljs-keyword">return</span> !Compare.eq(scope, x) &amp;&amp; predicate(x);
      });
    };

    <span class="hljs-keyword">var</span> child = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, predicate</span>) </span>{
      <span class="hljs-keyword">var</span> result = Arr.find(scope.dom().childNodes,
        Fun.compose(predicate, Element.fromDom));
      <span class="hljs-keyword">return</span> result.map(Element.fromDom);
    };

    <span class="hljs-keyword">var</span> descendant = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, predicate</span>) </span>{
      <span class="hljs-keyword">var</span> descend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; element.childNodes.length; i++) {
          <span class="hljs-keyword">if</span> (predicate(Element.fromDom(element.childNodes[i])))
            <span class="hljs-keyword">return</span> Option.some(Element.fromDom(element.childNodes[i]));

          <span class="hljs-keyword">var</span> res = descend(element.childNodes[i]);
          <span class="hljs-keyword">if</span> (res.isSome())
            <span class="hljs-keyword">return</span> res;
        }

        <span class="hljs-keyword">return</span> Option.none();
      };

      <span class="hljs-keyword">return</span> descend(scope.dom());
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">first</span>: first,
      <span class="hljs-attr">ancestor</span>: ancestor,
      <span class="hljs-attr">closest</span>: closest,
      <span class="hljs-attr">sibling</span>: sibling,
      <span class="hljs-attr">child</span>: child,
      <span class="hljs-attr">descendant</span>: descendant
    };
  }
);

define(
  <span class="hljs-string">'ephox.sugar.alien.Recurse'</span>,

  [

  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">/**
     * Applies f repeatedly until it completes (by returning Option.none()).
     *
     * Normally would just use recursion, but JavaScript lacks tail call optimisation.
     *
     * This is what recursion looks like when manually unravelled :)
     */</span>
    <span class="hljs-keyword">var</span> toArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, f</span>) </span>{
      <span class="hljs-keyword">var</span> r = [];

      <span class="hljs-keyword">var</span> recurse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        r.push(e);
        <span class="hljs-keyword">return</span> f(e);
      };

      <span class="hljs-keyword">var</span> cur = f(target);
      <span class="hljs-keyword">do</span> {
        cur = cur.bind(recurse);
      } <span class="hljs-keyword">while</span> (cur.isSome());

      <span class="hljs-keyword">return</span> r;
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">toArray</span>: toArray
    };
  }
);
define(
  <span class="hljs-string">'ephox.sugar.api.search.Traverse'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Type'</span>,
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'ephox.katamari.api.Struct'</span>,
    <span class="hljs-string">'ephox.sugar.alien.Recurse'</span>,
    <span class="hljs-string">'ephox.sugar.api.dom.Compare'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Element'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Type, Arr, Fun, Option, Struct, Recurse, Compare, Element</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1210">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1210">&#182;</a>
              </div>
              <p>The document associated with the current element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> owner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">return</span> Element.fromDom(element.dom().ownerDocument);
    };

    <span class="hljs-keyword">var</span> documentElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1211">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1211">&#182;</a>
              </div>
              <p>TODO: Avoid unnecessary wrap/unwrap here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> doc = owner(element);
      <span class="hljs-keyword">return</span> Element.fromDom(doc.dom().documentElement);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-1212">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1212">&#182;</a>
              </div>
              <p>The window element associated with the element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> defaultView = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">var</span> el = element.dom();
      <span class="hljs-keyword">var</span> defaultView = el.ownerDocument.defaultView;
      <span class="hljs-keyword">return</span> Element.fromDom(defaultView);
    };

    <span class="hljs-keyword">var</span> parent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">var</span> dom = element.dom();
      <span class="hljs-keyword">return</span> Option.from(dom.parentNode).map(Element.fromDom);
    };

    <span class="hljs-keyword">var</span> findIndex = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">return</span> parent(element).bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">p</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1213">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1213">&#182;</a>
              </div>
              <p>TODO: Refactor out children so we can avoid the constant unwrapping</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> kin = children(p);
        <span class="hljs-keyword">return</span> Arr.findIndex(kin, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
          <span class="hljs-keyword">return</span> Compare.eq(element, elem);
        });
      });
    };

    <span class="hljs-keyword">var</span> parents = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, isRoot</span>) </span>{
      <span class="hljs-keyword">var</span> stop = Type.isFunction(isRoot) ? isRoot : Fun.constant(<span class="hljs-literal">false</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1214">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1214">&#182;</a>
              </div>
              <p>This is used a <em>lot</em> so it needs to be performant, not recursive</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> dom = element.dom();
      <span class="hljs-keyword">var</span> ret = [];

      <span class="hljs-keyword">while</span> (dom.parentNode !== <span class="hljs-literal">null</span> &amp;&amp; dom.parentNode !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">var</span> rawParent = dom.parentNode;
        <span class="hljs-keyword">var</span> parent = Element.fromDom(rawParent);
        ret.push(parent);

        <span class="hljs-keyword">if</span> (stop(parent) === <span class="hljs-literal">true</span>) <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">else</span> dom = rawParent;
      }
      <span class="hljs-keyword">return</span> ret;
    };

    <span class="hljs-keyword">var</span> siblings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1215">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1215">&#182;</a>
              </div>
              <p>TODO: Refactor out children so we can just not add self instead of filtering afterwards</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> filterSelf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elements</span>) </span>{
        <span class="hljs-keyword">return</span> Arr.filter(elements, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
          <span class="hljs-keyword">return</span> !Compare.eq(element, x);
        });
      };

      <span class="hljs-keyword">return</span> parent(element).map(children).map(filterSelf).getOr([]);
    };

    <span class="hljs-keyword">var</span> offsetParent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">var</span> dom = element.dom();
      <span class="hljs-keyword">return</span> Option.from(dom.offsetParent).map(Element.fromDom);
    };

    <span class="hljs-keyword">var</span> prevSibling = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">var</span> dom = element.dom();
      <span class="hljs-keyword">return</span> Option.from(dom.previousSibling).map(Element.fromDom);
    };

    <span class="hljs-keyword">var</span> nextSibling = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">var</span> dom = element.dom();
      <span class="hljs-keyword">return</span> Option.from(dom.nextSibling).map(Element.fromDom);
    };

    <span class="hljs-keyword">var</span> prevSiblings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1216">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1216">&#182;</a>
              </div>
              <p>This one needs to be reversed, so theyre still in DOM order</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> Arr.reverse(Recurse.toArray(element, prevSibling));
    };

    <span class="hljs-keyword">var</span> nextSiblings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">return</span> Recurse.toArray(element, nextSibling);
    };

    <span class="hljs-keyword">var</span> children = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">var</span> dom = element.dom();
      <span class="hljs-keyword">return</span> Arr.map(dom.childNodes, Element.fromDom);
    };

    <span class="hljs-keyword">var</span> child = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, index</span>) </span>{
      <span class="hljs-keyword">var</span> children = element.dom().childNodes;
      <span class="hljs-keyword">return</span> Option.from(children[index]).map(Element.fromDom);
    };

    <span class="hljs-keyword">var</span> firstChild = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">return</span> child(element, <span class="hljs-number">0</span>);
    };

    <span class="hljs-keyword">var</span> lastChild = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">return</span> child(element, element.dom().childNodes.length - <span class="hljs-number">1</span>);
    };

    <span class="hljs-keyword">var</span> spot = Struct.immutable(<span class="hljs-string">'element'</span>, <span class="hljs-string">'offset'</span>);
    <span class="hljs-keyword">var</span> leaf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, offset</span>) </span>{
      <span class="hljs-keyword">var</span> cs = children(element);
      <span class="hljs-keyword">return</span> cs.length &gt; <span class="hljs-number">0</span> &amp;&amp; offset &lt; cs.length ? spot(cs[offset], <span class="hljs-number">0</span>) : spot(element, offset);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">owner</span>: owner,
      <span class="hljs-attr">defaultView</span>: defaultView,
      <span class="hljs-attr">documentElement</span>: documentElement,
      <span class="hljs-attr">parent</span>: parent,
      <span class="hljs-attr">findIndex</span>: findIndex,
      <span class="hljs-attr">parents</span>: parents,
      <span class="hljs-attr">siblings</span>: siblings,
      <span class="hljs-attr">prevSibling</span>: prevSibling,
      <span class="hljs-attr">offsetParent</span>: offsetParent,
      <span class="hljs-attr">prevSiblings</span>: prevSiblings,
      <span class="hljs-attr">nextSibling</span>: nextSibling,
      <span class="hljs-attr">nextSiblings</span>: nextSiblings,
      <span class="hljs-attr">children</span>: children,
      <span class="hljs-attr">child</span>: child,
      <span class="hljs-attr">firstChild</span>: firstChild,
      <span class="hljs-attr">lastChild</span>: lastChild,
      <span class="hljs-attr">leaf</span>: leaf
    };
  }
);

<span class="hljs-comment">/**
 * CaretUtils.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Utility functions shared by the caret logic.
 *
 * @private
 * @class tinymce.caret.CaretUtils
 */</span>
define(
  <span class="hljs-string">'tinymce.core.caret.CaretUtils'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Fun"</span>,
    <span class="hljs-string">"tinymce.core.dom.TreeWalker"</span>,
    <span class="hljs-string">"tinymce.core.dom.NodeType"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretPosition"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretContainer"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretCandidate"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, TreeWalker, NodeType, CaretPosition, CaretContainer, CaretCandidate</span>) </span>{
    <span class="hljs-keyword">var</span> isContentEditableTrue = NodeType.isContentEditableTrue,
      isContentEditableFalse = NodeType.isContentEditableFalse,
      isBlockLike = NodeType.matchStyleValues(<span class="hljs-string">'display'</span>, <span class="hljs-string">'block table table-cell table-caption'</span>),
      isCaretContainer = CaretContainer.isCaretContainer,
      isCaretContainerBlock = CaretContainer.isCaretContainerBlock,
      curry = Fun.curry,
      isElement = NodeType.isElement,
      isCaretCandidate = CaretCandidate.isCaretCandidate;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isForwards</span>(<span class="hljs-params">direction</span>) </span>{
      <span class="hljs-keyword">return</span> direction &gt; <span class="hljs-number">0</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBackwards</span>(<span class="hljs-params">direction</span>) </span>{
      <span class="hljs-keyword">return</span> direction &lt; <span class="hljs-number">0</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipCaretContainers</span>(<span class="hljs-params">walk, shallow</span>) </span>{
      <span class="hljs-keyword">var</span> node;

      <span class="hljs-keyword">while</span> ((node = walk(shallow))) {
        <span class="hljs-keyword">if</span> (!isCaretContainerBlock(node)) {
          <span class="hljs-keyword">return</span> node;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findNode</span>(<span class="hljs-params">node, direction, predicateFn, rootNode, shallow</span>) </span>{
      <span class="hljs-keyword">var</span> walker = <span class="hljs-keyword">new</span> TreeWalker(node, rootNode);

      <span class="hljs-keyword">if</span> (isBackwards(direction)) {
        <span class="hljs-keyword">if</span> (isContentEditableFalse(node) || isCaretContainerBlock(node)) {
          node = skipCaretContainers(walker.prev, <span class="hljs-literal">true</span>);
          <span class="hljs-keyword">if</span> (predicateFn(node)) {
            <span class="hljs-keyword">return</span> node;
          }
        }

        <span class="hljs-keyword">while</span> ((node = skipCaretContainers(walker.prev, shallow))) {
          <span class="hljs-keyword">if</span> (predicateFn(node)) {
            <span class="hljs-keyword">return</span> node;
          }
        }
      }

      <span class="hljs-keyword">if</span> (isForwards(direction)) {
        <span class="hljs-keyword">if</span> (isContentEditableFalse(node) || isCaretContainerBlock(node)) {
          node = skipCaretContainers(walker.next, <span class="hljs-literal">true</span>);
          <span class="hljs-keyword">if</span> (predicateFn(node)) {
            <span class="hljs-keyword">return</span> node;
          }
        }

        <span class="hljs-keyword">while</span> ((node = skipCaretContainers(walker.next, shallow))) {
          <span class="hljs-keyword">if</span> (predicateFn(node)) {
            <span class="hljs-keyword">return</span> node;
          }
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEditingHost</span>(<span class="hljs-params">node, rootNode</span>) </span>{
      <span class="hljs-keyword">for</span> (node = node.parentNode; node &amp;&amp; node != rootNode; node = node.parentNode) {
        <span class="hljs-keyword">if</span> (isContentEditableTrue(node)) {
          <span class="hljs-keyword">return</span> node;
        }
      }

      <span class="hljs-keyword">return</span> rootNode;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParentBlock</span>(<span class="hljs-params">node, rootNode</span>) </span>{
      <span class="hljs-keyword">while</span> (node &amp;&amp; node != rootNode) {
        <span class="hljs-keyword">if</span> (isBlockLike(node)) {
          <span class="hljs-keyword">return</span> node;
        }

        node = node.parentNode;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isInSameBlock</span>(<span class="hljs-params">caretPosition1, caretPosition2, rootNode</span>) </span>{
      <span class="hljs-keyword">return</span> getParentBlock(caretPosition1.container(), rootNode) == getParentBlock(caretPosition2.container(), rootNode);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isInSameEditingHost</span>(<span class="hljs-params">caretPosition1, caretPosition2, rootNode</span>) </span>{
      <span class="hljs-keyword">return</span> getEditingHost(caretPosition1.container(), rootNode) == getEditingHost(caretPosition2.container(), rootNode);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChildNodeAtRelativeOffset</span>(<span class="hljs-params">relativeOffset, caretPosition</span>) </span>{
      <span class="hljs-keyword">var</span> container, offset;

      <span class="hljs-keyword">if</span> (!caretPosition) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      container = caretPosition.container();
      offset = caretPosition.offset();

      <span class="hljs-keyword">if</span> (!isElement(container)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">return</span> container.childNodes[offset + relativeOffset];
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beforeAfter</span>(<span class="hljs-params">before, node</span>) </span>{
      <span class="hljs-keyword">var</span> range = node.ownerDocument.createRange();

      <span class="hljs-keyword">if</span> (before) {
        range.setStartBefore(node);
        range.setEndBefore(node);
      } <span class="hljs-keyword">else</span> {
        range.setStartAfter(node);
        range.setEndAfter(node);
      }

      <span class="hljs-keyword">return</span> range;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNodesInSameBlock</span>(<span class="hljs-params">rootNode, node1, node2</span>) </span>{
      <span class="hljs-keyword">return</span> getParentBlock(node1, rootNode) == getParentBlock(node2, rootNode);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lean</span>(<span class="hljs-params">left, rootNode, node</span>) </span>{
      <span class="hljs-keyword">var</span> sibling, siblingName;

      <span class="hljs-keyword">if</span> (left) {
        siblingName = <span class="hljs-string">'previousSibling'</span>;
      } <span class="hljs-keyword">else</span> {
        siblingName = <span class="hljs-string">'nextSibling'</span>;
      }

      <span class="hljs-keyword">while</span> (node &amp;&amp; node != rootNode) {
        sibling = node[siblingName];

        <span class="hljs-keyword">if</span> (isCaretContainer(sibling)) {
          sibling = sibling[siblingName];
        }

        <span class="hljs-keyword">if</span> (isContentEditableFalse(sibling)) {
          <span class="hljs-keyword">if</span> (isNodesInSameBlock(rootNode, sibling, node)) {
            <span class="hljs-keyword">return</span> sibling;
          }

          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">if</span> (isCaretCandidate(sibling)) {
          <span class="hljs-keyword">break</span>;
        }

        node = node.parentNode;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> before = curry(beforeAfter, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">var</span> after = curry(beforeAfter, <span class="hljs-literal">false</span>);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeRange</span>(<span class="hljs-params">direction, rootNode, range</span>) </span>{
      <span class="hljs-keyword">var</span> node, container, offset, location;
      <span class="hljs-keyword">var</span> leanLeft = curry(lean, <span class="hljs-literal">true</span>, rootNode);
      <span class="hljs-keyword">var</span> leanRight = curry(lean, <span class="hljs-literal">false</span>, rootNode);

      container = range.startContainer;
      offset = range.startOffset;

      <span class="hljs-keyword">if</span> (CaretContainer.isCaretContainerBlock(container)) {
        <span class="hljs-keyword">if</span> (!isElement(container)) {
          container = container.parentNode;
        }

        location = container.getAttribute(<span class="hljs-string">'data-mce-caret'</span>);

        <span class="hljs-keyword">if</span> (location == <span class="hljs-string">'before'</span>) {
          node = container.nextSibling;
          <span class="hljs-keyword">if</span> (isContentEditableFalse(node)) {
            <span class="hljs-keyword">return</span> before(node);
          }
        }

        <span class="hljs-keyword">if</span> (location == <span class="hljs-string">'after'</span>) {
          node = container.previousSibling;
          <span class="hljs-keyword">if</span> (isContentEditableFalse(node)) {
            <span class="hljs-keyword">return</span> after(node);
          }
        }
      }

      <span class="hljs-keyword">if</span> (!range.collapsed) {
        <span class="hljs-keyword">return</span> range;
      }

      <span class="hljs-keyword">if</span> (NodeType.isText(container)) {
        <span class="hljs-keyword">if</span> (isCaretContainer(container)) {
          <span class="hljs-keyword">if</span> (direction === <span class="hljs-number">1</span>) {
            node = leanRight(container);
            <span class="hljs-keyword">if</span> (node) {
              <span class="hljs-keyword">return</span> before(node);
            }

            node = leanLeft(container);
            <span class="hljs-keyword">if</span> (node) {
              <span class="hljs-keyword">return</span> after(node);
            }
          }

          <span class="hljs-keyword">if</span> (direction === <span class="hljs-number">-1</span>) {
            node = leanLeft(container);
            <span class="hljs-keyword">if</span> (node) {
              <span class="hljs-keyword">return</span> after(node);
            }

            node = leanRight(container);
            <span class="hljs-keyword">if</span> (node) {
              <span class="hljs-keyword">return</span> before(node);
            }
          }

          <span class="hljs-keyword">return</span> range;
        }

        <span class="hljs-keyword">if</span> (CaretContainer.endsWithCaretContainer(container) &amp;&amp; offset &gt;= container.data.length - <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">if</span> (direction === <span class="hljs-number">1</span>) {
            node = leanRight(container);
            <span class="hljs-keyword">if</span> (node) {
              <span class="hljs-keyword">return</span> before(node);
            }
          }

          <span class="hljs-keyword">return</span> range;
        }

        <span class="hljs-keyword">if</span> (CaretContainer.startsWithCaretContainer(container) &amp;&amp; offset &lt;= <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">if</span> (direction === <span class="hljs-number">-1</span>) {
            node = leanLeft(container);
            <span class="hljs-keyword">if</span> (node) {
              <span class="hljs-keyword">return</span> after(node);
            }
          }

          <span class="hljs-keyword">return</span> range;
        }

        <span class="hljs-keyword">if</span> (offset === container.data.length) {
          node = leanRight(container);
          <span class="hljs-keyword">if</span> (node) {
            <span class="hljs-keyword">return</span> before(node);
          }

          <span class="hljs-keyword">return</span> range;
        }

        <span class="hljs-keyword">if</span> (offset === <span class="hljs-number">0</span>) {
          node = leanLeft(container);
          <span class="hljs-keyword">if</span> (node) {
            <span class="hljs-keyword">return</span> after(node);
          }

          <span class="hljs-keyword">return</span> range;
        }
      }

      <span class="hljs-keyword">return</span> range;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNextToContentEditableFalse</span>(<span class="hljs-params">relativeOffset, caretPosition</span>) </span>{
      <span class="hljs-keyword">return</span> isContentEditableFalse(getChildNodeAtRelativeOffset(relativeOffset, caretPosition));
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">isForwards</span>: isForwards,
      <span class="hljs-attr">isBackwards</span>: isBackwards,
      <span class="hljs-attr">findNode</span>: findNode,
      <span class="hljs-attr">getEditingHost</span>: getEditingHost,
      <span class="hljs-attr">getParentBlock</span>: getParentBlock,
      <span class="hljs-attr">isInSameBlock</span>: isInSameBlock,
      <span class="hljs-attr">isInSameEditingHost</span>: isInSameEditingHost,
      <span class="hljs-attr">isBeforeContentEditableFalse</span>: curry(isNextToContentEditableFalse, <span class="hljs-number">0</span>),
      <span class="hljs-attr">isAfterContentEditableFalse</span>: curry(isNextToContentEditableFalse, <span class="hljs-number">-1</span>),
      <span class="hljs-attr">normalizeRange</span>: normalizeRange
    };
  }
);

<span class="hljs-comment">/**
 * CaretWalker.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module contains logic for moving around a virtual caret in logical order within a DOM element.
 *
 * It ignores the most obvious invalid caret locations such as within a script element or within a
 * contentEditable=false element but it will return locations that isn't possible to render visually.
 *
 * @private
 * @class tinymce.caret.CaretWalker
 * @example
 * var caretWalker = new CaretWalker(rootElm);
 *
 * var prevLogicalCaretPosition = caretWalker.prev(CaretPosition.fromRangeStart(range));
 * var nextLogicalCaretPosition = caretWalker.next(CaretPosition.fromRangeEnd(range));
 */</span>
define(
  <span class="hljs-string">'tinymce.core.caret.CaretWalker'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.NodeType"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretCandidate"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretPosition"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretUtils"</span>,
    <span class="hljs-string">"tinymce.core.util.Arr"</span>,
    <span class="hljs-string">"tinymce.core.util.Fun"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">NodeType, CaretCandidate, CaretPosition, CaretUtils, Arr, Fun</span>) </span>{
    <span class="hljs-keyword">var</span> isContentEditableFalse = NodeType.isContentEditableFalse,
      isText = NodeType.isText,
      isElement = NodeType.isElement,
      isBr = NodeType.isBr,
      isForwards = CaretUtils.isForwards,
      isBackwards = CaretUtils.isBackwards,
      isCaretCandidate = CaretCandidate.isCaretCandidate,
      isAtomic = CaretCandidate.isAtomic,
      isEditableCaretCandidate = CaretCandidate.isEditableCaretCandidate;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParents</span>(<span class="hljs-params">node, rootNode</span>) </span>{
      <span class="hljs-keyword">var</span> parents = [];

      <span class="hljs-keyword">while</span> (node &amp;&amp; node != rootNode) {
        parents.push(node);
        node = node.parentNode;
      }

      <span class="hljs-keyword">return</span> parents;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nodeAtIndex</span>(<span class="hljs-params">container, offset</span>) </span>{
      <span class="hljs-keyword">if</span> (container.hasChildNodes() &amp;&amp; offset &lt; container.childNodes.length) {
        <span class="hljs-keyword">return</span> container.childNodes[offset];
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCaretCandidatePosition</span>(<span class="hljs-params">direction, node</span>) </span>{
      <span class="hljs-keyword">if</span> (isForwards(direction)) {
        <span class="hljs-keyword">if</span> (isCaretCandidate(node.previousSibling) &amp;&amp; !isText(node.previousSibling)) {
          <span class="hljs-keyword">return</span> CaretPosition.before(node);
        }

        <span class="hljs-keyword">if</span> (isText(node)) {
          <span class="hljs-keyword">return</span> CaretPosition(node, <span class="hljs-number">0</span>);
        }
      }

      <span class="hljs-keyword">if</span> (isBackwards(direction)) {
        <span class="hljs-keyword">if</span> (isCaretCandidate(node.nextSibling) &amp;&amp; !isText(node.nextSibling)) {
          <span class="hljs-keyword">return</span> CaretPosition.after(node);
        }

        <span class="hljs-keyword">if</span> (isText(node)) {
          <span class="hljs-keyword">return</span> CaretPosition(node, node.data.length);
        }
      }

      <span class="hljs-keyword">if</span> (isBackwards(direction)) {
        <span class="hljs-keyword">if</span> (isBr(node)) {
          <span class="hljs-keyword">return</span> CaretPosition.before(node);
        }

        <span class="hljs-keyword">return</span> CaretPosition.after(node);
      }

      <span class="hljs-keyword">return</span> CaretPosition.before(node);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-1217">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1217">&#182;</a>
              </div>
              <p>Jumps over BR elements <p>|<br></p><p>a</p> -&gt; <p><br></p><p>|a</p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBrBeforeBlock</span>(<span class="hljs-params">node, rootNode</span>) </span>{
      <span class="hljs-keyword">var</span> next;

      <span class="hljs-keyword">if</span> (!NodeType.isBr(node)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      next = findCaretPosition(<span class="hljs-number">1</span>, CaretPosition.after(node), rootNode);
      <span class="hljs-keyword">if</span> (!next) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">return</span> !CaretUtils.isInSameBlock(CaretPosition.before(node), CaretPosition.before(next), rootNode);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findCaretPosition</span>(<span class="hljs-params">direction, startCaretPosition, rootNode</span>) </span>{
      <span class="hljs-keyword">var</span> container, offset, node, nextNode, innerNode,
        rootContentEditableFalseElm, caretPosition;

      <span class="hljs-keyword">if</span> (!isElement(rootNode) || !startCaretPosition) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (startCaretPosition.isEqual(CaretPosition.after(rootNode)) &amp;&amp; rootNode.lastChild) {
        caretPosition = CaretPosition.after(rootNode.lastChild);
        <span class="hljs-keyword">if</span> (isBackwards(direction) &amp;&amp; isCaretCandidate(rootNode.lastChild) &amp;&amp; isElement(rootNode.lastChild)) {
          <span class="hljs-keyword">return</span> isBr(rootNode.lastChild) ? CaretPosition.before(rootNode.lastChild) : caretPosition;
        }
      } <span class="hljs-keyword">else</span> {
        caretPosition = startCaretPosition;
      }

      container = caretPosition.container();
      offset = caretPosition.offset();

      <span class="hljs-keyword">if</span> (isText(container)) {
        <span class="hljs-keyword">if</span> (isBackwards(direction) &amp;&amp; offset &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> CaretPosition(container, --offset);
        }

        <span class="hljs-keyword">if</span> (isForwards(direction) &amp;&amp; offset &lt; container.length) {
          <span class="hljs-keyword">return</span> CaretPosition(container, ++offset);
        }

        node = container;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (isBackwards(direction) &amp;&amp; offset &gt; <span class="hljs-number">0</span>) {
          nextNode = nodeAtIndex(container, offset - <span class="hljs-number">1</span>);
          <span class="hljs-keyword">if</span> (isCaretCandidate(nextNode)) {
            <span class="hljs-keyword">if</span> (!isAtomic(nextNode)) {
              innerNode = CaretUtils.findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
              <span class="hljs-keyword">if</span> (innerNode) {
                <span class="hljs-keyword">if</span> (isText(innerNode)) {
                  <span class="hljs-keyword">return</span> CaretPosition(innerNode, innerNode.data.length);
                }

                <span class="hljs-keyword">return</span> CaretPosition.after(innerNode);
              }
            }

            <span class="hljs-keyword">if</span> (isText(nextNode)) {
              <span class="hljs-keyword">return</span> CaretPosition(nextNode, nextNode.data.length);
            }

            <span class="hljs-keyword">return</span> CaretPosition.before(nextNode);
          }
        }

        <span class="hljs-keyword">if</span> (isForwards(direction) &amp;&amp; offset &lt; container.childNodes.length) {
          nextNode = nodeAtIndex(container, offset);
          <span class="hljs-keyword">if</span> (isCaretCandidate(nextNode)) {
            <span class="hljs-keyword">if</span> (isBrBeforeBlock(nextNode, rootNode)) {
              <span class="hljs-keyword">return</span> findCaretPosition(direction, CaretPosition.after(nextNode), rootNode);
            }

            <span class="hljs-keyword">if</span> (!isAtomic(nextNode)) {
              innerNode = CaretUtils.findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
              <span class="hljs-keyword">if</span> (innerNode) {
                <span class="hljs-keyword">if</span> (isText(innerNode)) {
                  <span class="hljs-keyword">return</span> CaretPosition(innerNode, <span class="hljs-number">0</span>);
                }

                <span class="hljs-keyword">return</span> CaretPosition.before(innerNode);
              }
            }

            <span class="hljs-keyword">if</span> (isText(nextNode)) {
              <span class="hljs-keyword">return</span> CaretPosition(nextNode, <span class="hljs-number">0</span>);
            }

            <span class="hljs-keyword">return</span> CaretPosition.after(nextNode);
          }
        }

        node = caretPosition.getNode();
      }

      <span class="hljs-keyword">if</span> ((isForwards(direction) &amp;&amp; caretPosition.isAtEnd()) || (isBackwards(direction) &amp;&amp; caretPosition.isAtStart())) {
        node = CaretUtils.findNode(node, direction, Fun.constant(<span class="hljs-literal">true</span>), rootNode, <span class="hljs-literal">true</span>);
        <span class="hljs-keyword">if</span> (isEditableCaretCandidate(node)) {
          <span class="hljs-keyword">return</span> getCaretCandidatePosition(direction, node);
        }
      }

      nextNode = CaretUtils.findNode(node, direction, isEditableCaretCandidate, rootNode);

      rootContentEditableFalseElm = Arr.last(Arr.filter(getParents(container, rootNode), isContentEditableFalse));
      <span class="hljs-keyword">if</span> (rootContentEditableFalseElm &amp;&amp; (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
        <span class="hljs-keyword">if</span> (isForwards(direction)) {
          caretPosition = CaretPosition.after(rootContentEditableFalseElm);
        } <span class="hljs-keyword">else</span> {
          caretPosition = CaretPosition.before(rootContentEditableFalseElm);
        }

        <span class="hljs-keyword">return</span> caretPosition;
      }

      <span class="hljs-keyword">if</span> (nextNode) {
        <span class="hljs-keyword">return</span> getCaretCandidatePosition(direction, nextNode);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode</span>) </span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">/**
         * Returns the next logical caret position from the specificed input
         * caretPoisiton or null if there isn't any more positions left for example
         * at the end specified root element.
         *
         * @method next
         * @param {tinymce.caret.CaretPosition} caretPosition Caret position to start from.
         * @return {tinymce.caret.CaretPosition} CaretPosition or null if no position was found.
         */</span>
        next: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">caretPosition</span>) </span>{
          <span class="hljs-keyword">return</span> findCaretPosition(<span class="hljs-number">1</span>, caretPosition, rootNode);
        },

        <span class="hljs-comment">/**
         * Returns the previous logical caret position from the specificed input
         * caretPoisiton or null if there isn't any more positions left for example
         * at the end specified root element.
         *
         * @method prev
         * @param {tinymce.caret.CaretPosition} caretPosition Caret position to start from.
         * @return {tinymce.caret.CaretPosition} CaretPosition or null if no position was found.
         */</span>
        prev: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">caretPosition</span>) </span>{
          <span class="hljs-keyword">return</span> findCaretPosition(<span class="hljs-number">-1</span>, caretPosition, rootNode);
        }
      };
    };
  }
);
<span class="hljs-comment">/**
 * CaretFinder.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.caret.CaretFinder'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretWalker'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, Option, CaretPosition, CaretWalker</span>) </span>{
    <span class="hljs-keyword">var</span> fromPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">forward, rootElement, position</span>) </span>{
      <span class="hljs-keyword">var</span> walker = <span class="hljs-keyword">new</span> CaretWalker(rootElement);
      <span class="hljs-keyword">return</span> Option.from(forward ? walker.next(position) : walker.prev(position));
    };

    <span class="hljs-keyword">var</span> positionIn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">forward, element</span>) </span>{
      <span class="hljs-keyword">var</span> caretWalker = <span class="hljs-keyword">new</span> CaretWalker(element);
      <span class="hljs-keyword">var</span> startPos = forward ? CaretPosition.before(element) : CaretPosition.after(element);
      <span class="hljs-keyword">return</span> Option.from(forward ? caretWalker.next(startPos) : caretWalker.prev(startPos));
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">fromPosition</span>: fromPosition,
      <span class="hljs-attr">positionIn</span>: positionIn
    };
  }
);

<span class="hljs-comment">/**
 * DeleteUtils.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.delete.DeleteUtils'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'ephox.sugar.api.dom.Compare'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Element'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Node'</span>,
    <span class="hljs-string">'ephox.sugar.api.search.PredicateFind'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Option, Compare, Element, Node, PredicateFind</span>) </span>{
    <span class="hljs-keyword">var</span> toLookup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">names</span>) </span>{
      <span class="hljs-keyword">var</span> lookup = Arr.foldl(names, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">acc, name</span>) </span>{
        acc[name] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> acc;
      }, { });

      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">return</span> lookup[Node.name(elm)] === <span class="hljs-literal">true</span>;
      };
    };

    <span class="hljs-keyword">var</span> isTextBlock = toLookup([
      <span class="hljs-string">'h1'</span>, <span class="hljs-string">'h2'</span>, <span class="hljs-string">'h3'</span>, <span class="hljs-string">'h4'</span>, <span class="hljs-string">'h5'</span>, <span class="hljs-string">'h6'</span>, <span class="hljs-string">'p'</span>, <span class="hljs-string">'div'</span>, <span class="hljs-string">'address'</span>, <span class="hljs-string">'pre'</span>, <span class="hljs-string">'form'</span>, <span class="hljs-string">'blockquote'</span>, <span class="hljs-string">'center'</span>,
      <span class="hljs-string">'dir'</span>, <span class="hljs-string">'fieldset'</span>, <span class="hljs-string">'header'</span>, <span class="hljs-string">'footer'</span>, <span class="hljs-string">'article'</span>, <span class="hljs-string">'section'</span>, <span class="hljs-string">'hgroup'</span>, <span class="hljs-string">'aside'</span>, <span class="hljs-string">'nav'</span>, <span class="hljs-string">'figure'</span>
    ]);

    <span class="hljs-keyword">var</span> isBeforeRoot = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">return</span> Compare.eq(rootNode, Element.fromDom(elm.dom().parentNode));
      };
    };

    <span class="hljs-keyword">var</span> getParentTextBlock = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, elm</span>) </span>{
      <span class="hljs-keyword">return</span> Compare.contains(rootNode, elm) ? PredicateFind.closest(elm, isTextBlock, isBeforeRoot(rootNode)) : Option.none();
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">getParentTextBlock</span>: getParentTextBlock
    };
  }
);

define(
  <span class="hljs-string">'ephox.sugar.api.search.SelectorFind'</span>,

  [
    <span class="hljs-string">'ephox.sugar.api.search.PredicateFind'</span>,
    <span class="hljs-string">'ephox.sugar.api.search.Selectors'</span>,
    <span class="hljs-string">'ephox.sugar.impl.ClosestOrAncestor'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">PredicateFind, Selectors, ClosestOrAncestor</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1218">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1218">&#182;</a>
              </div>
              <p>TODO: An internal SelectorFilter module that doesnt Element.fromDom() everything</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> first = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
      <span class="hljs-keyword">return</span> Selectors.one(selector);
    };

    <span class="hljs-keyword">var</span> ancestor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, selector, isRoot</span>) </span>{
      <span class="hljs-keyword">return</span> PredicateFind.ancestor(scope, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">return</span> Selectors.is(e, selector);
      }, isRoot);
    };

    <span class="hljs-keyword">var</span> sibling = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, selector</span>) </span>{
      <span class="hljs-keyword">return</span> PredicateFind.sibling(scope, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">return</span> Selectors.is(e, selector);
      });
    };

    <span class="hljs-keyword">var</span> child = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, selector</span>) </span>{
      <span class="hljs-keyword">return</span> PredicateFind.child(scope, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">return</span> Selectors.is(e, selector);
      });
    };

    <span class="hljs-keyword">var</span> descendant = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, selector</span>) </span>{
      <span class="hljs-keyword">return</span> Selectors.one(selector, scope);
    };

    <span class="hljs-keyword">var</span> closest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, selector, isRoot</span>) </span>{
      <span class="hljs-keyword">return</span> ClosestOrAncestor(Selectors.is, ancestor, scope, selector, isRoot);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">first</span>: first,
      <span class="hljs-attr">ancestor</span>: ancestor,
      <span class="hljs-attr">sibling</span>: sibling,
      <span class="hljs-attr">child</span>: child,
      <span class="hljs-attr">descendant</span>: descendant,
      <span class="hljs-attr">closest</span>: closest
    };
  }
);

define(
  <span class="hljs-string">'ephox.sugar.api.search.SelectorExists'</span>,

  [
    <span class="hljs-string">'ephox.sugar.api.search.SelectorFind'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">SelectorFind</span>) </span>{
    <span class="hljs-keyword">var</span> any = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
      <span class="hljs-keyword">return</span> SelectorFind.first(selector).isSome();
    };

    <span class="hljs-keyword">var</span> ancestor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, selector, isRoot</span>) </span>{
      <span class="hljs-keyword">return</span> SelectorFind.ancestor(scope, selector, isRoot).isSome();
    };

    <span class="hljs-keyword">var</span> sibling = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, selector</span>) </span>{
      <span class="hljs-keyword">return</span> SelectorFind.sibling(scope, selector).isSome();
    };

    <span class="hljs-keyword">var</span> child = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, selector</span>) </span>{
      <span class="hljs-keyword">return</span> SelectorFind.child(scope, selector).isSome();
    };

    <span class="hljs-keyword">var</span> descendant = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, selector</span>) </span>{
      <span class="hljs-keyword">return</span> SelectorFind.descendant(scope, selector).isSome();
    };

    <span class="hljs-keyword">var</span> closest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, selector, isRoot</span>) </span>{
      <span class="hljs-keyword">return</span> SelectorFind.closest(scope, selector, isRoot).isSome();
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">any</span>: any,
      <span class="hljs-attr">ancestor</span>: ancestor,
      <span class="hljs-attr">sibling</span>: sibling,
      <span class="hljs-attr">child</span>: child,
      <span class="hljs-attr">descendant</span>: descendant,
      <span class="hljs-attr">closest</span>: closest
    };
  }
);

<span class="hljs-comment">/**
 * Empty.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.dom.Empty'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.sugar.api.dom.Compare'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Element'</span>,
    <span class="hljs-string">'ephox.sugar.api.search.SelectorExists'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretCandidate'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.dom.TreeWalker'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, Compare, Element, SelectorExists, CaretCandidate, NodeType, TreeWalker</span>) </span>{
    <span class="hljs-keyword">var</span> hasWhitespacePreserveParent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, node</span>) </span>{
      <span class="hljs-keyword">var</span> rootElement = Element.fromDom(rootNode);
      <span class="hljs-keyword">var</span> startNode = Element.fromDom(node);
      <span class="hljs-keyword">return</span> SelectorExists.ancestor(startNode, <span class="hljs-string">'pre,code'</span>, Fun.curry(Compare.eq, rootElement));
    };

    <span class="hljs-keyword">var</span> isWhitespace = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, node</span>) </span>{
      <span class="hljs-keyword">return</span> NodeType.isText(node) &amp;&amp; <span class="hljs-regexp">/^[ \t\r\n]*$/</span>.test(node.data) &amp;&amp; hasWhitespacePreserveParent(rootNode, node) === <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">var</span> isNamedAnchor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> NodeType.isElement(node) &amp;&amp; node.nodeName === <span class="hljs-string">'A'</span> &amp;&amp; node.hasAttribute(<span class="hljs-string">'name'</span>);
    };

    <span class="hljs-keyword">var</span> isContent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, node</span>) </span>{
      <span class="hljs-keyword">return</span> (CaretCandidate.isCaretCandidate(node) &amp;&amp; isWhitespace(rootNode, node) === <span class="hljs-literal">false</span>) || isNamedAnchor(node) || isBookmark(node);
    };

    <span class="hljs-keyword">var</span> isBookmark = NodeType.hasAttribute(<span class="hljs-string">'data-mce-bookmark'</span>);
    <span class="hljs-keyword">var</span> isBogus = NodeType.hasAttribute(<span class="hljs-string">'data-mce-bogus'</span>);
    <span class="hljs-keyword">var</span> isBogusAll = NodeType.hasAttributeValue(<span class="hljs-string">'data-mce-bogus'</span>, <span class="hljs-string">'all'</span>);

    <span class="hljs-keyword">var</span> isEmptyNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">targetNode</span>) </span>{
      <span class="hljs-keyword">var</span> walker, node, brCount = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (isContent(targetNode, targetNode)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      } <span class="hljs-keyword">else</span> {
        node = targetNode.firstChild;
        <span class="hljs-keyword">if</span> (!node) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        walker = <span class="hljs-keyword">new</span> TreeWalker(node, targetNode);
        <span class="hljs-keyword">do</span> {
          <span class="hljs-keyword">if</span> (isBogusAll(node)) {
            node = walker.next(<span class="hljs-literal">true</span>);
            <span class="hljs-keyword">continue</span>;
          }

          <span class="hljs-keyword">if</span> (isBogus(node)) {
            node = walker.next();
            <span class="hljs-keyword">continue</span>;
          }

          <span class="hljs-keyword">if</span> (NodeType.isBr(node)) {
            brCount++;
            node = walker.next();
            <span class="hljs-keyword">continue</span>;
          }

          <span class="hljs-keyword">if</span> (isContent(targetNode, node)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

          node = walker.next();
        } <span class="hljs-keyword">while</span> (node);

        <span class="hljs-keyword">return</span> brCount &lt;= <span class="hljs-number">1</span>;
      }
    };

    <span class="hljs-keyword">var</span> isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> isEmptyNode(elm.dom());
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">isEmpty</span>: isEmpty
    };
  }
);

<span class="hljs-comment">/**
 * BlockBoundary.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.delete.BlockBoundary'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'ephox.katamari.api.Options'</span>,
    <span class="hljs-string">'ephox.katamari.api.Struct'</span>,
    <span class="hljs-string">'ephox.sugar.api.dom.Compare'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Element'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Node'</span>,
    <span class="hljs-string">'ephox.sugar.api.search.PredicateFind'</span>,
    <span class="hljs-string">'ephox.sugar.api.search.Traverse'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretFinder'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.delete.DeleteUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.Empty'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Fun, Option, Options, Struct, Compare, Element, Node, PredicateFind, Traverse, CaretFinder, CaretPosition, DeleteUtils, Empty, NodeType</span>) </span>{
    <span class="hljs-keyword">var</span> BlockPosition = Struct.immutable(<span class="hljs-string">'block'</span>, <span class="hljs-string">'position'</span>);
    <span class="hljs-keyword">var</span> BlockBoundary = Struct.immutable(<span class="hljs-string">'from'</span>, <span class="hljs-string">'to'</span>);

    <span class="hljs-keyword">var</span> getBlockPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, pos</span>) </span>{
      <span class="hljs-keyword">var</span> rootElm = Element.fromDom(rootNode);
      <span class="hljs-keyword">var</span> containerElm = Element.fromDom(pos.container());
      <span class="hljs-keyword">return</span> DeleteUtils.getParentTextBlock(rootElm, containerElm).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">block</span>) </span>{
        <span class="hljs-keyword">return</span> BlockPosition(block, pos);
      });
    };

    <span class="hljs-keyword">var</span> isDifferentBlocks = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blockBoundary</span>) </span>{
      <span class="hljs-keyword">return</span> Compare.eq(blockBoundary.from().block(), blockBoundary.to().block()) === <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">var</span> hasSameParent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blockBoundary</span>) </span>{
      <span class="hljs-keyword">return</span> Traverse.parent(blockBoundary.from().block()).bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent1</span>) </span>{
        <span class="hljs-keyword">return</span> Traverse.parent(blockBoundary.to().block()).filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent2</span>) </span>{
          <span class="hljs-keyword">return</span> Compare.eq(parent1, parent2);
        });
      }).isSome();
    };

    <span class="hljs-keyword">var</span> isEditable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blockBoundary</span>) </span>{
      <span class="hljs-keyword">return</span> NodeType.isContentEditableFalse(blockBoundary.from().block()) === <span class="hljs-literal">false</span> &amp;&amp; NodeType.isContentEditableFalse(blockBoundary.to().block()) === <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">var</span> skipLastBr = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, forward, blockPosition</span>) </span>{
      <span class="hljs-keyword">if</span> (NodeType.isBr(blockPosition.position().getNode()) &amp;&amp; Empty.isEmpty(blockPosition.block()) === <span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">return</span> CaretFinder.positionIn(<span class="hljs-literal">false</span>, blockPosition.block().dom()).bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">lastPositionInBlock</span>) </span>{
          <span class="hljs-keyword">if</span> (lastPositionInBlock.isEqual(blockPosition.position())) {
            <span class="hljs-keyword">return</span> CaretFinder.fromPosition(forward, rootNode, lastPositionInBlock).bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">to</span>) </span>{
              <span class="hljs-keyword">return</span> getBlockPosition(rootNode, to);
            });
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> Option.some(blockPosition);
          }
        }).getOr(blockPosition);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> blockPosition;
      }
    };

    <span class="hljs-keyword">var</span> readFromRange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, forward, rng</span>) </span>{
      <span class="hljs-keyword">var</span> fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));
      <span class="hljs-keyword">var</span> toBlockPos = fromBlockPos.bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blockPos</span>) </span>{
        <span class="hljs-keyword">return</span> CaretFinder.fromPosition(forward, rootNode, blockPos.position()).bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">to</span>) </span>{
          <span class="hljs-keyword">return</span> getBlockPosition(rootNode, to).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blockPos</span>) </span>{
            <span class="hljs-keyword">return</span> skipLastBr(rootNode, forward, blockPos);
          });
        });
      });

      <span class="hljs-keyword">return</span> Options.liftN([fromBlockPos, toBlockPos], BlockBoundary).filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blockBoundary</span>) </span>{
        <span class="hljs-keyword">return</span> isDifferentBlocks(blockBoundary) &amp;&amp; hasSameParent(blockBoundary) &amp;&amp; isEditable(blockBoundary);
      });
    };

    <span class="hljs-keyword">var</span> read = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, forward, rng</span>) </span>{
      <span class="hljs-keyword">return</span> rng.collapsed ? readFromRange(rootNode, forward, rng) : Option.none();
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">read</span>: read
    };
  }
);

define(
  <span class="hljs-string">'ephox.sugar.api.dom.Insert'</span>,

  [
    <span class="hljs-string">'ephox.sugar.api.search.Traverse'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Traverse</span>) </span>{
    <span class="hljs-keyword">var</span> before = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">marker, element</span>) </span>{
      <span class="hljs-keyword">var</span> parent = Traverse.parent(marker);
      parent.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
        v.dom().insertBefore(element.dom(), marker.dom());
      });
    };

    <span class="hljs-keyword">var</span> after = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">marker, element</span>) </span>{
      <span class="hljs-keyword">var</span> sibling = Traverse.nextSibling(marker);
      sibling.fold(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> parent = Traverse.parent(marker);
        parent.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
          append(v, element);
        });
      }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
        before(v, element);
      });
    };

    <span class="hljs-keyword">var</span> prepend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent, element</span>) </span>{
      <span class="hljs-keyword">var</span> firstChild = Traverse.firstChild(parent);
      firstChild.fold(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        append(parent, element);
      }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
        parent.dom().insertBefore(element.dom(), v.dom());
      });
    };

    <span class="hljs-keyword">var</span> append = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent, element</span>) </span>{
      parent.dom().appendChild(element.dom());
    };

    <span class="hljs-keyword">var</span> appendAt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent, element, index</span>) </span>{
      Traverse.child(parent, index).fold(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        append(parent, element);
      }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
        before(v, element);
      });
    };

    <span class="hljs-keyword">var</span> wrap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, wrapper</span>) </span>{
      before(element, wrapper);
      append(wrapper, element);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">before</span>: before,
      <span class="hljs-attr">after</span>: after,
      <span class="hljs-attr">prepend</span>: prepend,
      <span class="hljs-attr">append</span>: append,
      <span class="hljs-attr">appendAt</span>: appendAt,
      <span class="hljs-attr">wrap</span>: wrap
    };
  }
);

define(
  <span class="hljs-string">'ephox.sugar.api.dom.InsertAll'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.sugar.api.dom.Insert'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Insert</span>) </span>{
    <span class="hljs-keyword">var</span> before = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">marker, elements</span>) </span>{
      Arr.each(elements, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
        Insert.before(marker, x);
      });
    };

    <span class="hljs-keyword">var</span> after = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">marker, elements</span>) </span>{
      Arr.each(elements, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, i</span>) </span>{
        <span class="hljs-keyword">var</span> e = i === <span class="hljs-number">0</span> ? marker : elements[i - <span class="hljs-number">1</span>];
        Insert.after(e, x);
      });
    };

    <span class="hljs-keyword">var</span> prepend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent, elements</span>) </span>{
      Arr.each(elements.slice().reverse(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
        Insert.prepend(parent, x);
      });
    };

    <span class="hljs-keyword">var</span> append = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent, elements</span>) </span>{
      Arr.each(elements, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
        Insert.append(parent, x);
      });
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">before</span>: before,
      <span class="hljs-attr">after</span>: after,
      <span class="hljs-attr">prepend</span>: prepend,
      <span class="hljs-attr">append</span>: append
    };
  }
);

define(
  <span class="hljs-string">'ephox.sugar.api.dom.Remove'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.sugar.api.dom.InsertAll'</span>,
    <span class="hljs-string">'ephox.sugar.api.search.Traverse'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, InsertAll, Traverse</span>) </span>{
    <span class="hljs-keyword">var</span> empty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1219">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1219">&#182;</a>
              </div>
              <p>shortcut empty node trick. Requires IE 9.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      element.dom().textContent = <span class="hljs-string">''</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1220">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1220">&#182;</a>
              </div>
              <p>If the contents was a single empty text node, the above doesnt remove it. But, its still faster in general
than removing every child node manually.
The following is (probably) safe for performance as 99.9% of the time the trick works and
Traverse.children will return an empty array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      Arr.each(Traverse.children(element), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rogue</span>) </span>{
        remove(rogue);
      });
    };

    <span class="hljs-keyword">var</span> remove = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">var</span> dom = element.dom();
      <span class="hljs-keyword">if</span> (dom.parentNode !== <span class="hljs-literal">null</span>)
        dom.parentNode.removeChild(dom);
    };

    <span class="hljs-keyword">var</span> unwrap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">wrapper</span>) </span>{
      <span class="hljs-keyword">var</span> children = Traverse.children(wrapper);
      <span class="hljs-keyword">if</span> (children.length &gt; <span class="hljs-number">0</span>)
        InsertAll.before(wrapper, children);
      remove(wrapper);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">empty</span>: empty,
      <span class="hljs-attr">remove</span>: remove,
      <span class="hljs-attr">unwrap</span>: unwrap
    };
  }
);

<span class="hljs-comment">/**
 * MergeBlocks.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.delete.MergeBlocks'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'ephox.sugar.api.dom.Insert'</span>,
    <span class="hljs-string">'ephox.sugar.api.dom.Remove'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Element'</span>,
    <span class="hljs-string">'ephox.sugar.api.search.Traverse'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretFinder'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.dom.Empty'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Option, Insert, Remove, Element, Traverse, CaretFinder, CaretPosition, Empty, NodeType</span>) </span>{
    <span class="hljs-keyword">var</span> mergeBlocksAndReposition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">forward, fromBlock, toBlock, toPosition</span>) </span>{
      <span class="hljs-keyword">var</span> children = Traverse.children(fromBlock);

      <span class="hljs-keyword">if</span> (NodeType.isBr(toPosition.getNode())) {
        Remove.remove(Element.fromDom(toPosition.getNode()));
        toPosition = CaretFinder.positionIn(<span class="hljs-literal">false</span>, toBlock.dom()).getOr();
      }

      Arr.each(children, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        Insert.append(toBlock, node);
      });

      <span class="hljs-keyword">if</span> (Empty.isEmpty(fromBlock)) {
        Remove.remove(fromBlock);
      }

      <span class="hljs-keyword">return</span> children.length &gt; <span class="hljs-number">0</span> ? Option.from(toPosition) : Option.none();
    };

    <span class="hljs-keyword">var</span> mergeBlocks = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">forward, block1, block2</span>) </span>{
      <span class="hljs-keyword">if</span> (forward) {
        <span class="hljs-keyword">return</span> CaretFinder.positionIn(<span class="hljs-literal">false</span>, block1.dom()).bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">toPosition</span>) </span>{
          <span class="hljs-keyword">return</span> mergeBlocksAndReposition(forward, block2, block1, toPosition);
        });
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> CaretFinder.positionIn(<span class="hljs-literal">false</span>, block2.dom()).bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">toPosition</span>) </span>{
          <span class="hljs-keyword">return</span> mergeBlocksAndReposition(forward, block1, block2, toPosition);
        });
      }
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">mergeBlocks</span>: mergeBlocks
    };
  }
);

<span class="hljs-comment">/**
 * BlockBoundaryDelete.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.delete.BlockBoundaryDelete'</span>,
  [
    <span class="hljs-string">'tinymce.core.delete.BlockBoundary'</span>,
    <span class="hljs-string">'tinymce.core.delete.MergeBlocks'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">BlockBoundary, MergeBlocks</span>) </span>{
    <span class="hljs-keyword">var</span> backspaceDelete = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, forward</span>) </span>{
      <span class="hljs-keyword">var</span> position;

      position = BlockBoundary.read(editor.getBody(), forward, editor.selection.getRng()).bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blockBoundary</span>) </span>{
        <span class="hljs-keyword">return</span> MergeBlocks.mergeBlocks(forward, blockBoundary.from().block(), blockBoundary.to().block());
      });

      position.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
        editor.selection.setRng(pos.toRange());
      });

      <span class="hljs-keyword">return</span> position.isSome();
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">backspaceDelete</span>: backspaceDelete
    };
  }
);

<span class="hljs-comment">/**
 * BlockRangeDelete.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.delete.BlockRangeDelete'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Options'</span>,
    <span class="hljs-string">'ephox.sugar.api.dom.Compare'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Element'</span>,
    <span class="hljs-string">'tinymce.core.delete.DeleteUtils'</span>,
    <span class="hljs-string">'tinymce.core.delete.MergeBlocks'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Options, Compare, Element, DeleteUtils, MergeBlocks</span>) </span>{
    <span class="hljs-keyword">var</span> deleteRange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, selection</span>) </span>{
      <span class="hljs-keyword">var</span> rng = selection.getRng();

      <span class="hljs-keyword">return</span> Options.liftN([
        DeleteUtils.getParentTextBlock(rootNode, Element.fromDom(rng.startContainer)),
        DeleteUtils.getParentTextBlock(rootNode, Element.fromDom(rng.endContainer))
      ], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">block1, block2</span>) </span>{
        <span class="hljs-keyword">if</span> (Compare.eq(block1, block2) === <span class="hljs-literal">false</span>) {
          rng.deleteContents();

          MergeBlocks.mergeBlocks(<span class="hljs-literal">true</span>, block1, block2).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
            selection.setRng(pos.toRange());
          });

          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }).getOr(<span class="hljs-literal">false</span>);
    };

    <span class="hljs-keyword">var</span> backspaceDelete = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, forward</span>) </span>{
      <span class="hljs-keyword">var</span> rootNode = Element.fromDom(editor.getBody());

      <span class="hljs-keyword">if</span> (editor.selection.isCollapsed() === <span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">return</span> deleteRange(rootNode, editor.selection);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">backspaceDelete</span>: backspaceDelete
    };
  }
);

define(
  <span class="hljs-string">'ephox.katamari.api.Adt'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Obj'</span>,
    <span class="hljs-string">'ephox.katamari.api.Type'</span>,
    <span class="hljs-string">'global!Array'</span>,
    <span class="hljs-string">'global!Error'</span>,
    <span class="hljs-string">'global!console'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Obj, Type, Array, Error, console</span>) </span>{
    <span class="hljs-comment">/*
     * Generates a church encoded ADT (https://en.wikipedia.org/wiki/Church_encoding)
     * For syntax and use, look at the test code.
     */</span>
    <span class="hljs-keyword">var</span> generate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cases</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1221">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1221">&#182;</a>
              </div>
              <p>validation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!Type.isArray(cases)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'cases must be an array'</span>);
      }
      <span class="hljs-keyword">if</span> (cases.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'there must be at least one case'</span>);
      }

      <span class="hljs-keyword">var</span> constructors = [ ];</pre></div></div>
            
        </li>
        
        
        <li id="section-1222">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1222">&#182;</a>
              </div>
              <p>adt is mutated to add the individual cases</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> adt = {};
      Arr.each(cases, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">acase, count</span>) </span>{
        <span class="hljs-keyword">var</span> keys = Obj.keys(acase);</pre></div></div>
            
        </li>
        
        
        <li id="section-1223">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1223">&#182;</a>
              </div>
              <p>validation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (keys.length !== <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'one and only one name per case'</span>);
        }

        <span class="hljs-keyword">var</span> key = keys[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">var</span> value = acase[key];</pre></div></div>
            
        </li>
        
        
        <li id="section-1224">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1224">&#182;</a>
              </div>
              <p>validation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (adt[key] !== <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'duplicate key detected:'</span> + key);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'cata'</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'cannot have a case named cata (sorry)'</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!Type.isArray(value)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1225">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1225">&#182;</a>
              </div>
              <p>this implicitly checks if acase is an object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'case arguments must be an array'</span>);
        }

        constructors.push(key);</pre></div></div>
            
        </li>
        
        
        <li id="section-1226">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1226">&#182;</a>
              </div>
              <p>constructor for key</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        adt[key] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> argLength = <span class="hljs-built_in">arguments</span>.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-1227">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1227">&#182;</a>
              </div>
              <p>validation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (argLength !== value.length) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Wrong number of arguments to case '</span> + key + <span class="hljs-string">'. Expected '</span> + value.length + <span class="hljs-string">' ('</span> + value + <span class="hljs-string">'), got '</span> + argLength);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1228">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1228">&#182;</a>
              </div>
              <p>Dont use array slice(arguments), makes the whole function unoptimisable on Chrome</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(argLength);
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) args[i] = <span class="hljs-built_in">arguments</span>[i];


          <span class="hljs-keyword">var</span> match = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">branches</span>) </span>{
            <span class="hljs-keyword">var</span> branchKeys = Obj.keys(branches);
            <span class="hljs-keyword">if</span> (constructors.length !== branchKeys.length) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Wrong number of arguments to match. Expected: '</span> + constructors.join(<span class="hljs-string">','</span>) + <span class="hljs-string">'\nActual: '</span> + branchKeys.join(<span class="hljs-string">','</span>));
            }

            <span class="hljs-keyword">var</span> allReqd = Arr.forall(constructors, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reqKey</span>) </span>{
              <span class="hljs-keyword">return</span> Arr.contains(branchKeys, reqKey);
            });

            <span class="hljs-keyword">if</span> (!allReqd) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Not all branches were specified when using match. Specified: '</span> + branchKeys.join(<span class="hljs-string">', '</span>) + <span class="hljs-string">'\nRequired: '</span> + constructors.join(<span class="hljs-string">', '</span>));

            <span class="hljs-keyword">return</span> branches[key].apply(<span class="hljs-literal">null</span>, args);
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-1229">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1229">&#182;</a>
              </div>
              <p>the fold function for key</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">fold</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-regexp">/* arguments */</span></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1230">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1230">&#182;</a>
              </div>
              <p>runtime validation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== cases.length) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Wrong number of arguments to fold. Expected '</span> + cases.length + <span class="hljs-string">', got '</span> + <span class="hljs-built_in">arguments</span>.length);
              }
              <span class="hljs-keyword">var</span> target = <span class="hljs-built_in">arguments</span>[count];
              <span class="hljs-keyword">return</span> target.apply(<span class="hljs-literal">null</span>, args);
            },
            <span class="hljs-attr">match</span>: match,</pre></div></div>
            
        </li>
        
        
        <li id="section-1231">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1231">&#182;</a>
              </div>
              <p>NOTE: Only for debugging.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            log: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">label</span>) </span>{
              <span class="hljs-built_in">console</span>.log(label, {
                <span class="hljs-attr">constructors</span>: constructors,
                <span class="hljs-attr">constructor</span>: key,
                <span class="hljs-attr">params</span>: args
              });
            }
          };
        };
      });

      <span class="hljs-keyword">return</span> adt;
    };
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">generate</span>: generate
    };
  }
);
<span class="hljs-comment">/**
 * CefDeleteAction.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.delete.CefDeleteAction'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Adt'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Element'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretFinder'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretUtils'</span>,
    <span class="hljs-string">'tinymce.core.delete.DeleteUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.Empty'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Adt, Option, Element, CaretFinder, CaretPosition, CaretUtils, DeleteUtils, Empty, NodeType</span>) </span>{
    <span class="hljs-keyword">var</span> DeleteAction = Adt.generate([
      { <span class="hljs-attr">remove</span>: [ <span class="hljs-string">'element'</span> ] },
      { <span class="hljs-attr">moveToElement</span>: [ <span class="hljs-string">'element'</span> ] },
      { <span class="hljs-attr">moveToPosition</span>: [ <span class="hljs-string">'position'</span> ] }
    ]);

    <span class="hljs-keyword">var</span> isAtContentEditableBlockCaret = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">forward, from</span>) </span>{
      <span class="hljs-keyword">var</span> elm = <span class="hljs-keyword">from</span>.getNode(forward === <span class="hljs-literal">false</span>);
      <span class="hljs-keyword">var</span> caretLocation = forward ? <span class="hljs-string">'after'</span> : <span class="hljs-string">'before'</span>;
      <span class="hljs-keyword">return</span> NodeType.isElement(elm) &amp;&amp; elm.getAttribute(<span class="hljs-string">'data-mce-caret'</span>) === caretLocation;
    };

    <span class="hljs-keyword">var</span> deleteEmptyBlockOrMoveToCef = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, forward, from, to</span>) </span>{
      <span class="hljs-keyword">var</span> toCefElm = to.getNode(forward === <span class="hljs-literal">false</span>);
      <span class="hljs-keyword">return</span> DeleteUtils.getParentTextBlock(Element.fromDom(rootNode), Element.fromDom(<span class="hljs-keyword">from</span>.getNode())).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blockElm</span>) </span>{
        <span class="hljs-keyword">return</span> Empty.isEmpty(blockElm) ? DeleteAction.remove(blockElm.dom()) : DeleteAction.moveToElement(toCefElm);
      }).orThunk(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> Option.some(DeleteAction.moveToElement(toCefElm));
      });
    };

    <span class="hljs-keyword">var</span> findCefPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, forward, from</span>) </span>{
      <span class="hljs-keyword">return</span> CaretFinder.fromPosition(forward, rootNode, <span class="hljs-keyword">from</span>).bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">to</span>) </span>{
        <span class="hljs-keyword">if</span> (forward &amp;&amp; NodeType.isContentEditableFalse(to.getNode())) {
          <span class="hljs-keyword">return</span> deleteEmptyBlockOrMoveToCef(rootNode, forward, <span class="hljs-keyword">from</span>, to);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (forward === <span class="hljs-literal">false</span> &amp;&amp; NodeType.isContentEditableFalse(to.getNode(<span class="hljs-literal">true</span>))) {
          <span class="hljs-keyword">return</span> deleteEmptyBlockOrMoveToCef(rootNode, forward, <span class="hljs-keyword">from</span>, to);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (forward &amp;&amp; CaretUtils.isAfterContentEditableFalse(<span class="hljs-keyword">from</span>)) {
          <span class="hljs-keyword">return</span> Option.some(DeleteAction.moveToPosition(to));
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (forward === <span class="hljs-literal">false</span> &amp;&amp; CaretUtils.isBeforeContentEditableFalse(<span class="hljs-keyword">from</span>)) {
          <span class="hljs-keyword">return</span> Option.some(DeleteAction.moveToPosition(to));
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> Option.none();
        }
      });
    };

    <span class="hljs-keyword">var</span> getContentEditableBlockAction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">forward, elm</span>) </span>{
      <span class="hljs-keyword">if</span> (forward &amp;&amp; NodeType.isContentEditableFalse(elm.nextSibling)) {
        <span class="hljs-keyword">return</span> Option.some(DeleteAction.moveToElement(elm.nextSibling));
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (forward === <span class="hljs-literal">false</span> &amp;&amp; NodeType.isContentEditableFalse(elm.previousSibling)) {
        <span class="hljs-keyword">return</span> Option.some(DeleteAction.moveToElement(elm.previousSibling));
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> Option.none();
      }
    };

    <span class="hljs-keyword">var</span> getContentEditableAction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, forward, from</span>) </span>{
      <span class="hljs-keyword">if</span> (isAtContentEditableBlockCaret(forward, <span class="hljs-keyword">from</span>)) {
        <span class="hljs-keyword">return</span> getContentEditableBlockAction(forward, <span class="hljs-keyword">from</span>.getNode(forward === <span class="hljs-literal">false</span>))
          .fold(
            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">return</span> findCefPosition(rootNode, forward, <span class="hljs-keyword">from</span>);
            },
            Option.some
          );
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> findCefPosition(rootNode, forward, <span class="hljs-keyword">from</span>);
      }
    };

    <span class="hljs-keyword">var</span> read = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, forward, rng</span>) </span>{
      <span class="hljs-keyword">var</span> normalizedRange = CaretUtils.normalizeRange(forward ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>, rootNode, rng);
      <span class="hljs-keyword">var</span> <span class="hljs-keyword">from</span> = CaretPosition.fromRangeStart(normalizedRange);

      <span class="hljs-keyword">if</span> (forward === <span class="hljs-literal">false</span> &amp;&amp; CaretUtils.isAfterContentEditableFalse(<span class="hljs-keyword">from</span>)) {
        <span class="hljs-keyword">return</span> Option.some(DeleteAction.remove(<span class="hljs-keyword">from</span>.getNode(<span class="hljs-literal">true</span>)));
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (forward &amp;&amp; CaretUtils.isBeforeContentEditableFalse(<span class="hljs-keyword">from</span>)) {
        <span class="hljs-keyword">return</span> Option.some(DeleteAction.remove(<span class="hljs-keyword">from</span>.getNode()));
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> getContentEditableAction(rootNode, forward, <span class="hljs-keyword">from</span>);
      }
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">read</span>: read
    };
  }
);

<span class="hljs-comment">/**
 * Bidi.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.text.Bidi'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> strongRtl = <span class="hljs-regexp">/[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/</span>;

    <span class="hljs-keyword">var</span> hasStrongRtl = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
      <span class="hljs-keyword">return</span> strongRtl.test(text);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">hasStrongRtl</span>: hasStrongRtl
    };
  }
);
<span class="hljs-comment">/**
 * InlineUtils.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.keyboard.InlineUtils'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'ephox.katamari.api.Options'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretContainer'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretFinder'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretUtils'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretWalker'</span>,
    <span class="hljs-string">'tinymce.core.dom.DOMUtils'</span>,
    <span class="hljs-string">'tinymce.core.text.Bidi'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, Option, Options, CaretContainer, CaretFinder, CaretPosition, CaretUtils, CaretWalker, DOMUtils, Bidi</span>) </span>{
    <span class="hljs-keyword">var</span> isInlineTarget = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> DOMUtils.DOM.is(elm, <span class="hljs-string">'a[href],code'</span>);
    };

    <span class="hljs-keyword">var</span> isRtl = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">return</span> DOMUtils.DOM.getStyle(element, <span class="hljs-string">'direction'</span>, <span class="hljs-literal">true</span>) === <span class="hljs-string">'rtl'</span> || Bidi.hasStrongRtl(element.textContent);
    };

    <span class="hljs-keyword">var</span> findInline = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, pos</span>) </span>{
      <span class="hljs-keyword">return</span> Option.from(DOMUtils.DOM.getParent(pos.container(), isInlineTarget, rootNode));
    };

    <span class="hljs-keyword">var</span> hasSameParentBlock = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, node1, node2</span>) </span>{
      <span class="hljs-keyword">var</span> block1 = CaretUtils.getParentBlock(node1, rootNode);
      <span class="hljs-keyword">var</span> block2 = CaretUtils.getParentBlock(node2, rootNode);
      <span class="hljs-keyword">return</span> block1 &amp;&amp; block1 === block2;
    };

    <span class="hljs-keyword">var</span> isInInline = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, pos</span>) </span>{
      <span class="hljs-keyword">return</span> pos ? findInline(rootNode, pos).isSome() : <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">var</span> isAtInlineEndPoint = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, pos</span>) </span>{
      <span class="hljs-keyword">return</span> findInline(rootNode, pos).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inline</span>) </span>{
        <span class="hljs-keyword">return</span> findCaretPosition(inline, <span class="hljs-literal">false</span>, pos).isNone() || findCaretPosition(inline, <span class="hljs-literal">true</span>, pos).isNone();
      }).getOr(<span class="hljs-literal">false</span>);
    };

    <span class="hljs-keyword">var</span> isAtZwsp = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
      <span class="hljs-keyword">return</span> CaretContainer.isBeforeInline(pos) || CaretContainer.isAfterInline(pos);
    };

    <span class="hljs-keyword">var</span> findCaretPositionIn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, forward</span>) </span>{
      <span class="hljs-keyword">return</span> CaretFinder.positionIn(forward, node);
    };

    <span class="hljs-keyword">var</span> findCaretPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, forward, from</span>) </span>{
      <span class="hljs-keyword">return</span> CaretFinder.fromPosition(forward, rootNode, <span class="hljs-keyword">from</span>);
    };

    <span class="hljs-keyword">var</span> normalizePosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">forward, pos</span>) </span>{
      <span class="hljs-keyword">var</span> container = pos.container(), offset = pos.offset();

      <span class="hljs-keyword">if</span> (forward) {
        <span class="hljs-keyword">return</span> CaretContainer.isBeforeInline(pos) ? <span class="hljs-keyword">new</span> CaretPosition(container, offset + <span class="hljs-number">1</span>) : pos;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> CaretContainer.isAfterInline(pos) ? <span class="hljs-keyword">new</span> CaretPosition(container, offset - <span class="hljs-number">1</span>) : pos;
      }
    };

    <span class="hljs-keyword">var</span> normalizeForwards = Fun.curry(normalizePosition, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">var</span> normalizeBackwards = Fun.curry(normalizePosition, <span class="hljs-literal">false</span>);

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">isInlineTarget</span>: isInlineTarget,
      <span class="hljs-attr">findInline</span>: findInline,
      <span class="hljs-attr">isInInline</span>: isInInline,
      <span class="hljs-attr">isRtl</span>: isRtl,
      <span class="hljs-attr">isAtInlineEndPoint</span>: isAtInlineEndPoint,
      <span class="hljs-attr">isAtZwsp</span>: isAtZwsp,
      <span class="hljs-attr">findCaretPositionIn</span>: findCaretPositionIn,
      <span class="hljs-attr">findCaretPosition</span>: findCaretPosition,
      <span class="hljs-attr">normalizePosition</span>: normalizePosition,
      <span class="hljs-attr">normalizeForwards</span>: normalizeForwards,
      <span class="hljs-attr">normalizeBackwards</span>: normalizeBackwards,
      <span class="hljs-attr">hasSameParentBlock</span>: hasSameParentBlock
    };
  }
);
<span class="hljs-comment">/**
 * DeleteElement.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.delete.DeleteElement'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'ephox.sugar.api.dom.Insert'</span>,
    <span class="hljs-string">'ephox.sugar.api.dom.Remove'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Element'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Node'</span>,
    <span class="hljs-string">'ephox.sugar.api.search.PredicateFind'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretCandidate'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.dom.Empty'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.InlineUtils'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, Option, Insert, Remove, Element, Node, PredicateFind, CaretCandidate, CaretPosition, Empty, NodeType, InlineUtils</span>) </span>{
    <span class="hljs-keyword">var</span> needsReposition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos, elm</span>) </span>{
      <span class="hljs-keyword">var</span> container = pos.container();
      <span class="hljs-keyword">var</span> offset = pos.offset();
      <span class="hljs-keyword">return</span> CaretPosition.isTextPosition(pos) === <span class="hljs-literal">false</span> &amp;&amp; container === elm.parentNode &amp;&amp; offset &gt; CaretPosition.before(elm).offset();
    };

    <span class="hljs-keyword">var</span> reposition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, pos</span>) </span>{
      <span class="hljs-keyword">return</span> needsReposition(pos, elm) ? <span class="hljs-keyword">new</span> CaretPosition(pos.container(), pos.offset() - <span class="hljs-number">1</span>) : pos;
    };

    <span class="hljs-keyword">var</span> beforeOrStartOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> NodeType.isText(node) ? <span class="hljs-keyword">new</span> CaretPosition(node, <span class="hljs-number">0</span>) : CaretPosition.before(node);
    };

    <span class="hljs-keyword">var</span> afterOrEndOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> NodeType.isText(node) ? <span class="hljs-keyword">new</span> CaretPosition(node, node.data.length) : CaretPosition.after(node);
    };

    <span class="hljs-keyword">var</span> getPreviousSiblingCaretPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">if</span> (CaretCandidate.isCaretCandidate(elm.previousSibling)) {
        <span class="hljs-keyword">return</span> Option.some(afterOrEndOf(elm.previousSibling));
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> elm.previousSibling ? InlineUtils.findCaretPositionIn(elm.previousSibling, <span class="hljs-literal">false</span>) : Option.none();
      }
    };

    <span class="hljs-keyword">var</span> getNextSiblingCaretPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">if</span> (CaretCandidate.isCaretCandidate(elm.nextSibling)) {
        <span class="hljs-keyword">return</span> Option.some(beforeOrStartOf(elm.nextSibling));
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> elm.nextSibling ? InlineUtils.findCaretPositionIn(elm.nextSibling, <span class="hljs-literal">true</span>) : Option.none();
      }
    };

    <span class="hljs-keyword">var</span> findCaretPositionBackwardsFromElm = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootElement, elm</span>) </span>{
      <span class="hljs-keyword">var</span> startPosition = CaretPosition.before(elm.previousSibling ? elm.previousSibling : elm.parentNode);
      <span class="hljs-keyword">return</span> InlineUtils.findCaretPosition(rootElement, <span class="hljs-literal">false</span>, startPosition).fold(
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> InlineUtils.findCaretPosition(rootElement, <span class="hljs-literal">true</span>, CaretPosition.after(elm));
        },
        Option.some
      );
    };

    <span class="hljs-keyword">var</span> findCaretPositionForwardsFromElm = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootElement, elm</span>) </span>{
      <span class="hljs-keyword">return</span> InlineUtils.findCaretPosition(rootElement, <span class="hljs-literal">true</span>, CaretPosition.after(elm)).fold(
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> InlineUtils.findCaretPosition(rootElement, <span class="hljs-literal">false</span>, CaretPosition.before(elm));
        },
        Option.some
      );
    };

    <span class="hljs-keyword">var</span> findCaretPositionBackwards = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootElement, elm</span>) </span>{
      <span class="hljs-keyword">return</span> getPreviousSiblingCaretPosition(elm).orThunk(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> getNextSiblingCaretPosition(elm);
      }).orThunk(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> findCaretPositionBackwardsFromElm(rootElement, elm);
      });
    };

    <span class="hljs-keyword">var</span> findCaretPositionForward = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootElement, elm</span>) </span>{
      <span class="hljs-keyword">return</span> getNextSiblingCaretPosition(elm).orThunk(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> getPreviousSiblingCaretPosition(elm);
      }).orThunk(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> findCaretPositionForwardsFromElm(rootElement, elm);
      });
    };

    <span class="hljs-keyword">var</span> findCaretPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">forward, rootElement, elm</span>) </span>{
      <span class="hljs-keyword">return</span> forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
    };

    <span class="hljs-keyword">var</span> findCaretPosOutsideElmAfterDelete = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">forward, rootElement, elm</span>) </span>{
      <span class="hljs-keyword">return</span> findCaretPosition(forward, rootElement, elm).map(Fun.curry(reposition, elm));
    };

    <span class="hljs-keyword">var</span> setSelection = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, forward, pos</span>) </span>{
      pos.fold(
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          editor.focus();
        },
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
          editor.selection.setRng(pos.toRange(), forward);
        }
      );
    };

    <span class="hljs-keyword">var</span> eqRawNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rawNode</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">return</span> elm.dom() === rawNode;
      };
    };

    <span class="hljs-keyword">var</span> isBlock = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, elm</span>) </span>{
      <span class="hljs-keyword">return</span> elm &amp;&amp; editor.schema.getBlockElements().hasOwnProperty(Node.name(elm));
    };

    <span class="hljs-keyword">var</span> paddEmptyBlock = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">if</span> (Empty.isEmpty(elm)) {
        <span class="hljs-keyword">var</span> br = Element.fromHtml(<span class="hljs-string">'&lt;br data-mce-bogus="1"&gt;'</span>);
        Remove.empty(elm);
        Insert.append(elm, br);
        <span class="hljs-keyword">return</span> Option.some(CaretPosition.before(br.dom()));
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> Option.none();
      }
    };

    <span class="hljs-keyword">var</span> deleteElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, forward, elm</span>) </span>{
      <span class="hljs-keyword">var</span> afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom());
      <span class="hljs-keyword">var</span> parentBlock = PredicateFind.ancestor(elm, Fun.curry(isBlock, editor), eqRawNode(editor.getBody()));

      Remove.remove(elm);

      parentBlock.bind(paddEmptyBlock).fold(
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          setSelection(editor, forward, afterDeletePos);
        },
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">paddPos</span>) </span>{
          setSelection(editor, forward, Option.some(paddPos));
        }
      );
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">deleteElement</span>: deleteElement
    };
  }
);
<span class="hljs-comment">/**
 * CefDelete.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.delete.CefDelete'</span>,
  [
    <span class="hljs-string">'ephox.sugar.api.node.Element'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretUtils'</span>,
    <span class="hljs-string">'tinymce.core.delete.BlockBoundary'</span>,
    <span class="hljs-string">'tinymce.core.delete.CefDeleteAction'</span>,
    <span class="hljs-string">'tinymce.core.delete.DeleteElement'</span>,
    <span class="hljs-string">'tinymce.core.delete.MergeBlocks'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Element, CaretPosition, CaretUtils, BlockBoundary, CefDeleteAction, DeleteElement, MergeBlocks, NodeType</span>) </span>{
    <span class="hljs-keyword">var</span> deleteElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, forward</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
        DeleteElement.deleteElement(editor, forward, Element.fromDom(element));
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      };
    };

    <span class="hljs-keyword">var</span> moveToElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, forward</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
        <span class="hljs-keyword">var</span> pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);
        editor.selection.setRng(pos.toRange());
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      };
    };

    <span class="hljs-keyword">var</span> moveToPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
        editor.selection.setRng(pos.toRange());
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      };
    };

    <span class="hljs-keyword">var</span> backspaceDeleteCaret = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, forward</span>) </span>{
      <span class="hljs-keyword">var</span> result = CefDeleteAction.read(editor.getBody(), forward, editor.selection.getRng()).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">deleteAction</span>) </span>{
        <span class="hljs-keyword">return</span> deleteAction.fold(
          deleteElement(editor, forward),
          moveToElement(editor, forward),
          moveToPosition(editor)
        );
      });

      <span class="hljs-keyword">return</span> result.getOr(<span class="hljs-literal">false</span>);
    };

    <span class="hljs-keyword">var</span> backspaceDeleteRange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, forward</span>) </span>{
      <span class="hljs-keyword">var</span> selectedElement = editor.selection.getNode();
      <span class="hljs-keyword">if</span> (NodeType.isContentEditableFalse(selectedElement)) {
        DeleteElement.deleteElement(editor, forward, Element.fromDom(editor.selection.getNode()));
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    };

    <span class="hljs-keyword">var</span> getContentEditableRoot = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, node</span>) </span>{
      <span class="hljs-keyword">while</span> (node &amp;&amp; node !== root) {
        <span class="hljs-keyword">if</span> (NodeType.isContentEditableTrue(node) || NodeType.isContentEditableFalse(node)) {
          <span class="hljs-keyword">return</span> node;
        }

        node = node.parentNode;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    };

    <span class="hljs-keyword">var</span> paddEmptyElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> br, ceRoot = getContentEditableRoot(editor.getBody(), editor.selection.getNode());

      <span class="hljs-keyword">if</span> (NodeType.isContentEditableTrue(ceRoot) &amp;&amp; editor.dom.isBlock(ceRoot) &amp;&amp; editor.dom.isEmpty(ceRoot)) {
        br = editor.dom.create(<span class="hljs-string">'br'</span>, { <span class="hljs-string">"data-mce-bogus"</span>: <span class="hljs-string">"1"</span> });
        editor.dom.setHTML(ceRoot, <span class="hljs-string">''</span>);
        ceRoot.appendChild(br);
        editor.selection.setRng(CaretPosition.before(br).toRange());
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    };

    <span class="hljs-keyword">var</span> backspaceDelete = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, forward</span>) </span>{
      <span class="hljs-keyword">if</span> (editor.selection.isCollapsed()) {
        <span class="hljs-keyword">return</span> backspaceDeleteCaret(editor, forward);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> backspaceDeleteRange(editor, forward);
      }
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">backspaceDelete</span>: backspaceDelete,
      <span class="hljs-attr">paddEmptyElement</span>: paddEmptyElement
    };
  }
);

<span class="hljs-comment">/**
 * CaretContainerInline.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.caret.CaretContainerInline'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.text.Zwsp'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, NodeType, Zwsp</span>) </span>{
    <span class="hljs-keyword">var</span> isText = NodeType.isText;

    <span class="hljs-keyword">var</span> startsWithCaretContainer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> isText(node) &amp;&amp; node.data[<span class="hljs-number">0</span>] === Zwsp.ZWSP;
    };

    <span class="hljs-keyword">var</span> endsWithCaretContainer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> isText(node) &amp;&amp; node.data[node.data.length - <span class="hljs-number">1</span>] === Zwsp.ZWSP;
    };

    <span class="hljs-keyword">var</span> createZwsp = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> node.ownerDocument.createTextNode(Zwsp.ZWSP);
    };

    <span class="hljs-keyword">var</span> insertBefore = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">if</span> (isText(node.previousSibling)) {
        <span class="hljs-keyword">if</span> (endsWithCaretContainer(node.previousSibling)) {
          <span class="hljs-keyword">return</span> node.previousSibling;
        } <span class="hljs-keyword">else</span> {
          node.previousSibling.appendData(Zwsp.ZWSP);
          <span class="hljs-keyword">return</span> node.previousSibling;
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isText(node)) {
        <span class="hljs-keyword">if</span> (startsWithCaretContainer(node)) {
          <span class="hljs-keyword">return</span> node;
        } <span class="hljs-keyword">else</span> {
          node.insertData(<span class="hljs-number">0</span>, Zwsp.ZWSP);
          <span class="hljs-keyword">return</span> node;
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> newNode = createZwsp(node);
        node.parentNode.insertBefore(newNode, node);
        <span class="hljs-keyword">return</span> newNode;
      }
    };

    <span class="hljs-keyword">var</span> insertAfter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">if</span> (isText(node.nextSibling)) {
        <span class="hljs-keyword">if</span> (startsWithCaretContainer(node.nextSibling)) {
          <span class="hljs-keyword">return</span> node.nextSibling;
        } <span class="hljs-keyword">else</span> {
          node.nextSibling.insertData(<span class="hljs-number">0</span>, Zwsp.ZWSP);
          <span class="hljs-keyword">return</span> node.nextSibling;
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isText(node)) {
        <span class="hljs-keyword">if</span> (endsWithCaretContainer(node)) {
          <span class="hljs-keyword">return</span> node;
        } <span class="hljs-keyword">else</span> {
          node.appendData(Zwsp.ZWSP);
          <span class="hljs-keyword">return</span> node;
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> newNode = createZwsp(node);
        <span class="hljs-keyword">if</span> (node.nextSibling) {
          node.parentNode.insertBefore(newNode, node.nextSibling);
        } <span class="hljs-keyword">else</span> {
          node.parentNode.appendChild(newNode);
        }
        <span class="hljs-keyword">return</span> newNode;
      }
    };

    <span class="hljs-keyword">var</span> insertInline = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">before, node</span>) </span>{
      <span class="hljs-keyword">return</span> before ? insertBefore(node) : insertAfter(node);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">insertInline</span>: insertInline,
      <span class="hljs-attr">insertInlineBefore</span>: Fun.curry(insertInline, <span class="hljs-literal">true</span>),
      <span class="hljs-attr">insertInlineAfter</span>: Fun.curry(insertInline, <span class="hljs-literal">false</span>)
    };
  }
);
<span class="hljs-comment">/**
 * CaretContainerRemove.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.caret.CaretContainerRemove'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretContainer'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.text.Zwsp'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, CaretContainer, CaretPosition, NodeType, Zwsp, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> isElement = NodeType.isElement;
    <span class="hljs-keyword">var</span> isText = NodeType.isText;

    <span class="hljs-keyword">var</span> removeNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">var</span> parentNode = node.parentNode;
      <span class="hljs-keyword">if</span> (parentNode) {
        parentNode.removeChild(node);
      }
    };

    <span class="hljs-keyword">var</span> getNodeValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> node.nodeValue;
      } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1232">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1232">&#182;</a>
              </div>
              <p>IE sometimes produces Invalid argument on nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
      }
    };

    <span class="hljs-keyword">var</span> setNodeValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, text</span>) </span>{
      <span class="hljs-keyword">if</span> (text.length === <span class="hljs-number">0</span>) {
        removeNode(node);
      } <span class="hljs-keyword">else</span> {
        node.nodeValue = text;
      }
    };

    <span class="hljs-keyword">var</span> trimCount = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
      <span class="hljs-keyword">var</span> trimmedText = Zwsp.trim(text);
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: text.length - trimmedText.length, <span class="hljs-attr">text</span>: trimmedText };
    };

    <span class="hljs-keyword">var</span> removeUnchanged = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">caretContainer, pos</span>) </span>{
      remove(caretContainer);
      <span class="hljs-keyword">return</span> pos;
    };

    <span class="hljs-keyword">var</span> removeTextAndReposition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">caretContainer, pos</span>) </span>{
      <span class="hljs-keyword">var</span> before = trimCount(caretContainer.data.substr(<span class="hljs-number">0</span>, pos.offset()));
      <span class="hljs-keyword">var</span> after = trimCount(caretContainer.data.substr(pos.offset()));
      <span class="hljs-keyword">var</span> text = before.text + after.text;

      <span class="hljs-keyword">if</span> (text.length &gt; <span class="hljs-number">0</span>) {
        setNodeValue(caretContainer, text);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CaretPosition(caretContainer, pos.offset() - before.count);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> pos;
      }
    };

    <span class="hljs-keyword">var</span> removeElementAndReposition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">caretContainer, pos</span>) </span>{
      <span class="hljs-keyword">var</span> parentNode = pos.container();
      <span class="hljs-keyword">var</span> newPosition = Arr.indexOf(parentNode.childNodes, caretContainer).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>{
        <span class="hljs-keyword">return</span> index &lt; pos.offset() ? <span class="hljs-keyword">new</span> CaretPosition(parentNode, pos.offset() - <span class="hljs-number">1</span>) : pos;
      }).getOr(pos);
      remove(caretContainer);
      <span class="hljs-keyword">return</span> newPosition;
    };

    <span class="hljs-keyword">var</span> removeTextCaretContainer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">caretContainer, pos</span>) </span>{
      <span class="hljs-keyword">return</span> pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    };

    <span class="hljs-keyword">var</span> removeElementCaretContainer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">caretContainer, pos</span>) </span>{
      <span class="hljs-keyword">return</span> pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    };

    <span class="hljs-keyword">var</span> removeAndReposition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">container, pos</span>) </span>{
      <span class="hljs-keyword">return</span> CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
    };

    <span class="hljs-keyword">var</span> remove = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">caretContainerNode</span>) </span>{
      <span class="hljs-keyword">if</span> (isElement(caretContainerNode) &amp;&amp; CaretContainer.isCaretContainer(caretContainerNode)) {
        <span class="hljs-keyword">if</span> (CaretContainer.hasContent(caretContainerNode)) {
          caretContainerNode.removeAttribute(<span class="hljs-string">'data-mce-caret'</span>);
        } <span class="hljs-keyword">else</span> {
          removeNode(caretContainerNode);
        }
      }

      <span class="hljs-keyword">if</span> (isText(caretContainerNode)) {
        <span class="hljs-keyword">var</span> text = Zwsp.trim(getNodeValue(caretContainerNode));
        setNodeValue(caretContainerNode, text);
      }
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">removeAndReposition</span>: removeAndReposition,
      <span class="hljs-attr">remove</span>: remove
    };
  }
);
<span class="hljs-comment">/**
 * BoundaryCaret.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.keyboard.BoundaryCaret'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretContainer'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretContainerInline'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretContainerRemove'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.InlineUtils'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Option, CaretContainer, CaretContainerInline, CaretContainerRemove, CaretPosition, NodeType, InlineUtils</span>) </span>{
    <span class="hljs-keyword">var</span> insertInlinePos = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos, before</span>) </span>{
      <span class="hljs-keyword">if</span> (NodeType.isText(pos.container())) {
        <span class="hljs-keyword">return</span> CaretContainerInline.insertInline(before, pos.container());
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> CaretContainerInline.insertInline(before, pos.getNode());
      }
    };

    <span class="hljs-keyword">var</span> renderCaret = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">caret, location</span>) </span>{
      <span class="hljs-keyword">return</span> location.fold(
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{ <span class="hljs-comment">// Before</span>
          CaretContainerRemove.remove(caret.get());
          <span class="hljs-keyword">var</span> text = CaretContainerInline.insertInlineBefore(element);
          caret.set(text);
          <span class="hljs-keyword">return</span> Option.some(<span class="hljs-keyword">new</span> CaretPosition(text, text.length - <span class="hljs-number">1</span>));
        },
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{ <span class="hljs-comment">// Start</span>
          <span class="hljs-keyword">return</span> InlineUtils.findCaretPositionIn(element, <span class="hljs-literal">true</span>).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
            CaretContainerRemove.remove(caret.get());
            <span class="hljs-keyword">var</span> text = insertInlinePos(pos, <span class="hljs-literal">true</span>);
            caret.set(text);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CaretPosition(text, <span class="hljs-number">1</span>);
          });
        },
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{ <span class="hljs-comment">// End</span>
          <span class="hljs-keyword">return</span> InlineUtils.findCaretPositionIn(element, <span class="hljs-literal">false</span>).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
            CaretContainerRemove.remove(caret.get());
            <span class="hljs-keyword">var</span> text = insertInlinePos(pos, <span class="hljs-literal">false</span>);
            caret.set(text);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CaretPosition(text, text.length - <span class="hljs-number">1</span>);
          });
        },
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{ <span class="hljs-comment">// After</span>
          CaretContainerRemove.remove(caret.get());
          <span class="hljs-keyword">var</span> text = CaretContainerInline.insertInlineAfter(element);
          caret.set(text);
          <span class="hljs-keyword">return</span> Option.some(<span class="hljs-keyword">new</span> CaretPosition(text, <span class="hljs-number">1</span>));
        }
      );
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">renderCaret</span>: renderCaret
    };
  }
);
<span class="hljs-comment">/**
 * LazyEvaluator.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.util.LazyEvaluator'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Option'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Option</span>) </span>{
    <span class="hljs-keyword">var</span> evaluateUntil = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fns, args</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; fns.length; i++) {
        <span class="hljs-keyword">var</span> result = fns[i].apply(<span class="hljs-literal">null</span>, args);
        <span class="hljs-keyword">if</span> (result.isSome()) {
          <span class="hljs-keyword">return</span> result;
        }
      }

      <span class="hljs-keyword">return</span> Option.none();
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">evaluateUntil</span>: evaluateUntil
    };
  }
);
<span class="hljs-comment">/**
 * BoundaryLocation.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.keyboard.BoundaryLocation'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Adt'</span>,
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'ephox.katamari.api.Options'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretContainer'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.InlineUtils'</span>,
    <span class="hljs-string">'tinymce.core.util.LazyEvaluator'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Adt, Fun, Option, Options, CaretContainer, CaretPosition, CaretUtils, NodeType, InlineUtils, LazyEvaluator</span>) </span>{
    <span class="hljs-keyword">var</span> Location = Adt.generate([
      { <span class="hljs-attr">before</span>: [ <span class="hljs-string">'element'</span> ] },
      { <span class="hljs-attr">start</span>: [ <span class="hljs-string">'element'</span> ] },
      { <span class="hljs-attr">end</span>: [ <span class="hljs-string">'element'</span> ] },
      { <span class="hljs-attr">after</span>: [ <span class="hljs-string">'element'</span> ] }
    ]);

    <span class="hljs-keyword">var</span> rescope = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, node</span>) </span>{
      <span class="hljs-keyword">var</span> parentBlock = CaretUtils.getParentBlock(node, rootNode);
      <span class="hljs-keyword">return</span> parentBlock ? parentBlock : rootNode;
    };

    <span class="hljs-keyword">var</span> before = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, pos</span>) </span>{
      <span class="hljs-keyword">var</span> nPos = InlineUtils.normalizeForwards(pos);
      <span class="hljs-keyword">var</span> scope = rescope(rootNode, nPos.container());
      <span class="hljs-keyword">return</span> InlineUtils.findInline(scope, nPos).fold(
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> InlineUtils.findCaretPosition(scope, <span class="hljs-literal">true</span>, nPos)
            .bind(Fun.curry(InlineUtils.findInline, scope))
            .map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inline</span>) </span>{
              <span class="hljs-keyword">return</span> Location.before(inline);
            });
        },
        Option.none
      );
    };

    <span class="hljs-keyword">var</span> start = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, pos</span>) </span>{
      <span class="hljs-keyword">var</span> nPos = InlineUtils.normalizeBackwards(pos);
      <span class="hljs-keyword">return</span> InlineUtils.findInline(rootNode, nPos).bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inline</span>) </span>{
        <span class="hljs-keyword">var</span> prevPos = InlineUtils.findCaretPosition(inline, <span class="hljs-literal">false</span>, nPos);
        <span class="hljs-keyword">return</span> prevPos.isNone() ? Option.some(Location.start(inline)) : Option.none();
      });
    };

    <span class="hljs-keyword">var</span> end = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, pos</span>) </span>{
      <span class="hljs-keyword">var</span> nPos = InlineUtils.normalizeForwards(pos);
      <span class="hljs-keyword">return</span> InlineUtils.findInline(rootNode, nPos).bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inline</span>) </span>{
        <span class="hljs-keyword">var</span> nextPos = InlineUtils.findCaretPosition(inline, <span class="hljs-literal">true</span>, nPos);
        <span class="hljs-keyword">return</span> nextPos.isNone() ? Option.some(Location.end(inline)) : Option.none();
      });
    };

    <span class="hljs-keyword">var</span> after = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, pos</span>) </span>{
      <span class="hljs-keyword">var</span> nPos = InlineUtils.normalizeBackwards(pos);
      <span class="hljs-keyword">var</span> scope = rescope(rootNode, nPos.container());
      <span class="hljs-keyword">return</span> InlineUtils.findInline(scope, nPos).fold(
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> InlineUtils.findCaretPosition(scope, <span class="hljs-literal">false</span>, nPos)
            .bind(Fun.curry(InlineUtils.findInline, scope))
            .map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inline</span>) </span>{
              <span class="hljs-keyword">return</span> Location.after(inline);
            });
        },
        Option.none
      );
    };

    <span class="hljs-keyword">var</span> isValidLocation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">location</span>) </span>{
      <span class="hljs-keyword">return</span> InlineUtils.isRtl(getElement(location)) === <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">var</span> readLocation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, pos</span>) </span>{
      <span class="hljs-keyword">var</span> location = LazyEvaluator.evaluateUntil([
        before,
        start,
        end,
        after
      ], [rootNode, pos]);

      <span class="hljs-keyword">return</span> location.filter(isValidLocation);
    };

    <span class="hljs-keyword">var</span> getElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">location</span>) </span>{
      <span class="hljs-keyword">return</span> location.fold(
        Fun.identity, <span class="hljs-comment">// Before</span>
        Fun.identity, <span class="hljs-comment">// Start</span>
        Fun.identity, <span class="hljs-comment">// End</span>
        Fun.identity  <span class="hljs-comment">// After</span>
      );
    };

    <span class="hljs-keyword">var</span> getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">location</span>) </span>{
      <span class="hljs-keyword">return</span> location.fold(
        Fun.constant(<span class="hljs-string">'before'</span>), <span class="hljs-comment">// Before</span>
        Fun.constant(<span class="hljs-string">'start'</span>),  <span class="hljs-comment">// Start</span>
        Fun.constant(<span class="hljs-string">'end'</span>),    <span class="hljs-comment">// End</span>
        Fun.constant(<span class="hljs-string">'after'</span>)   <span class="hljs-comment">// After</span>
      );
    };

    <span class="hljs-keyword">var</span> outside = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">location</span>) </span>{
      <span class="hljs-keyword">return</span> location.fold(
        Location.before, <span class="hljs-comment">// Before</span>
        Location.before, <span class="hljs-comment">// Start</span>
        Location.after,  <span class="hljs-comment">// End</span>
        Location.after   <span class="hljs-comment">// After</span>
      );
    };

    <span class="hljs-keyword">var</span> inside = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">location</span>) </span>{
      <span class="hljs-keyword">return</span> location.fold(
        Location.start, <span class="hljs-comment">// Before</span>
        Location.start, <span class="hljs-comment">// Start</span>
        Location.end,   <span class="hljs-comment">// End</span>
        Location.end    <span class="hljs-comment">// After</span>
      );
    };

    <span class="hljs-keyword">var</span> isEq = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">location1, location2</span>) </span>{
      <span class="hljs-keyword">return</span> getName(location1) === getName(location2) &amp;&amp; getElement(location1) === getElement(location2);
    };

    <span class="hljs-keyword">var</span> betweenInlines = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">forward, rootNode, from, to, location</span>) </span>{
      <span class="hljs-keyword">return</span> Options.liftN([
        InlineUtils.findInline(rootNode, <span class="hljs-keyword">from</span>),
        InlineUtils.findInline(rootNode, to)
      ], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fromInline, toInline</span>) </span>{
        <span class="hljs-keyword">if</span> (fromInline !== toInline &amp;&amp; InlineUtils.hasSameParentBlock(rootNode, fromInline, toInline)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1233">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1233">&#182;</a>
              </div>
              <p>Force after since some browsers normalize and lean left into the closest inline</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> Location.after(forward ? fromInline : toInline);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> location;
        }
      }).getOr(location);
    };

    <span class="hljs-keyword">var</span> skipNoMovement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fromLocation, toLocation</span>) </span>{
      <span class="hljs-keyword">return</span> fromLocation.fold(
        Fun.constant(<span class="hljs-literal">true</span>),
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fromLocation</span>) </span>{
          <span class="hljs-keyword">return</span> !isEq(fromLocation, toLocation);
        }
      );
    };

    <span class="hljs-keyword">var</span> findLocationTraverse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">forward, rootNode, fromLocation, pos</span>) </span>{
      <span class="hljs-keyword">var</span> <span class="hljs-keyword">from</span> = InlineUtils.normalizePosition(forward, pos);
      <span class="hljs-keyword">var</span> to = InlineUtils.findCaretPosition(rootNode, forward, <span class="hljs-keyword">from</span>).map(Fun.curry(InlineUtils.normalizePosition, forward));

      <span class="hljs-keyword">var</span> location = to.fold(
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> fromLocation.map(outside);
        },
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">to</span>) </span>{
          <span class="hljs-keyword">return</span> readLocation(rootNode, to)
            .map(Fun.curry(betweenInlines, forward, rootNode, <span class="hljs-keyword">from</span>, to))
            .filter(Fun.curry(skipNoMovement, fromLocation));
        }
      );

      <span class="hljs-keyword">return</span> location.filter(isValidLocation);
    };

    <span class="hljs-keyword">var</span> findLocationSimple = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">forward, location</span>) </span>{
      <span class="hljs-keyword">if</span> (forward) {
        <span class="hljs-keyword">return</span> location.fold(
          Fun.compose(Option.some, Location.start), <span class="hljs-comment">// Before -&gt; Start</span>
          Option.none,
          Fun.compose(Option.some, Location.after), <span class="hljs-comment">// End -&gt; After</span>
          Option.none
        );
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> location.fold(
          Option.none,
          Fun.compose(Option.some, Location.before), <span class="hljs-comment">// Before &lt;- Start</span>
          Option.none,
          Fun.compose(Option.some, Location.end) <span class="hljs-comment">// End &lt;- After</span>
        );
      }
    };

    <span class="hljs-keyword">var</span> findLocation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">forward, rootNode, pos</span>) </span>{
      <span class="hljs-keyword">var</span> <span class="hljs-keyword">from</span> = InlineUtils.normalizePosition(forward, pos);
      <span class="hljs-keyword">var</span> fromLocation = readLocation(rootNode, <span class="hljs-keyword">from</span>);

      <span class="hljs-keyword">return</span> readLocation(rootNode, <span class="hljs-keyword">from</span>).bind(Fun.curry(findLocationSimple, forward)).orThunk(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> findLocationTraverse(forward, rootNode, fromLocation, pos);
      });
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">readLocation</span>: readLocation,
      <span class="hljs-attr">prevLocation</span>: Fun.curry(findLocation, <span class="hljs-literal">false</span>),
      <span class="hljs-attr">nextLocation</span>: Fun.curry(findLocation, <span class="hljs-literal">true</span>),
      <span class="hljs-attr">getElement</span>: getElement,
      <span class="hljs-attr">outside</span>: outside,
      <span class="hljs-attr">inside</span>: inside
    };
  }
);
define(
  <span class="hljs-string">'ephox.katamari.api.Cell'</span>,

  [
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> Cell = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initial</span>) </span>{
      <span class="hljs-keyword">var</span> value = initial;

      <span class="hljs-keyword">var</span> get = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> value;
      };

      <span class="hljs-keyword">var</span> set = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
        value = v;
      };

      <span class="hljs-keyword">var</span> clone = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> Cell(get());
      };

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">get</span>: get,
        <span class="hljs-attr">set</span>: set,
        <span class="hljs-attr">clone</span>: clone
      };
    };

    <span class="hljs-keyword">return</span> Cell;
  }
);

<span class="hljs-comment">/**
 * BoundarySelection.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.keyboard.BoundarySelection'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Cell'</span>,
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretContainerRemove'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.BoundaryCaret'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.BoundaryLocation'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.InlineUtils'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Cell, Fun, CaretContainerRemove, CaretPosition, BoundaryCaret, BoundaryLocation, InlineUtils</span>) </span>{
    <span class="hljs-keyword">var</span> setCaretPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, pos</span>) </span>{
      <span class="hljs-keyword">var</span> rng = editor.dom.createRng();
      rng.setStart(pos.container(), pos.offset());
      rng.setEnd(pos.container(), pos.offset());
      editor.selection.setRng(rng);
    };

    <span class="hljs-keyword">var</span> isFeatureEnabled = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">return</span> editor.settings.inline_boundaries !== <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">var</span> setSelected = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state, elm</span>) </span>{
      <span class="hljs-keyword">if</span> (state) {
        elm.setAttribute(<span class="hljs-string">'data-mce-selected'</span>, <span class="hljs-string">'1'</span>);
      } <span class="hljs-keyword">else</span> {
        elm.removeAttribute(<span class="hljs-string">'data-mce-selected'</span>, <span class="hljs-string">'1'</span>);
      }
    };

    <span class="hljs-keyword">var</span> renderCaretLocation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caret, location</span>) </span>{
      <span class="hljs-keyword">return</span> BoundaryCaret.renderCaret(caret, location).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
        setCaretPosition(editor, pos);
        <span class="hljs-keyword">return</span> location;
      });
    };

    <span class="hljs-keyword">var</span> findLocation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caret, forward</span>) </span>{
      <span class="hljs-keyword">var</span> rootNode = editor.getBody();
      <span class="hljs-keyword">var</span> <span class="hljs-keyword">from</span> = CaretPosition.fromRangeStart(editor.selection.getRng());
      <span class="hljs-keyword">var</span> location = forward ? BoundaryLocation.nextLocation(rootNode, <span class="hljs-keyword">from</span>) : BoundaryLocation.prevLocation(rootNode, <span class="hljs-keyword">from</span>);
      <span class="hljs-keyword">return</span> location.bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">location</span>) </span>{
        <span class="hljs-keyword">return</span> renderCaretLocation(editor, caret, location);
      });
    };

    <span class="hljs-keyword">var</span> toggleInlines = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dom, elms</span>) </span>{
      <span class="hljs-keyword">var</span> selectedInlines = dom.select(<span class="hljs-string">'a[href][data-mce-selected],code[data-mce-selected]'</span>);
      <span class="hljs-keyword">var</span> targetInlines = Arr.filter(elms, InlineUtils.isInlineTarget);
      Arr.each(Arr.difference(selectedInlines, targetInlines), Fun.curry(setSelected, <span class="hljs-literal">false</span>));
      Arr.each(Arr.difference(targetInlines, selectedInlines), Fun.curry(setSelected, <span class="hljs-literal">true</span>));
    };

    <span class="hljs-keyword">var</span> safeRemoveCaretContainer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caret</span>) </span>{
      <span class="hljs-keyword">if</span> (editor.selection.isCollapsed() &amp;&amp; editor.composing !== <span class="hljs-literal">true</span> &amp;&amp; caret.get()) {
        <span class="hljs-keyword">var</span> pos = CaretPosition.fromRangeStart(editor.selection.getRng());
        <span class="hljs-keyword">if</span> (CaretPosition.isTextPosition(pos) &amp;&amp; InlineUtils.isAtZwsp(pos) === <span class="hljs-literal">false</span>) {
          setCaretPosition(editor, CaretContainerRemove.removeAndReposition(caret.get(), pos));
          caret.set(<span class="hljs-literal">null</span>);
        }
      }
    };

    <span class="hljs-keyword">var</span> renderInsideInlineCaret = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caret, elms</span>) </span>{
      <span class="hljs-keyword">if</span> (editor.selection.isCollapsed()) {
        <span class="hljs-keyword">var</span> inlines = Arr.filter(elms, InlineUtils.isInlineTarget);
        Arr.each(inlines, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inline</span>) </span>{
          <span class="hljs-keyword">var</span> pos = CaretPosition.fromRangeStart(editor.selection.getRng());
          BoundaryLocation.readLocation(editor.getBody(), pos).bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">location</span>) </span>{
            <span class="hljs-keyword">return</span> renderCaretLocation(editor, caret, location);
          });
        });
      }
    };

    <span class="hljs-keyword">var</span> move = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caret, forward</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> isFeatureEnabled(editor) ? findLocation(editor, caret, forward).isSome() : <span class="hljs-literal">false</span>;
      };
    };

    <span class="hljs-keyword">var</span> setupSelectedState = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> caret = <span class="hljs-keyword">new</span> Cell(<span class="hljs-literal">null</span>);

      editor.on(<span class="hljs-string">'NodeChange'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (isFeatureEnabled(editor)) {
          toggleInlines(editor.dom, e.parents);
          safeRemoveCaretContainer(editor, caret);
          renderInsideInlineCaret(editor, caret, e.parents);
        }
      });

      <span class="hljs-keyword">return</span> caret;
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">move</span>: move,
      <span class="hljs-attr">setupSelectedState</span>: setupSelectedState,
      <span class="hljs-attr">setCaretPosition</span>: setCaretPosition
    };
  }
);
<span class="hljs-comment">/**
 * InlineBoundaryDelete.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.delete.InlineBoundaryDelete'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.katamari.api.Option'</span>,
    <span class="hljs-string">'ephox.katamari.api.Options'</span>,
    <span class="hljs-string">'ephox.sugar.api.node.Element'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretContainer'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretUtils'</span>,
    <span class="hljs-string">'tinymce.core.delete.DeleteElement'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.BoundaryCaret'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.BoundaryLocation'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.BoundarySelection'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.InlineUtils'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, Option, Options, Element, CaretContainer, CaretPosition, CaretUtils, DeleteElement, BoundaryCaret, BoundaryLocation, BoundarySelection, InlineUtils</span>) </span>{
    <span class="hljs-keyword">var</span> isFeatureEnabled = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">return</span> editor.settings.inline_boundaries !== <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">var</span> rangeFromPositions = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">from, to</span>) </span>{
      <span class="hljs-keyword">var</span> range = <span class="hljs-built_in">document</span>.createRange();

      range.setStart(<span class="hljs-keyword">from</span>.container(), <span class="hljs-keyword">from</span>.offset());
      range.setEnd(to.container(), to.offset());

      <span class="hljs-keyword">return</span> range;
    };

    <span class="hljs-keyword">var</span> setCaretLocation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caret</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">location</span>) </span>{
        <span class="hljs-keyword">return</span> BoundaryCaret.renderCaret(caret, location).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
          BoundarySelection.setCaretPosition(editor, pos);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }).getOr(<span class="hljs-literal">false</span>);
      };
    };

    <span class="hljs-keyword">var</span> deleteFromTo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caret, from, to</span>) </span>{
      <span class="hljs-keyword">var</span> rootNode = editor.getBody();

      editor.undoManager.ignore(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        editor.selection.setRng(rangeFromPositions(<span class="hljs-keyword">from</span>, to));
        editor.execCommand(<span class="hljs-string">'Delete'</span>);

        BoundaryLocation.readLocation(rootNode, CaretPosition.fromRangeStart(editor.selection.getRng()))
          .map(BoundaryLocation.inside)
          .map(setCaretLocation(editor, caret));
      });

      editor.nodeChanged();
    };

    <span class="hljs-keyword">var</span> rescope = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, node</span>) </span>{
      <span class="hljs-keyword">var</span> parentBlock = CaretUtils.getParentBlock(node, rootNode);
      <span class="hljs-keyword">return</span> parentBlock ? parentBlock : rootNode;
    };

    <span class="hljs-keyword">var</span> backspaceDeleteCollapsed = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caret, forward, from</span>) </span>{
      <span class="hljs-keyword">var</span> rootNode = rescope(editor.getBody(), <span class="hljs-keyword">from</span>.container());
      <span class="hljs-keyword">var</span> fromLocation = BoundaryLocation.readLocation(rootNode, <span class="hljs-keyword">from</span>);

      <span class="hljs-keyword">return</span> fromLocation.bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">location</span>) </span>{
        <span class="hljs-keyword">if</span> (forward) {
          <span class="hljs-keyword">return</span> location.fold(
            Fun.constant(Option.some(BoundaryLocation.inside(location))), <span class="hljs-comment">// Before</span>
            Option.none, <span class="hljs-comment">// Start</span>
            Fun.constant(Option.some(BoundaryLocation.outside(location))), <span class="hljs-comment">// End</span>
            Option.none  <span class="hljs-comment">// After</span>
          );
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> location.fold(
            Option.none, <span class="hljs-comment">// Before</span>
            Fun.constant(Option.some(BoundaryLocation.outside(location))), <span class="hljs-comment">// Start</span>
            Option.none, <span class="hljs-comment">// End</span>
            Fun.constant(Option.some(BoundaryLocation.inside(location)))  <span class="hljs-comment">// After</span>
          );
        }
      })
      .map(setCaretLocation(editor, caret))
      .getOrThunk(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> toPosition = InlineUtils.findCaretPosition(rootNode, forward, <span class="hljs-keyword">from</span>);
        <span class="hljs-keyword">var</span> toLocation = toPosition.bind(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos</span>) </span>{
          <span class="hljs-keyword">return</span> BoundaryLocation.readLocation(rootNode, pos);
        });

        <span class="hljs-keyword">if</span> (fromLocation.isSome() &amp;&amp; toLocation.isSome()) {
          <span class="hljs-keyword">return</span> InlineUtils.findInline(rootNode, <span class="hljs-keyword">from</span>).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
            DeleteElement.deleteElement(editor, forward, Element.fromDom(elm));
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }).getOr(<span class="hljs-literal">false</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> toLocation.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) </span>{
            toPosition.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">to</span>) </span>{
              <span class="hljs-keyword">if</span> (forward) {
                deleteFromTo(editor, caret, <span class="hljs-keyword">from</span>, to);
              } <span class="hljs-keyword">else</span> {
                deleteFromTo(editor, caret, to, <span class="hljs-keyword">from</span>);
              }
            });

            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }).getOr(<span class="hljs-literal">false</span>);
        }
      });
    };

    <span class="hljs-keyword">var</span> backspaceDelete = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caret, forward</span>) </span>{
      <span class="hljs-keyword">if</span> (editor.selection.isCollapsed() &amp;&amp; isFeatureEnabled(editor)) {
        <span class="hljs-keyword">var</span> <span class="hljs-keyword">from</span> = CaretPosition.fromRangeStart(editor.selection.getRng());
        <span class="hljs-keyword">return</span> backspaceDeleteCollapsed(editor, caret, forward, <span class="hljs-keyword">from</span>);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">backspaceDelete</span>: backspaceDelete
    };
  }
);
<span class="hljs-comment">/**
 * Commands.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.delete.DeleteCommands'</span>,
  [
    <span class="hljs-string">'tinymce.core.delete.BlockBoundaryDelete'</span>,
    <span class="hljs-string">'tinymce.core.delete.BlockRangeDelete'</span>,
    <span class="hljs-string">'tinymce.core.delete.CefDelete'</span>,
    <span class="hljs-string">'tinymce.core.delete.InlineBoundaryDelete'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">BlockBoundaryDelete, BlockRangeDelete, CefDelete, BoundaryDelete</span>) </span>{
    <span class="hljs-keyword">var</span> nativeCommand = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, command</span>) </span>{
      editor.getDoc().execCommand(command, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);
    };

    <span class="hljs-keyword">var</span> paddEmptyBody = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> dom = editor.dom;</pre></div></div>
            
        </li>
        
        
        <li id="section-1234">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1234">&#182;</a>
              </div>
              <p>Check if body is empty after the delete call if so then set the contents
to an empty string and move the caret to any block produced by that operation
this fixes the issue with root blocks not being properly produced after a delete call on IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> body = editor.getBody();

      <span class="hljs-keyword">if</span> (dom.isEmpty(body)) {
        editor.setContent(<span class="hljs-string">''</span>);

        <span class="hljs-keyword">if</span> (body.firstChild &amp;&amp; dom.isBlock(body.firstChild)) {
          editor.selection.setCursorLocation(body.firstChild, <span class="hljs-number">0</span>);
        } <span class="hljs-keyword">else</span> {
          editor.selection.setCursorLocation(body, <span class="hljs-number">0</span>);
        }
      }
    };

    <span class="hljs-keyword">var</span> deleteCommand = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">if</span> (CefDelete.backspaceDelete(editor, <span class="hljs-literal">false</span>)) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (BoundaryDelete.backspaceDelete(editor, <span class="hljs-literal">false</span>)) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (BlockBoundaryDelete.backspaceDelete(editor, <span class="hljs-literal">false</span>)) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (BlockRangeDelete.backspaceDelete(editor, <span class="hljs-literal">false</span>)) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">else</span> {
        nativeCommand(editor, <span class="hljs-string">'Delete'</span>);
        paddEmptyBody(editor);
      }
    };

    <span class="hljs-keyword">var</span> forwardDeleteCommand = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">if</span> (CefDelete.backspaceDelete(editor, <span class="hljs-literal">true</span>)) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (BoundaryDelete.backspaceDelete(editor, <span class="hljs-literal">true</span>)) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (BlockBoundaryDelete.backspaceDelete(editor, <span class="hljs-literal">true</span>)) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (BlockRangeDelete.backspaceDelete(editor, <span class="hljs-literal">true</span>)) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">else</span> {
        nativeCommand(editor, <span class="hljs-string">'ForwardDelete'</span>);
      }
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">deleteCommand</span>: deleteCommand,
      <span class="hljs-attr">forwardDeleteCommand</span>: forwardDeleteCommand
    };
  }
);
<span class="hljs-comment">/**
 * RangeNormalizer.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.dom.RangeNormalizer'</span>,
  [
    <span class="hljs-string">'tinymce.core.caret.CaretFinder'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">CaretFinder, CaretPosition, CaretUtils, NodeType</span>) </span>{
    <span class="hljs-keyword">var</span> isTextBlock = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> NodeType.isElement(elm) &amp;&amp; <span class="hljs-regexp">/^(P|H[1-6]|DIV)$/</span>.test(elm.nodeName);
    };

    <span class="hljs-keyword">var</span> matchEndContainer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rng, predicate</span>) </span>{
      <span class="hljs-keyword">return</span> predicate(rng.endContainer);
    };

    <span class="hljs-keyword">var</span> createRange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sc, so, ec, eo</span>) </span>{
      <span class="hljs-keyword">var</span> rng = <span class="hljs-built_in">document</span>.createRange();
      rng.setStart(sc, so);
      rng.setEnd(ec, eo);
      <span class="hljs-keyword">return</span> rng;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-1235">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1235">&#182;</a>
              </div>
              <p>If you tripple click a paragraph in this case:
  <blockquote><p>a</p></blockquote><p>b</p>
It would become this range in webkit:
  <blockquote><p>[a</p></blockquote><p>]b</p>
We would want it to be:
  <blockquote><p>[a]</p></blockquote><p>b</p>
Since it would otherwise produces spans out of thin air on insertContent for example.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> normalizeBlockSelection = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rng</span>) </span>{
      <span class="hljs-keyword">var</span> startPos = CaretPosition.fromRangeStart(rng);
      <span class="hljs-keyword">var</span> endPos = CaretPosition.fromRangeEnd(rng);
      <span class="hljs-keyword">var</span> rootNode = rng.commonAncestorContainer;

      <span class="hljs-keyword">if</span> (rng.collapsed === <span class="hljs-literal">false</span> &amp;&amp; matchEndContainer(rng, isTextBlock) &amp;&amp; rng.endOffset === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> CaretFinder.fromPosition(<span class="hljs-literal">false</span>, rootNode, endPos)
          .map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newEndPos</span>) </span>{
            <span class="hljs-keyword">if</span> (!CaretUtils.isInSameBlock(startPos, endPos, rootNode) &amp;&amp; CaretUtils.isInSameBlock(startPos, newEndPos, rootNode)) {
              <span class="hljs-keyword">return</span> createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> rng;
            }
          }).getOr(rng);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> rng;
      }
    };

    <span class="hljs-keyword">var</span> normalize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rng</span>) </span>{
      <span class="hljs-keyword">return</span> normalizeBlockSelection(rng);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">normalize</span>: normalize
    };
  }
);
<span class="hljs-comment">/**
 * InsertList.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Handles inserts of lists into the editor instance.
 *
 * @class tinymce.InsertList
 * @private
 */</span>
define(
  <span class="hljs-string">'tinymce.core.InsertList'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretWalker"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretPosition"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Tools, CaretWalker, CaretPosition</span>) </span>{
    <span class="hljs-keyword">var</span> isListFragment = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fragment</span>) </span>{
      <span class="hljs-keyword">var</span> firstChild = fragment.firstChild;
      <span class="hljs-keyword">var</span> lastChild = fragment.lastChild;</pre></div></div>
            
        </li>
        
        
        <li id="section-1236">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1236">&#182;</a>
              </div>
              <p>Skip meta since its likely <meta><ul>..</ul></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (firstChild &amp;&amp; firstChild.name === <span class="hljs-string">'meta'</span>) {
        firstChild = firstChild.next;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1237">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1237">&#182;</a>
              </div>
              <p>Skip mce_marker since its likely <ul>..</ul><span id="mce_marker"></span></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (lastChild &amp;&amp; lastChild.attr(<span class="hljs-string">'id'</span>) === <span class="hljs-string">'mce_marker'</span>) {
        lastChild = lastChild.prev;
      }

      <span class="hljs-keyword">if</span> (!firstChild || firstChild !== lastChild) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">return</span> firstChild.name === <span class="hljs-string">'ul'</span> || firstChild.name === <span class="hljs-string">'ol'</span>;
    };

    <span class="hljs-keyword">var</span> cleanupDomFragment = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">domFragment</span>) </span>{
      <span class="hljs-keyword">var</span> firstChild = domFragment.firstChild;
      <span class="hljs-keyword">var</span> lastChild = domFragment.lastChild;</pre></div></div>
            
        </li>
        
        
        <li id="section-1238">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1238">&#182;</a>
              </div>
              <p>TODO: remove the meta tag from paste logic</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (firstChild &amp;&amp; firstChild.nodeName === <span class="hljs-string">'META'</span>) {
        firstChild.parentNode.removeChild(firstChild);
      }

      <span class="hljs-keyword">if</span> (lastChild &amp;&amp; lastChild.id === <span class="hljs-string">'mce_marker'</span>) {
        lastChild.parentNode.removeChild(lastChild);
      }

      <span class="hljs-keyword">return</span> domFragment;
    };

    <span class="hljs-keyword">var</span> toDomFragment = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dom, serializer, fragment</span>) </span>{
      <span class="hljs-keyword">var</span> html = serializer.serialize(fragment);
      <span class="hljs-keyword">var</span> domFragment = dom.createFragment(html);

      <span class="hljs-keyword">return</span> cleanupDomFragment(domFragment);
    };

    <span class="hljs-keyword">var</span> listItems = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> Tools.grep(elm.childNodes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) </span>{
        <span class="hljs-keyword">return</span> child.nodeName === <span class="hljs-string">'LI'</span>;
      });
    };

    <span class="hljs-keyword">var</span> isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> !elm.firstChild;
    };

    <span class="hljs-keyword">var</span> trimListItems = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elms</span>) </span>{
      <span class="hljs-keyword">return</span> elms.length &gt; <span class="hljs-number">0</span> &amp;&amp; isEmpty(elms[elms.length - <span class="hljs-number">1</span>]) ? elms.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>) : elms;
    };

    <span class="hljs-keyword">var</span> getParentLi = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dom, node</span>) </span>{
      <span class="hljs-keyword">var</span> parentBlock = dom.getParent(node, dom.isBlock);
      <span class="hljs-keyword">return</span> parentBlock &amp;&amp; parentBlock.nodeName === <span class="hljs-string">'LI'</span> ? parentBlock : <span class="hljs-literal">null</span>;
    };

    <span class="hljs-keyword">var</span> isParentBlockLi = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dom, node</span>) </span>{
      <span class="hljs-keyword">return</span> !!getParentLi(dom, node);
    };

    <span class="hljs-keyword">var</span> getSplit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parentNode, rng</span>) </span>{
      <span class="hljs-keyword">var</span> beforeRng = rng.cloneRange();
      <span class="hljs-keyword">var</span> afterRng = rng.cloneRange();

      beforeRng.setStartBefore(parentNode);
      afterRng.setEndAfter(parentNode);

      <span class="hljs-keyword">return</span> [
        beforeRng.cloneContents(),
        afterRng.cloneContents()
      ];
    };

    <span class="hljs-keyword">var</span> findFirstIn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, rootNode</span>) </span>{
      <span class="hljs-keyword">var</span> caretPos = CaretPosition.before(node);
      <span class="hljs-keyword">var</span> caretWalker = <span class="hljs-keyword">new</span> CaretWalker(rootNode);
      <span class="hljs-keyword">var</span> newCaretPos = caretWalker.next(caretPos);

      <span class="hljs-keyword">return</span> newCaretPos ? newCaretPos.toRange() : <span class="hljs-literal">null</span>;
    };

    <span class="hljs-keyword">var</span> findLastOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, rootNode</span>) </span>{
      <span class="hljs-keyword">var</span> caretPos = CaretPosition.after(node);
      <span class="hljs-keyword">var</span> caretWalker = <span class="hljs-keyword">new</span> CaretWalker(rootNode);
      <span class="hljs-keyword">var</span> newCaretPos = caretWalker.prev(caretPos);

      <span class="hljs-keyword">return</span> newCaretPos ? newCaretPos.toRange() : <span class="hljs-literal">null</span>;
    };

    <span class="hljs-keyword">var</span> insertMiddle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, elms, rootNode, rng</span>) </span>{
      <span class="hljs-keyword">var</span> parts = getSplit(target, rng);
      <span class="hljs-keyword">var</span> parentElm = target.parentNode;

      parentElm.insertBefore(parts[<span class="hljs-number">0</span>], target);
      Tools.each(elms, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">li</span>) </span>{
        parentElm.insertBefore(li, target);
      });
      parentElm.insertBefore(parts[<span class="hljs-number">1</span>], target);
      parentElm.removeChild(target);

      <span class="hljs-keyword">return</span> findLastOf(elms[elms.length - <span class="hljs-number">1</span>], rootNode);
    };

    <span class="hljs-keyword">var</span> insertBefore = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, elms, rootNode</span>) </span>{
      <span class="hljs-keyword">var</span> parentElm = target.parentNode;

      Tools.each(elms, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        parentElm.insertBefore(elm, target);
      });

      <span class="hljs-keyword">return</span> findFirstIn(target, rootNode);
    };

    <span class="hljs-keyword">var</span> insertAfter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, elms, rootNode, dom</span>) </span>{
      dom.insertAfter(elms.reverse(), target);
      <span class="hljs-keyword">return</span> findLastOf(elms[<span class="hljs-number">0</span>], rootNode);
    };

    <span class="hljs-keyword">var</span> insertAtCaret = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">serializer, dom, rng, fragment</span>) </span>{
      <span class="hljs-keyword">var</span> domFragment = toDomFragment(dom, serializer, fragment);
      <span class="hljs-keyword">var</span> liTarget = getParentLi(dom, rng.startContainer);
      <span class="hljs-keyword">var</span> liElms = trimListItems(listItems(domFragment.firstChild));
      <span class="hljs-keyword">var</span> BEGINNING = <span class="hljs-number">1</span>, END = <span class="hljs-number">2</span>;
      <span class="hljs-keyword">var</span> rootNode = dom.getRoot();

      <span class="hljs-keyword">var</span> isAt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">location</span>) </span>{
        <span class="hljs-keyword">var</span> caretPos = CaretPosition.fromRangeStart(rng);
        <span class="hljs-keyword">var</span> caretWalker = <span class="hljs-keyword">new</span> CaretWalker(dom.getRoot());
        <span class="hljs-keyword">var</span> newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);

        <span class="hljs-keyword">return</span> newPos ? getParentLi(dom, newPos.getNode()) !== liTarget : <span class="hljs-literal">true</span>;
      };

      <span class="hljs-keyword">if</span> (isAt(BEGINNING)) {
        <span class="hljs-keyword">return</span> insertBefore(liTarget, liElms, rootNode);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isAt(END)) {
        <span class="hljs-keyword">return</span> insertAfter(liTarget, liElms, rootNode, dom);
      }

      <span class="hljs-keyword">return</span> insertMiddle(liTarget, liElms, rootNode, rng);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">isListFragment</span>: isListFragment,
      <span class="hljs-attr">insertAtCaret</span>: insertAtCaret,
      <span class="hljs-attr">isParentBlockLi</span>: isParentBlockLi,
      <span class="hljs-attr">trimListItems</span>: trimListItems,
      <span class="hljs-attr">listItems</span>: listItems
    };
  }
);
<span class="hljs-comment">/**
 * InsertContent.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Handles inserts of contents into the editor instance.
 *
 * @class tinymce.InsertContent
 * @private
 */</span>
define(
  <span class="hljs-string">'tinymce.core.InsertContent'</span>,
  [
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretWalker'</span>,
    <span class="hljs-string">'tinymce.core.dom.ElementUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.dom.RangeNormalizer'</span>,
    <span class="hljs-string">'tinymce.core.Env'</span>,
    <span class="hljs-string">'tinymce.core.html.Serializer'</span>,
    <span class="hljs-string">'tinymce.core.InsertList'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">CaretPosition, CaretWalker, ElementUtils, NodeType, RangeNormalizer, Env, Serializer, InsertList, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> isTableCell = NodeType.matchNodeNames(<span class="hljs-string">'td th'</span>);

    <span class="hljs-keyword">var</span> validInsertion = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, value, parentNode</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1239">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1239">&#182;</a>
              </div>
              <p>Should never insert content into bogus elements, since these can
be resize handles or similar</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (parentNode.getAttribute(<span class="hljs-string">'data-mce-bogus'</span>) === <span class="hljs-string">'all'</span>) {
        parentNode.parentNode.insertBefore(editor.dom.createFragment(value), parentNode);
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1240">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1240">&#182;</a>
              </div>
              <p>Check if parent is empty or only has one BR element then set the innerHTML of that parent</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> node = parentNode.firstChild;
        <span class="hljs-keyword">var</span> node2 = parentNode.lastChild;
        <span class="hljs-keyword">if</span> (!node || (node === node2 &amp;&amp; node.nodeName === <span class="hljs-string">'BR'</span>)) {<span class="hljs-comment">///</span>
          editor.dom.setHTML(parentNode, value);
        } <span class="hljs-keyword">else</span> {
          editor.selection.setContent(value);
        }
      }
    };

    <span class="hljs-keyword">var</span> insertHtmlAtCaret = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, value, details</span>) </span>{
      <span class="hljs-keyword">var</span> parser, serializer, parentNode, rootNode, fragment, args;
      <span class="hljs-keyword">var</span> marker, rng, node, node2, bookmarkHtml, merge;
      <span class="hljs-keyword">var</span> textInlineElements = editor.schema.getTextInlineElements();
      <span class="hljs-keyword">var</span> selection = editor.selection, dom = editor.dom;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimOrPaddLeftRight</span>(<span class="hljs-params">html</span>) </span>{
        <span class="hljs-keyword">var</span> rng, container, offset;

        rng = selection.getRng(<span class="hljs-literal">true</span>);
        container = rng.startContainer;
        offset = rng.startOffset;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasSiblingText</span>(<span class="hljs-params">siblingName</span>) </span>{
          <span class="hljs-keyword">return</span> container[siblingName] &amp;&amp; container[siblingName].nodeType == <span class="hljs-number">3</span>;
        }

        <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">3</span>) {
          <span class="hljs-keyword">if</span> (offset &gt; <span class="hljs-number">0</span>) {
            html = html.replace(<span class="hljs-regexp">/^&amp;nbsp;/</span>, <span class="hljs-string">' '</span>);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hasSiblingText(<span class="hljs-string">'previousSibling'</span>)) {
            html = html.replace(<span class="hljs-regexp">/^ /</span>, <span class="hljs-string">'&amp;nbsp;'</span>);
          }

          <span class="hljs-keyword">if</span> (offset &lt; container.length) {
            html = html.replace(<span class="hljs-regexp">/&amp;nbsp;(&lt;br&gt;|)$/</span>, <span class="hljs-string">' '</span>);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hasSiblingText(<span class="hljs-string">'nextSibling'</span>)) {
            html = html.replace(<span class="hljs-regexp">/(&amp;nbsp;| )(&lt;br&gt;|)$/</span>, <span class="hljs-string">'&amp;nbsp;'</span>);
          }
        }

        <span class="hljs-keyword">return</span> html;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1241">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1241">&#182;</a>
              </div>
              <p>Removes &nbsp; from a [b] c -&gt; a &nbsp;c -&gt; a c</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimNbspAfterDeleteAndPaddValue</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> rng, container, offset;

        rng = selection.getRng(<span class="hljs-literal">true</span>);
        container = rng.startContainer;
        offset = rng.startOffset;

        <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">3</span> &amp;&amp; rng.collapsed) {
          <span class="hljs-keyword">if</span> (container.data[offset] === <span class="hljs-string">'\u00a0'</span>) {
            container.deleteData(offset, <span class="hljs-number">1</span>);

            <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/[\u00a0| ]$/</span>.test(value)) {
              value += <span class="hljs-string">' '</span>;
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (container.data[offset - <span class="hljs-number">1</span>] === <span class="hljs-string">'\u00a0'</span>) {
            container.deleteData(offset - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);

            <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/[\u00a0| ]$/</span>.test(value)) {
              value = <span class="hljs-string">' '</span> + value;
            }
          }
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduceInlineTextElements</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (merge) {
          <span class="hljs-keyword">var</span> root = editor.getBody(), elementUtils = <span class="hljs-keyword">new</span> ElementUtils(dom);

          Tools.each(dom.select(<span class="hljs-string">'*[data-mce-fragment]'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> testNode = node.parentNode; testNode &amp;&amp; testNode != root; testNode = testNode.parentNode) {
              <span class="hljs-keyword">if</span> (textInlineElements[node.nodeName.toLowerCase()] &amp;&amp; elementUtils.compare(testNode, node)) {
                dom.remove(node, <span class="hljs-literal">true</span>);
              }
            }
          });
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markFragmentElements</span>(<span class="hljs-params">fragment</span>) </span>{
        <span class="hljs-keyword">var</span> node = fragment;

        <span class="hljs-keyword">while</span> ((node = node.walk())) {
          <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">1</span>) {
            node.attr(<span class="hljs-string">'data-mce-fragment'</span>, <span class="hljs-string">'1'</span>);
          }
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">umarkFragmentElements</span>(<span class="hljs-params">elm</span>) </span>{
        Tools.each(elm.getElementsByTagName(<span class="hljs-string">'*'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
          elm.removeAttribute(<span class="hljs-string">'data-mce-fragment'</span>);
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPartOfFragment</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> !!node.getAttribute(<span class="hljs-string">'data-mce-fragment'</span>);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canHaveChildren</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> node &amp;&amp; !editor.schema.getShortEndedElements()[node.nodeName];
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveSelectionToMarker</span>(<span class="hljs-params">marker</span>) </span>{
        <span class="hljs-keyword">var</span> parentEditableFalseElm, parentBlock, nextRng;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContentEditableFalseParent</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> root = editor.getBody();

          <span class="hljs-keyword">for</span> (; node &amp;&amp; node !== root; node = node.parentNode) {
            <span class="hljs-keyword">if</span> (editor.dom.getContentEditable(node) === <span class="hljs-string">'false'</span>) {
              <span class="hljs-keyword">return</span> node;
            }
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">if</span> (!marker) {
          <span class="hljs-keyword">return</span>;
        }

        selection.scrollIntoView(marker);</pre></div></div>
            
        </li>
        
        
        <li id="section-1242">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1242">&#182;</a>
              </div>
              <p>If marker is in cE=false then move selection to that element instead</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        parentEditableFalseElm = getContentEditableFalseParent(marker);
        <span class="hljs-keyword">if</span> (parentEditableFalseElm) {
          dom.remove(marker);
          selection.select(parentEditableFalseElm);
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1243">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1243">&#182;</a>
              </div>
              <p>Move selection before marker and remove it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        rng = dom.createRng();</pre></div></div>
            
        </li>
        
        
        <li id="section-1244">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1244">&#182;</a>
              </div>
              <p>If previous sibling is a text node set the selection to the end of that node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        node = marker.previousSibling;
        <span class="hljs-keyword">if</span> (node &amp;&amp; node.nodeType == <span class="hljs-number">3</span>) {
          rng.setStart(node, node.nodeValue.length);</pre></div></div>
            
        </li>
        
        
        <li id="section-1245">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1245">&#182;</a>
              </div>
              <p>TODO: Why cant we normalize on IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!Env.ie) {
            node2 = marker.nextSibling;
            <span class="hljs-keyword">if</span> (node2 &amp;&amp; node2.nodeType == <span class="hljs-number">3</span>) {
              node.appendData(node2.data);
              node2.parentNode.removeChild(node2);
            }
          }
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1246">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1246">&#182;</a>
              </div>
              <p>If the previous sibling isnt a text node or doesnt exist set the selection before the marker node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          rng.setStartBefore(marker);
          rng.setEndBefore(marker);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findNextCaretRng</span>(<span class="hljs-params">rng</span>) </span>{
          <span class="hljs-keyword">var</span> caretPos = CaretPosition.fromRangeStart(rng);
          <span class="hljs-keyword">var</span> caretWalker = <span class="hljs-keyword">new</span> CaretWalker(editor.getBody());

          caretPos = caretWalker.next(caretPos);
          <span class="hljs-keyword">if</span> (caretPos) {
            <span class="hljs-keyword">return</span> caretPos.toRange();
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1247">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1247">&#182;</a>
              </div>
              <p>Remove the marker node and set the new range</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        parentBlock = dom.getParent(marker, dom.isBlock);
        dom.remove(marker);

        <span class="hljs-keyword">if</span> (parentBlock &amp;&amp; dom.isEmpty(parentBlock)) {
          editor.$(parentBlock).empty();

          rng.setStart(parentBlock, <span class="hljs-number">0</span>);
          rng.setEnd(parentBlock, <span class="hljs-number">0</span>);

          <span class="hljs-keyword">if</span> (!isTableCell(parentBlock) &amp;&amp; !isPartOfFragment(parentBlock) &amp;&amp; (nextRng = findNextCaretRng(rng))) {
            rng = nextRng;
            dom.remove(parentBlock);
          } <span class="hljs-keyword">else</span> {
            dom.add(parentBlock, dom.create(<span class="hljs-string">'br'</span>, { <span class="hljs-string">'data-mce-bogus'</span>: <span class="hljs-string">'1'</span> }));
          }
        }

        selection.setRng(rng);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1248">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1248">&#182;</a>
              </div>
              <p>Check for whitespace before/after value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^ | $/</span>.test(value)) {
        value = trimOrPaddLeftRight(value);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1249">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1249">&#182;</a>
              </div>
              <p>Setup parser and serializer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      parser = editor.parser;
      merge = details.merge;

      serializer = <span class="hljs-keyword">new</span> Serializer({
        <span class="hljs-attr">validate</span>: editor.settings.validate
      }, editor.schema);
      bookmarkHtml = <span class="hljs-string">'&lt;span id="mce_marker" data-mce-type="bookmark"&gt;&amp;#xFEFF;&amp;#x200B;&lt;/span&gt;'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1250">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1250">&#182;</a>
              </div>
              <p>Run beforeSetContent handlers on the HTML to be inserted</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      args = { <span class="hljs-attr">content</span>: value, <span class="hljs-attr">format</span>: <span class="hljs-string">'html'</span>, <span class="hljs-attr">selection</span>: <span class="hljs-literal">true</span> };
      editor.fire(<span class="hljs-string">'BeforeSetContent'</span>, args);
      value = args.content;</pre></div></div>
            
        </li>
        
        
        <li id="section-1251">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1251">&#182;</a>
              </div>
              <p>Add caret at end of contents if its missing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (value.indexOf(<span class="hljs-string">'{$caret}'</span>) == <span class="hljs-number">-1</span>) {
        value += <span class="hljs-string">'{$caret}'</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1252">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1252">&#182;</a>
              </div>
              <p>Replace the caret marker with a span bookmark element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      value = value.replace(<span class="hljs-regexp">/\{\$caret\}/</span>, bookmarkHtml);</pre></div></div>
            
        </li>
        
        
        <li id="section-1253">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1253">&#182;</a>
              </div>
              <p>If selection is at <body>|<p></p> then move it into <body><p>|</p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      rng = selection.getRng();
      <span class="hljs-keyword">var</span> caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : <span class="hljs-literal">null</span>);
      <span class="hljs-keyword">var</span> body = editor.getBody();
      <span class="hljs-keyword">if</span> (caretElement === body &amp;&amp; selection.isCollapsed()) {
        <span class="hljs-keyword">if</span> (dom.isBlock(body.firstChild) &amp;&amp; canHaveChildren(body.firstChild) &amp;&amp; dom.isEmpty(body.firstChild)) {
          rng = dom.createRng();
          rng.setStart(body.firstChild, <span class="hljs-number">0</span>);
          rng.setEnd(body.firstChild, <span class="hljs-number">0</span>);
          selection.setRng(rng);
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1254">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1254">&#182;</a>
              </div>
              <p>Insert node maker where we will insert the new HTML and get its parent</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!selection.isCollapsed()) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1255">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1255">&#182;</a>
              </div>
              <p>Fix for #2595 seems that delete removes one extra character on
WebKit for some odd reason if you double click select a word</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        editor.selection.setRng(RangeNormalizer.normalize(editor.selection.getRng()));
        editor.getDoc().execCommand(<span class="hljs-string">'Delete'</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);
        trimNbspAfterDeleteAndPaddValue();
      }

      parentNode = selection.getNode();</pre></div></div>
            
        </li>
        
        
        <li id="section-1256">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1256">&#182;</a>
              </div>
              <p>Parse the fragment within the context of the parent node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> parserArgs = { <span class="hljs-attr">context</span>: parentNode.nodeName.toLowerCase(), <span class="hljs-attr">data</span>: details.data };
      fragment = parser.parse(value, parserArgs);</pre></div></div>
            
        </li>
        
        
        <li id="section-1257">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1257">&#182;</a>
              </div>
              <p>Custom handling of lists</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (details.paste === <span class="hljs-literal">true</span> &amp;&amp; InsertList.isListFragment(fragment) &amp;&amp; InsertList.isParentBlockLi(dom, parentNode)) {
        rng = InsertList.insertAtCaret(serializer, dom, editor.selection.getRng(<span class="hljs-literal">true</span>), fragment);
        editor.selection.setRng(rng);
        editor.fire(<span class="hljs-string">'SetContent'</span>, args);
        <span class="hljs-keyword">return</span>;
      }

      markFragmentElements(fragment);</pre></div></div>
            
        </li>
        
        
        <li id="section-1258">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1258">&#182;</a>
              </div>
              <p>Move the caret to a more suitable location</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      node = fragment.lastChild;
      <span class="hljs-keyword">if</span> (node.attr(<span class="hljs-string">'id'</span>) == <span class="hljs-string">'mce_marker'</span>) {
        marker = node;

        <span class="hljs-keyword">for</span> (node = node.prev; node; node = node.walk(<span class="hljs-literal">true</span>)) {
          <span class="hljs-keyword">if</span> (node.type == <span class="hljs-number">3</span> || !dom.isBlock(node.name)) {
            <span class="hljs-keyword">if</span> (editor.schema.isValidChild(node.parent.name, <span class="hljs-string">'span'</span>)) {
              node.parent.insert(marker, node, node.name === <span class="hljs-string">'br'</span>);
            }
            <span class="hljs-keyword">break</span>;
          }
        }
      }

      editor._selectionOverrides.showBlockCaretContainer(parentNode);</pre></div></div>
            
        </li>
        
        
        <li id="section-1259">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1259">&#182;</a>
              </div>
              <p>If parser says valid we can insert the contents into that parent</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!parserArgs.invalid) {
        value = serializer.serialize(fragment);
        validInsertion(editor, value, parentNode);
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1260">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1260">&#182;</a>
              </div>
              <p>If the fragment was invalid within that context then we need
to parse and process the parent its inserted into</p>

            </div>
            
        </li>
        
        
        <li id="section-1261">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1261">&#182;</a>
              </div>
              <p>Insert bookmark node and get the parent</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        selection.setContent(bookmarkHtml);
        parentNode = selection.getNode();
        rootNode = editor.getBody();</pre></div></div>
            
        </li>
        
        
        <li id="section-1262">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1262">&#182;</a>
              </div>
              <p>Opera will return the document node when selection is in root</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (parentNode.nodeType == <span class="hljs-number">9</span>) {
          parentNode = node = rootNode;
        } <span class="hljs-keyword">else</span> {
          node = parentNode;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1263">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1263">&#182;</a>
              </div>
              <p>Find the ancestor just before the root element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">while</span> (node !== rootNode) {
          parentNode = node;
          node = node.parentNode;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1264">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1264">&#182;</a>
              </div>
              <p>Get the outer/inner HTML depending on if we are in the root and parser and serialize that</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        value = parentNode == rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);
        value = serializer.serialize(
          parser.parse(</pre></div></div>
            
        </li>
        
        
        <li id="section-1265">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1265">&#182;</a>
              </div>
              <p>Need to replace by using a function since $ in the contents would otherwise be a problem</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            value.replace(<span class="hljs-regexp">/&lt;span (id="mce_marker"|id=mce_marker).+?&lt;\/span&gt;/i</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">return</span> serializer.serialize(fragment);
            })
          )
        );</pre></div></div>
            
        </li>
        
        
        <li id="section-1266">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1266">&#182;</a>
              </div>
              <p>Set the inner/outer HTML depending on if we are in the root or not</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (parentNode == rootNode) {
          dom.setHTML(rootNode, value);
        } <span class="hljs-keyword">else</span> {
          dom.setOuterHTML(parentNode, value);
        }
      }

      reduceInlineTextElements();
      moveSelectionToMarker(dom.get(<span class="hljs-string">'mce_marker'</span>));
      umarkFragmentElements(editor.getBody());
      editor.fire(<span class="hljs-string">'SetContent'</span>, args);
      editor.addVisual();
    };

    <span class="hljs-keyword">var</span> processValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">var</span> details;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'string'</span>) {
        details = Tools.extend({
          <span class="hljs-attr">paste</span>: value.paste,
          <span class="hljs-attr">data</span>: {
            <span class="hljs-attr">paste</span>: value.paste
          }
        }, value);

        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">content</span>: value.content,
          <span class="hljs-attr">details</span>: details
        };
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">content</span>: value,
        <span class="hljs-attr">details</span>: {}
      };
    };

    <span class="hljs-keyword">var</span> insertAtCaret = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, value</span>) </span>{
      <span class="hljs-keyword">var</span> result = processValue(value);
      insertHtmlAtCaret(editor, result.content, result.details);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">insertAtCaret</span>: insertAtCaret
    };
  }
);
<span class="hljs-comment">/**
 * EditorCommands.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class enables you to add custom editor commands and it contains
 * overrides for native browser commands to address various bugs and issues.
 *
 * @class tinymce.EditorCommands
 */</span>
define(
  <span class="hljs-string">'tinymce.core.EditorCommands'</span>,
  [
    <span class="hljs-string">'tinymce.core.delete.DeleteCommands'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.dom.RangeUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.TreeWalker'</span>,
    <span class="hljs-string">'tinymce.core.Env'</span>,
    <span class="hljs-string">'tinymce.core.InsertContent'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">DeleteCommands, NodeType, RangeUtils, TreeWalker, Env, InsertContent, Tools</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1267">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1267">&#182;</a>
              </div>
              <p>Added for compression purposes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> each = Tools.each, extend = Tools.extend;
    <span class="hljs-keyword">var</span> map = Tools.map, inArray = Tools.inArray, explode = Tools.explode;
    <span class="hljs-keyword">var</span> isOldIE = Env.ie &amp;&amp; Env.ie &lt; <span class="hljs-number">11</span>;
    <span class="hljs-keyword">var</span> TRUE = <span class="hljs-literal">true</span>, FALSE = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> dom, selection, formatter,
        commands = { <span class="hljs-attr">state</span>: {}, <span class="hljs-attr">exec</span>: {}, <span class="hljs-attr">value</span>: {} },
        settings = editor.settings,
        bookmark;

      editor.on(<span class="hljs-string">'PreInit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        dom = editor.dom;
        selection = editor.selection;
        settings = editor.settings;
        formatter = editor.formatter;
      });

      <span class="hljs-comment">/**
       * Executes the specified command.
       *
       * @method execCommand
       * @param {String} command Command to execute.
       * @param {Boolean} ui Optional user interface state.
       * @param {Object} value Optional value for command.
       * @param {Object} args Optional extra arguments to the execCommand.
       * @return {Boolean} true/false if the command was found or not.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execCommand</span>(<span class="hljs-params">command, ui, value, args</span>) </span>{
        <span class="hljs-keyword">var</span> func, customCommand, state = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/</span>.test(command) &amp;&amp; (!args || !args.skip_focus)) {
          editor.focus();
        }

        args = editor.fire(<span class="hljs-string">'BeforeExecCommand'</span>, { <span class="hljs-attr">command</span>: command, <span class="hljs-attr">ui</span>: ui, <span class="hljs-attr">value</span>: value });
        <span class="hljs-keyword">if</span> (args.isDefaultPrevented()) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        customCommand = command.toLowerCase();
        <span class="hljs-keyword">if</span> ((func = commands.exec[customCommand])) {
          func(customCommand, ui, value);
          editor.fire(<span class="hljs-string">'ExecCommand'</span>, { <span class="hljs-attr">command</span>: command, <span class="hljs-attr">ui</span>: ui, <span class="hljs-attr">value</span>: value });
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1268">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1268">&#182;</a>
              </div>
              <p>Plugin commands</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        each(editor.plugins, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">p</span>) </span>{
          <span class="hljs-keyword">if</span> (p.execCommand &amp;&amp; p.execCommand(command, ui, value)) {
            editor.fire(<span class="hljs-string">'ExecCommand'</span>, { <span class="hljs-attr">command</span>: command, <span class="hljs-attr">ui</span>: ui, <span class="hljs-attr">value</span>: value });
            state = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        });

        <span class="hljs-keyword">if</span> (state) {
          <span class="hljs-keyword">return</span> state;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1269">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1269">&#182;</a>
              </div>
              <p>Theme commands</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (editor.theme &amp;&amp; editor.theme.execCommand &amp;&amp; editor.theme.execCommand(command, ui, value)) {
          editor.fire(<span class="hljs-string">'ExecCommand'</span>, { <span class="hljs-attr">command</span>: command, <span class="hljs-attr">ui</span>: ui, <span class="hljs-attr">value</span>: value });
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1270">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1270">&#182;</a>
              </div>
              <p>Browser commands</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">try</span> {
          state = editor.getDoc().execCommand(command, ui, value);
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1271">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1271">&#182;</a>
              </div>
              <p>Ignore old IE errors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }

        <span class="hljs-keyword">if</span> (state) {
          editor.fire(<span class="hljs-string">'ExecCommand'</span>, { <span class="hljs-attr">command</span>: command, <span class="hljs-attr">ui</span>: ui, <span class="hljs-attr">value</span>: value });
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-comment">/**
       * Queries the current state for a command for example if the current selection is "bold".
       *
       * @method queryCommandState
       * @param {String} command Command to check the state of.
       * @return {Boolean/Number} true/false if the selected contents is bold or not, -1 if it's not found.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryCommandState</span>(<span class="hljs-params">command</span>) </span>{
        <span class="hljs-keyword">var</span> func;</pre></div></div>
            
        </li>
        
        
        <li id="section-1272">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1272">&#182;</a>
              </div>
              <p>Is hidden then return undefined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (editor.quirks.isHidden()) {
          <span class="hljs-keyword">return</span>;
        }

        command = command.toLowerCase();
        <span class="hljs-keyword">if</span> ((func = commands.state[command])) {
          <span class="hljs-keyword">return</span> func(command);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1273">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1273">&#182;</a>
              </div>
              <p>Browser commands</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> editor.getDoc().queryCommandState(command);
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1274">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1274">&#182;</a>
              </div>
              <p>Fails sometimes see bug: 1896577</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-comment">/**
       * Queries the command value for example the current fontsize.
       *
       * @method queryCommandValue
       * @param {String} command Command to check the value of.
       * @return {Object} Command value of false if it's not found.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryCommandValue</span>(<span class="hljs-params">command</span>) </span>{
        <span class="hljs-keyword">var</span> func;</pre></div></div>
            
        </li>
        
        
        <li id="section-1275">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1275">&#182;</a>
              </div>
              <p>Is hidden then return undefined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (editor.quirks.isHidden()) {
          <span class="hljs-keyword">return</span>;
        }

        command = command.toLowerCase();
        <span class="hljs-keyword">if</span> ((func = commands.value[command])) {
          <span class="hljs-keyword">return</span> func(command);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1276">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1276">&#182;</a>
              </div>
              <p>Browser commands</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> editor.getDoc().queryCommandValue(command);
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1277">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1277">&#182;</a>
              </div>
              <p>Fails sometimes see bug: 1896577</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }
      }

      <span class="hljs-comment">/**
       * Adds commands to the command collection.
       *
       * @method addCommands
       * @param {Object} commandList Name/value collection with commands to add, the names can also be comma separated.
       * @param {String} type Optional type to add, defaults to exec. Can be value or state as well.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCommands</span>(<span class="hljs-params">commandList, type</span>) </span>{
        type = type || <span class="hljs-string">'exec'</span>;

        each(commandList, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, command</span>) </span>{
          each(command.toLowerCase().split(<span class="hljs-string">','</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command</span>) </span>{
            commands[type][command] = callback;
          });
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCommand</span>(<span class="hljs-params">command, callback, scope</span>) </span>{
        command = command.toLowerCase();
        commands.exec[command] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command, ui, value, args</span>) </span>{
          <span class="hljs-keyword">return</span> callback.call(scope || editor, ui, value, args);
        };
      }

      <span class="hljs-comment">/**
       * Returns true/false if the command is supported or not.
       *
       * @method queryCommandSupported
       * @param {String} command Command that we check support for.
       * @return {Boolean} true/false if the command is supported or not.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryCommandSupported</span>(<span class="hljs-params">command</span>) </span>{
        command = command.toLowerCase();

        <span class="hljs-keyword">if</span> (commands.exec[command]) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1278">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1278">&#182;</a>
              </div>
              <p>Browser commands</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> editor.getDoc().queryCommandSupported(command);
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1279">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1279">&#182;</a>
              </div>
              <p>Fails sometimes see bug: 1896577</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addQueryStateHandler</span>(<span class="hljs-params">command, callback, scope</span>) </span>{
        command = command.toLowerCase();
        commands.state[command] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> callback.call(scope || editor);
        };
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addQueryValueHandler</span>(<span class="hljs-params">command, callback, scope</span>) </span>{
        command = command.toLowerCase();
        commands.value[command] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> callback.call(scope || editor);
        };
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasCustomCommand</span>(<span class="hljs-params">command</span>) </span>{
        command = command.toLowerCase();
        <span class="hljs-keyword">return</span> !!commands.exec[command];
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1280">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1280">&#182;</a>
              </div>
              <p>Expose public methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      extend(<span class="hljs-keyword">this</span>, {
        <span class="hljs-attr">execCommand</span>: execCommand,
        <span class="hljs-attr">queryCommandState</span>: queryCommandState,
        <span class="hljs-attr">queryCommandValue</span>: queryCommandValue,
        <span class="hljs-attr">queryCommandSupported</span>: queryCommandSupported,
        <span class="hljs-attr">addCommands</span>: addCommands,
        <span class="hljs-attr">addCommand</span>: addCommand,
        <span class="hljs-attr">addQueryStateHandler</span>: addQueryStateHandler,
        <span class="hljs-attr">addQueryValueHandler</span>: addQueryValueHandler,
        <span class="hljs-attr">hasCustomCommand</span>: hasCustomCommand
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-1281">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1281">&#182;</a>
              </div>
              <p>Private methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execNativeCommand</span>(<span class="hljs-params">command, ui, value</span>) </span>{
        <span class="hljs-keyword">if</span> (ui === <span class="hljs-literal">undefined</span>) {
          ui = FALSE;
        }

        <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">undefined</span>) {
          value = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> editor.getDoc().execCommand(command, ui, value);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFormatMatch</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> formatter.match(name);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleFormat</span>(<span class="hljs-params">name, value</span>) </span>{
        formatter.toggle(name, value ? { <span class="hljs-attr">value</span>: value } : <span class="hljs-literal">undefined</span>);
        editor.nodeChanged();
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">storeSelection</span>(<span class="hljs-params">type</span>) </span>{
        bookmark = selection.getBookmark(type);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restoreSelection</span>(<span class="hljs-params"></span>) </span>{
        selection.moveToBookmark(bookmark);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1282">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1282">&#182;</a>
              </div>
              <p>Add execCommand overrides</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      addCommands({</pre></div></div>
            
        </li>
        
        
        <li id="section-1283">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1283">&#182;</a>
              </div>
              <p>Ignore these, added for compatibility</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">'mceResetDesignMode,mceBeginUndoLevel'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ },</pre></div></div>
            
        </li>
        
        
        <li id="section-1284">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1284">&#182;</a>
              </div>
              <p>Add undo manager logic</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">'mceEndUndoLevel,mceAddUndoLevel'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          editor.undoManager.add();
        },

        <span class="hljs-string">'Cut,Copy,Paste'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command</span>) </span>{
          <span class="hljs-keyword">var</span> doc = editor.getDoc(), failed;</pre></div></div>
            
        </li>
        
        
        <li id="section-1285">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1285">&#182;</a>
              </div>
              <p>Try executing the native command</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">try</span> {
            execNativeCommand(command);
          } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1286">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1286">&#182;</a>
              </div>
              <p>Command failed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            failed = TRUE;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1287">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1287">&#182;</a>
              </div>
              <p>Chrome reports the paste command as supported however older IE:s will return false for cut/paste</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (command === <span class="hljs-string">'paste'</span> &amp;&amp; !doc.queryCommandEnabled(command)) {
            failed = <span class="hljs-literal">true</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1288">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1288">&#182;</a>
              </div>
              <p>Present alert message about clipboard access not being available</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (failed || !doc.queryCommandSupported(command)) {
            <span class="hljs-keyword">var</span> msg = editor.translate(
              <span class="hljs-string">"Your browser doesn't support direct access to the clipboard. "</span> +
              <span class="hljs-string">"Please use the Ctrl+X/C/V keyboard shortcuts instead."</span>
            );

            <span class="hljs-keyword">if</span> (Env.mac) {
              msg = msg.replace(<span class="hljs-regexp">/Ctrl\+/g</span>, <span class="hljs-string">'\u2318+'</span>);
            }

            editor.notificationManager.open({ <span class="hljs-attr">text</span>: msg, <span class="hljs-attr">type</span>: <span class="hljs-string">'error'</span> });
          }
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-1289">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1289">&#182;</a>
              </div>
              <p>Override unlink command</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        unlink: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (selection.isCollapsed()) {
            <span class="hljs-keyword">var</span> elm = editor.dom.getParent(editor.selection.getStart(), <span class="hljs-string">'a'</span>);
            <span class="hljs-keyword">if</span> (elm) {
              editor.dom.remove(elm, <span class="hljs-literal">true</span>);
            }

            <span class="hljs-keyword">return</span>;
          }

          formatter.remove(<span class="hljs-string">"link"</span>);
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-1290">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1290">&#182;</a>
              </div>
              <p>Override justify commands to use the text formatter engine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull,JustifyNone'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command</span>) </span>{
          <span class="hljs-keyword">var</span> align = command.substring(<span class="hljs-number">7</span>);

          <span class="hljs-keyword">if</span> (align == <span class="hljs-string">'full'</span>) {
            align = <span class="hljs-string">'justify'</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1291">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1291">&#182;</a>
              </div>
              <p>Remove all other alignments first</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          each(<span class="hljs-string">'left,center,right,justify'</span>.split(<span class="hljs-string">','</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
            <span class="hljs-keyword">if</span> (align != name) {
              formatter.remove(<span class="hljs-string">'align'</span> + name);
            }
          });

          <span class="hljs-keyword">if</span> (align != <span class="hljs-string">'none'</span>) {
            toggleFormat(<span class="hljs-string">'align'</span> + align);
          }
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-1292">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1292">&#182;</a>
              </div>
              <p>Override list commands to fix WebKit bug</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">'InsertUnorderedList,InsertOrderedList'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command</span>) </span>{
          <span class="hljs-keyword">var</span> listElm, listParent;

          execNativeCommand(command);</pre></div></div>
            
        </li>
        
        
        <li id="section-1293">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1293">&#182;</a>
              </div>
              <p>WebKit produces lists within block elements so we need to split them
we will replace the native list creation logic to custom logic later on
TODO: Remove this when the list creation logic is removed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          listElm = dom.getParent(selection.getNode(), <span class="hljs-string">'ol,ul'</span>);
          <span class="hljs-keyword">if</span> (listElm) {
            listParent = listElm.parentNode;</pre></div></div>
            
        </li>
        
        
        <li id="section-1294">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1294">&#182;</a>
              </div>
              <p>If list is within a text block then split that block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(H[1-6]|P|ADDRESS|PRE)$/</span>.test(listParent.nodeName)) {
              storeSelection();
              dom.split(listParent, listElm);
              restoreSelection();
            }
          }
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-1295">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1295">&#182;</a>
              </div>
              <p>Override commands to use the text formatter engine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">'Bold,Italic,Underline,Strikethrough,Superscript,Subscript'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command</span>) </span>{
          toggleFormat(command);
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-1296">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1296">&#182;</a>
              </div>
              <p>Override commands to use the text formatter engine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">'ForeColor,HiliteColor,FontName'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command, ui, value</span>) </span>{
          toggleFormat(command, value);
        },

        <span class="hljs-attr">FontSize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command, ui, value</span>) </span>{
          <span class="hljs-keyword">var</span> fontClasses, fontSizes;</pre></div></div>
            
        </li>
        
        
        <li id="section-1297">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1297">&#182;</a>
              </div>
              <p>Convert font size 1-7 to styles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">1</span> &amp;&amp; value &lt;= <span class="hljs-number">7</span>) {
            fontSizes = explode(settings.font_size_style_values);
            fontClasses = explode(settings.font_size_classes);

            <span class="hljs-keyword">if</span> (fontClasses) {
              value = fontClasses[value - <span class="hljs-number">1</span>] || value;
            } <span class="hljs-keyword">else</span> {
              value = fontSizes[value - <span class="hljs-number">1</span>] || value;
            }
          }

          toggleFormat(command, value);
        },

        <span class="hljs-attr">RemoveFormat</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command</span>) </span>{
          formatter.remove(command);
        },

        <span class="hljs-attr">mceBlockQuote</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          toggleFormat(<span class="hljs-string">'blockquote'</span>);
        },

        <span class="hljs-attr">FormatBlock</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command, ui, value</span>) </span>{
          <span class="hljs-keyword">return</span> toggleFormat(value || <span class="hljs-string">'p'</span>);
        },

        <span class="hljs-attr">mceCleanup</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> bookmark = selection.getBookmark();

          editor.setContent(editor.getContent({ <span class="hljs-attr">cleanup</span>: TRUE }), { <span class="hljs-attr">cleanup</span>: TRUE });

          selection.moveToBookmark(bookmark);
        },

        <span class="hljs-attr">mceRemoveNode</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command, ui, value</span>) </span>{
          <span class="hljs-keyword">var</span> node = value || selection.getNode();</pre></div></div>
            
        </li>
        
        
        <li id="section-1298">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1298">&#182;</a>
              </div>
              <p>Make sure that the body node isnt removed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (node != editor.getBody()) {
            storeSelection();
            editor.dom.remove(node, TRUE);
            restoreSelection();
          }
        },

        <span class="hljs-attr">mceSelectNodeDepth</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command, ui, value</span>) </span>{
          <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;

          dom.getParent(selection.getNode(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">if</span> (node.nodeType == <span class="hljs-number">1</span> &amp;&amp; counter++ == value) {
              selection.select(node);
              <span class="hljs-keyword">return</span> FALSE;
            }
          }, editor.getBody());
        },

        <span class="hljs-attr">mceSelectNode</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command, ui, value</span>) </span>{
          selection.select(value);
        },

        <span class="hljs-attr">mceInsertContent</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command, ui, value</span>) </span>{
          InsertContent.insertAtCaret(editor, value);
        },

        <span class="hljs-attr">mceInsertRawHTML</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command, ui, value</span>) </span>{
          selection.setContent(<span class="hljs-string">'tiny_mce_marker'</span>);
          editor.setContent(
            editor.getContent().replace(<span class="hljs-regexp">/tiny_mce_marker/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">return</span> value;
            })
          );
        },

        <span class="hljs-attr">mceToggleFormat</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command, ui, value</span>) </span>{
          toggleFormat(value);
        },

        <span class="hljs-attr">mceSetContent</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command, ui, value</span>) </span>{
          editor.setContent(value);
        },

        <span class="hljs-string">'Indent,Outdent'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command</span>) </span>{
          <span class="hljs-keyword">var</span> intentValue, indentUnit, value;</pre></div></div>
            
        </li>
        
        
        <li id="section-1299">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1299">&#182;</a>
              </div>
              <p>Setup indent level</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          intentValue = settings.indentation;
          indentUnit = <span class="hljs-regexp">/[a-z%]+$/i</span>.exec(intentValue);
          intentValue = <span class="hljs-built_in">parseInt</span>(intentValue, <span class="hljs-number">10</span>);

          <span class="hljs-keyword">if</span> (!queryCommandState(<span class="hljs-string">'InsertUnorderedList'</span>) &amp;&amp; !queryCommandState(<span class="hljs-string">'InsertOrderedList'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1300">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1300">&#182;</a>
              </div>
              <p>If forced_root_blocks is set to false we dont have a block to indent so lets create a div</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!settings.forced_root_block &amp;&amp; !dom.getParent(selection.getNode(), dom.isBlock)) {
              formatter.apply(<span class="hljs-string">'div'</span>);
            }

            each(selection.getSelectedBlocks(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
              <span class="hljs-keyword">if</span> (dom.getContentEditable(element) === <span class="hljs-string">"false"</span>) {
                <span class="hljs-keyword">return</span>;
              }

              <span class="hljs-keyword">if</span> (element.nodeName !== <span class="hljs-string">"LI"</span>) {
                <span class="hljs-keyword">var</span> indentStyleName = editor.getParam(<span class="hljs-string">'indent_use_margin'</span>, <span class="hljs-literal">false</span>) ? <span class="hljs-string">'margin'</span> : <span class="hljs-string">'padding'</span>;
                indentStyleName = element.nodeName === <span class="hljs-string">'TABLE'</span> ? <span class="hljs-string">'margin'</span> : indentStyleName;
                indentStyleName += dom.getStyle(element, <span class="hljs-string">'direction'</span>, <span class="hljs-literal">true</span>) == <span class="hljs-string">'rtl'</span> ? <span class="hljs-string">'Right'</span> : <span class="hljs-string">'Left'</span>;

                <span class="hljs-keyword">if</span> (command == <span class="hljs-string">'outdent'</span>) {
                  value = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-built_in">parseInt</span>(element.style[indentStyleName] || <span class="hljs-number">0</span>, <span class="hljs-number">10</span>) - intentValue);
                  dom.setStyle(element, indentStyleName, value ? value + indentUnit : <span class="hljs-string">''</span>);
                } <span class="hljs-keyword">else</span> {
                  value = (<span class="hljs-built_in">parseInt</span>(element.style[indentStyleName] || <span class="hljs-number">0</span>, <span class="hljs-number">10</span>) + intentValue) + indentUnit;
                  dom.setStyle(element, indentStyleName, value);
                }
              }
            });
          } <span class="hljs-keyword">else</span> {
            execNativeCommand(command);
          }
        },

        <span class="hljs-attr">mceRepaint</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        },

        <span class="hljs-attr">InsertHorizontalRule</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          editor.execCommand(<span class="hljs-string">'mceInsertContent'</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">'&lt;hr /&gt;'</span>);
        },

        <span class="hljs-attr">mceToggleVisualAid</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          editor.hasVisual = !editor.hasVisual;
          editor.addVisual();
        },

        <span class="hljs-attr">mceReplaceContent</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command, ui, value</span>) </span>{
          editor.execCommand(<span class="hljs-string">'mceInsertContent'</span>, <span class="hljs-literal">false</span>, value.replace(<span class="hljs-regexp">/\{\$selection\}/g</span>, selection.getContent({ <span class="hljs-attr">format</span>: <span class="hljs-string">'text'</span> })));
        },

        <span class="hljs-attr">mceInsertLink</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command, ui, value</span>) </span>{
          <span class="hljs-keyword">var</span> anchor;

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'string'</span>) {
            value = { <span class="hljs-attr">href</span>: value };
          }

          anchor = dom.getParent(selection.getNode(), <span class="hljs-string">'a'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1301">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1301">&#182;</a>
              </div>
              <p>Spaces are never valid in URLs and its a very common mistake for people to make so we fix it here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          value.href = value.href.replace(<span class="hljs-string">' '</span>, <span class="hljs-string">'%20'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1302">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1302">&#182;</a>
              </div>
              <p>Remove existing links if there could be child links or that the href isnt specified</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!anchor || !value.href) {
            formatter.remove(<span class="hljs-string">'link'</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1303">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1303">&#182;</a>
              </div>
              <p>Apply new link to selection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (value.href) {
            formatter.apply(<span class="hljs-string">'link'</span>, value, anchor);
          }
        },

        <span class="hljs-attr">selectAll</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> root = dom.getRoot(), rng;

          <span class="hljs-keyword">if</span> (selection.getRng().setStart) {
            <span class="hljs-keyword">var</span> editingHost = dom.getParent(selection.getStart(), NodeType.isContentEditableTrue);
            <span class="hljs-keyword">if</span> (editingHost) {
              rng = dom.createRng();
              rng.selectNodeContents(editingHost);
              selection.setRng(rng);
            }
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1304">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1304">&#182;</a>
              </div>
              <p>IE will render its own root level block elements and sometimes
even put font elements in them when the user starts typing. So we need to
move the selection to a more suitable element from this:</p>
<body>|<p></p></body> to this: <body><p>|</p></body>

            </div>
            
            <div class="content"><div class='highlight'><pre>            rng = selection.getRng();
            <span class="hljs-keyword">if</span> (!rng.item) {
              rng.moveToElementText(root);
              rng.select();
            }
          }
        },

        <span class="hljs-string">"delete"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          DeleteCommands.deleteCommand(editor);
        },

        <span class="hljs-string">"forwardDelete"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          DeleteCommands.forwardDeleteCommand(editor);
        },

        <span class="hljs-attr">mceNewDocument</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          editor.setContent(<span class="hljs-string">''</span>);
        },

        <span class="hljs-attr">InsertLineBreak</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command, ui, value</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1305">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1305">&#182;</a>
              </div>
              <p>We load the current event in from EnterKey.js when appropriate to heed
certain event-specific variations such as ctrl-enter in a list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> evt = value;
          <span class="hljs-keyword">var</span> brElm, extraBr, marker;
          <span class="hljs-keyword">var</span> rng = selection.getRng(<span class="hljs-literal">true</span>);
          <span class="hljs-keyword">new</span> RangeUtils(dom).normalize(rng);

          <span class="hljs-keyword">var</span> offset = rng.startOffset;
          <span class="hljs-keyword">var</span> container = rng.startContainer;</pre></div></div>
            
        </li>
        
        
        <li id="section-1306">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1306">&#182;</a>
              </div>
              <p>Resolve node index</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">1</span> &amp;&amp; container.hasChildNodes()) {
            <span class="hljs-keyword">var</span> isAfterLastNodeInContainer = offset &gt; container.childNodes.length - <span class="hljs-number">1</span>;

            container = container.childNodes[<span class="hljs-built_in">Math</span>.min(offset, container.childNodes.length - <span class="hljs-number">1</span>)] || container;
            <span class="hljs-keyword">if</span> (isAfterLastNodeInContainer &amp;&amp; container.nodeType == <span class="hljs-number">3</span>) {
              offset = container.nodeValue.length;
            } <span class="hljs-keyword">else</span> {
              offset = <span class="hljs-number">0</span>;
            }
          }

          <span class="hljs-keyword">var</span> parentBlock = dom.getParent(container, dom.isBlock);
          <span class="hljs-keyword">var</span> parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : <span class="hljs-string">''</span>; <span class="hljs-comment">// IE &lt; 9 &amp; HTML5</span>
          <span class="hljs-keyword">var</span> containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">var</span> containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : <span class="hljs-string">''</span>; <span class="hljs-comment">// IE &lt; 9 &amp; HTML5</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1307">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1307">&#182;</a>
              </div>
              <p>Enter inside block contained within a LI then split or insert before/after LI</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> isControlKey = evt &amp;&amp; evt.ctrlKey;
          <span class="hljs-keyword">if</span> (containerBlockName == <span class="hljs-string">'LI'</span> &amp;&amp; !isControlKey) {
            parentBlock = containerBlock;
            parentBlockName = containerBlockName;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1308">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1308">&#182;</a>
              </div>
              <p>Walks the parent block to the right and look for BR elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasRightSideContent</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> walker = <span class="hljs-keyword">new</span> TreeWalker(container, parentBlock), node;
            <span class="hljs-keyword">var</span> nonEmptyElementsMap = editor.schema.getNonEmptyElements();

            <span class="hljs-keyword">while</span> ((node = walker.next())) {
              <span class="hljs-keyword">if</span> (nonEmptyElementsMap[node.nodeName.toLowerCase()] || node.length &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              }
            }
          }

          <span class="hljs-keyword">if</span> (container &amp;&amp; container.nodeType == <span class="hljs-number">3</span> &amp;&amp; offset &gt;= container.nodeValue.length) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1309">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1309">&#182;</a>
              </div>
              <p>Insert extra BR element at the end block elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!isOldIE &amp;&amp; !hasRightSideContent()) {
              brElm = dom.create(<span class="hljs-string">'br'</span>);
              rng.insertNode(brElm);
              rng.setStartAfter(brElm);
              rng.setEndAfter(brElm);
              extraBr = <span class="hljs-literal">true</span>;
            }
          }

          brElm = dom.create(<span class="hljs-string">'br'</span>);
          rng.insertNode(brElm);</pre></div></div>
            
        </li>
        
        
        <li id="section-1310">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1310">&#182;</a>
              </div>
              <p>Rendering modes below IE8 doesnt display BR elements in PRE unless we have a \n before it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> documentMode = dom.doc.documentMode;
          <span class="hljs-keyword">if</span> (isOldIE &amp;&amp; parentBlockName == <span class="hljs-string">'PRE'</span> &amp;&amp; (!documentMode || documentMode &lt; <span class="hljs-number">8</span>)) {
            brElm.parentNode.insertBefore(dom.doc.createTextNode(<span class="hljs-string">'\r'</span>), brElm);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1311">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1311">&#182;</a>
              </div>
              <p>Insert temp marker and scroll to that</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          marker = dom.create(<span class="hljs-string">'span'</span>, {}, <span class="hljs-string">'&amp;nbsp;'</span>);
          brElm.parentNode.insertBefore(marker, brElm);
          selection.scrollIntoView(marker);
          dom.remove(marker);

          <span class="hljs-keyword">if</span> (!extraBr) {
            rng.setStartAfter(brElm);
            rng.setEndAfter(brElm);
          } <span class="hljs-keyword">else</span> {
            rng.setStartBefore(brElm);
            rng.setEndBefore(brElm);
          }

          selection.setRng(rng);
          editor.undoManager.add();

          <span class="hljs-keyword">return</span> TRUE;
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-1312">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1312">&#182;</a>
              </div>
              <p>Add queryCommandState overrides</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      addCommands({</pre></div></div>
            
        </li>
        
        
        <li id="section-1313">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1313">&#182;</a>
              </div>
              <p>Override justify commands</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command</span>) </span>{
          <span class="hljs-keyword">var</span> name = <span class="hljs-string">'align'</span> + command.substring(<span class="hljs-number">7</span>);
          <span class="hljs-keyword">var</span> nodes = selection.isCollapsed() ? [dom.getParent(selection.getNode(), dom.isBlock)] : selection.getSelectedBlocks();
          <span class="hljs-keyword">var</span> matches = map(nodes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">return</span> !!formatter.matchNode(node, name);
          });
          <span class="hljs-keyword">return</span> inArray(matches, TRUE) !== <span class="hljs-number">-1</span>;
        },

        <span class="hljs-string">'Bold,Italic,Underline,Strikethrough,Superscript,Subscript'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command</span>) </span>{
          <span class="hljs-keyword">return</span> isFormatMatch(command);
        },

        <span class="hljs-attr">mceBlockQuote</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> isFormatMatch(<span class="hljs-string">'blockquote'</span>);
        },

        <span class="hljs-attr">Outdent</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> node;

          <span class="hljs-keyword">if</span> (settings.inline_styles) {
            <span class="hljs-keyword">if</span> ((node = dom.getParent(selection.getStart(), dom.isBlock)) &amp;&amp; <span class="hljs-built_in">parseInt</span>(node.style.paddingLeft, <span class="hljs-number">10</span>) &gt; <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> TRUE;
            }

            <span class="hljs-keyword">if</span> ((node = dom.getParent(selection.getEnd(), dom.isBlock)) &amp;&amp; <span class="hljs-built_in">parseInt</span>(node.style.paddingLeft, <span class="hljs-number">10</span>) &gt; <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> TRUE;
            }
          }

          <span class="hljs-keyword">return</span> (
            queryCommandState(<span class="hljs-string">'InsertUnorderedList'</span>) ||
            queryCommandState(<span class="hljs-string">'InsertOrderedList'</span>) ||
            (!settings.inline_styles &amp;&amp; !!dom.getParent(selection.getNode(), <span class="hljs-string">'BLOCKQUOTE'</span>))
          );
        },

        <span class="hljs-string">'InsertUnorderedList,InsertOrderedList'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command</span>) </span>{
          <span class="hljs-keyword">var</span> list = dom.getParent(selection.getNode(), <span class="hljs-string">'ul,ol'</span>);

          <span class="hljs-keyword">return</span> list &amp;&amp;
            (
              command === <span class="hljs-string">'insertunorderedlist'</span> &amp;&amp; list.tagName === <span class="hljs-string">'UL'</span> ||
              command === <span class="hljs-string">'insertorderedlist'</span> &amp;&amp; list.tagName === <span class="hljs-string">'OL'</span>
            );
        }
      }, <span class="hljs-string">'state'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1314">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1314">&#182;</a>
              </div>
              <p>Add queryCommandValue overrides</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      addCommands({
        <span class="hljs-string">'FontSize,FontName'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command</span>) </span>{
          <span class="hljs-keyword">var</span> value = <span class="hljs-number">0</span>, parent;

          <span class="hljs-keyword">if</span> ((parent = dom.getParent(selection.getNode(), <span class="hljs-string">'span'</span>))) {
            <span class="hljs-keyword">if</span> (command == <span class="hljs-string">'fontsize'</span>) {
              value = parent.style.fontSize;
            } <span class="hljs-keyword">else</span> {
              value = parent.style.fontFamily.replace(<span class="hljs-regexp">/, /g</span>, <span class="hljs-string">','</span>).replace(<span class="hljs-regexp">/[\'\"]/g</span>, <span class="hljs-string">''</span>).toLowerCase();
            }
          }

          <span class="hljs-keyword">return</span> value;
        }
      }, <span class="hljs-string">'value'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1315">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1315">&#182;</a>
              </div>
              <p>Add undo manager logic</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      addCommands({
        <span class="hljs-attr">Undo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          editor.undoManager.undo();
        },

        <span class="hljs-attr">Redo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          editor.undoManager.redo();
        }
      });
    };
  }
);

<span class="hljs-comment">/**
 * URI.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class handles parsing, modification and serialization of URI/URL strings.
 * @class tinymce.util.URI
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.URI'</span>,
  [
    <span class="hljs-string">'global!document'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">document, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> each = Tools.each, trim = Tools.trim;
    <span class="hljs-keyword">var</span> queryParts = <span class="hljs-string">"source protocol authority userInfo user password host port relative path directory file query anchor"</span>.split(<span class="hljs-string">' '</span>);
    <span class="hljs-keyword">var</span> DEFAULT_PORTS = {
      <span class="hljs-string">'ftp'</span>: <span class="hljs-number">21</span>,
      <span class="hljs-string">'http'</span>: <span class="hljs-number">80</span>,
      <span class="hljs-string">'https'</span>: <span class="hljs-number">443</span>,
      <span class="hljs-string">'mailto'</span>: <span class="hljs-number">25</span>
    };

    <span class="hljs-comment">/**
     * Constructs a new URI instance.
     *
     * @constructor
     * @method URI
     * @param {String} url URI string to parse.
     * @param {Object} settings Optional settings object.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">URI</span>(<span class="hljs-params">url, settings</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, baseUri, baseUrl;

      url = trim(url);
      settings = self.settings = settings || {};
      baseUri = settings.base_uri;</pre></div></div>
            
        </li>
        
        
        <li id="section-1316">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1316">&#182;</a>
              </div>
              <p>Strange app protocol that isnt http/https or local anchor
For example: mailto,skype,tel etc.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^([\w\-]+):([^\/]{2})/i</span>.test(url) || <span class="hljs-regexp">/^\s*#/</span>.test(url)) {
        self.source = url;
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> isProtocolRelative = url.indexOf(<span class="hljs-string">'//'</span>) === <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1317">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1317">&#182;</a>
              </div>
              <p>Absolute path with no host, fake host and protocol</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (url.indexOf(<span class="hljs-string">'/'</span>) === <span class="hljs-number">0</span> &amp;&amp; !isProtocolRelative) {
        url = (baseUri ? baseUri.protocol || <span class="hljs-string">'http'</span> : <span class="hljs-string">'http'</span>) + <span class="hljs-string">'://mce_host'</span> + url;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1318">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1318">&#182;</a>
              </div>
              <p>Relative path http:// or protocol relative //path</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^[\w\-]*:?\/\//</span>.test(url)) {
        baseUrl = settings.base_uri ? settings.base_uri.path : <span class="hljs-keyword">new</span> URI(<span class="hljs-built_in">document</span>.location.href).directory;
        <span class="hljs-keyword">if</span> (settings.base_uri.protocol === <span class="hljs-string">""</span>) {
          url = <span class="hljs-string">'//mce_host'</span> + self.toAbsPath(baseUrl, url);
        } <span class="hljs-keyword">else</span> {
          url = <span class="hljs-regexp">/([^#?]*)([#?]?.*)/</span>.exec(url);
          url = ((baseUri &amp;&amp; baseUri.protocol) || <span class="hljs-string">'http'</span>) + <span class="hljs-string">'://mce_host'</span> + self.toAbsPath(baseUrl, url[<span class="hljs-number">1</span>]) + url[<span class="hljs-number">2</span>];
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1319">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1319">&#182;</a>
              </div>
              <p>Parse URL (Credits goes to Steave, <a href="http://blog.stevenlevithan.com/archives/parseuri">http://blog.stevenlevithan.com/archives/parseuri</a>)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      url = url.replace(<span class="hljs-regexp">/@@/g</span>, <span class="hljs-string">'(mce_at)'</span>); <span class="hljs-comment">// Zope 3 workaround, they use @@something</span>

      <span class="hljs-comment">/*jshint maxlen: 255 */</span>
      <span class="hljs-comment">/*eslint max-len: 0 */</span>
      url = <span class="hljs-regexp">/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/</span>.exec(url);

      each(queryParts, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v, i</span>) </span>{
        <span class="hljs-keyword">var</span> part = url[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-1320">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1320">&#182;</a>
              </div>
              <p>Zope 3 workaround, they use @@something</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (part) {
          part = part.replace(<span class="hljs-regexp">/\(mce_at\)/g</span>, <span class="hljs-string">'@@'</span>);
        }

        self[v] = part;
      });

      <span class="hljs-keyword">if</span> (baseUri) {
        <span class="hljs-keyword">if</span> (!self.protocol) {
          self.protocol = baseUri.protocol;
        }

        <span class="hljs-keyword">if</span> (!self.userInfo) {
          self.userInfo = baseUri.userInfo;
        }

        <span class="hljs-keyword">if</span> (!self.port &amp;&amp; self.host === <span class="hljs-string">'mce_host'</span>) {
          self.port = baseUri.port;
        }

        <span class="hljs-keyword">if</span> (!self.host || self.host === <span class="hljs-string">'mce_host'</span>) {
          self.host = baseUri.host;
        }

        self.source = <span class="hljs-string">''</span>;
      }

      <span class="hljs-keyword">if</span> (isProtocolRelative) {
        self.protocol = <span class="hljs-string">''</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1321">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1321">&#182;</a>
              </div>
              <p>t.path = t.path || /;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    }

    URI.prototype = {
      <span class="hljs-comment">/**
       * Sets the internal path part of the URI.
       *
       * @method setPath
       * @param {string} path Path string to set.
       */</span>
      setPath: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        path = <span class="hljs-regexp">/^(.*?)\/?(\w+)?$/</span>.exec(path);</pre></div></div>
            
        </li>
        
        
        <li id="section-1322">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1322">&#182;</a>
              </div>
              <p>Update path parts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self.path = path[<span class="hljs-number">0</span>];
        self.directory = path[<span class="hljs-number">1</span>];
        self.file = path[<span class="hljs-number">2</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-1323">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1323">&#182;</a>
              </div>
              <p>Rebuild source</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self.source = <span class="hljs-string">''</span>;
        self.getURI();
      },

      <span class="hljs-comment">/**
       * Converts the specified URI into a relative URI based on the current URI instance location.
       *
       * @method toRelative
       * @param {String} uri URI to convert into a relative path/URI.
       * @return {String} Relative URI from the point specified in the current URI instance.
       * @example
       * // Converts an absolute URL to an relative URL url will be somedir/somefile.htm
       * var url = new tinymce.util.URI('http://www.site.com/dir/').toRelative('http://www.site.com/dir/somedir/somefile.htm');
       */</span>
      toRelative: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">uri</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, output;

        <span class="hljs-keyword">if</span> (uri === <span class="hljs-string">"./"</span>) {
          <span class="hljs-keyword">return</span> uri;
        }

        uri = <span class="hljs-keyword">new</span> URI(uri, { <span class="hljs-attr">base_uri</span>: self });</pre></div></div>
            
        </li>
        
        
        <li id="section-1324">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1324">&#182;</a>
              </div>
              <p>Not on same domain/port or protocol</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((uri.host != <span class="hljs-string">'mce_host'</span> &amp;&amp; self.host != uri.host &amp;&amp; uri.host) || self.port != uri.port ||
          (self.protocol != uri.protocol &amp;&amp; uri.protocol !== <span class="hljs-string">""</span>)) {
          <span class="hljs-keyword">return</span> uri.getURI();
        }

        <span class="hljs-keyword">var</span> tu = self.getURI(), uu = uri.getURI();</pre></div></div>
            
        </li>
        
        
        <li id="section-1325">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1325">&#182;</a>
              </div>
              <p>Allow usage of the base_uri when relative_urls = true</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (tu == uu || (tu.charAt(tu.length - <span class="hljs-number">1</span>) == <span class="hljs-string">"/"</span> &amp;&amp; tu.substr(<span class="hljs-number">0</span>, tu.length - <span class="hljs-number">1</span>) == uu)) {
          <span class="hljs-keyword">return</span> tu;
        }

        output = self.toRelPath(self.path, uri.path);</pre></div></div>
            
        </li>
        
        
        <li id="section-1326">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1326">&#182;</a>
              </div>
              <p>Add query</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (uri.query) {
          output += <span class="hljs-string">'?'</span> + uri.query;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1327">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1327">&#182;</a>
              </div>
              <p>Add anchor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (uri.anchor) {
          output += <span class="hljs-string">'#'</span> + uri.anchor;
        }

        <span class="hljs-keyword">return</span> output;
      },

      <span class="hljs-comment">/**
       * Converts the specified URI into a absolute URI based on the current URI instance location.
       *
       * @method toAbsolute
       * @param {String} uri URI to convert into a relative path/URI.
       * @param {Boolean} noHost No host and protocol prefix.
       * @return {String} Absolute URI from the point specified in the current URI instance.
       * @example
       * // Converts an relative URL to an absolute URL url will be http://www.site.com/dir/somedir/somefile.htm
       * var url = new tinymce.util.URI('http://www.site.com/dir/').toAbsolute('somedir/somefile.htm');
       */</span>
      toAbsolute: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">uri, noHost</span>) </span>{
        uri = <span class="hljs-keyword">new</span> URI(uri, { <span class="hljs-attr">base_uri</span>: <span class="hljs-keyword">this</span> });

        <span class="hljs-keyword">return</span> uri.getURI(noHost &amp;&amp; <span class="hljs-keyword">this</span>.isSameOrigin(uri));
      },

      <span class="hljs-comment">/**
       * Determine whether the given URI has the same origin as this URI.  Based on RFC-6454.
       * Supports default ports for protocols listed in DEFAULT_PORTS.  Unsupported protocols will fail safe: they
       * won't match, if the port specifications differ.
       *
       * @method isSameOrigin
       * @param {tinymce.util.URI} uri Uri instance to compare.
       * @returns {Boolean} True if the origins are the same.
       */</span>
      isSameOrigin: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">uri</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.host == uri.host &amp;&amp; <span class="hljs-keyword">this</span>.protocol == uri.protocol) {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.port == uri.port) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }

          <span class="hljs-keyword">var</span> defaultPort = DEFAULT_PORTS[<span class="hljs-keyword">this</span>.protocol];
          <span class="hljs-keyword">if</span> (defaultPort &amp;&amp; ((<span class="hljs-keyword">this</span>.port || defaultPort) == (uri.port || defaultPort))) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      },

      <span class="hljs-comment">/**
       * Converts a absolute path into a relative path.
       *
       * @method toRelPath
       * @param {String} base Base point to convert the path from.
       * @param {String} path Absolute path to convert into a relative path.
       */</span>
      toRelPath: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">base, path</span>) </span>{
        <span class="hljs-keyword">var</span> items, breakPoint = <span class="hljs-number">0</span>, out = <span class="hljs-string">''</span>, i, l;</pre></div></div>
            
        </li>
        
        
        <li id="section-1328">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1328">&#182;</a>
              </div>
              <p>Split the paths</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        base = base.substring(<span class="hljs-number">0</span>, base.lastIndexOf(<span class="hljs-string">'/'</span>));
        base = base.split(<span class="hljs-string">'/'</span>);
        items = path.split(<span class="hljs-string">'/'</span>);

        <span class="hljs-keyword">if</span> (base.length &gt;= items.length) {
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = base.length; i &lt; l; i++) {
            <span class="hljs-keyword">if</span> (i &gt;= items.length || base[i] != items[i]) {
              breakPoint = i + <span class="hljs-number">1</span>;
              <span class="hljs-keyword">break</span>;
            }
          }
        }

        <span class="hljs-keyword">if</span> (base.length &lt; items.length) {
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = items.length; i &lt; l; i++) {
            <span class="hljs-keyword">if</span> (i &gt;= base.length || base[i] != items[i]) {
              breakPoint = i + <span class="hljs-number">1</span>;
              <span class="hljs-keyword">break</span>;
            }
          }
        }

        <span class="hljs-keyword">if</span> (breakPoint === <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">return</span> path;
        }

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = base.length - (breakPoint - <span class="hljs-number">1</span>); i &lt; l; i++) {
          out += <span class="hljs-string">"../"</span>;
        }

        <span class="hljs-keyword">for</span> (i = breakPoint - <span class="hljs-number">1</span>, l = items.length; i &lt; l; i++) {
          <span class="hljs-keyword">if</span> (i != breakPoint - <span class="hljs-number">1</span>) {
            out += <span class="hljs-string">"/"</span> + items[i];
          } <span class="hljs-keyword">else</span> {
            out += items[i];
          }
        }

        <span class="hljs-keyword">return</span> out;
      },

      <span class="hljs-comment">/**
       * Converts a relative path into a absolute path.
       *
       * @method toAbsPath
       * @param {String} base Base point to convert the path from.
       * @param {String} path Relative path to convert into an absolute path.
       */</span>
      toAbsPath: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">base, path</span>) </span>{
        <span class="hljs-keyword">var</span> i, nb = <span class="hljs-number">0</span>, o = [], tr, outPath;</pre></div></div>
            
        </li>
        
        
        <li id="section-1329">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1329">&#182;</a>
              </div>
              <p>Split paths</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        tr = <span class="hljs-regexp">/\/$/</span>.test(path) ? <span class="hljs-string">'/'</span> : <span class="hljs-string">''</span>;
        base = base.split(<span class="hljs-string">'/'</span>);
        path = path.split(<span class="hljs-string">'/'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1330">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1330">&#182;</a>
              </div>
              <p>Remove empty chunks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        each(base, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">k</span>) </span>{
          <span class="hljs-keyword">if</span> (k) {
            o.push(k);
          }
        });

        base = o;</pre></div></div>
            
        </li>
        
        
        <li id="section-1331">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1331">&#182;</a>
              </div>
              <p>Merge relURLParts chunks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (i = path.length - <span class="hljs-number">1</span>, o = []; i &gt;= <span class="hljs-number">0</span>; i--) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1332">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1332">&#182;</a>
              </div>
              <p>Ignore empty or .</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (path[i].length === <span class="hljs-number">0</span> || path[i] === <span class="hljs-string">"."</span>) {
            <span class="hljs-keyword">continue</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1333">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1333">&#182;</a>
              </div>
              <p>Is parent</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (path[i] === <span class="hljs-string">'..'</span>) {
            nb++;
            <span class="hljs-keyword">continue</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1334">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1334">&#182;</a>
              </div>
              <p>Move up</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (nb &gt; <span class="hljs-number">0</span>) {
            nb--;
            <span class="hljs-keyword">continue</span>;
          }

          o.push(path[i]);
        }

        i = base.length - nb;</pre></div></div>
            
        </li>
        
        
        <li id="section-1335">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1335">&#182;</a>
              </div>
              <p>If /a/b/c or /</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">0</span>) {
          outPath = o.reverse().join(<span class="hljs-string">'/'</span>);
        } <span class="hljs-keyword">else</span> {
          outPath = base.slice(<span class="hljs-number">0</span>, i).join(<span class="hljs-string">'/'</span>) + <span class="hljs-string">'/'</span> + o.reverse().join(<span class="hljs-string">'/'</span>);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1336">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1336">&#182;</a>
              </div>
              <p>Add front / if its needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (outPath.indexOf(<span class="hljs-string">'/'</span>) !== <span class="hljs-number">0</span>) {
          outPath = <span class="hljs-string">'/'</span> + outPath;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1337">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1337">&#182;</a>
              </div>
              <p>Add traling / if its needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (tr &amp;&amp; outPath.lastIndexOf(<span class="hljs-string">'/'</span>) !== outPath.length - <span class="hljs-number">1</span>) {
          outPath += tr;
        }

        <span class="hljs-keyword">return</span> outPath;
      },

      <span class="hljs-comment">/**
       * Returns the full URI of the internal structure.
       *
       * @method getURI
       * @param {Boolean} noProtoHost Optional no host and protocol part. Defaults to false.
       */</span>
      getURI: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">noProtoHost</span>) </span>{
        <span class="hljs-keyword">var</span> s, self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1338">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1338">&#182;</a>
              </div>
              <p>Rebuild source</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!self.source || noProtoHost) {
          s = <span class="hljs-string">''</span>;

          <span class="hljs-keyword">if</span> (!noProtoHost) {
            <span class="hljs-keyword">if</span> (self.protocol) {
              s += self.protocol + <span class="hljs-string">'://'</span>;
            } <span class="hljs-keyword">else</span> {
              s += <span class="hljs-string">'//'</span>;
            }

            <span class="hljs-keyword">if</span> (self.userInfo) {
              s += self.userInfo + <span class="hljs-string">'@'</span>;
            }

            <span class="hljs-keyword">if</span> (self.host) {
              s += self.host;
            }

            <span class="hljs-keyword">if</span> (self.port) {
              s += <span class="hljs-string">':'</span> + self.port;
            }
          }

          <span class="hljs-keyword">if</span> (self.path) {
            s += self.path;
          }

          <span class="hljs-keyword">if</span> (self.query) {
            s += <span class="hljs-string">'?'</span> + self.query;
          }

          <span class="hljs-keyword">if</span> (self.anchor) {
            s += <span class="hljs-string">'#'</span> + self.anchor;
          }

          self.source = s;
        }

        <span class="hljs-keyword">return</span> self.source;
      }
    };

    URI.parseDataUri = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">uri</span>) </span>{
      <span class="hljs-keyword">var</span> type, matches;

      uri = <span class="hljs-built_in">decodeURIComponent</span>(uri).split(<span class="hljs-string">','</span>);

      matches = <span class="hljs-regexp">/data:([^;]+)/</span>.exec(uri[<span class="hljs-number">0</span>]);
      <span class="hljs-keyword">if</span> (matches) {
        type = matches[<span class="hljs-number">1</span>];
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">type</span>: type,
        <span class="hljs-attr">data</span>: uri[<span class="hljs-number">1</span>]
      };
    };

    URI.getDocumentBaseUrl = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">loc</span>) </span>{
      <span class="hljs-keyword">var</span> baseUrl;</pre></div></div>
            
        </li>
        
        
        <li id="section-1339">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1339">&#182;</a>
              </div>
              <p>Pass applewebdata:// and other non web protocols though</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (loc.protocol.indexOf(<span class="hljs-string">'http'</span>) !== <span class="hljs-number">0</span> &amp;&amp; loc.protocol !== <span class="hljs-string">'file:'</span>) {
        baseUrl = loc.href;
      } <span class="hljs-keyword">else</span> {
        baseUrl = loc.protocol + <span class="hljs-string">'//'</span> + loc.host + loc.pathname;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^[^:]+:\/\/\/?[^\/]+\//</span>.test(baseUrl)) {
        baseUrl = baseUrl.replace(<span class="hljs-regexp">/[\?#].*$/</span>, <span class="hljs-string">''</span>).replace(<span class="hljs-regexp">/[\/\\][^\/]+$/</span>, <span class="hljs-string">''</span>);

        <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/[\/\\]$/</span>.test(baseUrl)) {
          baseUrl += <span class="hljs-string">'/'</span>;
        }
      }

      <span class="hljs-keyword">return</span> baseUrl;
    };

    <span class="hljs-keyword">return</span> URI;
  }
);

<span class="hljs-comment">/**
 * Class.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This utilitiy class is used for easier inheritance.
 *
 * Features:
 * * Exposed super functions: this._super();
 * * Mixins
 * * Dummy functions
 * * Property functions: var value = object.value(); and object.value(newValue);
 * * Static functions
 * * Defaults settings
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.Class'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Tools</span>) </span>{
    <span class="hljs-keyword">var</span> each = Tools.each, extend = Tools.extend;

    <span class="hljs-keyword">var</span> extendClass, initializing;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Class</span>(<span class="hljs-params"></span>) </span>{
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-1340">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1340">&#182;</a>
              </div>
              <p>Provides classical inheritance, based on code made by John Resig</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Class.extend = extendClass = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prop</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, _super = self.prototype, prototype, name, member;</pre></div></div>
            
        </li>
        
        
        <li id="section-1341">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1341">&#182;</a>
              </div>
              <p>The dummy class constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Class</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> i, mixins, mixin, self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1342">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1342">&#182;</a>
              </div>
              <p>All construction is actually done in the init method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!initializing) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1343">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1343">&#182;</a>
              </div>
              <p>Run class constuctor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (self.init) {
            self.init.apply(self, <span class="hljs-built_in">arguments</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1344">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1344">&#182;</a>
              </div>
              <p>Run mixin constructors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          mixins = self.Mixins;
          <span class="hljs-keyword">if</span> (mixins) {
            i = mixins.length;
            <span class="hljs-keyword">while</span> (i--) {
              mixin = mixins[i];
              <span class="hljs-keyword">if</span> (mixin.init) {
                mixin.init.apply(self, <span class="hljs-built_in">arguments</span>);
              }
            }
          }
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1345">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1345">&#182;</a>
              </div>
              <p>Dummy function, needs to be extended in order to provide functionality</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dummy</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1346">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1346">&#182;</a>
              </div>
              <p>Creates a overloaded method for the class
this enables you to use this._super(); to call the super function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMethod</span>(<span class="hljs-params">name, fn</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, tmp = self._super, ret;

          self._super = _super[name];
          ret = fn.apply(self, <span class="hljs-built_in">arguments</span>);
          self._super = tmp;

          <span class="hljs-keyword">return</span> ret;
        };
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1347">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1347">&#182;</a>
              </div>
              <p>Instantiate a base class (but only create the instance,
dont run the init constructor)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      initializing = <span class="hljs-literal">true</span>;

      <span class="hljs-comment">/*eslint new-cap:0 */</span>
      prototype = <span class="hljs-keyword">new</span> self();
      initializing = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1348">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1348">&#182;</a>
              </div>
              <p>Add mixins</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (prop.Mixins) {
        each(prop.Mixins, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mixin</span>) </span>{
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> mixin) {
            <span class="hljs-keyword">if</span> (name !== <span class="hljs-string">"init"</span>) {
              prop[name] = mixin[name];
            }
          }
        });

        <span class="hljs-keyword">if</span> (_super.Mixins) {
          prop.Mixins = _super.Mixins.concat(prop.Mixins);
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1349">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1349">&#182;</a>
              </div>
              <p>Generate dummy methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (prop.Methods) {
        each(prop.Methods.split(<span class="hljs-string">','</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          prop[name] = dummy;
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1350">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1350">&#182;</a>
              </div>
              <p>Generate property methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (prop.Properties) {
        each(prop.Properties.split(<span class="hljs-string">','</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">var</span> fieldName = <span class="hljs-string">'_'</span> + name;

          prop[name] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, undef;</pre></div></div>
            
        </li>
        
        
        <li id="section-1351">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1351">&#182;</a>
              </div>
              <p>Set value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (value !== undef) {
              self[fieldName] = value;

              <span class="hljs-keyword">return</span> self;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1352">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1352">&#182;</a>
              </div>
              <p>Get value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> self[fieldName];
          };
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1353">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1353">&#182;</a>
              </div>
              <p>Static functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (prop.Statics) {
        each(prop.Statics, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func, name</span>) </span>{
          Class[name] = func;
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1354">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1354">&#182;</a>
              </div>
              <p>Default settings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (prop.Defaults &amp;&amp; _super.Defaults) {
        prop.Defaults = extend({}, _super.Defaults, prop.Defaults);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1355">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1355">&#182;</a>
              </div>
              <p>Copy the properties over onto the new prototype</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> prop) {
        member = prop[name];

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> member == <span class="hljs-string">"function"</span> &amp;&amp; _super[name]) {
          prototype[name] = createMethod(name, member);
        } <span class="hljs-keyword">else</span> {
          prototype[name] = member;
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1356">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1356">&#182;</a>
              </div>
              <p>Populate our constructed prototype object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      Class.prototype = prototype;</pre></div></div>
            
        </li>
        
        
        <li id="section-1357">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1357">&#182;</a>
              </div>
              <p>Enforce the constructor to be what we expect</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      Class.constructor = Class;</pre></div></div>
            
        </li>
        
        
        <li id="section-1358">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1358">&#182;</a>
              </div>
              <p>And make this class extendible</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      Class.extend = extendClass;

      <span class="hljs-keyword">return</span> Class;
    };

    <span class="hljs-keyword">return</span> Class;
  }
);
<span class="hljs-comment">/**
 * EventDispatcher.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class lets you add/remove and fire events by name on the specified scope. This makes
 * it easy to add event listener logic to any class.
 *
 * @class tinymce.util.EventDispatcher
 * @example
 *  var eventDispatcher = new EventDispatcher();
 *
 *  eventDispatcher.on('click', function() {console.log('data');});
 *  eventDispatcher.fire('click', {data: 123});
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.EventDispatcher'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Tools</span>) </span>{
    <span class="hljs-keyword">var</span> nativeEvents = Tools.makeMap(
      <span class="hljs-string">"focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange "</span> +
      <span class="hljs-string">"mouseout mouseenter mouseleave wheel keydown keypress keyup input contextmenu dragstart dragend dragover "</span> +
      <span class="hljs-string">"draggesture dragdrop drop drag submit "</span> +
      <span class="hljs-string">"compositionstart compositionend compositionupdate touchstart touchmove touchend"</span>,
      <span class="hljs-string">' '</span>
    );

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dispatcher</span>(<span class="hljs-params">settings</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, scope, bindings = {}, toggleEvent;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnFalse</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnTrue</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      settings = settings || {};
      scope = settings.scope || self;
      toggleEvent = settings.toggleEvent || returnFalse;

      <span class="hljs-comment">/**
       * Fires the specified event by name.
       *
       * @method fire
       * @param {String} name Name of the event to fire.
       * @param {Object?} args Event arguments.
       * @return {Object} Event args instance passed in.
       * @example
       * instance.fire('event', {...});
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fire</span>(<span class="hljs-params">name, args</span>) </span>{
        <span class="hljs-keyword">var</span> handlers, i, l, callback;

        name = name.toLowerCase();
        args = args || {};
        args.type = name;</pre></div></div>
            
        </li>
        
        
        <li id="section-1359">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1359">&#182;</a>
              </div>
              <p>Setup target is there isnt one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!args.target) {
          args.target = scope;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1360">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1360">&#182;</a>
              </div>
              <p>Add event delegation methods if they are missing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!args.preventDefault) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1361">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1361">&#182;</a>
              </div>
              <p>Add preventDefault method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          args.preventDefault = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            args.isDefaultPrevented = returnTrue;
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-1362">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1362">&#182;</a>
              </div>
              <p>Add stopPropagation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          args.stopPropagation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            args.isPropagationStopped = returnTrue;
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-1363">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1363">&#182;</a>
              </div>
              <p>Add stopImmediatePropagation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          args.stopImmediatePropagation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            args.isImmediatePropagationStopped = returnTrue;
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-1364">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1364">&#182;</a>
              </div>
              <p>Add event delegation states</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          args.isDefaultPrevented = returnFalse;
          args.isPropagationStopped = returnFalse;
          args.isImmediatePropagationStopped = returnFalse;
        }

        <span class="hljs-keyword">if</span> (settings.beforeFire) {
          settings.beforeFire(args);
        }

        handlers = bindings[name];
        <span class="hljs-keyword">if</span> (handlers) {
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = handlers.length; i &lt; l; i++) {
            callback = handlers[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-1365">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1365">&#182;</a>
              </div>
              <p>Unbind handlers marked with once</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (callback.once) {
              off(name, callback.func);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1366">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1366">&#182;</a>
              </div>
              <p>Stop immediate propagation if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (args.isImmediatePropagationStopped()) {
              args.stopPropagation();
              <span class="hljs-keyword">return</span> args;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1367">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1367">&#182;</a>
              </div>
              <p>If callback returns false then prevent default and stop all propagation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (callback.func.call(scope, args) === <span class="hljs-literal">false</span>) {
              args.preventDefault();
              <span class="hljs-keyword">return</span> args;
            }
          }
        }

        <span class="hljs-keyword">return</span> args;
      }

      <span class="hljs-comment">/**
       * Binds an event listener to a specific event by name.
       *
       * @method on
       * @param {String} name Event name or space separated list of events to bind.
       * @param {callback} callback Callback to be executed when the event occurs.
       * @param {Boolean} first Optional flag if the event should be prepended. Use this with care.
       * @return {Object} Current class instance.
       * @example
       * instance.on('event', function(e) {
       *     // Callback logic
       * });
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">on</span>(<span class="hljs-params">name, callback, prepend, extra</span>) </span>{
        <span class="hljs-keyword">var</span> handlers, names, i;

        <span class="hljs-keyword">if</span> (callback === <span class="hljs-literal">false</span>) {
          callback = returnFalse;
        }

        <span class="hljs-keyword">if</span> (callback) {
          callback = {
            <span class="hljs-attr">func</span>: callback
          };

          <span class="hljs-keyword">if</span> (extra) {
            Tools.extend(callback, extra);
          }

          names = name.toLowerCase().split(<span class="hljs-string">' '</span>);
          i = names.length;
          <span class="hljs-keyword">while</span> (i--) {
            name = names[i];
            handlers = bindings[name];
            <span class="hljs-keyword">if</span> (!handlers) {
              handlers = bindings[name] = [];
              toggleEvent(name, <span class="hljs-literal">true</span>);
            }

            <span class="hljs-keyword">if</span> (prepend) {
              handlers.unshift(callback);
            } <span class="hljs-keyword">else</span> {
              handlers.push(callback);
            }
          }
        }

        <span class="hljs-keyword">return</span> self;
      }

      <span class="hljs-comment">/**
       * Unbinds an event listener to a specific event by name.
       *
       * @method off
       * @param {String?} name Name of the event to unbind.
       * @param {callback?} callback Callback to unbind.
       * @return {Object} Current class instance.
       * @example
       * // Unbind specific callback
       * instance.off('event', handler);
       *
       * // Unbind all listeners by name
       * instance.off('event');
       *
       * // Unbind all events
       * instance.off();
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">off</span>(<span class="hljs-params">name, callback</span>) </span>{
        <span class="hljs-keyword">var</span> i, handlers, bindingName, names, hi;

        <span class="hljs-keyword">if</span> (name) {
          names = name.toLowerCase().split(<span class="hljs-string">' '</span>);
          i = names.length;
          <span class="hljs-keyword">while</span> (i--) {
            name = names[i];
            handlers = bindings[name];</pre></div></div>
            
        </li>
        
        
        <li id="section-1368">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1368">&#182;</a>
              </div>
              <p>Unbind all handlers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!name) {
              <span class="hljs-keyword">for</span> (bindingName <span class="hljs-keyword">in</span> bindings) {
                toggleEvent(bindingName, <span class="hljs-literal">false</span>);
                <span class="hljs-keyword">delete</span> bindings[bindingName];
              }

              <span class="hljs-keyword">return</span> self;
            }

            <span class="hljs-keyword">if</span> (handlers) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1369">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1369">&#182;</a>
              </div>
              <p>Unbind all by name</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (!callback) {
                handlers.length = <span class="hljs-number">0</span>;
              } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1370">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1370">&#182;</a>
              </div>
              <p>Unbind specific ones</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                hi = handlers.length;
                <span class="hljs-keyword">while</span> (hi--) {
                  <span class="hljs-keyword">if</span> (handlers[hi].func === callback) {
                    handlers = handlers.slice(<span class="hljs-number">0</span>, hi).concat(handlers.slice(hi + <span class="hljs-number">1</span>));
                    bindings[name] = handlers;
                  }
                }
              }

              <span class="hljs-keyword">if</span> (!handlers.length) {
                toggleEvent(name, <span class="hljs-literal">false</span>);
                <span class="hljs-keyword">delete</span> bindings[name];
              }
            }
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> bindings) {
            toggleEvent(name, <span class="hljs-literal">false</span>);
          }

          bindings = {};
        }

        <span class="hljs-keyword">return</span> self;
      }

      <span class="hljs-comment">/**
       * Binds an event listener to a specific event by name
       * and automatically unbind the event once the callback fires.
       *
       * @method once
       * @param {String} name Event name or space separated list of events to bind.
       * @param {callback} callback Callback to be executed when the event occurs.
       * @param {Boolean} first Optional flag if the event should be prepended. Use this with care.
       * @return {Object} Current class instance.
       * @example
       * instance.once('event', function(e) {
       *     // Callback logic
       * });
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">once</span>(<span class="hljs-params">name, callback, prepend</span>) </span>{
        <span class="hljs-keyword">return</span> on(name, callback, prepend, { <span class="hljs-attr">once</span>: <span class="hljs-literal">true</span> });
      }

      <span class="hljs-comment">/**
       * Returns true/false if the dispatcher has a event of the specified name.
       *
       * @method has
       * @param {String} name Name of the event to check for.
       * @return {Boolean} true/false if the event exists or not.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">has</span>(<span class="hljs-params">name</span>) </span>{
        name = name.toLowerCase();
        <span class="hljs-keyword">return</span> !(!bindings[name] || bindings[name].length === <span class="hljs-number">0</span>);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1371">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1371">&#182;</a>
              </div>
              <p>Expose</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      self.fire = fire;
      self.on = on;
      self.off = off;
      self.once = once;
      self.has = has;
    }

    <span class="hljs-comment">/**
     * Returns true/false if the specified event name is a native browser event or not.
     *
     * @method isNative
     * @param {String} name Name to check if it's native.
     * @return {Boolean} true/false if the event is native or not.
     * @static
     */</span>
    Dispatcher.isNative = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
      <span class="hljs-keyword">return</span> !!nativeEvents[name.toLowerCase()];
    };

    <span class="hljs-keyword">return</span> Dispatcher;
  }
);

<span class="hljs-comment">/**
 * Observable.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This mixin will add event binding logic to classes.
 *
 * @mixin tinymce.util.Observable
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.Observable'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.EventDispatcher"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">EventDispatcher</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventDispatcher</span>(<span class="hljs-params">obj</span>) </span>{
      <span class="hljs-keyword">if</span> (!obj._eventDispatcher) {
        obj._eventDispatcher = <span class="hljs-keyword">new</span> EventDispatcher({
          <span class="hljs-attr">scope</span>: obj,
          <span class="hljs-attr">toggleEvent</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, state</span>) </span>{
            <span class="hljs-keyword">if</span> (EventDispatcher.isNative(name) &amp;&amp; obj.toggleNativeEvent) {
              obj.toggleNativeEvent(name, state);
            }
          }
        });
      }

      <span class="hljs-keyword">return</span> obj._eventDispatcher;
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">/**
       * Fires the specified event by name. Consult the
       * &lt;a href="/docs/advanced/events"&gt;event reference&lt;/a&gt; for more details on each event.
       *
       * @method fire
       * @param {String} name Name of the event to fire.
       * @param {Object?} args Event arguments.
       * @param {Boolean?} bubble True/false if the event is to be bubbled.
       * @return {Object} Event args instance passed in.
       * @example
       * instance.fire('event', {...});
       */</span>
      fire: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, args, bubble</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1372">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1372">&#182;</a>
              </div>
              <p>Prevent all events except the remove event after the instance has been removed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self.removed &amp;&amp; name !== <span class="hljs-string">"remove"</span>) {
          <span class="hljs-keyword">return</span> args;
        }

        args = getEventDispatcher(self).fire(name, args, bubble);</pre></div></div>
            
        </li>
        
        
        <li id="section-1373">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1373">&#182;</a>
              </div>
              <p>Bubble event up to parents</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (bubble !== <span class="hljs-literal">false</span> &amp;&amp; self.parent) {
          <span class="hljs-keyword">var</span> parent = self.parent();
          <span class="hljs-keyword">while</span> (parent &amp;&amp; !args.isPropagationStopped()) {
            parent.fire(name, args, <span class="hljs-literal">false</span>);
            parent = parent.parent();
          }
        }

        <span class="hljs-keyword">return</span> args;
      },

      <span class="hljs-comment">/**
       * Binds an event listener to a specific event by name. Consult the
       * &lt;a href="/docs/advanced/events"&gt;event reference&lt;/a&gt; for more details on each event.
       *
       * @method on
       * @param {String} name Event name or space separated list of events to bind.
       * @param {callback} callback Callback to be executed when the event occurs.
       * @param {Boolean} first Optional flag if the event should be prepended. Use this with care.
       * @return {Object} Current class instance.
       * @example
       * instance.on('event', function(e) {
       *     // Callback logic
       * });
       */</span>
      on: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, callback, prepend</span>) </span>{
        <span class="hljs-keyword">return</span> getEventDispatcher(<span class="hljs-keyword">this</span>).on(name, callback, prepend);
      },

      <span class="hljs-comment">/**
       * Unbinds an event listener to a specific event by name. Consult the
       * &lt;a href="/docs/advanced/events"&gt;event reference&lt;/a&gt; for more details on each event.
       *
       * @method off
       * @param {String?} name Name of the event to unbind.
       * @param {callback?} callback Callback to unbind.
       * @return {Object} Current class instance.
       * @example
       * // Unbind specific callback
       * instance.off('event', handler);
       *
       * // Unbind all listeners by name
       * instance.off('event');
       *
       * // Unbind all events
       * instance.off();
       */</span>
      off: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, callback</span>) </span>{
        <span class="hljs-keyword">return</span> getEventDispatcher(<span class="hljs-keyword">this</span>).off(name, callback);
      },

      <span class="hljs-comment">/**
       * Bind the event callback and once it fires the callback is removed. Consult the
       * &lt;a href="/docs/advanced/events"&gt;event reference&lt;/a&gt; for more details on each event.
       *
       * @method once
       * @param {String} name Name of the event to bind.
       * @param {callback} callback Callback to bind only once.
       * @return {Object} Current class instance.
       */</span>
      once: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, callback</span>) </span>{
        <span class="hljs-keyword">return</span> getEventDispatcher(<span class="hljs-keyword">this</span>).once(name, callback);
      },

      <span class="hljs-comment">/**
       * Returns true/false if the object has a event of the specified name.
       *
       * @method hasEventListeners
       * @param {String} name Name of the event to check for.
       * @return {Boolean} true/false if the event exists or not.
       */</span>
      hasEventListeners: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> getEventDispatcher(<span class="hljs-keyword">this</span>).has(name);
      }
    };
  }
);
<span class="hljs-comment">/**
 * Binding.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class gets dynamically extended to provide a binding between two models. This makes it possible to
 * sync the state of two properties in two models by a layer of abstraction.
 *
 * @private
 * @class tinymce.data.Binding
 */</span>
define(
  <span class="hljs-string">'tinymce.core.data.Binding'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">/**
     * Constructs a new bidning.
     *
     * @constructor
     * @method Binding
     * @param {Object} settings Settings to the binding.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Binding</span>(<span class="hljs-params">settings</span>) </span>{
      <span class="hljs-keyword">this</span>.create = settings.create;
    }

    <span class="hljs-comment">/**
     * Creates a binding for a property on a model.
     *
     * @method create
     * @param {tinymce.data.ObservableObject} model Model to create binding to.
     * @param {String} name Name of property to bind.
     * @return {tinymce.data.Binding} Binding instance.
     */</span>
    Binding.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">model, name</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Binding({
        <span class="hljs-attr">create</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">otherModel, otherName</span>) </span>{
          <span class="hljs-keyword">var</span> bindings;

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromSelfToOther</span>(<span class="hljs-params">e</span>) </span>{
            otherModel.set(otherName, e.value);
          }

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromOtherToSelf</span>(<span class="hljs-params">e</span>) </span>{
            model.set(name, e.value);
          }

          otherModel.on(<span class="hljs-string">'change:'</span> + otherName, fromOtherToSelf);
          model.on(<span class="hljs-string">'change:'</span> + name, fromSelfToOther);</pre></div></div>
            
        </li>
        
        
        <li id="section-1374">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1374">&#182;</a>
              </div>
              <p>Keep track of the bindings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          bindings = otherModel._bindings;

          <span class="hljs-keyword">if</span> (!bindings) {
            bindings = otherModel._bindings = [];

            otherModel.on(<span class="hljs-string">'destroy'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">var</span> i = bindings.length;

              <span class="hljs-keyword">while</span> (i--) {
                bindings[i]();
              }
            });
          }

          bindings.push(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            model.off(<span class="hljs-string">'change:'</span> + name, fromSelfToOther);
          });

          <span class="hljs-keyword">return</span> model.get(name);
        }
      });
    };

    <span class="hljs-keyword">return</span> Binding;
  }
);
<span class="hljs-comment">/**
 * ObservableObject.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class is a object that is observable when properties changes a change event gets emitted.
 *
 * @private
 * @class tinymce.data.ObservableObject
 */</span>
define(
  <span class="hljs-string">'tinymce.core.data.ObservableObject'</span>,
  [
    <span class="hljs-string">'tinymce.core.data.Binding'</span>,
    <span class="hljs-string">'tinymce.core.util.Class'</span>,
    <span class="hljs-string">'tinymce.core.util.Observable'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>
  ], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Binding, Class, Observable, Tools</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNode</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> node.nodeType &gt; <span class="hljs-number">0</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-1375">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1375">&#182;</a>
              </div>
              <p>Todo: Maybe this should be shallow compare since it might be huge object references</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEqual</span>(<span class="hljs-params">a, b</span>) </span>{
      <span class="hljs-keyword">var</span> k, checked;</pre></div></div>
            
        </li>
        
        
        <li id="section-1376">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1376">&#182;</a>
              </div>
              <p>Strict equals</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (a === b) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1377">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1377">&#182;</a>
              </div>
              <p>Compare null</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (a === <span class="hljs-literal">null</span> || b === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> a === b;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1378">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1378">&#182;</a>
              </div>
              <p>Compare number, boolean, string, undefined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">"object"</span> || <span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">"object"</span>) {
        <span class="hljs-keyword">return</span> a === b;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1379">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1379">&#182;</a>
              </div>
              <p>Compare arrays</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (Tools.isArray(b)) {
        <span class="hljs-keyword">if</span> (a.length !== b.length) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        k = a.length;
        <span class="hljs-keyword">while</span> (k--) {
          <span class="hljs-keyword">if</span> (!isEqual(a[k], b[k])) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1380">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1380">&#182;</a>
              </div>
              <p>Shallow compare nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (isNode(a) || isNode(b)) {
        <span class="hljs-keyword">return</span> a === b;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1381">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1381">&#182;</a>
              </div>
              <p>Compare objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      checked = {};
      <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> b) {
        <span class="hljs-keyword">if</span> (!isEqual(a[k], b[k])) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        checked[k] = <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> a) {
        <span class="hljs-keyword">if</span> (!checked[k] &amp;&amp; !isEqual(a[k], b[k])) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">return</span> Class.extend({
      <span class="hljs-attr">Mixins</span>: [Observable],

      <span class="hljs-comment">/**
       * Constructs a new observable object instance.
       *
       * @constructor
       * @param {Object} data Initial data for the object.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
        <span class="hljs-keyword">var</span> name, value;

        data = data || {};

        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> data) {
          value = data[name];

          <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Binding) {
            data[name] = value.create(<span class="hljs-keyword">this</span>, name);
          }
        }

        <span class="hljs-keyword">this</span>.data = data;
      },

      <span class="hljs-comment">/**
       * Sets a property on the value this will call
       * observers if the value is a change from the current value.
       *
       * @method set
       * @param {String/object} name Name of the property to set or a object of items to set.
       * @param {Object} value Value to set for the property.
       * @return {tinymce.data.ObservableObject} Observable object instance.
       */</span>
      set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
        <span class="hljs-keyword">var</span> key, args, oldValue = <span class="hljs-keyword">this</span>.data[name];

        <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Binding) {
          value = value.create(<span class="hljs-keyword">this</span>, name);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">"object"</span>) {
          <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> name) {
            <span class="hljs-keyword">this</span>.set(key, name[key]);
          }

          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        }

        <span class="hljs-keyword">if</span> (!isEqual(oldValue, value)) {
          <span class="hljs-keyword">this</span>.data[name] = value;

          args = {
            <span class="hljs-attr">target</span>: <span class="hljs-keyword">this</span>,
            <span class="hljs-attr">name</span>: name,
            <span class="hljs-attr">value</span>: value,
            <span class="hljs-attr">oldValue</span>: oldValue
          };

          <span class="hljs-keyword">this</span>.fire(<span class="hljs-string">'change:'</span> + name, args);
          <span class="hljs-keyword">this</span>.fire(<span class="hljs-string">'change'</span>, args);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Gets a property by name.
       *
       * @method get
       * @param {String} name Name of the property to get.
       * @return {Object} Object value of propery.
       */</span>
      get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.data[name];
      },

      <span class="hljs-comment">/**
       * Returns true/false if the specified property exists.
       *
       * @method has
       * @param {String} name Name of the property to check for.
       * @return {Boolean} true/false if the item exists.
       */</span>
      has: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> name <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.data;
      },

      <span class="hljs-comment">/**
       * Returns a dynamic property binding for the specified property name. This makes
       * it possible to sync the state of two properties in two ObservableObject instances.
       *
       * @method bind
       * @param {String} name Name of the property to sync with the property it's inserted to.
       * @return {tinymce.data.Binding} Data binding instance.
       */</span>
      bind: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> Binding.create(<span class="hljs-keyword">this</span>, name);
      },

      <span class="hljs-comment">/**
       * Destroys the observable object and fires the "destroy"
       * event and clean up any internal resources.
       *
       * @method destroy
       */</span>
      destroy: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.fire(<span class="hljs-string">'destroy'</span>);
      }
    });
  }
);
<span class="hljs-comment">/**
 * Selector.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/*eslint no-nested-ternary:0 */</span>

<span class="hljs-comment">/**
 * Selector engine, enables you to select controls by using CSS like expressions.
 * We currently only support basic CSS expressions to reduce the size of the core
 * and the ones we support should be enough for most cases.
 *
 * @example
 * Supported expressions:
 *  element
 *  element#name
 *  element.class
 *  element[attr]
 *  element[attr*=value]
 *  element[attr~=value]
 *  element[attr!=value]
 *  element[attr^=value]
 *  element[attr$=value]
 *  element:&lt;state&gt;
 *  element:not(&lt;expression&gt;)
 *  element:first
 *  element:last
 *  element:odd
 *  element:even
 *  element element
 *  element &gt; element
 *
 * @class tinymce.ui.Selector
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Selector'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Class"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Class</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-comment">/**
     * Produces an array with a unique set of objects. It will not compare the values
     * but the references of the objects.
     *
     * @private
     * @method unqiue
     * @param {Array} array Array to make into an array with unique items.
     * @return {Array} Array with unique items.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">array</span>) </span>{
      <span class="hljs-keyword">var</span> uniqueItems = [], i = array.length, item;

      <span class="hljs-keyword">while</span> (i--) {
        item = array[i];

        <span class="hljs-keyword">if</span> (!item.__checked) {
          uniqueItems.push(item);
          item.__checked = <span class="hljs-number">1</span>;
        }
      }

      i = uniqueItems.length;
      <span class="hljs-keyword">while</span> (i--) {
        <span class="hljs-keyword">delete</span> uniqueItems[i].__checked;
      }

      <span class="hljs-keyword">return</span> uniqueItems;
    }

    <span class="hljs-keyword">var</span> expression = <span class="hljs-regexp">/^([\w\\*]+)?(?:#([\w\-\\]+))?(?:\.([\w\\\.]+))?(?:\[\@?([\w\\]+)([\^\$\*!~]?=)([\w\\]+)\])?(?:\:(.+))?/i</span>;

    <span class="hljs-comment">/*jshint maxlen:255 */</span>
    <span class="hljs-comment">/*eslint max-len:0 */</span>
    <span class="hljs-keyword">var</span> chunker = <span class="hljs-regexp">/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ &gt;+~,(\[\\]+)+|[&gt;+~])(\s*,\s*)?((?:.|\r|\n)*)/g</span>,
      whiteSpace = <span class="hljs-regexp">/^\s*|\s*$/g</span>,
      Collection;

    <span class="hljs-keyword">var</span> Selector = Class.extend({
      <span class="hljs-comment">/**
       * Constructs a new Selector instance.
       *
       * @constructor
       * @method init
       * @param {String} selector CSS like selector expression.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
        <span class="hljs-keyword">var</span> match = <span class="hljs-keyword">this</span>.match;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileNameFilter</span>(<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">if</span> (name) {
            name = name.toLowerCase();

            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
              <span class="hljs-keyword">return</span> name === <span class="hljs-string">'*'</span> || item.type === name;
            };
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileIdFilter</span>(<span class="hljs-params">id</span>) </span>{
          <span class="hljs-keyword">if</span> (id) {
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
              <span class="hljs-keyword">return</span> item._name === id;
            };
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileClassesFilter</span>(<span class="hljs-params">classes</span>) </span>{
          <span class="hljs-keyword">if</span> (classes) {
            classes = classes.split(<span class="hljs-string">'.'</span>);

            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
              <span class="hljs-keyword">var</span> i = classes.length;

              <span class="hljs-keyword">while</span> (i--) {
                <span class="hljs-keyword">if</span> (!item.classes.contains(classes[i])) {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
              }

              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            };
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileAttrFilter</span>(<span class="hljs-params">name, cmp, check</span>) </span>{
          <span class="hljs-keyword">if</span> (name) {
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
              <span class="hljs-keyword">var</span> value = item[name] ? item[name]() : <span class="hljs-string">''</span>;

              <span class="hljs-keyword">return</span> !cmp ? !!check :
                cmp === <span class="hljs-string">"="</span> ? value === check :
                  cmp === <span class="hljs-string">"*="</span> ? value.indexOf(check) &gt;= <span class="hljs-number">0</span> :
                    cmp === <span class="hljs-string">"~="</span> ? (<span class="hljs-string">" "</span> + value + <span class="hljs-string">" "</span>).indexOf(<span class="hljs-string">" "</span> + check + <span class="hljs-string">" "</span>) &gt;= <span class="hljs-number">0</span> :
                      cmp === <span class="hljs-string">"!="</span> ? value != check :
                        cmp === <span class="hljs-string">"^="</span> ? value.indexOf(check) === <span class="hljs-number">0</span> :
                          cmp === <span class="hljs-string">"$="</span> ? value.substr(value.length - check.length) === check :
                            <span class="hljs-literal">false</span>;
            };
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compilePsuedoFilter</span>(<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">var</span> notSelectors;

          <span class="hljs-keyword">if</span> (name) {
            name = <span class="hljs-regexp">/(?:not\((.+)\))|(.+)/i</span>.exec(name);

            <span class="hljs-keyword">if</span> (!name[<span class="hljs-number">1</span>]) {
              name = name[<span class="hljs-number">2</span>];

              <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, length</span>) </span>{
                <span class="hljs-keyword">return</span> name === <span class="hljs-string">'first'</span> ? index === <span class="hljs-number">0</span> :
                  name === <span class="hljs-string">'last'</span> ? index === length - <span class="hljs-number">1</span> :
                    name === <span class="hljs-string">'even'</span> ? index % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> :
                      name === <span class="hljs-string">'odd'</span> ? index % <span class="hljs-number">2</span> === <span class="hljs-number">1</span> :
                        item[name] ? item[name]() :
                          <span class="hljs-literal">false</span>;
              };
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1382">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1382">&#182;</a>
              </div>
              <p>Compile not expression</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            notSelectors = parseChunks(name[<span class="hljs-number">1</span>], []);

            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
              <span class="hljs-keyword">return</span> !match(item, notSelectors);
            };
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compile</span>(<span class="hljs-params">selector, filters, direct</span>) </span>{
          <span class="hljs-keyword">var</span> parts;

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">filter</span>) </span>{
            <span class="hljs-keyword">if</span> (filter) {
              filters.push(filter);
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1383">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1383">&#182;</a>
              </div>
              <p>Parse expression into parts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          parts = expression.exec(selector.replace(whiteSpace, <span class="hljs-string">''</span>));

          add(compileNameFilter(parts[<span class="hljs-number">1</span>]));
          add(compileIdFilter(parts[<span class="hljs-number">2</span>]));
          add(compileClassesFilter(parts[<span class="hljs-number">3</span>]));
          add(compileAttrFilter(parts[<span class="hljs-number">4</span>], parts[<span class="hljs-number">5</span>], parts[<span class="hljs-number">6</span>]));
          add(compilePsuedoFilter(parts[<span class="hljs-number">7</span>]));</pre></div></div>
            
        </li>
        
        
        <li id="section-1384">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1384">&#182;</a>
              </div>
              <p>Mark the filter with pseudo for performance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          filters.pseudo = !!parts[<span class="hljs-number">7</span>];
          filters.direct = direct;

          <span class="hljs-keyword">return</span> filters;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1385">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1385">&#182;</a>
              </div>
              <p>Parser logic based on Sizzle by John Resig</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseChunks</span>(<span class="hljs-params">selector, selectors</span>) </span>{
          <span class="hljs-keyword">var</span> parts = [], extra, matches, i;

          <span class="hljs-keyword">do</span> {
            chunker.exec(<span class="hljs-string">""</span>);
            matches = chunker.exec(selector);

            <span class="hljs-keyword">if</span> (matches) {
              selector = matches[<span class="hljs-number">3</span>];
              parts.push(matches[<span class="hljs-number">1</span>]);

              <span class="hljs-keyword">if</span> (matches[<span class="hljs-number">2</span>]) {
                extra = matches[<span class="hljs-number">3</span>];
                <span class="hljs-keyword">break</span>;
              }
            }
          } <span class="hljs-keyword">while</span> (matches);

          <span class="hljs-keyword">if</span> (extra) {
            parseChunks(extra, selectors);
          }

          selector = [];
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; parts.length; i++) {
            <span class="hljs-keyword">if</span> (parts[i] != <span class="hljs-string">'&gt;'</span>) {
              selector.push(compile(parts[i], [], parts[i - <span class="hljs-number">1</span>] === <span class="hljs-string">'&gt;'</span>));
            }
          }

          selectors.push(selector);

          <span class="hljs-keyword">return</span> selectors;
        }

        <span class="hljs-keyword">this</span>._selectors = parseChunks(selector, []);
      },

      <span class="hljs-comment">/**
       * Returns true/false if the selector matches the specified control.
       *
       * @method match
       * @param {tinymce.ui.Control} control Control to match against the selector.
       * @param {Array} selectors Optional array of selectors, mostly used internally.
       * @return {Boolean} true/false state if the control matches or not.
       */</span>
      match: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">control, selectors</span>) </span>{
        <span class="hljs-keyword">var</span> i, l, si, sl, selector, fi, fl, filters, index, length, siblings, count, item;

        selectors = selectors || <span class="hljs-keyword">this</span>._selectors;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = selectors.length; i &lt; l; i++) {
          selector = selectors[i];
          sl = selector.length;
          item = control;
          count = <span class="hljs-number">0</span>;

          <span class="hljs-keyword">for</span> (si = sl - <span class="hljs-number">1</span>; si &gt;= <span class="hljs-number">0</span>; si--) {
            filters = selector[si];

            <span class="hljs-keyword">while</span> (item) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1386">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1386">&#182;</a>
              </div>
              <p>Find the index and length since a pseudo filter like :first needs it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (filters.pseudo) {
                siblings = item.parent().items();
                index = length = siblings.length;
                <span class="hljs-keyword">while</span> (index--) {
                  <span class="hljs-keyword">if</span> (siblings[index] === item) {
                    <span class="hljs-keyword">break</span>;
                  }
                }
              }

              <span class="hljs-keyword">for</span> (fi = <span class="hljs-number">0</span>, fl = filters.length; fi &lt; fl; fi++) {
                <span class="hljs-keyword">if</span> (!filters[fi](item, index, length)) {
                  fi = fl + <span class="hljs-number">1</span>;
                  <span class="hljs-keyword">break</span>;
                }
              }

              <span class="hljs-keyword">if</span> (fi === fl) {
                count++;
                <span class="hljs-keyword">break</span>;
              } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1387">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1387">&#182;</a>
              </div>
              <p>If it didnt match the right most expression then
break since its no point looking at the parents</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (si === sl - <span class="hljs-number">1</span>) {
                  <span class="hljs-keyword">break</span>;
                }
              }

              item = item.parent();
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1388">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1388">&#182;</a>
              </div>
              <p>If we found all selectors then return true otherwise continue looking</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (count === sl) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      },

      <span class="hljs-comment">/**
       * Returns a tinymce.ui.Collection with matches of the specified selector inside the specified container.
       *
       * @method find
       * @param {tinymce.ui.Control} container Container to look for items in.
       * @return {tinymce.ui.Collection} Collection with matched elements.
       */</span>
      find: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">container</span>) </span>{
        <span class="hljs-keyword">var</span> matches = [], i, l, selectors = <span class="hljs-keyword">this</span>._selectors;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collect</span>(<span class="hljs-params">items, selector, index</span>) </span>{
          <span class="hljs-keyword">var</span> i, l, fi, fl, item, filters = selector[index];

          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = items.length; i &lt; l; i++) {
            item = items[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-1389">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1389">&#182;</a>
              </div>
              <p>Run each filter against the item</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">for</span> (fi = <span class="hljs-number">0</span>, fl = filters.length; fi &lt; fl; fi++) {
              <span class="hljs-keyword">if</span> (!filters[fi](item, i, l)) {
                fi = fl + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">break</span>;
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1390">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1390">&#182;</a>
              </div>
              <p>All filters matched the item</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (fi === fl) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1391">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1391">&#182;</a>
              </div>
              <p>Matched item is on the last expression like: panel toolbar [button]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (index == selector.length - <span class="hljs-number">1</span>) {
                matches.push(item);
              } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1392">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1392">&#182;</a>
              </div>
              <p>Collect next expression type</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (item.items) {
                  collect(item.items(), selector, index + <span class="hljs-number">1</span>);
                }
              }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (filters.direct) {
              <span class="hljs-keyword">return</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1393">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1393">&#182;</a>
              </div>
              <p>Collect child items</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (item.items) {
              collect(item.items(), selector, index);
            }
          }
        }

        <span class="hljs-keyword">if</span> (container.items) {
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = selectors.length; i &lt; l; i++) {
            collect(container.items(), selectors[i], <span class="hljs-number">0</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1394">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1394">&#182;</a>
              </div>
              <p>Unique the matches if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (l &gt; <span class="hljs-number">1</span>) {
            matches = unique(matches);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1395">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1395">&#182;</a>
              </div>
              <p>Fix for circular reference</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!Collection) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1396">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1396">&#182;</a>
              </div>
              <p>TODO: Fix me!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          Collection = Selector.Collection;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Collection(matches);
      }
    });

    <span class="hljs-keyword">return</span> Selector;
  }
);

<span class="hljs-comment">/**
 * Collection.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Control collection, this class contains control instances and it enables you to
 * perform actions on all the contained items. This is very similar to how jQuery works.
 *
 * @example
 * someCollection.show().disabled(true);
 *
 * @class tinymce.ui.Collection
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Collection'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.ui.Selector"</span>,
    <span class="hljs-string">"tinymce.core.util.Class"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Tools, Selector, Class</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> Collection, proto, push = <span class="hljs-built_in">Array</span>.prototype.push, slice = <span class="hljs-built_in">Array</span>.prototype.slice;

    proto = {
      <span class="hljs-comment">/**
       * Current number of contained control instances.
       *
       * @field length
       * @type Number
       */</span>
      length: <span class="hljs-number">0</span>,

      <span class="hljs-comment">/**
       * Constructor for the collection.
       *
       * @constructor
       * @method init
       * @param {Array} items Optional array with items to add.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>{
        <span class="hljs-keyword">if</span> (items) {
          <span class="hljs-keyword">this</span>.add(items);
        }
      },

      <span class="hljs-comment">/**
       * Adds new items to the control collection.
       *
       * @method add
       * @param {Array} items Array if items to add to collection.
       * @return {tinymce.ui.Collection} Current collection instance.
       */</span>
      add: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1397">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1397">&#182;</a>
              </div>
              <p>Force single item into array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!Tools.isArray(items)) {
          <span class="hljs-keyword">if</span> (items <span class="hljs-keyword">instanceof</span> Collection) {
            self.add(items.toArray());
          } <span class="hljs-keyword">else</span> {
            push.call(self, items);
          }
        } <span class="hljs-keyword">else</span> {
          push.apply(self, items);
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Sets the contents of the collection. This will remove any existing items
       * and replace them with the ones specified in the input array.
       *
       * @method set
       * @param {Array} items Array with items to set into the Collection.
       * @return {tinymce.ui.Collection} Collection instance.
       */</span>
      set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, len = self.length, i;

        self.length = <span class="hljs-number">0</span>;
        self.add(items);</pre></div></div>
            
        </li>
        
        
        <li id="section-1398">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1398">&#182;</a>
              </div>
              <p>Remove old entries</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (i = self.length; i &lt; len; i++) {
          <span class="hljs-keyword">delete</span> self[i];
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Filters the collection item based on the specified selector expression or selector function.
       *
       * @method filter
       * @param {String} selector Selector expression to filter items by.
       * @return {tinymce.ui.Collection} Collection containing the filtered items.
       */</span>
      filter: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, i, l, matches = [], item, match;</pre></div></div>
            
        </li>
        
        
        <li id="section-1399">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1399">&#182;</a>
              </div>
              <p>Compile string into selector expression</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> selector === <span class="hljs-string">"string"</span>) {
          selector = <span class="hljs-keyword">new</span> Selector(selector);

          match = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
            <span class="hljs-keyword">return</span> selector.match(item);
          };
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1400">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1400">&#182;</a>
              </div>
              <p>Use selector as matching function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          match = selector;
        }

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = self.length; i &lt; l; i++) {
          item = self[i];

          <span class="hljs-keyword">if</span> (match(item)) {
            matches.push(item);
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Collection(matches);
      },

      <span class="hljs-comment">/**
       * Slices the items within the collection.
       *
       * @method slice
       * @param {Number} index Index to slice at.
       * @param {Number} len Optional length to slice.
       * @return {tinymce.ui.Collection} Current collection.
       */</span>
      slice: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Collection(slice.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>));
      },

      <span class="hljs-comment">/**
       * Makes the current collection equal to the specified index.
       *
       * @method eq
       * @param {Number} index Index of the item to set the collection to.
       * @return {tinymce.ui.Collection} Current collection.
       */</span>
      eq: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>{
        <span class="hljs-keyword">return</span> index === <span class="hljs-number">-1</span> ? <span class="hljs-keyword">this</span>.slice(index) : <span class="hljs-keyword">this</span>.slice(index, +index + <span class="hljs-number">1</span>);
      },

      <span class="hljs-comment">/**
       * Executes the specified callback on each item in collection.
       *
       * @method each
       * @param {function} callback Callback to execute for each item in collection.
       * @return {tinymce.ui.Collection} Current collection instance.
       */</span>
      each: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
        Tools.each(<span class="hljs-keyword">this</span>, callback);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Returns an JavaScript array object of the contents inside the collection.
       *
       * @method toArray
       * @return {Array} Array with all items from collection.
       */</span>
      toArray: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> Tools.toArray(<span class="hljs-keyword">this</span>);
      },

      <span class="hljs-comment">/**
       * Finds the index of the specified control or return -1 if it isn't in the collection.
       *
       * @method indexOf
       * @param {Control} ctrl Control instance to look for.
       * @return {Number} Index of the specified control or -1.
       */</span>
      indexOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, i = self.length;

        <span class="hljs-keyword">while</span> (i--) {
          <span class="hljs-keyword">if</span> (self[i] === ctrl) {
            <span class="hljs-keyword">break</span>;
          }
        }

        <span class="hljs-keyword">return</span> i;
      },

      <span class="hljs-comment">/**
       * Returns a new collection of the contents in reverse order.
       *
       * @method reverse
       * @return {tinymce.ui.Collection} Collection instance with reversed items.
       */</span>
      reverse: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Collection(Tools.toArray(<span class="hljs-keyword">this</span>).reverse());
      },

      <span class="hljs-comment">/**
       * Returns true/false if the class exists or not.
       *
       * @method hasClass
       * @param {String} cls Class to check for.
       * @return {Boolean} true/false state if the class exists or not.
       */</span>
      hasClass: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cls</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>] ? <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>].classes.contains(cls) : <span class="hljs-literal">false</span>;
      },

      <span class="hljs-comment">/**
       * Sets/gets the specific property on the items in the collection. The same as executing control.&lt;property&gt;(&lt;value&gt;);
       *
       * @method prop
       * @param {String} name Property name to get/set.
       * @param {Object} value Optional object value to set.
       * @return {tinymce.ui.Collection} Current collection instance or value of the first item on a get operation.
       */</span>
      prop: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, undef, item;

        <span class="hljs-keyword">if</span> (value !== undef) {
          self.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
            <span class="hljs-keyword">if</span> (item[name]) {
              item[name](value);
            }
          });

          <span class="hljs-keyword">return</span> self;
        }

        item = self[<span class="hljs-number">0</span>];

        <span class="hljs-keyword">if</span> (item &amp;&amp; item[name]) {
          <span class="hljs-keyword">return</span> item[name]();
        }
      },

      <span class="hljs-comment">/**
       * Executes the specific function name with optional arguments an all items in collection if it exists.
       *
       * @example collection.exec("myMethod", arg1, arg2, arg3);
       * @method exec
       * @param {String} name Name of the function to execute.
       * @param {Object} ... Multiple arguments to pass to each function.
       * @return {tinymce.ui.Collection} Current collection.
       */</span>
      exec: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, args = Tools.toArray(<span class="hljs-built_in">arguments</span>).slice(<span class="hljs-number">1</span>);

        self.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          <span class="hljs-keyword">if</span> (item[name]) {
            item[name].apply(item, args);
          }
        });

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Remove all items from collection and DOM.
       *
       * @method remove
       * @return {tinymce.ui.Collection} Current collection.
       */</span>
      remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> i = <span class="hljs-keyword">this</span>.length;

        <span class="hljs-keyword">while</span> (i--) {
          <span class="hljs-keyword">this</span>[i].remove();
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Adds a class to all items in the collection.
       *
       * @method addClass
       * @param {String} cls Class to add to each item.
       * @return {tinymce.ui.Collection} Current collection instance.
       */</span>
      addClass: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cls</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          item.classes.add(cls);
        });
      },

      <span class="hljs-comment">/**
       * Removes the specified class from all items in collection.
       *
       * @method removeClass
       * @param {String} cls Class to remove from each item.
       * @return {tinymce.ui.Collection} Current collection instance.
       */</span>
      removeClass: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cls</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          item.classes.remove(cls);
        });
      }

      <span class="hljs-comment">/**
       * Fires the specified event by name and arguments on the control. This will execute all
       * bound event handlers.
       *
       * @method fire
       * @param {String} name Name of the event to fire.
       * @param {Object} args Optional arguments to pass to the event.
       * @return {tinymce.ui.Collection} Current collection instance.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1401">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1401">&#182;</a>
              </div>
              <p>fire: function(event, args) {},  Generated by code below</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Binds a callback to the specified event. This event can both be
       * native browser events like "click" or custom ones like PostRender.
       *
       * The callback function will have two parameters the first one being the control that received the event
       * the second one will be the event object either the browsers native event object or a custom JS object.
       *
       * @method on
       * @param {String} name Name of the event to bind. For example "click".
       * @param {String/function} callback Callback function to execute ones the event occurs.
       * @return {tinymce.ui.Collection} Current collection instance.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1402">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1402">&#182;</a>
              </div>
              <p>on: function(name, callback) {},  Generated by code below</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Unbinds the specified event and optionally a specific callback. If you omit the name
       * parameter all event handlers will be removed. If you omit the callback all event handles
       * by the specified name will be removed.
       *
       * @method off
       * @param {String} name Optional name for the event to unbind.
       * @param {function} callback Optional callback function to unbind.
       * @return {tinymce.ui.Collection} Current collection instance.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1403">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1403">&#182;</a>
              </div>
              <p>off: function(name, callback) {},  Generated by code below</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Shows the items in the current collection.
       *
       * @method show
       * @return {tinymce.ui.Collection} Current collection instance.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1404">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1404">&#182;</a>
              </div>
              <p>show: function() {},  Generated by code below</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Hides the items in the current collection.
       *
       * @method hide
       * @return {tinymce.ui.Collection} Current collection instance.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1405">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1405">&#182;</a>
              </div>
              <p>hide: function() {},  Generated by code below</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Sets/gets the text contents of the items in the current collection.
       *
       * @method text
       * @return {tinymce.ui.Collection} Current collection instance or text value of the first item on a get operation.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1406">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1406">&#182;</a>
              </div>
              <p>text: function(value) {},  Generated by code below</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Sets/gets the name contents of the items in the current collection.
       *
       * @method name
       * @return {tinymce.ui.Collection} Current collection instance or name value of the first item on a get operation.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1407">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1407">&#182;</a>
              </div>
              <p>name: function(value) {},  Generated by code below</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Sets/gets the disabled state on the items in the current collection.
       *
       * @method disabled
       * @return {tinymce.ui.Collection} Current collection instance or disabled state of the first item on a get operation.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1408">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1408">&#182;</a>
              </div>
              <p>disabled: function(state) {},  Generated by code below</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Sets/gets the active state on the items in the current collection.
       *
       * @method active
       * @return {tinymce.ui.Collection} Current collection instance or active state of the first item on a get operation.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1409">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1409">&#182;</a>
              </div>
              <p>active: function(state) {},  Generated by code below</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Sets/gets the selected state on the items in the current collection.
       *
       * @method selected
       * @return {tinymce.ui.Collection} Current collection instance or selected state of the first item on a get operation.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1410">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1410">&#182;</a>
              </div>
              <p>selected: function(state) {},  Generated by code below</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Sets/gets the selected state on the items in the current collection.
       *
       * @method visible
       * @return {tinymce.ui.Collection} Current collection instance or visible state of the first item on a get operation.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1411">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1411">&#182;</a>
              </div>
              <p>visible: function(state) {},  Generated by code below</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    };</pre></div></div>
            
        </li>
        
        
        <li id="section-1412">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1412">&#182;</a>
              </div>
              <p>Extend tinymce.ui.Collection prototype with some generated control specific methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tools.each(<span class="hljs-string">'fire on off show hide append prepend before after reflow'</span>.split(<span class="hljs-string">' '</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
      proto[name] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> args = Tools.toArray(<span class="hljs-built_in">arguments</span>);

        <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
          <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> ctrl) {
            ctrl[name].apply(ctrl, args);
          }
        });

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      };
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-1413">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1413">&#182;</a>
              </div>
              <p>Extend tinymce.ui.Collection prototype with some property methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tools.each(<span class="hljs-string">'text name disabled active selected checked visible parent value data'</span>.split(<span class="hljs-string">' '</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
      proto[name] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.prop(name, value);
      };
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-1414">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1414">&#182;</a>
              </div>
              <p>Create class based on the new prototype</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Collection = Class.extend(proto);</pre></div></div>
            
        </li>
        
        
        <li id="section-1415">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1415">&#182;</a>
              </div>
              <p>Stick Collection into Selector to prevent circual references</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Selector.Collection = Collection;

    <span class="hljs-keyword">return</span> Collection;
  }
);
<span class="hljs-comment">/**
 * DomUtils.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Private UI DomUtils proxy.
 *
 * @private
 * @class tinymce.ui.DomUtils
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.DomUtils'</span>,
  [
    <span class="hljs-string">"tinymce.core.Env"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.dom.DOMUtils"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Env, Tools, DOMUtils</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">var</span> funcs = {
      <span class="hljs-attr">id</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'mceu_'</span> + (count++);
      },

      <span class="hljs-attr">create</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, attrs, children</span>) </span>{
        <span class="hljs-keyword">var</span> elm = <span class="hljs-built_in">document</span>.createElement(name);

        DOMUtils.DOM.setAttribs(elm, attrs);

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> children === <span class="hljs-string">'string'</span>) {
          elm.innerHTML = children;
        } <span class="hljs-keyword">else</span> {
          Tools.each(children, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) </span>{
            <span class="hljs-keyword">if</span> (child.nodeType) {
              elm.appendChild(child);
            }
          });
        }

        <span class="hljs-keyword">return</span> elm;
      },

      <span class="hljs-attr">createFragment</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">html</span>) </span>{
        <span class="hljs-keyword">return</span> DOMUtils.DOM.createFragment(html);
      },

      <span class="hljs-attr">getWindowSize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> DOMUtils.DOM.getViewPort();
      },

      <span class="hljs-attr">getSize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">var</span> width, height;

        <span class="hljs-keyword">if</span> (elm.getBoundingClientRect) {
          <span class="hljs-keyword">var</span> rect = elm.getBoundingClientRect();

          width = <span class="hljs-built_in">Math</span>.max(rect.width || (rect.right - rect.left), elm.offsetWidth);
          height = <span class="hljs-built_in">Math</span>.max(rect.height || (rect.bottom - rect.bottom), elm.offsetHeight);
        } <span class="hljs-keyword">else</span> {
          width = elm.offsetWidth;
          height = elm.offsetHeight;
        }

        <span class="hljs-keyword">return</span> { <span class="hljs-attr">width</span>: width, <span class="hljs-attr">height</span>: height };
      },

      <span class="hljs-attr">getPos</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, root</span>) </span>{
        <span class="hljs-keyword">return</span> DOMUtils.DOM.getPos(elm, root || funcs.getContainer());
      },

      <span class="hljs-attr">getContainer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> Env.container ? Env.container : <span class="hljs-built_in">document</span>.body;
      },

      <span class="hljs-attr">getViewPort</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">win</span>) </span>{
        <span class="hljs-keyword">return</span> DOMUtils.DOM.getViewPort(win);
      },

      <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.getElementById(id);
      },

      <span class="hljs-attr">addClass</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, cls</span>) </span>{
        <span class="hljs-keyword">return</span> DOMUtils.DOM.addClass(elm, cls);
      },

      <span class="hljs-attr">removeClass</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, cls</span>) </span>{
        <span class="hljs-keyword">return</span> DOMUtils.DOM.removeClass(elm, cls);
      },

      <span class="hljs-attr">hasClass</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, cls</span>) </span>{
        <span class="hljs-keyword">return</span> DOMUtils.DOM.hasClass(elm, cls);
      },

      <span class="hljs-attr">toggleClass</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, cls, state</span>) </span>{
        <span class="hljs-keyword">return</span> DOMUtils.DOM.toggleClass(elm, cls, state);
      },

      <span class="hljs-attr">css</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, name, value</span>) </span>{
        <span class="hljs-keyword">return</span> DOMUtils.DOM.setStyle(elm, name, value);
      },

      <span class="hljs-attr">getRuntimeStyle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, name</span>) </span>{
        <span class="hljs-keyword">return</span> DOMUtils.DOM.getStyle(elm, name, <span class="hljs-literal">true</span>);
      },

      <span class="hljs-attr">on</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, name, callback, scope</span>) </span>{
        <span class="hljs-keyword">return</span> DOMUtils.DOM.bind(target, name, callback, scope);
      },

      <span class="hljs-attr">off</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, name, callback</span>) </span>{
        <span class="hljs-keyword">return</span> DOMUtils.DOM.unbind(target, name, callback);
      },

      <span class="hljs-attr">fire</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, name, args</span>) </span>{
        <span class="hljs-keyword">return</span> DOMUtils.DOM.fire(target, name, args);
      },

      <span class="hljs-attr">innerHtml</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, html</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1416">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1416">&#182;</a>
              </div>
              <p>Workaround for <div> in <p> bug on IE 8 #6178</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        DOMUtils.DOM.setHTML(elm, html);
      }
    };

    <span class="hljs-keyword">return</span> funcs;
  }
);
<span class="hljs-comment">/**
 * BoxUtils.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Utility class for box parsing and measuring.
 *
 * @private
 * @class tinymce.ui.BoxUtils
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.BoxUtils'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">/**
       * Parses the specified box value. A box value contains 1-4 properties in clockwise order.
       *
       * @method parseBox
       * @param {String/Number} value Box value "0 1 2 3" or "0" etc.
       * @return {Object} Object with top/right/bottom/left properties.
       * @private
       */</span>
      parseBox: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">var</span> len, radix = <span class="hljs-number">10</span>;

        <span class="hljs-keyword">if</span> (!value) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"number"</span>) {
          value = value || <span class="hljs-number">0</span>;

          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">top</span>: value,
            <span class="hljs-attr">left</span>: value,
            <span class="hljs-attr">bottom</span>: value,
            <span class="hljs-attr">right</span>: value
          };
        }

        value = value.split(<span class="hljs-string">' '</span>);
        len = value.length;

        <span class="hljs-keyword">if</span> (len === <span class="hljs-number">1</span>) {
          value[<span class="hljs-number">1</span>] = value[<span class="hljs-number">2</span>] = value[<span class="hljs-number">3</span>] = value[<span class="hljs-number">0</span>];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len === <span class="hljs-number">2</span>) {
          value[<span class="hljs-number">2</span>] = value[<span class="hljs-number">0</span>];
          value[<span class="hljs-number">3</span>] = value[<span class="hljs-number">1</span>];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len === <span class="hljs-number">3</span>) {
          value[<span class="hljs-number">3</span>] = value[<span class="hljs-number">1</span>];
        }

        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">top</span>: <span class="hljs-built_in">parseInt</span>(value[<span class="hljs-number">0</span>], radix) || <span class="hljs-number">0</span>,
          <span class="hljs-attr">right</span>: <span class="hljs-built_in">parseInt</span>(value[<span class="hljs-number">1</span>], radix) || <span class="hljs-number">0</span>,
          <span class="hljs-attr">bottom</span>: <span class="hljs-built_in">parseInt</span>(value[<span class="hljs-number">2</span>], radix) || <span class="hljs-number">0</span>,
          <span class="hljs-attr">left</span>: <span class="hljs-built_in">parseInt</span>(value[<span class="hljs-number">3</span>], radix) || <span class="hljs-number">0</span>
        };
      },

      <span class="hljs-attr">measureBox</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, prefix</span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span>(<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">var</span> defaultView = <span class="hljs-built_in">document</span>.defaultView;

          <span class="hljs-keyword">if</span> (defaultView) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1417">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1417">&#182;</a>
              </div>
              <p>Remove camelcase</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            name = name.replace(<span class="hljs-regexp">/[A-Z]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
              <span class="hljs-keyword">return</span> <span class="hljs-string">'-'</span> + a;
            });

            <span class="hljs-keyword">return</span> defaultView.getComputedStyle(elm, <span class="hljs-literal">null</span>).getPropertyValue(name);
          }

          <span class="hljs-keyword">return</span> elm.currentStyle[name];
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSide</span>(<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">var</span> val = <span class="hljs-built_in">parseFloat</span>(getStyle(name), <span class="hljs-number">10</span>);

          <span class="hljs-keyword">return</span> <span class="hljs-built_in">isNaN</span>(val) ? <span class="hljs-number">0</span> : val;
        }

        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">top</span>: getSide(prefix + <span class="hljs-string">"TopWidth"</span>),
          <span class="hljs-attr">right</span>: getSide(prefix + <span class="hljs-string">"RightWidth"</span>),
          <span class="hljs-attr">bottom</span>: getSide(prefix + <span class="hljs-string">"BottomWidth"</span>),
          <span class="hljs-attr">left</span>: getSide(prefix + <span class="hljs-string">"LeftWidth"</span>)
        };
      }
    };
  }
);

<span class="hljs-comment">/**
 * ClassList.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Handles adding and removal of classes.
 *
 * @private
 * @class tinymce.ui.ClassList
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.ClassList'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Tools</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span>(<span class="hljs-params"></span>) </span>{
    }

    <span class="hljs-comment">/**
     * Constructs a new class list the specified onchange
     * callback will be executed when the class list gets modifed.
     *
     * @constructor ClassList
     * @param {function} onchange Onchange callback to be executed.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ClassList</span>(<span class="hljs-params">onchange</span>) </span>{
      <span class="hljs-keyword">this</span>.cls = [];
      <span class="hljs-keyword">this</span>.cls._map = {};
      <span class="hljs-keyword">this</span>.onchange = onchange || noop;
      <span class="hljs-keyword">this</span>.prefix = <span class="hljs-string">''</span>;
    }

    Tools.extend(ClassList.prototype, {
      <span class="hljs-comment">/**
       * Adds a new class to the class list.
       *
       * @method add
       * @param {String} cls Class to be added.
       * @return {tinymce.ui.ClassList} Current class list instance.
       */</span>
      add: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cls</span>) </span>{
        <span class="hljs-keyword">if</span> (cls &amp;&amp; !<span class="hljs-keyword">this</span>.contains(cls)) {
          <span class="hljs-keyword">this</span>.cls._map[cls] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">this</span>.cls.push(cls);
          <span class="hljs-keyword">this</span>._change();
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Removes the specified class from the class list.
       *
       * @method remove
       * @param {String} cls Class to be removed.
       * @return {tinymce.ui.ClassList} Current class list instance.
       */</span>
      remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cls</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.contains(cls)) {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.cls.length; i++) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cls[i] === cls) {
              <span class="hljs-keyword">break</span>;
            }
          }

          <span class="hljs-keyword">this</span>.cls.splice(i, <span class="hljs-number">1</span>);
          <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.cls._map[cls];
          <span class="hljs-keyword">this</span>._change();
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Toggles a class in the class list.
       *
       * @method toggle
       * @param {String} cls Class to be added/removed.
       * @param {Boolean} state Optional state if it should be added/removed.
       * @return {tinymce.ui.ClassList} Current class list instance.
       */</span>
      toggle: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cls, state</span>) </span>{
        <span class="hljs-keyword">var</span> curState = <span class="hljs-keyword">this</span>.contains(cls);

        <span class="hljs-keyword">if</span> (curState !== state) {
          <span class="hljs-keyword">if</span> (curState) {
            <span class="hljs-keyword">this</span>.remove(cls);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.add(cls);
          }

          <span class="hljs-keyword">this</span>._change();
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Returns true if the class list has the specified class.
       *
       * @method contains
       * @param {String} cls Class to look for.
       * @return {Boolean} true/false if the class exists or not.
       */</span>
      contains: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cls</span>) </span>{
        <span class="hljs-keyword">return</span> !!<span class="hljs-keyword">this</span>.cls._map[cls];
      },

      <span class="hljs-comment">/**
       * Returns a space separated list of classes.
       *
       * @method toString
       * @return {String} Space separated list of classes.
       */</span>

      _change: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.clsValue;
        <span class="hljs-keyword">this</span>.onchange.call(<span class="hljs-keyword">this</span>);
      }
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-1418">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1418">&#182;</a>
              </div>
              <p>IE 8 compatibility</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    ClassList.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> value;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.clsValue) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.clsValue;
      }

      value = <span class="hljs-string">''</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.cls.length; i++) {
        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) {
          value += <span class="hljs-string">' '</span>;
        }

        value += <span class="hljs-keyword">this</span>.prefix + <span class="hljs-keyword">this</span>.cls[i];
      }

      <span class="hljs-keyword">return</span> value;
    };

    <span class="hljs-keyword">return</span> ClassList;
  }
);
<span class="hljs-comment">/**
 * ReflowQueue.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class will automatically reflow controls on the next animation frame within a few milliseconds on older browsers.
 * If the user manually reflows then the automatic reflow will be cancelled. This class is used internally when various control states
 * changes that triggers a reflow.
 *
 * @class tinymce.ui.ReflowQueue
 * @static
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.ReflowQueue'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Delay"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Delay</span>) </span>{
    <span class="hljs-keyword">var</span> dirtyCtrls = {}, animationFrameRequested;

    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">/**
       * Adds a control to the next automatic reflow call. This is the control that had a state
       * change for example if the control was hidden/shown.
       *
       * @method add
       * @param {tinymce.ui.Control} ctrl Control to add to queue.
       */</span>
      add: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
        <span class="hljs-keyword">var</span> parent = ctrl.parent();

        <span class="hljs-keyword">if</span> (parent) {
          <span class="hljs-keyword">if</span> (!parent._layout || parent._layout.isNative()) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (!dirtyCtrls[parent._id]) {
            dirtyCtrls[parent._id] = parent;
          }

          <span class="hljs-keyword">if</span> (!animationFrameRequested) {
            animationFrameRequested = <span class="hljs-literal">true</span>;

            Delay.requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">var</span> id, ctrl;

              animationFrameRequested = <span class="hljs-literal">false</span>;

              <span class="hljs-keyword">for</span> (id <span class="hljs-keyword">in</span> dirtyCtrls) {
                ctrl = dirtyCtrls[id];

                <span class="hljs-keyword">if</span> (ctrl.state.get(<span class="hljs-string">'rendered'</span>)) {
                  ctrl.reflow();
                }
              }

              dirtyCtrls = {};
            }, <span class="hljs-built_in">document</span>.body);
          }
        }
      },

      <span class="hljs-comment">/**
       * Removes the specified control from the automatic reflow. This will happen when for example the user
       * manually triggers a reflow.
       *
       * @method remove
       * @param {tinymce.ui.Control} ctrl Control to remove from queue.
       */</span>
      remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
        <span class="hljs-keyword">if</span> (dirtyCtrls[ctrl._id]) {
          <span class="hljs-keyword">delete</span> dirtyCtrls[ctrl._id];
        }
      }
    };
  }
);

<span class="hljs-comment">/**
 * Control.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/*eslint consistent-this:0 */</span>

<span class="hljs-comment">/**
 * This is the base class for all controls and containers. All UI control instances inherit
 * from this one as it has the base logic needed by all of them.
 *
 * @class tinymce.ui.Control
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Control'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Class"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.util.EventDispatcher"</span>,
    <span class="hljs-string">"tinymce.core.data.ObservableObject"</span>,
    <span class="hljs-string">"tinymce.core.ui.Collection"</span>,
    <span class="hljs-string">"tinymce.core.ui.DomUtils"</span>,
    <span class="hljs-string">"tinymce.core.dom.DomQuery"</span>,
    <span class="hljs-string">"tinymce.core.ui.BoxUtils"</span>,
    <span class="hljs-string">"tinymce.core.ui.ClassList"</span>,
    <span class="hljs-string">"tinymce.core.ui.ReflowQueue"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Class, Tools, EventDispatcher, ObservableObject, Collection, DomUtils, $, BoxUtils, ClassList, ReflowQueue</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> hasMouseWheelEventSupport = <span class="hljs-string">"onmousewheel"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">document</span>;
    <span class="hljs-keyword">var</span> hasWheelEventSupport = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> classPrefix = <span class="hljs-string">"mce-"</span>;
    <span class="hljs-keyword">var</span> Control, idCounter = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">var</span> proto = {
      <span class="hljs-attr">Statics</span>: {
        <span class="hljs-attr">classPrefix</span>: classPrefix
      },

      <span class="hljs-attr">isRtl</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> Control.rtl;
      },

      <span class="hljs-comment">/**
       * Class/id prefix to use for all controls.
       *
       * @final
       * @field {String} classPrefix
       */</span>
      classPrefix: classPrefix,

      <span class="hljs-comment">/**
       * Constructs a new control instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {String} style Style CSS properties to add.
       * @setting {String} border Border box values example: 1 1 1 1
       * @setting {String} padding Padding box values example: 1 1 1 1
       * @setting {String} margin Margin box values example: 1 1 1 1
       * @setting {Number} minWidth Minimal width for the control.
       * @setting {Number} minHeight Minimal height for the control.
       * @setting {String} classes Space separated list of classes to add.
       * @setting {String} role WAI-ARIA role to use for control.
       * @setting {Boolean} hidden Is the control hidden by default.
       * @setting {Boolean} disabled Is the control disabled by default.
       * @setting {String} name Name of the control instance.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, classes, defaultClasses;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyClasses</span>(<span class="hljs-params">classes</span>) </span>{
          <span class="hljs-keyword">var</span> i;

          classes = classes.split(<span class="hljs-string">' '</span>);
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; classes.length; i++) {
            self.classes.add(classes[i]);
          }
        }

        self.settings = settings = Tools.extend({}, self.Defaults, settings);</pre></div></div>
            
        </li>
        
        
        <li id="section-1419">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1419">&#182;</a>
              </div>
              <p>Initial states</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self._id = settings.id || (<span class="hljs-string">'mceu_'</span> + (idCounter++));
        self._aria = { <span class="hljs-attr">role</span>: settings.role };
        self._elmCache = {};
        self.$ = $;

        self.state = <span class="hljs-keyword">new</span> ObservableObject({
          <span class="hljs-attr">visible</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">active</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">disabled</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">value</span>: <span class="hljs-string">''</span>
        });

        self.data = <span class="hljs-keyword">new</span> ObservableObject(settings.data);

        self.classes = <span class="hljs-keyword">new</span> ClassList(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'rendered'</span>)) {
            self.getEl().className = <span class="hljs-keyword">this</span>.toString();
          }
        });
        self.classes.prefix = self.classPrefix;</pre></div></div>
            
        </li>
        
        
        <li id="section-1420">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1420">&#182;</a>
              </div>
              <p>Setup classes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        classes = settings.classes;
        <span class="hljs-keyword">if</span> (classes) {
          <span class="hljs-keyword">if</span> (self.Defaults) {
            defaultClasses = self.Defaults.classes;

            <span class="hljs-keyword">if</span> (defaultClasses &amp;&amp; classes != defaultClasses) {
              applyClasses(defaultClasses);
            }
          }

          applyClasses(classes);
        }

        Tools.each(<span class="hljs-string">'title text name visible disabled active value'</span>.split(<span class="hljs-string">' '</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> settings) {
            self[name](settings[name]);
          }
        });

        self.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (self.disabled()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        });

        <span class="hljs-comment">/**
         * Name/value object with settings for the current control.
         *
         * @field {Object} settings
         */</span>
        self.settings = settings;

        self.borderBox = BoxUtils.parseBox(settings.border);
        self.paddingBox = BoxUtils.parseBox(settings.padding);
        self.marginBox = BoxUtils.parseBox(settings.margin);

        <span class="hljs-keyword">if</span> (settings.hidden) {
          self.hide();
        }
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-1421">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1421">&#182;</a>
              </div>
              <p>Will generate getter/setter methods for these properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      Properties: <span class="hljs-string">'parent,name'</span>,

      <span class="hljs-comment">/**
       * Returns the root element to render controls into.
       *
       * @method getContainerElm
       * @return {Element} HTML DOM element to render into.
       */</span>
      getContainerElm: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> DomUtils.getContainer();
      },

      <span class="hljs-comment">/**
       * Returns a control instance for the current DOM element.
       *
       * @method getParentCtrl
       * @param {Element} elm HTML dom element to get parent control from.
       * @return {tinymce.ui.Control} Control instance or undefined.
       */</span>
      getParentCtrl: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">var</span> ctrl, lookup = <span class="hljs-keyword">this</span>.getRoot().controlIdLookup;

        <span class="hljs-keyword">while</span> (elm &amp;&amp; lookup) {
          ctrl = lookup[elm.id];
          <span class="hljs-keyword">if</span> (ctrl) {
            <span class="hljs-keyword">break</span>;
          }

          elm = elm.parentNode;
        }

        <span class="hljs-keyword">return</span> ctrl;
      },

      <span class="hljs-comment">/**
       * Initializes the current controls layout rect.
       * This will be executed by the layout managers to determine the
       * default minWidth/minHeight etc.
       *
       * @method initLayoutRect
       * @return {Object} Layout rect instance.
       */</span>
      initLayoutRect: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, settings = self.settings, borderBox, layoutRect;
        <span class="hljs-keyword">var</span> elm = self.getEl(), width, height, minWidth, minHeight, autoResize;
        <span class="hljs-keyword">var</span> startMinWidth, startMinHeight, initialSize;</pre></div></div>
            
        </li>
        
        
        <li id="section-1422">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1422">&#182;</a>
              </div>
              <p>Measure the current element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        borderBox = self.borderBox = self.borderBox || BoxUtils.measureBox(elm, <span class="hljs-string">'border'</span>);
        self.paddingBox = self.paddingBox || BoxUtils.measureBox(elm, <span class="hljs-string">'padding'</span>);
        self.marginBox = self.marginBox || BoxUtils.measureBox(elm, <span class="hljs-string">'margin'</span>);
        initialSize = DomUtils.getSize(elm);</pre></div></div>
            
        </li>
        
        
        <li id="section-1423">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1423">&#182;</a>
              </div>
              <p>Setup minWidth/minHeight and width/height</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        startMinWidth = settings.minWidth;
        startMinHeight = settings.minHeight;
        minWidth = startMinWidth || initialSize.width;
        minHeight = startMinHeight || initialSize.height;
        width = settings.width;
        height = settings.height;
        autoResize = settings.autoResize;
        autoResize = <span class="hljs-keyword">typeof</span> autoResize != <span class="hljs-string">"undefined"</span> ? autoResize : !width &amp;&amp; !height;

        width = width || minWidth;
        height = height || minHeight;

        <span class="hljs-keyword">var</span> deltaW = borderBox.left + borderBox.right;
        <span class="hljs-keyword">var</span> deltaH = borderBox.top + borderBox.bottom;

        <span class="hljs-keyword">var</span> maxW = settings.maxWidth || <span class="hljs-number">0xFFFF</span>;
        <span class="hljs-keyword">var</span> maxH = settings.maxHeight || <span class="hljs-number">0xFFFF</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1424">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1424">&#182;</a>
              </div>
              <p>Setup initial layout rect</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self._layoutRect = layoutRect = {
          <span class="hljs-attr">x</span>: settings.x || <span class="hljs-number">0</span>,
          <span class="hljs-attr">y</span>: settings.y || <span class="hljs-number">0</span>,
          <span class="hljs-attr">w</span>: width,
          <span class="hljs-attr">h</span>: height,
          <span class="hljs-attr">deltaW</span>: deltaW,
          <span class="hljs-attr">deltaH</span>: deltaH,
          <span class="hljs-attr">contentW</span>: width - deltaW,
          <span class="hljs-attr">contentH</span>: height - deltaH,
          <span class="hljs-attr">innerW</span>: width - deltaW,
          <span class="hljs-attr">innerH</span>: height - deltaH,
          <span class="hljs-attr">startMinWidth</span>: startMinWidth || <span class="hljs-number">0</span>,
          <span class="hljs-attr">startMinHeight</span>: startMinHeight || <span class="hljs-number">0</span>,
          <span class="hljs-attr">minW</span>: <span class="hljs-built_in">Math</span>.min(minWidth, maxW),
          <span class="hljs-attr">minH</span>: <span class="hljs-built_in">Math</span>.min(minHeight, maxH),
          <span class="hljs-attr">maxW</span>: maxW,
          <span class="hljs-attr">maxH</span>: maxH,
          <span class="hljs-attr">autoResize</span>: autoResize,
          <span class="hljs-attr">scrollW</span>: <span class="hljs-number">0</span>
        };

        self._lastLayoutRect = {};

        <span class="hljs-keyword">return</span> layoutRect;
      },

      <span class="hljs-comment">/**
       * Getter/setter for the current layout rect.
       *
       * @method layoutRect
       * @param {Object} [newRect] Optional new layout rect.
       * @return {tinymce.ui.Control/Object} Current control or rect object.
       */</span>
      layoutRect: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newRect</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, curRect = self._layoutRect, lastLayoutRect, size, deltaWidth, deltaHeight, undef, repaintControls;</pre></div></div>
            
        </li>
        
        
        <li id="section-1425">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1425">&#182;</a>
              </div>
              <p>Initialize default layout rect</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!curRect) {
          curRect = self.initLayoutRect();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1426">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1426">&#182;</a>
              </div>
              <p>Set new rect values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (newRect) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1427">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1427">&#182;</a>
              </div>
              <p>Calc deltas between inner and outer sizes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          deltaWidth = curRect.deltaW;
          deltaHeight = curRect.deltaH;</pre></div></div>
            
        </li>
        
        
        <li id="section-1428">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1428">&#182;</a>
              </div>
              <p>Set x position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (newRect.x !== undef) {
            curRect.x = newRect.x;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1429">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1429">&#182;</a>
              </div>
              <p>Set y position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (newRect.y !== undef) {
            curRect.y = newRect.y;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1430">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1430">&#182;</a>
              </div>
              <p>Set minW</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (newRect.minW !== undef) {
            curRect.minW = newRect.minW;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1431">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1431">&#182;</a>
              </div>
              <p>Set minH</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (newRect.minH !== undef) {
            curRect.minH = newRect.minH;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1432">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1432">&#182;</a>
              </div>
              <p>Set new width and calculate inner width</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          size = newRect.w;
          <span class="hljs-keyword">if</span> (size !== undef) {
            size = size &lt; curRect.minW ? curRect.minW : size;
            size = size &gt; curRect.maxW ? curRect.maxW : size;
            curRect.w = size;
            curRect.innerW = size - deltaWidth;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1433">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1433">&#182;</a>
              </div>
              <p>Set new height and calculate inner height</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          size = newRect.h;
          <span class="hljs-keyword">if</span> (size !== undef) {
            size = size &lt; curRect.minH ? curRect.minH : size;
            size = size &gt; curRect.maxH ? curRect.maxH : size;
            curRect.h = size;
            curRect.innerH = size - deltaHeight;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1434">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1434">&#182;</a>
              </div>
              <p>Set new inner width and calculate width</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          size = newRect.innerW;
          <span class="hljs-keyword">if</span> (size !== undef) {
            size = size &lt; curRect.minW - deltaWidth ? curRect.minW - deltaWidth : size;
            size = size &gt; curRect.maxW - deltaWidth ? curRect.maxW - deltaWidth : size;
            curRect.innerW = size;
            curRect.w = size + deltaWidth;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1435">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1435">&#182;</a>
              </div>
              <p>Set new height and calculate inner height</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          size = newRect.innerH;
          <span class="hljs-keyword">if</span> (size !== undef) {
            size = size &lt; curRect.minH - deltaHeight ? curRect.minH - deltaHeight : size;
            size = size &gt; curRect.maxH - deltaHeight ? curRect.maxH - deltaHeight : size;
            curRect.innerH = size;
            curRect.h = size + deltaHeight;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1436">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1436">&#182;</a>
              </div>
              <p>Set new contentW</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (newRect.contentW !== undef) {
            curRect.contentW = newRect.contentW;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1437">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1437">&#182;</a>
              </div>
              <p>Set new contentH</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (newRect.contentH !== undef) {
            curRect.contentH = newRect.contentH;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1438">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1438">&#182;</a>
              </div>
              <p>Compare last layout rect with the current one to see if we need to repaint or not</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          lastLayoutRect = self._lastLayoutRect;
          <span class="hljs-keyword">if</span> (lastLayoutRect.x !== curRect.x || lastLayoutRect.y !== curRect.y ||
            lastLayoutRect.w !== curRect.w || lastLayoutRect.h !== curRect.h) {
            repaintControls = Control.repaintControls;

            <span class="hljs-keyword">if</span> (repaintControls) {
              <span class="hljs-keyword">if</span> (repaintControls.map &amp;&amp; !repaintControls.map[self._id]) {
                repaintControls.push(self);
                repaintControls.map[self._id] = <span class="hljs-literal">true</span>;
              }
            }

            lastLayoutRect.x = curRect.x;
            lastLayoutRect.y = curRect.y;
            lastLayoutRect.w = curRect.w;
            lastLayoutRect.h = curRect.h;
          }

          <span class="hljs-keyword">return</span> self;
        }

        <span class="hljs-keyword">return</span> curRect;
      },

      <span class="hljs-comment">/**
       * Repaints the control after a layout operation.
       *
       * @method repaint
       */</span>
      repaint: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, style, bodyStyle, bodyElm, rect, borderBox;
        <span class="hljs-keyword">var</span> borderW, borderH, lastRepaintRect, round, value;</pre></div></div>
            
        </li>
        
        
        <li id="section-1439">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1439">&#182;</a>
              </div>
              <p>Use Math.round on all values on IE &lt; 9</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        round = !<span class="hljs-built_in">document</span>.createRange ? <span class="hljs-built_in">Math</span>.round : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
          <span class="hljs-keyword">return</span> value;
        };

        style = self.getEl().style;
        rect = self._layoutRect;
        lastRepaintRect = self._lastRepaintRect || {};

        borderBox = self.borderBox;
        borderW = borderBox.left + borderBox.right;
        borderH = borderBox.top + borderBox.bottom;

        <span class="hljs-keyword">if</span> (rect.x !== lastRepaintRect.x) {
          style.left = round(rect.x) + <span class="hljs-string">'px'</span>;
          lastRepaintRect.x = rect.x;
        }

        <span class="hljs-keyword">if</span> (rect.y !== lastRepaintRect.y) {
          style.top = round(rect.y) + <span class="hljs-string">'px'</span>;
          lastRepaintRect.y = rect.y;
        }

        <span class="hljs-keyword">if</span> (rect.w !== lastRepaintRect.w) {
          value = round(rect.w - borderW);
          style.width = (value &gt;= <span class="hljs-number">0</span> ? value : <span class="hljs-number">0</span>) + <span class="hljs-string">'px'</span>;
          lastRepaintRect.w = rect.w;
        }

        <span class="hljs-keyword">if</span> (rect.h !== lastRepaintRect.h) {
          value = round(rect.h - borderH);
          style.height = (value &gt;= <span class="hljs-number">0</span> ? value : <span class="hljs-number">0</span>) + <span class="hljs-string">'px'</span>;
          lastRepaintRect.h = rect.h;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1440">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1440">&#182;</a>
              </div>
              <p>Update body if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self._hasBody &amp;&amp; rect.innerW !== lastRepaintRect.innerW) {
          value = round(rect.innerW);

          bodyElm = self.getEl(<span class="hljs-string">'body'</span>);
          <span class="hljs-keyword">if</span> (bodyElm) {
            bodyStyle = bodyElm.style;
            bodyStyle.width = (value &gt;= <span class="hljs-number">0</span> ? value : <span class="hljs-number">0</span>) + <span class="hljs-string">'px'</span>;
          }

          lastRepaintRect.innerW = rect.innerW;
        }

        <span class="hljs-keyword">if</span> (self._hasBody &amp;&amp; rect.innerH !== lastRepaintRect.innerH) {
          value = round(rect.innerH);

          bodyElm = bodyElm || self.getEl(<span class="hljs-string">'body'</span>);
          <span class="hljs-keyword">if</span> (bodyElm) {
            bodyStyle = bodyStyle || bodyElm.style;
            bodyStyle.height = (value &gt;= <span class="hljs-number">0</span> ? value : <span class="hljs-number">0</span>) + <span class="hljs-string">'px'</span>;
          }

          lastRepaintRect.innerH = rect.innerH;
        }

        self._lastRepaintRect = lastRepaintRect;
        self.fire(<span class="hljs-string">'repaint'</span>, {}, <span class="hljs-literal">false</span>);
      },

      <span class="hljs-comment">/**
       * Updates the controls layout rect by re-measuing it.
       */</span>
      updateLayoutRect: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.parent()._lastRect = <span class="hljs-literal">null</span>;

        DomUtils.css(self.getEl(), { <span class="hljs-attr">width</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">height</span>: <span class="hljs-string">''</span> });

        self._layoutRect = self._lastRepaintRect = self._lastLayoutRect = <span class="hljs-literal">null</span>;
        self.initLayoutRect();
      },

      <span class="hljs-comment">/**
       * Binds a callback to the specified event. This event can both be
       * native browser events like "click" or custom ones like PostRender.
       *
       * The callback function will be passed a DOM event like object that enables yout do stop propagation.
       *
       * @method on
       * @param {String} name Name of the event to bind. For example "click".
       * @param {String/function} callback Callback function to execute ones the event occurs.
       * @return {tinymce.ui.Control} Current control object.
       */</span>
      on: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, callback</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveCallbackName</span>(<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">var</span> callback, scope;

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name != <span class="hljs-string">'string'</span>) {
            <span class="hljs-keyword">return</span> name;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">if</span> (!callback) {
              self.parentsAndSelf().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
                <span class="hljs-keyword">var</span> callbacks = ctrl.settings.callbacks;

                <span class="hljs-keyword">if</span> (callbacks &amp;&amp; (callback = callbacks[name])) {
                  scope = ctrl;
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
              });
            }

            <span class="hljs-keyword">if</span> (!callback) {
              e.action = name;
              <span class="hljs-keyword">this</span>.fire(<span class="hljs-string">'execute'</span>, e);
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">return</span> callback.call(scope, e);
          };
        }

        getEventDispatcher(self).on(name, resolveCallbackName(callback));

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Unbinds the specified event and optionally a specific callback. If you omit the name
       * parameter all event handlers will be removed. If you omit the callback all event handles
       * by the specified name will be removed.
       *
       * @method off
       * @param {String} [name] Name for the event to unbind.
       * @param {function} [callback] Callback function to unbind.
       * @return {tinymce.ui.Control} Current control object.
       */</span>
      off: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, callback</span>) </span>{
        getEventDispatcher(<span class="hljs-keyword">this</span>).off(name, callback);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Fires the specified event by name and arguments on the control. This will execute all
       * bound event handlers.
       *
       * @method fire
       * @param {String} name Name of the event to fire.
       * @param {Object} [args] Arguments to pass to the event.
       * @param {Boolean} [bubble] Value to control bubbling. Defaults to true.
       * @return {Object} Current arguments object.
       */</span>
      fire: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, args, bubble</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        args = args || {};

        <span class="hljs-keyword">if</span> (!args.control) {
          args.control = self;
        }

        args = getEventDispatcher(self).fire(name, args);</pre></div></div>
            
        </li>
        
        
        <li id="section-1441">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1441">&#182;</a>
              </div>
              <p>Bubble event up to parents</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (bubble !== <span class="hljs-literal">false</span> &amp;&amp; self.parent) {
          <span class="hljs-keyword">var</span> parent = self.parent();
          <span class="hljs-keyword">while</span> (parent &amp;&amp; !args.isPropagationStopped()) {
            parent.fire(name, args, <span class="hljs-literal">false</span>);
            parent = parent.parent();
          }
        }

        <span class="hljs-keyword">return</span> args;
      },

      <span class="hljs-comment">/**
       * Returns true/false if the specified event has any listeners.
       *
       * @method hasEventListeners
       * @param {String} name Name of the event to check for.
       * @return {Boolean} True/false state if the event has listeners.
       */</span>
      hasEventListeners: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> getEventDispatcher(<span class="hljs-keyword">this</span>).has(name);
      },

      <span class="hljs-comment">/**
       * Returns a control collection with all parent controls.
       *
       * @method parents
       * @param {String} selector Optional selector expression to find parents.
       * @return {tinymce.ui.Collection} Collection with all parent controls.
       */</span>
      parents: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, ctrl, parents = <span class="hljs-keyword">new</span> Collection();</pre></div></div>
            
        </li>
        
        
        <li id="section-1442">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1442">&#182;</a>
              </div>
              <p>Add each parent to collection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (ctrl = self.parent(); ctrl; ctrl = ctrl.parent()) {
          parents.add(ctrl);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1443">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1443">&#182;</a>
              </div>
              <p>Filter away everything that doesnt match the selector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (selector) {
          parents = parents.filter(selector);
        }

        <span class="hljs-keyword">return</span> parents;
      },

      <span class="hljs-comment">/**
       * Returns the current control and it's parents.
       *
       * @method parentsAndSelf
       * @param {String} selector Optional selector expression to find parents.
       * @return {tinymce.ui.Collection} Collection with all parent controls.
       */</span>
      parentsAndSelf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Collection(<span class="hljs-keyword">this</span>).add(<span class="hljs-keyword">this</span>.parents(selector));
      },

      <span class="hljs-comment">/**
       * Returns the control next to the current control.
       *
       * @method next
       * @return {tinymce.ui.Control} Next control instance.
       */</span>
      next: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> parentControls = <span class="hljs-keyword">this</span>.parent().items();

        <span class="hljs-keyword">return</span> parentControls[parentControls.indexOf(<span class="hljs-keyword">this</span>) + <span class="hljs-number">1</span>];
      },

      <span class="hljs-comment">/**
       * Returns the control previous to the current control.
       *
       * @method prev
       * @return {tinymce.ui.Control} Previous control instance.
       */</span>
      prev: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> parentControls = <span class="hljs-keyword">this</span>.parent().items();

        <span class="hljs-keyword">return</span> parentControls[parentControls.indexOf(<span class="hljs-keyword">this</span>) - <span class="hljs-number">1</span>];
      },

      <span class="hljs-comment">/**
       * Sets the inner HTML of the control element.
       *
       * @method innerHtml
       * @param {String} html Html string to set as inner html.
       * @return {tinymce.ui.Control} Current control object.
       */</span>
      innerHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">html</span>) </span>{
        <span class="hljs-keyword">this</span>.$el.html(html);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Returns the control DOM element or sub element.
       *
       * @method getEl
       * @param {String} [suffix] Suffix to get element by.
       * @return {Element} HTML DOM element for the current control or it's children.
       */</span>
      getEl: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">suffix</span>) </span>{
        <span class="hljs-keyword">var</span> id = suffix ? <span class="hljs-keyword">this</span>._id + <span class="hljs-string">'-'</span> + suffix : <span class="hljs-keyword">this</span>._id;

        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._elmCache[id]) {
          <span class="hljs-keyword">this</span>._elmCache[id] = $(<span class="hljs-string">'#'</span> + id)[<span class="hljs-number">0</span>];
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._elmCache[id];
      },

      <span class="hljs-comment">/**
       * Sets the visible state to true.
       *
       * @method show
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      show: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.visible(<span class="hljs-literal">true</span>);
      },

      <span class="hljs-comment">/**
       * Sets the visible state to false.
       *
       * @method hide
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      hide: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.visible(<span class="hljs-literal">false</span>);
      },

      <span class="hljs-comment">/**
       * Focuses the current control.
       *
       * @method focus
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      focus: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">this</span>.getEl().focus();
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1444">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1444">&#182;</a>
              </div>
              <p>Ignore IE error</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Blurs the current control.
       *
       * @method blur
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      blur: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.getEl().blur();

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Sets the specified aria property.
       *
       * @method aria
       * @param {String} name Name of the aria property to set.
       * @param {String} value Value of the aria property.
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      aria: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, elm = self.getEl(self.ariaTarget);

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"undefined"</span>) {
          <span class="hljs-keyword">return</span> self._aria[name];
        }

        self._aria[name] = value;

        <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'rendered'</span>)) {
          elm.setAttribute(name == <span class="hljs-string">'role'</span> ? name : <span class="hljs-string">'aria-'</span> + name, value);
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Encodes the specified string with HTML entities. It will also
       * translate the string to different languages.
       *
       * @method encode
       * @param {String/Object/Array} text Text to entity encode.
       * @param {Boolean} [translate=true] False if the contents shouldn't be translated.
       * @return {String} Encoded and possible traslated string.
       */</span>
      encode: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, translate</span>) </span>{
        <span class="hljs-keyword">if</span> (translate !== <span class="hljs-literal">false</span>) {
          text = <span class="hljs-keyword">this</span>.translate(text);
        }

        <span class="hljs-keyword">return</span> (text || <span class="hljs-string">''</span>).replace(<span class="hljs-regexp">/[&amp;&lt;&gt;"]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match</span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-string">'&amp;#'</span> + match.charCodeAt(<span class="hljs-number">0</span>) + <span class="hljs-string">';'</span>;
        });
      },

      <span class="hljs-comment">/**
       * Returns the translated string.
       *
       * @method translate
       * @param {String} text Text to translate.
       * @return {String} Translated string or the same as the input.
       */</span>
      translate: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
        <span class="hljs-keyword">return</span> Control.translate ? Control.translate(text) : text;
      },

      <span class="hljs-comment">/**
       * Adds items before the current control.
       *
       * @method before
       * @param {Array/tinymce.ui.Collection} items Array of items to prepend before this control.
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      before: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, parent = self.parent();

        <span class="hljs-keyword">if</span> (parent) {
          parent.insert(items, parent.items().indexOf(self), <span class="hljs-literal">true</span>);
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Adds items after the current control.
       *
       * @method after
       * @param {Array/tinymce.ui.Collection} items Array of items to append after this control.
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      after: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, parent = self.parent();

        <span class="hljs-keyword">if</span> (parent) {
          parent.insert(items, parent.items().indexOf(self));
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Removes the current control from DOM and from UI collections.
       *
       * @method remove
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, elm = self.getEl(), parent = self.parent(), newItems, i;

        <span class="hljs-keyword">if</span> (self.items) {
          <span class="hljs-keyword">var</span> controls = self.items().toArray();
          i = controls.length;
          <span class="hljs-keyword">while</span> (i--) {
            controls[i].remove();
          }
        }

        <span class="hljs-keyword">if</span> (parent &amp;&amp; parent.items) {
          newItems = [];

          parent.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
            <span class="hljs-keyword">if</span> (item !== self) {
              newItems.push(item);
            }
          });

          parent.items().set(newItems);
          parent._lastRect = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">if</span> (self._eventsRoot &amp;&amp; self._eventsRoot == self) {
          $(elm).off();
        }

        <span class="hljs-keyword">var</span> lookup = self.getRoot().controlIdLookup;
        <span class="hljs-keyword">if</span> (lookup) {
          <span class="hljs-keyword">delete</span> lookup[self._id];
        }

        <span class="hljs-keyword">if</span> (elm &amp;&amp; elm.parentNode) {
          elm.parentNode.removeChild(elm);
        }

        self.state.set(<span class="hljs-string">'rendered'</span>, <span class="hljs-literal">false</span>);
        self.state.destroy();

        self.fire(<span class="hljs-string">'remove'</span>);

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Renders the control before the specified element.
       *
       * @method renderBefore
       * @param {Element} elm Element to render before.
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      renderBefore: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        $(elm).before(<span class="hljs-keyword">this</span>.renderHtml());
        <span class="hljs-keyword">this</span>.postRender();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Renders the control to the specified element.
       *
       * @method renderBefore
       * @param {Element} elm Element to render to.
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      renderTo: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        $(elm || <span class="hljs-keyword">this</span>.getContainerElm()).append(<span class="hljs-keyword">this</span>.renderHtml());
        <span class="hljs-keyword">this</span>.postRender();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-attr">preRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      },

      <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      },

      <span class="hljs-attr">renderHtml</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div id="'</span> + <span class="hljs-keyword">this</span>._id + <span class="hljs-string">'" class="'</span> + <span class="hljs-keyword">this</span>.classes + <span class="hljs-string">'"&gt;&lt;/div&gt;'</span>;
      },

      <span class="hljs-comment">/**
       * Post render method. Called after the control has been rendered to the target.
       *
       * @method postRender
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, settings = self.settings, elm, box, parent, name, parentEventsRoot;

        self.$el = $(self.getEl());
        self.state.set(<span class="hljs-string">'rendered'</span>, <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1445">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1445">&#182;</a>
              </div>
              <p>Bind on<event> settings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> settings) {
          <span class="hljs-keyword">if</span> (name.indexOf(<span class="hljs-string">"on"</span>) === <span class="hljs-number">0</span>) {
            self.on(name.substr(<span class="hljs-number">2</span>), settings[name]);
          }
        }

        <span class="hljs-keyword">if</span> (self._eventsRoot) {
          <span class="hljs-keyword">for</span> (parent = self.parent(); !parentEventsRoot &amp;&amp; parent; parent = parent.parent()) {
            parentEventsRoot = parent._eventsRoot;
          }

          <span class="hljs-keyword">if</span> (parentEventsRoot) {
            <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> parentEventsRoot._nativeEvents) {
              self._nativeEvents[name] = <span class="hljs-literal">true</span>;
            }
          }
        }

        bindPendingEvents(self);

        <span class="hljs-keyword">if</span> (settings.style) {
          elm = self.getEl();
          <span class="hljs-keyword">if</span> (elm) {
            elm.setAttribute(<span class="hljs-string">'style'</span>, settings.style);
            elm.style.cssText = settings.style;
          }
        }

        <span class="hljs-keyword">if</span> (self.settings.border) {
          box = self.borderBox;
          self.$el.css({
            <span class="hljs-string">'border-top-width'</span>: box.top,
            <span class="hljs-string">'border-right-width'</span>: box.right,
            <span class="hljs-string">'border-bottom-width'</span>: box.bottom,
            <span class="hljs-string">'border-left-width'</span>: box.left
          });
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1446">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1446">&#182;</a>
              </div>
              <p>Add instance to lookup</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> root = self.getRoot();
        <span class="hljs-keyword">if</span> (!root.controlIdLookup) {
          root.controlIdLookup = {};
        }

        root.controlIdLookup[self._id] = self;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> self._aria) {
          self.aria(key, self._aria[key]);
        }

        <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'visible'</span>) === <span class="hljs-literal">false</span>) {
          self.getEl().style.display = <span class="hljs-string">'none'</span>;
        }

        self.bindStates();

        self.state.on(<span class="hljs-string">'change:visible'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> state = e.value, parentCtrl;

          <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'rendered'</span>)) {
            self.getEl().style.display = state === <span class="hljs-literal">false</span> ? <span class="hljs-string">'none'</span> : <span class="hljs-string">''</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1447">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1447">&#182;</a>
              </div>
              <p>Need to force a reflow here on IE 8</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            self.getEl().getBoundingClientRect();
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1448">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1448">&#182;</a>
              </div>
              <p>Parent container needs to reflow</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          parentCtrl = self.parent();
          <span class="hljs-keyword">if</span> (parentCtrl) {
            parentCtrl._lastRect = <span class="hljs-literal">null</span>;
          }

          self.fire(state ? <span class="hljs-string">'show'</span> : <span class="hljs-string">'hide'</span>);

          ReflowQueue.add(self);
        });

        self.fire(<span class="hljs-string">'postrender'</span>, {}, <span class="hljs-literal">false</span>);
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      },

      <span class="hljs-comment">/**
       * Scrolls the current control into view.
       *
       * @method scrollIntoView
       * @param {String} align Alignment in view top|center|bottom.
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      scrollIntoView: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">align</span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOffset</span>(<span class="hljs-params">elm, rootElm</span>) </span>{
          <span class="hljs-keyword">var</span> x, y, parent = elm;

          x = y = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">while</span> (parent &amp;&amp; parent != rootElm &amp;&amp; parent.nodeType) {
            x += parent.offsetLeft || <span class="hljs-number">0</span>;
            y += parent.offsetTop || <span class="hljs-number">0</span>;
            parent = parent.offsetParent;
          }

          <span class="hljs-keyword">return</span> { <span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y };
        }

        <span class="hljs-keyword">var</span> elm = <span class="hljs-keyword">this</span>.getEl(), parentElm = elm.parentNode;
        <span class="hljs-keyword">var</span> x, y, width, height, parentWidth, parentHeight;
        <span class="hljs-keyword">var</span> pos = getOffset(elm, parentElm);

        x = pos.x;
        y = pos.y;
        width = elm.offsetWidth;
        height = elm.offsetHeight;
        parentWidth = parentElm.clientWidth;
        parentHeight = parentElm.clientHeight;

        <span class="hljs-keyword">if</span> (align == <span class="hljs-string">"end"</span>) {
          x -= parentWidth - width;
          y -= parentHeight - height;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (align == <span class="hljs-string">"center"</span>) {
          x -= (parentWidth / <span class="hljs-number">2</span>) - (width / <span class="hljs-number">2</span>);
          y -= (parentHeight / <span class="hljs-number">2</span>) - (height / <span class="hljs-number">2</span>);
        }

        parentElm.scrollLeft = x;
        parentElm.scrollTop = y;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-attr">getRoot</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> ctrl = <span class="hljs-keyword">this</span>, rootControl, parents = [];

        <span class="hljs-keyword">while</span> (ctrl) {
          <span class="hljs-keyword">if</span> (ctrl.rootControl) {
            rootControl = ctrl.rootControl;
            <span class="hljs-keyword">break</span>;
          }

          parents.push(ctrl);
          rootControl = ctrl;
          ctrl = ctrl.parent();
        }

        <span class="hljs-keyword">if</span> (!rootControl) {
          rootControl = <span class="hljs-keyword">this</span>;
        }

        <span class="hljs-keyword">var</span> i = parents.length;
        <span class="hljs-keyword">while</span> (i--) {
          parents[i].rootControl = rootControl;
        }

        <span class="hljs-keyword">return</span> rootControl;
      },

      <span class="hljs-comment">/**
       * Reflows the current control and it's parents.
       * This should be used after you for example append children to the current control so
       * that the layout managers know that they need to reposition everything.
       *
       * @example
       * container.append({type: 'button', text: 'My button'}).reflow();
       *
       * @method reflow
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      reflow: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        ReflowQueue.remove(<span class="hljs-keyword">this</span>);

        <span class="hljs-keyword">var</span> parent = <span class="hljs-keyword">this</span>.parent();
        <span class="hljs-keyword">if</span> (parent &amp;&amp; parent._layout &amp;&amp; !parent._layout.isNative()) {
          parent.reflow();
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      }

      <span class="hljs-comment">/**
       * Sets/gets the parent container for the control.
       *
       * @method parent
       * @param {tinymce.ui.Container} parent Optional parent to set.
       * @return {tinymce.ui.Control} Parent control or the current control on a set action.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1449">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1449">&#182;</a>
              </div>
              <p>parent: function(parent) {}  Generated</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Sets/gets the text for the control.
       *
       * @method text
       * @param {String} value Value to set to control.
       * @return {String/tinymce.ui.Control} Current control on a set operation or current value on a get.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1450">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1450">&#182;</a>
              </div>
              <p>text: function(value) {}  Generated</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Sets/gets the disabled state on the control.
       *
       * @method disabled
       * @param {Boolean} state Value to set to control.
       * @return {Boolean/tinymce.ui.Control} Current control on a set operation or current state on a get.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1451">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1451">&#182;</a>
              </div>
              <p>disabled: function(state) {}  Generated</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Sets/gets the active for the control.
       *
       * @method active
       * @param {Boolean} state Value to set to control.
       * @return {Boolean/tinymce.ui.Control} Current control on a set operation or current state on a get.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1452">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1452">&#182;</a>
              </div>
              <p>active: function(state) {}  Generated</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Sets/gets the name for the control.
       *
       * @method name
       * @param {String} value Value to set to control.
       * @return {String/tinymce.ui.Control} Current control on a set operation or current value on a get.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1453">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1453">&#182;</a>
              </div>
              <p>name: function(value) {}  Generated</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Sets/gets the title for the control.
       *
       * @method title
       * @param {String} value Value to set to control.
       * @return {String/tinymce.ui.Control} Current control on a set operation or current value on a get.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1454">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1454">&#182;</a>
              </div>
              <p>title: function(value) {}  Generated</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Sets/gets the visible for the control.
       *
       * @method visible
       * @param {Boolean} state Value to set to control.
       * @return {Boolean/tinymce.ui.Control} Current control on a set operation or current state on a get.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1455">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1455">&#182;</a>
              </div>
              <p>visible: function(value) {}  Generated</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    };

    <span class="hljs-comment">/**
     * Setup state properties.
     */</span>
    Tools.each(<span class="hljs-string">'text title visible disabled active value'</span>.split(<span class="hljs-string">' '</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
      proto[name] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.get(name);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value != <span class="hljs-string">"undefined"</span>) {
          <span class="hljs-keyword">this</span>.state.set(name, value);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      };
    });

    Control = Class.extend(proto);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventDispatcher</span>(<span class="hljs-params">obj</span>) </span>{
      <span class="hljs-keyword">if</span> (!obj._eventDispatcher) {
        obj._eventDispatcher = <span class="hljs-keyword">new</span> EventDispatcher({
          <span class="hljs-attr">scope</span>: obj,
          <span class="hljs-attr">toggleEvent</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, state</span>) </span>{
            <span class="hljs-keyword">if</span> (state &amp;&amp; EventDispatcher.isNative(name)) {
              <span class="hljs-keyword">if</span> (!obj._nativeEvents) {
                obj._nativeEvents = {};
              }

              obj._nativeEvents[name] = <span class="hljs-literal">true</span>;

              <span class="hljs-keyword">if</span> (obj.state.get(<span class="hljs-string">'rendered'</span>)) {
                bindPendingEvents(obj);
              }
            }
          }
        });
      }

      <span class="hljs-keyword">return</span> obj._eventDispatcher;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindPendingEvents</span>(<span class="hljs-params">eventCtrl</span>) </span>{
      <span class="hljs-keyword">var</span> i, l, parents, eventRootCtrl, nativeEvents, name;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delegate</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> control = eventCtrl.getParentCtrl(e.target);

        <span class="hljs-keyword">if</span> (control) {
          control.fire(e.type, e);
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseLeaveHandler</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> ctrl = eventRootCtrl._lastHoverCtrl;

        <span class="hljs-keyword">if</span> (ctrl) {
          ctrl.fire(<span class="hljs-string">"mouseleave"</span>, { <span class="hljs-attr">target</span>: ctrl.getEl() });

          ctrl.parents().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
            ctrl.fire(<span class="hljs-string">"mouseleave"</span>, { <span class="hljs-attr">target</span>: ctrl.getEl() });
          });

          eventRootCtrl._lastHoverCtrl = <span class="hljs-literal">null</span>;
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseEnterHandler</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> ctrl = eventCtrl.getParentCtrl(e.target), lastCtrl = eventRootCtrl._lastHoverCtrl, idx = <span class="hljs-number">0</span>, i, parents, lastParents;</pre></div></div>
            
        </li>
        
        
        <li id="section-1456">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1456">&#182;</a>
              </div>
              <p>Over on a new control</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (ctrl !== lastCtrl) {
          eventRootCtrl._lastHoverCtrl = ctrl;

          parents = ctrl.parents().toArray().reverse();
          parents.push(ctrl);

          <span class="hljs-keyword">if</span> (lastCtrl) {
            lastParents = lastCtrl.parents().toArray().reverse();
            lastParents.push(lastCtrl);

            <span class="hljs-keyword">for</span> (idx = <span class="hljs-number">0</span>; idx &lt; lastParents.length; idx++) {
              <span class="hljs-keyword">if</span> (parents[idx] !== lastParents[idx]) {
                <span class="hljs-keyword">break</span>;
              }
            }

            <span class="hljs-keyword">for</span> (i = lastParents.length - <span class="hljs-number">1</span>; i &gt;= idx; i--) {
              lastCtrl = lastParents[i];
              lastCtrl.fire(<span class="hljs-string">"mouseleave"</span>, {
                <span class="hljs-attr">target</span>: lastCtrl.getEl()
              });
            }
          }

          <span class="hljs-keyword">for</span> (i = idx; i &lt; parents.length; i++) {
            ctrl = parents[i];
            ctrl.fire(<span class="hljs-string">"mouseenter"</span>, {
              <span class="hljs-attr">target</span>: ctrl.getEl()
            });
          }
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fixWheelEvent</span>(<span class="hljs-params">e</span>) </span>{
        e.preventDefault();

        <span class="hljs-keyword">if</span> (e.type == <span class="hljs-string">"mousewheel"</span>) {
          e.deltaY = <span class="hljs-number">-1</span> / <span class="hljs-number">40</span> * e.wheelDelta;

          <span class="hljs-keyword">if</span> (e.wheelDeltaX) {
            e.deltaX = <span class="hljs-number">-1</span> / <span class="hljs-number">40</span> * e.wheelDeltaX;
          }
        } <span class="hljs-keyword">else</span> {
          e.deltaX = <span class="hljs-number">0</span>;
          e.deltaY = e.detail;
        }

        e = eventCtrl.fire(<span class="hljs-string">"wheel"</span>, e);
      }

      nativeEvents = eventCtrl._nativeEvents;
      <span class="hljs-keyword">if</span> (nativeEvents) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1457">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1457">&#182;</a>
              </div>
              <p>Find event root element if it exists</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        parents = eventCtrl.parents().toArray();
        parents.unshift(eventCtrl);
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = parents.length; !eventRootCtrl &amp;&amp; i &lt; l; i++) {
          eventRootCtrl = parents[i]._eventsRoot;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1458">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1458">&#182;</a>
              </div>
              <p>Event root wasnt found the use the root control</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!eventRootCtrl) {
          eventRootCtrl = parents[parents.length - <span class="hljs-number">1</span>] || eventCtrl;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1459">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1459">&#182;</a>
              </div>
              <p>Set the eventsRoot property on children that didnt have it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        eventCtrl._eventsRoot = eventRootCtrl;
        <span class="hljs-keyword">for</span> (l = i, i = <span class="hljs-number">0</span>; i &lt; l; i++) {
          parents[i]._eventsRoot = eventRootCtrl;
        }

        <span class="hljs-keyword">var</span> eventRootDelegates = eventRootCtrl._delegates;
        <span class="hljs-keyword">if</span> (!eventRootDelegates) {
          eventRootDelegates = eventRootCtrl._delegates = {};
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1460">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1460">&#182;</a>
              </div>
              <p>Bind native event delegates</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> nativeEvents) {
          <span class="hljs-keyword">if</span> (!nativeEvents) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

          <span class="hljs-keyword">if</span> (name === <span class="hljs-string">"wheel"</span> &amp;&amp; !hasWheelEventSupport) {
            <span class="hljs-keyword">if</span> (hasMouseWheelEventSupport) {
              $(eventCtrl.getEl()).on(<span class="hljs-string">"mousewheel"</span>, fixWheelEvent);
            } <span class="hljs-keyword">else</span> {
              $(eventCtrl.getEl()).on(<span class="hljs-string">"DOMMouseScroll"</span>, fixWheelEvent);
            }

            <span class="hljs-keyword">continue</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1461">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1461">&#182;</a>
              </div>
              <p>Special treatment for mousenter/mouseleave since these doesnt bubble</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (name === <span class="hljs-string">"mouseenter"</span> || name === <span class="hljs-string">"mouseleave"</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1462">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1462">&#182;</a>
              </div>
              <p>Fake mousenter/mouseleave</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!eventRootCtrl._hasMouseEnter) {
              $(eventRootCtrl.getEl()).on(<span class="hljs-string">"mouseleave"</span>, mouseLeaveHandler).on(<span class="hljs-string">"mouseover"</span>, mouseEnterHandler);
              eventRootCtrl._hasMouseEnter = <span class="hljs-number">1</span>;
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!eventRootDelegates[name]) {
            $(eventRootCtrl.getEl()).on(name, delegate);
            eventRootDelegates[name] = <span class="hljs-literal">true</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1463">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1463">&#182;</a>
              </div>
              <p>Remove the event once its bound</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          nativeEvents[name] = <span class="hljs-literal">false</span>;
        }
      }
    }

    <span class="hljs-keyword">return</span> Control;
  }
);

<span class="hljs-comment">/**
 * Factory.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class is a factory for control instances. This enables you
 * to create instances of controls without having to require the UI controls directly.
 *
 * It also allow you to override or add new control types.
 *
 * @class tinymce.ui.Factory
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Factory'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> types = {};

    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">/**
       * Adds a new control instance type to the factory.
       *
       * @method add
       * @param {String} type Type name for example "button".
       * @param {function} typeClass Class type function.
       */</span>
      add: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, typeClass</span>) </span>{
        types[type.toLowerCase()] = typeClass;
      },

      <span class="hljs-comment">/**
       * Returns true/false if the specified type exists or not.
       *
       * @method has
       * @param {String} type Type to look for.
       * @return {Boolean} true/false if the control by name exists.
       */</span>
      has: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
        <span class="hljs-keyword">return</span> !!types[type.toLowerCase()];
      },

      <span class="hljs-comment">/**
       * Creates a new control instance based on the settings provided. The instance created will be
       * based on the specified type property it can also create whole structures of components out of
       * the specified JSON object.
       *
       * @example
       * tinymce.ui.Factory.create({
       *     type: 'button',
       *     text: 'Hello world!'
       * });
       *
       * @method create
       * @param {Object/String} settings Name/Value object with items used to create the type.
       * @return {tinymce.ui.Control} Control instance based on the specified type.
       */</span>
      create: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, settings</span>) </span>{
        <span class="hljs-keyword">var</span> ControlType;</pre></div></div>
            
        </li>
        
        
        <li id="section-1464">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1464">&#182;</a>
              </div>
              <p>If string is specified then use it as the type</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type == <span class="hljs-string">'string'</span>) {
          settings = settings || {};
          settings.type = type;
        } <span class="hljs-keyword">else</span> {
          settings = type;
          type = settings.type;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1465">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1465">&#182;</a>
              </div>
              <p>Find control type</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        type = type.toLowerCase();
        ControlType = types[type];</pre></div></div>
            
        </li>
        
        
        <li id="section-1466">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1466">&#182;</a>
              </div>
              <p>#if debug</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">if</span> (!ControlType) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Could not find control by type: "</span> + type);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1467">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1467">&#182;</a>
              </div>
              <p>#endif</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        ControlType = <span class="hljs-keyword">new</span> ControlType(settings);
        ControlType.type = type; <span class="hljs-comment">// Set the type on the instance, this will be used by the Selector engine</span>

        <span class="hljs-keyword">return</span> ControlType;
      }
    };
  }
);
<span class="hljs-comment">/**
 * KeyboardNavigation.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class handles keyboard navigation of controls and elements.
 *
 * @class tinymce.ui.KeyboardNavigation
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.KeyboardNavigation'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> hasTabstopData = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> elm.getAttribute(<span class="hljs-string">'data-mce-tabstop'</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
    };

    <span class="hljs-comment">/**
     * This class handles all keyboard navigation for WAI-ARIA support. Each root container
     * gets an instance of this class.
     *
     * @constructor
     */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
      <span class="hljs-keyword">var</span> root = settings.root, focusedElement, focusedControl;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isElement</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> node &amp;&amp; node.nodeType === <span class="hljs-number">1</span>;
      }

      <span class="hljs-keyword">try</span> {
        focusedElement = <span class="hljs-built_in">document</span>.activeElement;
      } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1468">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1468">&#182;</a>
              </div>
              <p>IE sometimes fails to return a proper element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        focusedElement = <span class="hljs-built_in">document</span>.body;
      }

      focusedControl = root.getParentCtrl(focusedElement);

      <span class="hljs-comment">/**
       * Returns the currently focused elements wai aria role of the currently
       * focused element or specified element.
       *
       * @private
       * @param {Element} elm Optional element to get role from.
       * @return {String} Role of specified element.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRole</span>(<span class="hljs-params">elm</span>) </span>{
        elm = elm || focusedElement;

        <span class="hljs-keyword">if</span> (isElement(elm)) {
          <span class="hljs-keyword">return</span> elm.getAttribute(<span class="hljs-string">'role'</span>);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-comment">/**
       * Returns the wai role of the parent element of the currently
       * focused element or specified element.
       *
       * @private
       * @param {Element} elm Optional element to get parent role from.
       * @return {String} Role of the first parent that has a role.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParentRole</span>(<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">var</span> role, parent = elm || focusedElement;

        <span class="hljs-keyword">while</span> ((parent = parent.parentNode)) {
          <span class="hljs-keyword">if</span> ((role = getRole(parent))) {
            <span class="hljs-keyword">return</span> role;
          }
        }
      }

      <span class="hljs-comment">/**
       * Returns a wai aria property by name for example aria-selected.
       *
       * @private
       * @param {String} name Name of the aria property to get for example "disabled".
       * @return {String} Aria property value.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAriaProp</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">var</span> elm = focusedElement;

        <span class="hljs-keyword">if</span> (isElement(elm)) {
          <span class="hljs-keyword">return</span> elm.getAttribute(<span class="hljs-string">'aria-'</span> + name);
        }
      }

      <span class="hljs-comment">/**
       * Is the element a text input element or not.
       *
       * @private
       * @param {Element} elm Element to check if it's an text input element or not.
       * @return {Boolean} True/false if the element is a text element or not.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTextInputElement</span>(<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">var</span> tagName = elm.tagName.toUpperCase();</pre></div></div>
            
        </li>
        
        
        <li id="section-1469">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1469">&#182;</a>
              </div>
              <p>Notice: since type can be email etc we dont check the type
So all input elements gets treated as text input elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> tagName == <span class="hljs-string">"INPUT"</span> || tagName == <span class="hljs-string">"TEXTAREA"</span> || tagName == <span class="hljs-string">"SELECT"</span>;
      }

      <span class="hljs-comment">/**
       * Returns true/false if the specified element can be focused or not.
       *
       * @private
       * @param {Element} elm DOM element to check if it can be focused or not.
       * @return {Boolean} True/false if the element can have focus.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canFocus</span>(<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">if</span> (isTextInputElement(elm) &amp;&amp; !elm.hidden) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (hasTabstopData(elm)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(button|menuitem|checkbox|tab|menuitemcheckbox|option|gridcell|slider)$/</span>.test(getRole(elm))) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-comment">/**
       * Returns an array of focusable visible elements within the specified container element.
       *
       * @private
       * @param {Element} elm DOM element to find focusable elements within.
       * @return {Array} Array of focusable elements.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFocusElements</span>(<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">var</span> elements = [];

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collect</span>(<span class="hljs-params">elm</span>) </span>{
          <span class="hljs-keyword">if</span> (elm.nodeType != <span class="hljs-number">1</span> || elm.style.display == <span class="hljs-string">'none'</span> || elm.disabled) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (canFocus(elm)) {
            elements.push(elm);
          }

          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; elm.childNodes.length; i++) {
            collect(elm.childNodes[i]);
          }
        }

        collect(elm || root.getEl());

        <span class="hljs-keyword">return</span> elements;
      }

      <span class="hljs-comment">/**
       * Returns the navigation root control for the specified control. The navigation root
       * is the control that the keyboard navigation gets scoped to for example a menubar or toolbar group.
       * It will look for parents of the specified target control or the currently focused control if this option is omitted.
       *
       * @private
       * @param {tinymce.ui.Control} targetControl Optional target control to find root of.
       * @return {tinymce.ui.Control} Navigation root control.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNavigationRoot</span>(<span class="hljs-params">targetControl</span>) </span>{
        <span class="hljs-keyword">var</span> navigationRoot, controls;

        targetControl = targetControl || focusedControl;
        controls = targetControl.parents().toArray();
        controls.unshift(targetControl);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; controls.length; i++) {
          navigationRoot = controls[i];

          <span class="hljs-keyword">if</span> (navigationRoot.settings.ariaRoot) {
            <span class="hljs-keyword">break</span>;
          }
        }

        <span class="hljs-keyword">return</span> navigationRoot;
      }

      <span class="hljs-comment">/**
       * Focuses the first item in the specified targetControl element or the last aria index if the
       * navigation root has the ariaRemember option enabled.
       *
       * @private
       * @param {tinymce.ui.Control} targetControl Target control to focus the first item in.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">focusFirst</span>(<span class="hljs-params">targetControl</span>) </span>{
        <span class="hljs-keyword">var</span> navigationRoot = getNavigationRoot(targetControl);
        <span class="hljs-keyword">var</span> focusElements = getFocusElements(navigationRoot.getEl());

        <span class="hljs-keyword">if</span> (navigationRoot.settings.ariaRemember &amp;&amp; <span class="hljs-string">"lastAriaIndex"</span> <span class="hljs-keyword">in</span> navigationRoot) {
          moveFocusToIndex(navigationRoot.lastAriaIndex, focusElements);
        } <span class="hljs-keyword">else</span> {
          moveFocusToIndex(<span class="hljs-number">0</span>, focusElements);
        }
      }

      <span class="hljs-comment">/**
       * Moves the focus to the specified index within the elements list.
       * This will scope the index to the size of the element list if it changed.
       *
       * @private
       * @param {Number} idx Specified index to move to.
       * @param {Array} elements Array with dom elements to move focus within.
       * @return {Number} Input index or a changed index if it was out of range.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveFocusToIndex</span>(<span class="hljs-params">idx, elements</span>) </span>{
        <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span>) {
          idx = elements.length - <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idx &gt;= elements.length) {
          idx = <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">if</span> (elements[idx]) {
          elements[idx].focus();
        }

        <span class="hljs-keyword">return</span> idx;
      }

      <span class="hljs-comment">/**
       * Moves the focus forwards or backwards.
       *
       * @private
       * @param {Number} dir Direction to move in positive means forward, negative means backwards.
       * @param {Array} elements Optional array of elements to move within defaults to the current navigation roots elements.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveFocus</span>(<span class="hljs-params">dir, elements</span>) </span>{
        <span class="hljs-keyword">var</span> idx = <span class="hljs-number">-1</span>, navigationRoot = getNavigationRoot();

        elements = elements || getFocusElements(navigationRoot.getEl());

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; elements.length; i++) {
          <span class="hljs-keyword">if</span> (elements[i] === focusedElement) {
            idx = i;
          }
        }

        idx += dir;
        navigationRoot.lastAriaIndex = moveFocusToIndex(idx, elements);
      }

      <span class="hljs-comment">/**
       * Moves the focus to the left this is called by the left key.
       *
       * @private
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">left</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> parentRole = getParentRole();

        <span class="hljs-keyword">if</span> (parentRole == <span class="hljs-string">"tablist"</span>) {
          moveFocus(<span class="hljs-number">-1</span>, getFocusElements(focusedElement.parentNode));
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (focusedControl.parent().submenu) {
          cancel();
        } <span class="hljs-keyword">else</span> {
          moveFocus(<span class="hljs-number">-1</span>);
        }
      }

      <span class="hljs-comment">/**
       * Moves the focus to the right this is called by the right key.
       *
       * @private
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">right</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> role = getRole(), parentRole = getParentRole();

        <span class="hljs-keyword">if</span> (parentRole == <span class="hljs-string">"tablist"</span>) {
          moveFocus(<span class="hljs-number">1</span>, getFocusElements(focusedElement.parentNode));
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (role == <span class="hljs-string">"menuitem"</span> &amp;&amp; parentRole == <span class="hljs-string">"menu"</span> &amp;&amp; getAriaProp(<span class="hljs-string">'haspopup'</span>)) {
          enter();
        } <span class="hljs-keyword">else</span> {
          moveFocus(<span class="hljs-number">1</span>);
        }
      }

      <span class="hljs-comment">/**
       * Moves the focus to the up this is called by the up key.
       *
       * @private
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">up</span>(<span class="hljs-params"></span>) </span>{
        moveFocus(<span class="hljs-number">-1</span>);
      }

      <span class="hljs-comment">/**
       * Moves the focus to the up this is called by the down key.
       *
       * @private
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">down</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> role = getRole(), parentRole = getParentRole();

        <span class="hljs-keyword">if</span> (role == <span class="hljs-string">"menuitem"</span> &amp;&amp; parentRole == <span class="hljs-string">"menubar"</span>) {
          enter();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (role == <span class="hljs-string">"button"</span> &amp;&amp; getAriaProp(<span class="hljs-string">'haspopup'</span>)) {
          enter({ <span class="hljs-attr">key</span>: <span class="hljs-string">'down'</span> });
        } <span class="hljs-keyword">else</span> {
          moveFocus(<span class="hljs-number">1</span>);
        }
      }

      <span class="hljs-comment">/**
       * Moves the focus to the next item or previous item depending on shift key.
       *
       * @private
       * @param {DOMEvent} e DOM event object.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tab</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> parentRole = getParentRole();

        <span class="hljs-keyword">if</span> (parentRole == <span class="hljs-string">"tablist"</span>) {
          <span class="hljs-keyword">var</span> elm = getFocusElements(focusedControl.getEl(<span class="hljs-string">'body'</span>))[<span class="hljs-number">0</span>];

          <span class="hljs-keyword">if</span> (elm) {
            elm.focus();
          }
        } <span class="hljs-keyword">else</span> {
          moveFocus(e.shiftKey ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>);
        }
      }

      <span class="hljs-comment">/**
       * Calls the cancel event on the currently focused control. This is normally done using the Esc key.
       *
       * @private
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancel</span>(<span class="hljs-params"></span>) </span>{
        focusedControl.fire(<span class="hljs-string">'cancel'</span>);
      }

      <span class="hljs-comment">/**
       * Calls the click event on the currently focused control. This is normally done using the Enter/Space keys.
       *
       * @private
       * @param {Object} aria Optional aria data to pass along with the enter event.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enter</span>(<span class="hljs-params">aria</span>) </span>{
        aria = aria || {};
        focusedControl.fire(<span class="hljs-string">'click'</span>, { <span class="hljs-attr">target</span>: focusedElement, <span class="hljs-attr">aria</span>: aria });
      }

      root.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleNonTabOrEscEvent</span>(<span class="hljs-params">e, handler</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1470">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1470">&#182;</a>
              </div>
              <p>Ignore non tab keys for text elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (isTextInputElement(focusedElement) || hasTabstopData(focusedElement)) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (getRole(focusedElement) === <span class="hljs-string">'slider'</span>) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (handler(e) !== <span class="hljs-literal">false</span>) {
            e.preventDefault();
          }
        }

        <span class="hljs-keyword">if</span> (e.isDefaultPrevented()) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">switch</span> (e.keyCode) {
          <span class="hljs-keyword">case</span> <span class="hljs-number">37</span>: <span class="hljs-comment">// DOM_VK_LEFT</span>
            handleNonTabOrEscEvent(e, left);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-number">39</span>: <span class="hljs-comment">// DOM_VK_RIGHT</span>
            handleNonTabOrEscEvent(e, right);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-number">38</span>: <span class="hljs-comment">// DOM_VK_UP</span>
            handleNonTabOrEscEvent(e, up);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-number">40</span>: <span class="hljs-comment">// DOM_VK_DOWN</span>
            handleNonTabOrEscEvent(e, down);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-number">27</span>: <span class="hljs-comment">// DOM_VK_ESCAPE</span>
            cancel();
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>: <span class="hljs-comment">// DOM_VK_ENTER</span>
          <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>: <span class="hljs-comment">// DOM_VK_RETURN</span>
          <span class="hljs-keyword">case</span> <span class="hljs-number">32</span>: <span class="hljs-comment">// DOM_VK_SPACE</span>
            handleNonTabOrEscEvent(e, enter);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: <span class="hljs-comment">// DOM_VK_TAB</span>
            <span class="hljs-keyword">if</span> (tab(e) !== <span class="hljs-literal">false</span>) {
              e.preventDefault();
            }
            <span class="hljs-keyword">break</span>;
        }
      });

      root.on(<span class="hljs-string">'focusin'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        focusedElement = e.target;
        focusedControl = e.control;
      });

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">focusFirst</span>: focusFirst
      };
    };
  }
);
<span class="hljs-comment">/**
 * Container.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Container control. This is extended by all controls that can have
 * children such as panels etc. You can also use this class directly as an
 * generic container instance. The container doesn't have any specific role or style.
 *
 * @-x-less Container.less
 * @class tinymce.ui.Container
 * @extends tinymce.ui.Control
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Container'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Control"</span>,
    <span class="hljs-string">"tinymce.core.ui.Collection"</span>,
    <span class="hljs-string">"tinymce.core.ui.Selector"</span>,
    <span class="hljs-string">"tinymce.core.ui.Factory"</span>,
    <span class="hljs-string">"tinymce.core.ui.KeyboardNavigation"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.dom.DomQuery"</span>,
    <span class="hljs-string">"tinymce.core.ui.ClassList"</span>,
    <span class="hljs-string">"tinymce.core.ui.ReflowQueue"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Control, Collection, Selector, Factory, KeyboardNavigation, Tools, $, ClassList, ReflowQueue</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> selectorCache = {};

    <span class="hljs-keyword">return</span> Control.extend({
      <span class="hljs-comment">/**
       * Constructs a new control instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {Array} items Items to add to container in JSON format or control instances.
       * @setting {String} layout Layout manager by name to use.
       * @setting {Object} defaults Default settings to apply to all items.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super(settings);
        settings = self.settings;

        <span class="hljs-keyword">if</span> (settings.fixed) {
          self.state.set(<span class="hljs-string">'fixed'</span>, <span class="hljs-literal">true</span>);
        }

        self._items = <span class="hljs-keyword">new</span> Collection();

        <span class="hljs-keyword">if</span> (self.isRtl()) {
          self.classes.add(<span class="hljs-string">'rtl'</span>);
        }

        self.bodyClasses = <span class="hljs-keyword">new</span> ClassList(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'rendered'</span>)) {
            self.getEl(<span class="hljs-string">'body'</span>).className = <span class="hljs-keyword">this</span>.toString();
          }
        });
        self.bodyClasses.prefix = self.classPrefix;

        self.classes.add(<span class="hljs-string">'container'</span>);
        self.bodyClasses.add(<span class="hljs-string">'container-body'</span>);

        <span class="hljs-keyword">if</span> (settings.containerCls) {
          self.classes.add(settings.containerCls);
        }

        self._layout = Factory.create((settings.layout || <span class="hljs-string">''</span>) + <span class="hljs-string">'layout'</span>);

        <span class="hljs-keyword">if</span> (self.settings.items) {
          self.add(self.settings.items);
        } <span class="hljs-keyword">else</span> {
          self.add(self.render());
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1471">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1471">&#182;</a>
              </div>
              <p>TODO: Fix this!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self._hasBody = <span class="hljs-literal">true</span>;
      },

      <span class="hljs-comment">/**
       * Returns a collection of child items that the container currently have.
       *
       * @method items
       * @return {tinymce.ui.Collection} Control collection direct child controls.
       */</span>
      items: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._items;
      },

      <span class="hljs-comment">/**
       * Find child controls by selector.
       *
       * @method find
       * @param {String} selector Selector CSS pattern to find children by.
       * @return {tinymce.ui.Collection} Control collection with child controls.
       */</span>
      find: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
        selector = selectorCache[selector] = selectorCache[selector] || <span class="hljs-keyword">new</span> Selector(selector);

        <span class="hljs-keyword">return</span> selector.find(<span class="hljs-keyword">this</span>);
      },

      <span class="hljs-comment">/**
       * Adds one or many items to the current container. This will create instances of
       * the object representations if needed.
       *
       * @method add
       * @param {Array/Object/tinymce.ui.Control} items Array or item that will be added to the container.
       * @return {tinymce.ui.Collection} Current collection control.
       */</span>
      add: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.items().add(self.create(items)).parent(self);

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Focuses the current container instance. This will look
       * for the first control in the container and focus that.
       *
       * @method focus
       * @param {Boolean} keyboard Optional true/false if the focus was a keyboard focus or not.
       * @return {tinymce.ui.Collection} Current instance.
       */</span>
      focus: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">keyboard</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, focusCtrl, keyboardNav, items;

        <span class="hljs-keyword">if</span> (keyboard) {
          keyboardNav = self.keyboardNav || self.parents().eq(<span class="hljs-number">-1</span>)[<span class="hljs-number">0</span>].keyboardNav;

          <span class="hljs-keyword">if</span> (keyboardNav) {
            keyboardNav.focusFirst(self);
            <span class="hljs-keyword">return</span>;
          }
        }

        items = self.find(<span class="hljs-string">'*'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1472">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1472">&#182;</a>
              </div>
              <p>TODO: Figure out a better way to auto focus alert dialog buttons</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self.statusbar) {
          items.add(self.statusbar.items());
        }

        items.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
          <span class="hljs-keyword">if</span> (ctrl.settings.autofocus) {
            focusCtrl = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

          <span class="hljs-keyword">if</span> (ctrl.canFocus) {
            focusCtrl = focusCtrl || ctrl;
          }
        });

        <span class="hljs-keyword">if</span> (focusCtrl) {
          focusCtrl.focus();
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Replaces the specified child control with a new control.
       *
       * @method replace
       * @param {tinymce.ui.Control} oldItem Old item to be replaced.
       * @param {tinymce.ui.Control} newItem New item to be inserted.
       */</span>
      replace: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">oldItem, newItem</span>) </span>{
        <span class="hljs-keyword">var</span> ctrlElm, items = <span class="hljs-keyword">this</span>.items(), i = items.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-1473">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1473">&#182;</a>
              </div>
              <p>Replace the item in collection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">while</span> (i--) {
          <span class="hljs-keyword">if</span> (items[i] === oldItem) {
            items[i] = newItem;
            <span class="hljs-keyword">break</span>;
          }
        }

        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1474">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1474">&#182;</a>
              </div>
              <p>Remove new item from DOM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          ctrlElm = newItem.getEl();
          <span class="hljs-keyword">if</span> (ctrlElm) {
            ctrlElm.parentNode.removeChild(ctrlElm);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1475">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1475">&#182;</a>
              </div>
              <p>Remove old item from DOM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          ctrlElm = oldItem.getEl();
          <span class="hljs-keyword">if</span> (ctrlElm) {
            ctrlElm.parentNode.removeChild(ctrlElm);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1476">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1476">&#182;</a>
              </div>
              <p>Adopt the item</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        newItem.parent(<span class="hljs-keyword">this</span>);
      },

      <span class="hljs-comment">/**
       * Creates the specified items. If any of the items is plain JSON style objects
       * it will convert these into real tinymce.ui.Control instances.
       *
       * @method create
       * @param {Array} items Array of items to convert into control instances.
       * @return {Array} Array with control instances.
       */</span>
      create: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, settings, ctrlItems = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-1477">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1477">&#182;</a>
              </div>
              <p>Non array structure, then force it into an array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!Tools.isArray(items)) {
          items = [items];
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1478">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1478">&#182;</a>
              </div>
              <p>Add default type to each child control</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        Tools.each(items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          <span class="hljs-keyword">if</span> (item) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1479">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1479">&#182;</a>
              </div>
              <p>Construct item if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!(item <span class="hljs-keyword">instanceof</span> Control)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1480">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1480">&#182;</a>
              </div>
              <p>Name only then convert it to an object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item == <span class="hljs-string">"string"</span>) {
                item = { <span class="hljs-attr">type</span>: item };
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-1481">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1481">&#182;</a>
              </div>
              <p>Create control instance based on input settings and default settings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              settings = Tools.extend({}, self.settings.defaults, item);
              item.type = settings.type = settings.type || item.type || self.settings.defaultType ||
                (settings.defaults ? settings.defaults.type : <span class="hljs-literal">null</span>);
              item = Factory.create(settings);
            }

            ctrlItems.push(item);
          }
        });

        <span class="hljs-keyword">return</span> ctrlItems;
      },

      <span class="hljs-comment">/**
       * Renders new control instances.
       *
       * @private
       */</span>
      renderNew: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1482">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1482">&#182;</a>
              </div>
              <p>Render any new items</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl, index</span>) </span>{
          <span class="hljs-keyword">var</span> containerElm;

          ctrl.parent(self);

          <span class="hljs-keyword">if</span> (!ctrl.state.get(<span class="hljs-string">'rendered'</span>)) {
            containerElm = self.getEl(<span class="hljs-string">'body'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1483">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1483">&#182;</a>
              </div>
              <p>Insert or append the item</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (containerElm.hasChildNodes() &amp;&amp; index &lt;= containerElm.childNodes.length - <span class="hljs-number">1</span>) {
              $(containerElm.childNodes[index]).before(ctrl.renderHtml());
            } <span class="hljs-keyword">else</span> {
              $(containerElm).append(ctrl.renderHtml());
            }

            ctrl.postRender();
            ReflowQueue.add(ctrl);
          }
        });

        self._layout.applyClasses(self.items().filter(<span class="hljs-string">':visible'</span>));
        self._lastRect = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Appends new instances to the current container.
       *
       * @method append
       * @param {Array/tinymce.ui.Collection} items Array if controls to append.
       * @return {tinymce.ui.Container} Current container instance.
       */</span>
      append: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.add(items).renderNew();
      },

      <span class="hljs-comment">/**
       * Prepends new instances to the current container.
       *
       * @method prepend
       * @param {Array/tinymce.ui.Collection} items Array if controls to prepend.
       * @return {tinymce.ui.Container} Current container instance.
       */</span>
      prepend: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.items().set(self.create(items).concat(self.items().toArray()));

        <span class="hljs-keyword">return</span> self.renderNew();
      },

      <span class="hljs-comment">/**
       * Inserts an control at a specific index.
       *
       * @method insert
       * @param {Array/tinymce.ui.Collection} items Array if controls to insert.
       * @param {Number} index Index to insert controls at.
       * @param {Boolean} [before=false] Inserts controls before the index.
       */</span>
      insert: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items, index, before</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, curItems, beforeItems, afterItems;

        items = self.create(items);
        curItems = self.items();

        <span class="hljs-keyword">if</span> (!before &amp;&amp; index &lt; curItems.length - <span class="hljs-number">1</span>) {
          index += <span class="hljs-number">1</span>;
        }

        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; curItems.length) {
          beforeItems = curItems.slice(<span class="hljs-number">0</span>, index).toArray();
          afterItems = curItems.slice(index).toArray();
          curItems.set(beforeItems.concat(items, afterItems));
        }

        <span class="hljs-keyword">return</span> self.renderNew();
      },

      <span class="hljs-comment">/**
       * Populates the form fields from the specified JSON data object.
       *
       * Control items in the form that matches the data will have it's value set.
       *
       * @method fromJSON
       * @param {Object} data JSON data object to set control values by.
       * @return {tinymce.ui.Container} Current form instance.
       */</span>
      fromJSON: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> data) {
          self.find(<span class="hljs-string">'#'</span> + name).value(data[name]);
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Serializes the form into a JSON object by getting all items
       * that has a name and a value.
       *
       * @method toJSON
       * @return {Object} JSON object with form data.
       */</span>
      toJSON: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, data = {};

        self.find(<span class="hljs-string">'*'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
          <span class="hljs-keyword">var</span> name = ctrl.name(), value = ctrl.value();

          <span class="hljs-keyword">if</span> (name &amp;&amp; <span class="hljs-keyword">typeof</span> value != <span class="hljs-string">"undefined"</span>) {
            data[name] = value;
          }
        });

        <span class="hljs-keyword">return</span> data;
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, layout = self._layout, role = <span class="hljs-keyword">this</span>.settings.role;

        self.preRender();
        layout.preRender(self);

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'"'</span> + (role ? <span class="hljs-string">' role="'</span> + <span class="hljs-keyword">this</span>.settings.role + <span class="hljs-string">'"'</span> : <span class="hljs-string">''</span>) + <span class="hljs-string">'&gt;'</span> +
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'-body" class="'</span> + self.bodyClasses + <span class="hljs-string">'"&gt;'</span> +
          (self.settings.html || <span class="hljs-string">''</span>) + layout.renderHtml(self) +
          <span class="hljs-string">'&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-comment">/**
       * Post render method. Called after the control has been rendered to the target.
       *
       * @method postRender
       * @return {tinymce.ui.Container} Current combobox instance.
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, box;

        self.items().exec(<span class="hljs-string">'postRender'</span>);
        self._super();

        self._layout.postRender(self);
        self.state.set(<span class="hljs-string">'rendered'</span>, <span class="hljs-literal">true</span>);

        <span class="hljs-keyword">if</span> (self.settings.style) {
          self.$el.css(self.settings.style);
        }

        <span class="hljs-keyword">if</span> (self.settings.border) {
          box = self.borderBox;
          self.$el.css({
            <span class="hljs-string">'border-top-width'</span>: box.top,
            <span class="hljs-string">'border-right-width'</span>: box.right,
            <span class="hljs-string">'border-bottom-width'</span>: box.bottom,
            <span class="hljs-string">'border-left-width'</span>: box.left
          });
        }

        <span class="hljs-keyword">if</span> (!self.parent()) {
          self.keyboardNav = <span class="hljs-keyword">new</span> KeyboardNavigation({
            <span class="hljs-attr">root</span>: self
          });
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Initializes the current controls layout rect.
       * This will be executed by the layout managers to determine the
       * default minWidth/minHeight etc.
       *
       * @method initLayoutRect
       * @return {Object} Layout rect instance.
       */</span>
      initLayoutRect: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, layoutRect = self._super();</pre></div></div>
            
        </li>
        
        
        <li id="section-1484">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1484">&#182;</a>
              </div>
              <p>Recalc container size by asking layout manager</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self._layout.recalc(self);

        <span class="hljs-keyword">return</span> layoutRect;
      },

      <span class="hljs-comment">/**
       * Recalculates the positions of the controls in the current container.
       * This is invoked by the reflow method and shouldn't be called directly.
       *
       * @method recalc
       */</span>
      recalc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, rect = self._layoutRect, lastRect = self._lastRect;

        <span class="hljs-keyword">if</span> (!lastRect || lastRect.w != rect.w || lastRect.h != rect.h) {
          self._layout.recalc(self);
          rect = self.layoutRect();
          self._lastRect = { <span class="hljs-attr">x</span>: rect.x, <span class="hljs-attr">y</span>: rect.y, <span class="hljs-attr">w</span>: rect.w, <span class="hljs-attr">h</span>: rect.h };
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      },

      <span class="hljs-comment">/**
       * Reflows the current container and it's children and possible parents.
       * This should be used after you for example append children to the current control so
       * that the layout managers know that they need to reposition everything.
       *
       * @example
       * container.append({type: 'button', text: 'My button'}).reflow();
       *
       * @method reflow
       * @return {tinymce.ui.Container} Current container instance.
       */</span>
      reflow: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> i;

        ReflowQueue.remove(<span class="hljs-keyword">this</span>);

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.visible()) {
          Control.repaintControls = [];
          Control.repaintControls.map = {};

          <span class="hljs-keyword">this</span>.recalc();
          i = Control.repaintControls.length;

          <span class="hljs-keyword">while</span> (i--) {
            Control.repaintControls[i].repaint();
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1485">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1485">&#182;</a>
              </div>
              <p>TODO: Fix me!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.settings.layout !== <span class="hljs-string">"flow"</span> &amp;&amp; <span class="hljs-keyword">this</span>.settings.layout !== <span class="hljs-string">"stack"</span>) {
            <span class="hljs-keyword">this</span>.repaint();
          }

          Control.repaintControls = [];
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      }
    });
  }
);
<span class="hljs-comment">/**
 * DragHelper.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Drag/drop helper class.
 *
 * @example
 * var dragHelper = new tinymce.ui.DragHelper('mydiv', {
 *     start: function(evt) {
 *     },
 *
 *     drag: function(evt) {
 *     },
 *
 *     end: function(evt) {
 *     }
 * });
 *
 * @class tinymce.ui.DragHelper
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.DragHelper'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.DomQuery"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDocumentSize</span>(<span class="hljs-params">doc</span>) </span>{
      <span class="hljs-keyword">var</span> documentElement, body, scrollWidth, clientWidth;
      <span class="hljs-keyword">var</span> offsetWidth, scrollHeight, clientHeight, offsetHeight, max = <span class="hljs-built_in">Math</span>.max;

      documentElement = doc.documentElement;
      body = doc.body;

      scrollWidth = max(documentElement.scrollWidth, body.scrollWidth);
      clientWidth = max(documentElement.clientWidth, body.clientWidth);
      offsetWidth = max(documentElement.offsetWidth, body.offsetWidth);

      scrollHeight = max(documentElement.scrollHeight, body.scrollHeight);
      clientHeight = max(documentElement.clientHeight, body.clientHeight);
      offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">width</span>: scrollWidth &lt; offsetWidth ? clientWidth : scrollWidth,
        <span class="hljs-attr">height</span>: scrollHeight &lt; offsetHeight ? clientHeight : scrollHeight
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateWithTouchData</span>(<span class="hljs-params">e</span>) </span>{
      <span class="hljs-keyword">var</span> keys, i;

      <span class="hljs-keyword">if</span> (e.changedTouches) {
        keys = <span class="hljs-string">"screenX screenY pageX pageY clientX clientY"</span>.split(<span class="hljs-string">' '</span>);
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) {
          e[keys[i]] = e.changedTouches[<span class="hljs-number">0</span>][keys[i]];
        }
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, settings</span>) </span>{
      <span class="hljs-keyword">var</span> $eventOverlay, doc = settings.document || <span class="hljs-built_in">document</span>, downButton, start, stop, drag, startX, startY;

      settings = settings || {};

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHandleElm</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> doc.getElementById(settings.handle || id);
      }

      start = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> docSize = getDocumentSize(doc), handleElm, cursor;

        updateWithTouchData(e);

        e.preventDefault();
        downButton = e.button;
        handleElm = getHandleElm();
        startX = e.screenX;
        startY = e.screenY;</pre></div></div>
            
        </li>
        
        
        <li id="section-1486">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1486">&#182;</a>
              </div>
              <p>Grab cursor from handle so we can place it on overlay</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.getComputedStyle) {
          cursor = <span class="hljs-built_in">window</span>.getComputedStyle(handleElm, <span class="hljs-literal">null</span>).getPropertyValue(<span class="hljs-string">"cursor"</span>);
        } <span class="hljs-keyword">else</span> {
          cursor = handleElm.runtimeStyle.cursor;
        }

        $eventOverlay = $(<span class="hljs-string">'&lt;div&gt;&lt;/div&gt;'</span>).css({
          <span class="hljs-attr">position</span>: <span class="hljs-string">"absolute"</span>,
          <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>,
          <span class="hljs-attr">width</span>: docSize.width,
          <span class="hljs-attr">height</span>: docSize.height,
          <span class="hljs-attr">zIndex</span>: <span class="hljs-number">0x7FFFFFFF</span>,
          <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.0001</span>,
          <span class="hljs-attr">cursor</span>: cursor
        }).appendTo(doc.body);

        $(doc).on(<span class="hljs-string">'mousemove touchmove'</span>, drag).on(<span class="hljs-string">'mouseup touchend'</span>, stop);

        settings.start(e);
      };

      drag = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        updateWithTouchData(e);

        <span class="hljs-keyword">if</span> (e.button !== downButton) {
          <span class="hljs-keyword">return</span> stop(e);
        }

        e.deltaX = e.screenX - startX;
        e.deltaY = e.screenY - startY;

        e.preventDefault();
        settings.drag(e);
      };

      stop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        updateWithTouchData(e);

        $(doc).off(<span class="hljs-string">'mousemove touchmove'</span>, drag).off(<span class="hljs-string">'mouseup touchend'</span>, stop);

        $eventOverlay.remove();

        <span class="hljs-keyword">if</span> (settings.stop) {
          settings.stop(e);
        }
      };

      <span class="hljs-comment">/**
       * Destroys the drag/drop helper instance.
       *
       * @method destroy
       */</span>
      <span class="hljs-keyword">this</span>.destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        $(getHandleElm()).off();
      };

      $(getHandleElm()).on(<span class="hljs-string">'mousedown touchstart'</span>, start);
    };
  }
);
<span class="hljs-comment">/**
 * Scrollable.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This mixin makes controls scrollable using custom scrollbars.
 *
 * @-x-less Scrollable.less
 * @mixin tinymce.ui.Scrollable
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Scrollable'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.DomQuery"</span>,
    <span class="hljs-string">"tinymce.core.ui.DragHelper"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$, DragHelper</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
        self.on(<span class="hljs-string">'repaint'</span>, self.renderScroll);
      },

      <span class="hljs-attr">renderScroll</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, margin = <span class="hljs-number">2</span>;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repaintScroll</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> hasScrollH, hasScrollV, bodyElm;

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repaintAxis</span>(<span class="hljs-params">axisName, posName, sizeName, contentSizeName, hasScroll, ax</span>) </span>{
            <span class="hljs-keyword">var</span> containerElm, scrollBarElm, scrollThumbElm;
            <span class="hljs-keyword">var</span> containerSize, scrollSize, ratio, rect;
            <span class="hljs-keyword">var</span> posNameLower, sizeNameLower;

            scrollBarElm = self.getEl(<span class="hljs-string">'scroll'</span> + axisName);
            <span class="hljs-keyword">if</span> (scrollBarElm) {
              posNameLower = posName.toLowerCase();
              sizeNameLower = sizeName.toLowerCase();

              $(self.getEl(<span class="hljs-string">'absend'</span>)).css(posNameLower, self.layoutRect()[contentSizeName] - <span class="hljs-number">1</span>);

              <span class="hljs-keyword">if</span> (!hasScroll) {
                $(scrollBarElm).css(<span class="hljs-string">'display'</span>, <span class="hljs-string">'none'</span>);
                <span class="hljs-keyword">return</span>;
              }

              $(scrollBarElm).css(<span class="hljs-string">'display'</span>, <span class="hljs-string">'block'</span>);
              containerElm = self.getEl(<span class="hljs-string">'body'</span>);
              scrollThumbElm = self.getEl(<span class="hljs-string">'scroll'</span> + axisName + <span class="hljs-string">"t"</span>);
              containerSize = containerElm[<span class="hljs-string">"client"</span> + sizeName] - (margin * <span class="hljs-number">2</span>);
              containerSize -= hasScrollH &amp;&amp; hasScrollV ? scrollBarElm[<span class="hljs-string">"client"</span> + ax] : <span class="hljs-number">0</span>;
              scrollSize = containerElm[<span class="hljs-string">"scroll"</span> + sizeName];
              ratio = containerSize / scrollSize;

              rect = {};
              rect[posNameLower] = containerElm[<span class="hljs-string">"offset"</span> + posName] + margin;
              rect[sizeNameLower] = containerSize;
              $(scrollBarElm).css(rect);

              rect = {};
              rect[posNameLower] = containerElm[<span class="hljs-string">"scroll"</span> + posName] * ratio;
              rect[sizeNameLower] = containerSize * ratio;
              $(scrollThumbElm).css(rect);
            }
          }

          bodyElm = self.getEl(<span class="hljs-string">'body'</span>);
          hasScrollH = bodyElm.scrollWidth &gt; bodyElm.clientWidth;
          hasScrollV = bodyElm.scrollHeight &gt; bodyElm.clientHeight;

          repaintAxis(<span class="hljs-string">"h"</span>, <span class="hljs-string">"Left"</span>, <span class="hljs-string">"Width"</span>, <span class="hljs-string">"contentW"</span>, hasScrollH, <span class="hljs-string">"Height"</span>);
          repaintAxis(<span class="hljs-string">"v"</span>, <span class="hljs-string">"Top"</span>, <span class="hljs-string">"Height"</span>, <span class="hljs-string">"contentH"</span>, hasScrollV, <span class="hljs-string">"Width"</span>);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addScroll</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addScrollAxis</span>(<span class="hljs-params">axisName, posName, sizeName, deltaPosName, ax</span>) </span>{
            <span class="hljs-keyword">var</span> scrollStart, axisId = self._id + <span class="hljs-string">'-scroll'</span> + axisName, prefix = self.classPrefix;

            $(self.getEl()).append(
              <span class="hljs-string">'&lt;div id="'</span> + axisId + <span class="hljs-string">'" class="'</span> + prefix + <span class="hljs-string">'scrollbar '</span> + prefix + <span class="hljs-string">'scrollbar-'</span> + axisName + <span class="hljs-string">'"&gt;'</span> +
              <span class="hljs-string">'&lt;div id="'</span> + axisId + <span class="hljs-string">'t" class="'</span> + prefix + <span class="hljs-string">'scrollbar-thumb"&gt;&lt;/div&gt;'</span> +
              <span class="hljs-string">'&lt;/div&gt;'</span>
            );

            self.draghelper = <span class="hljs-keyword">new</span> DragHelper(axisId + <span class="hljs-string">'t'</span>, {
              <span class="hljs-attr">start</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                scrollStart = self.getEl(<span class="hljs-string">'body'</span>)[<span class="hljs-string">"scroll"</span> + posName];
                $(<span class="hljs-string">'#'</span> + axisId).addClass(prefix + <span class="hljs-string">'active'</span>);
              },

              <span class="hljs-attr">drag</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> ratio, hasScrollH, hasScrollV, containerSize, layoutRect = self.layoutRect();

                hasScrollH = layoutRect.contentW &gt; layoutRect.innerW;
                hasScrollV = layoutRect.contentH &gt; layoutRect.innerH;
                containerSize = self.getEl(<span class="hljs-string">'body'</span>)[<span class="hljs-string">"client"</span> + sizeName] - (margin * <span class="hljs-number">2</span>);
                containerSize -= hasScrollH &amp;&amp; hasScrollV ? self.getEl(<span class="hljs-string">'scroll'</span> + axisName)[<span class="hljs-string">"client"</span> + ax] : <span class="hljs-number">0</span>;

                ratio = containerSize / self.getEl(<span class="hljs-string">'body'</span>)[<span class="hljs-string">"scroll"</span> + sizeName];
                self.getEl(<span class="hljs-string">'body'</span>)[<span class="hljs-string">"scroll"</span> + posName] = scrollStart + (e[<span class="hljs-string">"delta"</span> + deltaPosName] / ratio);
              },

              <span class="hljs-attr">stop</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                $(<span class="hljs-string">'#'</span> + axisId).removeClass(prefix + <span class="hljs-string">'active'</span>);
              }
            });
          }

          self.classes.add(<span class="hljs-string">'scroll'</span>);

          addScrollAxis(<span class="hljs-string">"v"</span>, <span class="hljs-string">"Top"</span>, <span class="hljs-string">"Height"</span>, <span class="hljs-string">"Y"</span>, <span class="hljs-string">"Width"</span>);
          addScrollAxis(<span class="hljs-string">"h"</span>, <span class="hljs-string">"Left"</span>, <span class="hljs-string">"Width"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"Height"</span>);
        }

        <span class="hljs-keyword">if</span> (self.settings.autoScroll) {
          <span class="hljs-keyword">if</span> (!self._hasScroll) {
            self._hasScroll = <span class="hljs-literal">true</span>;
            addScroll();

            self.on(<span class="hljs-string">'wheel'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
              <span class="hljs-keyword">var</span> bodyEl = self.getEl(<span class="hljs-string">'body'</span>);

              bodyEl.scrollLeft += (e.deltaX || <span class="hljs-number">0</span>) * <span class="hljs-number">10</span>;
              bodyEl.scrollTop += e.deltaY * <span class="hljs-number">10</span>;

              repaintScroll();
            });

            $(self.getEl(<span class="hljs-string">'body'</span>)).on(<span class="hljs-string">"scroll"</span>, repaintScroll);
          }

          repaintScroll();
        }
      }
    };
  }
);
<span class="hljs-comment">/**
 * Panel.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a new panel.
 *
 * @-x-less Panel.less
 * @class tinymce.ui.Panel
 * @extends tinymce.ui.Container
 * @mixes tinymce.ui.Scrollable
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Panel'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Container"</span>,
    <span class="hljs-string">"tinymce.core.ui.Scrollable"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Container, Scrollable</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Container.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">layout</span>: <span class="hljs-string">'fit'</span>,
        <span class="hljs-attr">containerCls</span>: <span class="hljs-string">'panel'</span>
      },

      <span class="hljs-attr">Mixins</span>: [Scrollable],

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, layout = self._layout, innerHtml = self.settings.html;

        self.preRender();
        layout.preRender(self);

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> innerHtml == <span class="hljs-string">"undefined"</span>) {
          innerHtml = (
            <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'-body" class="'</span> + self.bodyClasses + <span class="hljs-string">'"&gt;'</span> +
            layout.renderHtml(self) +
            <span class="hljs-string">'&lt;/div&gt;'</span>
          );
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> innerHtml == <span class="hljs-string">'function'</span>) {
            innerHtml = innerHtml.call(self);
          }

          self._hasBody = <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'" hidefocus="1" tabindex="-1" role="group"&gt;'</span> +
          (self._preBodyHtml || <span class="hljs-string">''</span>) +
          innerHtml +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      }
    });
  }
);

<span class="hljs-comment">/**
 * Movable.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Movable mixin. Makes controls movable absolute and relative to other elements.
 *
 * @mixin tinymce.ui.Movable
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Movable'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.DomUtils"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">DomUtils</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateRelativePosition</span>(<span class="hljs-params">ctrl, targetElm, rel</span>) </span>{
      <span class="hljs-keyword">var</span> ctrlElm, pos, x, y, selfW, selfH, targetW, targetH, viewport, size;

      viewport = DomUtils.getViewPort();</pre></div></div>
            
        </li>
        
        
        <li id="section-1487">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1487">&#182;</a>
              </div>
              <p>Get pos of target</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      pos = DomUtils.getPos(targetElm);
      x = pos.x;
      y = pos.y;

      <span class="hljs-keyword">if</span> (ctrl.state.get(<span class="hljs-string">'fixed'</span>) &amp;&amp; DomUtils.getRuntimeStyle(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">'position'</span>) == <span class="hljs-string">'static'</span>) {
        x -= viewport.x;
        y -= viewport.y;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1488">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1488">&#182;</a>
              </div>
              <p>Get size of self</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      ctrlElm = ctrl.getEl();
      size = DomUtils.getSize(ctrlElm);
      selfW = size.width;
      selfH = size.height;</pre></div></div>
            
        </li>
        
        
        <li id="section-1489">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1489">&#182;</a>
              </div>
              <p>Get size of target</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      size = DomUtils.getSize(targetElm);
      targetW = size.width;
      targetH = size.height;</pre></div></div>
            
        </li>
        
        
        <li id="section-1490">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1490">&#182;</a>
              </div>
              <p>Parse align string</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      rel = (rel || <span class="hljs-string">''</span>).split(<span class="hljs-string">''</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1491">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1491">&#182;</a>
              </div>
              <p>Target corners</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">0</span>] === <span class="hljs-string">'b'</span>) {
        y += targetH;
      }

      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">1</span>] === <span class="hljs-string">'r'</span>) {
        x += targetW;
      }

      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">0</span>] === <span class="hljs-string">'c'</span>) {
        y += <span class="hljs-built_in">Math</span>.round(targetH / <span class="hljs-number">2</span>);
      }

      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">1</span>] === <span class="hljs-string">'c'</span>) {
        x += <span class="hljs-built_in">Math</span>.round(targetW / <span class="hljs-number">2</span>);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1492">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1492">&#182;</a>
              </div>
              <p>Self corners</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">3</span>] === <span class="hljs-string">'b'</span>) {
        y -= selfH;
      }

      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">4</span>] === <span class="hljs-string">'r'</span>) {
        x -= selfW;
      }

      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">3</span>] === <span class="hljs-string">'c'</span>) {
        y -= <span class="hljs-built_in">Math</span>.round(selfH / <span class="hljs-number">2</span>);
      }

      <span class="hljs-keyword">if</span> (rel[<span class="hljs-number">4</span>] === <span class="hljs-string">'c'</span>) {
        x -= <span class="hljs-built_in">Math</span>.round(selfW / <span class="hljs-number">2</span>);
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">x</span>: x,
        <span class="hljs-attr">y</span>: y,
        <span class="hljs-attr">w</span>: selfW,
        <span class="hljs-attr">h</span>: selfH
      };
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">/**
       * Tests various positions to get the most suitable one.
       *
       * @method testMoveRel
       * @param {DOMElement} elm Element to position against.
       * @param {Array} rels Array with relative positions.
       * @return {String} Best suitable relative position.
       */</span>
      testMoveRel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, rels</span>) </span>{
        <span class="hljs-keyword">var</span> viewPortRect = DomUtils.getViewPort();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; rels.length; i++) {
          <span class="hljs-keyword">var</span> pos = calculateRelativePosition(<span class="hljs-keyword">this</span>, elm, rels[i]);

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.get(<span class="hljs-string">'fixed'</span>)) {
            <span class="hljs-keyword">if</span> (pos.x &gt; <span class="hljs-number">0</span> &amp;&amp; pos.x + pos.w &lt; viewPortRect.w &amp;&amp; pos.y &gt; <span class="hljs-number">0</span> &amp;&amp; pos.y + pos.h &lt; viewPortRect.h) {
              <span class="hljs-keyword">return</span> rels[i];
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (pos.x &gt; viewPortRect.x &amp;&amp; pos.x + pos.w &lt; viewPortRect.w + viewPortRect.x &amp;&amp;
              pos.y &gt; viewPortRect.y &amp;&amp; pos.y + pos.h &lt; viewPortRect.h + viewPortRect.y) {
              <span class="hljs-keyword">return</span> rels[i];
            }
          }
        }

        <span class="hljs-keyword">return</span> rels[<span class="hljs-number">0</span>];
      },

      <span class="hljs-comment">/**
       * Move relative to the specified element.
       *
       * @method moveRel
       * @param {Element} elm Element to move relative to.
       * @param {String} rel Relative mode. For example: br-tl.
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      moveRel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, rel</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> rel != <span class="hljs-string">'string'</span>) {
          rel = <span class="hljs-keyword">this</span>.testMoveRel(elm, rel);
        }

        <span class="hljs-keyword">var</span> pos = calculateRelativePosition(<span class="hljs-keyword">this</span>, elm, rel);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.moveTo(pos.x, pos.y);
      },

      <span class="hljs-comment">/**
       * Move by a relative x, y values.
       *
       * @method moveBy
       * @param {Number} dx Relative x position.
       * @param {Number} dy Relative y position.
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      moveBy: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dx, dy</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, rect = self.layoutRect();

        self.moveTo(rect.x + dx, rect.y + dy);

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Move to absolute position.
       *
       * @method moveTo
       * @param {Number} x Absolute x position.
       * @param {Number} y Absolute y position.
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      moveTo: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1493">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1493">&#182;</a>
              </div>
              <p>TODO: Move this to some global class</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constrain</span>(<span class="hljs-params">value, max, size</span>) </span>{
          <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
          }

          <span class="hljs-keyword">if</span> (value + size &gt; max) {
            value = max - size;
            <span class="hljs-keyword">return</span> value &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : value;
          }

          <span class="hljs-keyword">return</span> value;
        }

        <span class="hljs-keyword">if</span> (self.settings.constrainToViewport) {
          <span class="hljs-keyword">var</span> viewPortRect = DomUtils.getViewPort(<span class="hljs-built_in">window</span>);
          <span class="hljs-keyword">var</span> layoutRect = self.layoutRect();

          x = constrain(x, viewPortRect.w + viewPortRect.x, layoutRect.w);
          y = constrain(y, viewPortRect.h + viewPortRect.y, layoutRect.h);
        }

        <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'rendered'</span>)) {
          self.layoutRect({ <span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y }).repaint();
        } <span class="hljs-keyword">else</span> {
          self.settings.x = x;
          self.settings.y = y;
        }

        self.fire(<span class="hljs-string">'move'</span>, { <span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y });

        <span class="hljs-keyword">return</span> self;
      }
    };
  }
);
<span class="hljs-comment">/**
 * Resizable.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Resizable mixin. Enables controls to be resized.
 *
 * @mixin tinymce.ui.Resizable
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Resizable'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.DomUtils"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">DomUtils</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">/**
       * Resizes the control to contents.
       *
       * @method resizeToContent
       */</span>
      resizeToContent: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._layoutRect.autoResize = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">this</span>._lastRect = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">this</span>.reflow();
      },

      <span class="hljs-comment">/**
       * Resizes the control to a specific width/height.
       *
       * @method resizeTo
       * @param {Number} w Control width.
       * @param {Number} h Control height.
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      resizeTo: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">w, h</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1494">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1494">&#182;</a>
              </div>
              <p>TODO: Fix hack</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (w &lt;= <span class="hljs-number">1</span> || h &lt;= <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">var</span> rect = DomUtils.getWindowSize();

          w = w &lt;= <span class="hljs-number">1</span> ? w * rect.w : w;
          h = h &lt;= <span class="hljs-number">1</span> ? h * rect.h : h;
        }

        <span class="hljs-keyword">this</span>._layoutRect.autoResize = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.layoutRect({ <span class="hljs-attr">minW</span>: w, <span class="hljs-attr">minH</span>: h, <span class="hljs-attr">w</span>: w, <span class="hljs-attr">h</span>: h }).reflow();
      },

      <span class="hljs-comment">/**
       * Resizes the control to a specific relative width/height.
       *
       * @method resizeBy
       * @param {Number} dw Relative control width.
       * @param {Number} dh Relative control height.
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      resizeBy: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dw, dh</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, rect = self.layoutRect();

        <span class="hljs-keyword">return</span> self.resizeTo(rect.w + dw, rect.h + dh);
      }
    };
  }
);
<span class="hljs-comment">/**
 * FloatPanel.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class creates a floating panel.
 *
 * @-x-less FloatPanel.less
 * @class tinymce.ui.FloatPanel
 * @extends tinymce.ui.Panel
 * @mixes tinymce.ui.Movable
 * @mixes tinymce.ui.Resizable
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.FloatPanel'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Panel"</span>,
    <span class="hljs-string">"tinymce.core.ui.Movable"</span>,
    <span class="hljs-string">"tinymce.core.ui.Resizable"</span>,
    <span class="hljs-string">"tinymce.core.ui.DomUtils"</span>,
    <span class="hljs-string">"tinymce.core.dom.DomQuery"</span>,
    <span class="hljs-string">"tinymce.core.util.Delay"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Panel, Movable, Resizable, DomUtils, $, Delay</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> documentClickHandler, documentScrollHandler, windowResizeHandler, visiblePanels = [];
    <span class="hljs-keyword">var</span> zOrder = [], hasModal;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isChildOf</span>(<span class="hljs-params">ctrl, parent</span>) </span>{
      <span class="hljs-keyword">while</span> (ctrl) {
        <span class="hljs-keyword">if</span> (ctrl == parent) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        ctrl = ctrl.parent();
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipOrHidePanels</span>(<span class="hljs-params">e</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1495">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1495">&#182;</a>
              </div>
              <p>Hide any float panel when a click/focus out is out side that float panel and the
float panels direct parent for example a click on a menu button</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> i = visiblePanels.length;

      <span class="hljs-keyword">while</span> (i--) {
        <span class="hljs-keyword">var</span> panel = visiblePanels[i], clickCtrl = panel.getParentCtrl(e.target);

        <span class="hljs-keyword">if</span> (panel.settings.autohide) {
          <span class="hljs-keyword">if</span> (clickCtrl) {
            <span class="hljs-keyword">if</span> (isChildOf(clickCtrl, panel) || panel.parent() === clickCtrl) {
              <span class="hljs-keyword">continue</span>;
            }
          }

          e = panel.fire(<span class="hljs-string">'autohide'</span>, { <span class="hljs-attr">target</span>: e.target });
          <span class="hljs-keyword">if</span> (!e.isDefaultPrevented()) {
            panel.hide();
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindDocumentClickHandler</span>(<span class="hljs-params"></span>) </span>{

      <span class="hljs-keyword">if</span> (!documentClickHandler) {
        documentClickHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1496">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1496">&#182;</a>
              </div>
              <p>Gecko fires click event and in the wrong order on Mac so lets normalize</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (e.button == <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">return</span>;
          }

          skipOrHidePanels(e);
        };

        $(<span class="hljs-built_in">document</span>).on(<span class="hljs-string">'click touchstart'</span>, documentClickHandler);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindDocumentScrollHandler</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!documentScrollHandler) {
        documentScrollHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> i;

          i = visiblePanels.length;
          <span class="hljs-keyword">while</span> (i--) {
            repositionPanel(visiblePanels[i]);
          }
        };

        $(<span class="hljs-built_in">window</span>).on(<span class="hljs-string">'scroll'</span>, documentScrollHandler);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindWindowResizeHandler</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!windowResizeHandler) {
        <span class="hljs-keyword">var</span> docElm = <span class="hljs-built_in">document</span>.documentElement, clientWidth = docElm.clientWidth, clientHeight = docElm.clientHeight;

        windowResizeHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1497">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1497">&#182;</a>
              </div>
              <p>Workaround for #7065 IE 7 fires resize events event though the window wasnt resized</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">document</span>.all || clientWidth != docElm.clientWidth || clientHeight != docElm.clientHeight) {
            clientWidth = docElm.clientWidth;
            clientHeight = docElm.clientHeight;
            FloatPanel.hideAll();
          }
        };

        $(<span class="hljs-built_in">window</span>).on(<span class="hljs-string">'resize'</span>, windowResizeHandler);
      }
    }

    <span class="hljs-comment">/**
     * Repositions the panel to the top of page if the panel is outside of the visual viewport. It will
     * also reposition all child panels of the current panel.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repositionPanel</span>(<span class="hljs-params">panel</span>) </span>{
      <span class="hljs-keyword">var</span> scrollY = DomUtils.getViewPort().y;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleFixedChildPanels</span>(<span class="hljs-params">fixed, deltaY</span>) </span>{
        <span class="hljs-keyword">var</span> parent;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; visiblePanels.length; i++) {
          <span class="hljs-keyword">if</span> (visiblePanels[i] != panel) {
            parent = visiblePanels[i].parent();

            <span class="hljs-keyword">while</span> (parent &amp;&amp; (parent = parent.parent())) {
              <span class="hljs-keyword">if</span> (parent == panel) {
                visiblePanels[i].fixed(fixed).moveBy(<span class="hljs-number">0</span>, deltaY).repaint();
              }
            }
          }
        }
      }

      <span class="hljs-keyword">if</span> (panel.settings.autofix) {
        <span class="hljs-keyword">if</span> (!panel.state.get(<span class="hljs-string">'fixed'</span>)) {
          panel._autoFixY = panel.layoutRect().y;

          <span class="hljs-keyword">if</span> (panel._autoFixY &lt; scrollY) {
            panel.fixed(<span class="hljs-literal">true</span>).layoutRect({ <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> }).repaint();
            toggleFixedChildPanels(<span class="hljs-literal">true</span>, scrollY - panel._autoFixY);
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (panel._autoFixY &gt; scrollY) {
            panel.fixed(<span class="hljs-literal">false</span>).layoutRect({ <span class="hljs-attr">y</span>: panel._autoFixY }).repaint();
            toggleFixedChildPanels(<span class="hljs-literal">false</span>, panel._autoFixY - scrollY);
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRemove</span>(<span class="hljs-params">add, ctrl</span>) </span>{
      <span class="hljs-keyword">var</span> i, zIndex = FloatPanel.zIndex || <span class="hljs-number">0xFFFF</span>, topModal;

      <span class="hljs-keyword">if</span> (add) {
        zOrder.push(ctrl);
      } <span class="hljs-keyword">else</span> {
        i = zOrder.length;

        <span class="hljs-keyword">while</span> (i--) {
          <span class="hljs-keyword">if</span> (zOrder[i] === ctrl) {
            zOrder.splice(i, <span class="hljs-number">1</span>);
          }
        }
      }

      <span class="hljs-keyword">if</span> (zOrder.length) {
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; zOrder.length; i++) {
          <span class="hljs-keyword">if</span> (zOrder[i].modal) {
            zIndex++;
            topModal = zOrder[i];
          }

          zOrder[i].getEl().style.zIndex = zIndex;
          zOrder[i].zIndex = zIndex;
          zIndex++;
        }
      }

      <span class="hljs-keyword">var</span> modalBlockEl = $(<span class="hljs-string">'#'</span> + ctrl.classPrefix + <span class="hljs-string">'modal-block'</span>, ctrl.getContainerElm())[<span class="hljs-number">0</span>];

      <span class="hljs-keyword">if</span> (topModal) {
        $(modalBlockEl).css(<span class="hljs-string">'z-index'</span>, topModal.zIndex - <span class="hljs-number">1</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (modalBlockEl) {
        modalBlockEl.parentNode.removeChild(modalBlockEl);
        hasModal = <span class="hljs-literal">false</span>;
      }

      FloatPanel.currentZIndex = zIndex;
    }

    <span class="hljs-keyword">var</span> FloatPanel = Panel.extend({
      <span class="hljs-attr">Mixins</span>: [Movable, Resizable],

      <span class="hljs-comment">/**
       * Constructs a new control instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {Boolean} autohide Automatically hide the panel.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super(settings);
        self._eventsRoot = self;

        self.classes.add(<span class="hljs-string">'floatpanel'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1498">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1498">&#182;</a>
              </div>
              <p>Hide floatpanes on click out side the root button</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (settings.autohide) {
          bindDocumentClickHandler();
          bindWindowResizeHandler();
          visiblePanels.push(self);
        }

        <span class="hljs-keyword">if</span> (settings.autofix) {
          bindDocumentScrollHandler();

          self.on(<span class="hljs-string">'move'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            repositionPanel(<span class="hljs-keyword">this</span>);
          });
        }

        self.on(<span class="hljs-string">'postrender show'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (e.control == self) {
            <span class="hljs-keyword">var</span> $modalBlockEl, prefix = self.classPrefix;

            <span class="hljs-keyword">if</span> (self.modal &amp;&amp; !hasModal) {
              $modalBlockEl = $(<span class="hljs-string">'#'</span> + prefix + <span class="hljs-string">'modal-block'</span>, self.getContainerElm());
              <span class="hljs-keyword">if</span> (!$modalBlockEl[<span class="hljs-number">0</span>]) {
                $modalBlockEl = $(
                  <span class="hljs-string">'&lt;div id="'</span> + prefix + <span class="hljs-string">'modal-block" class="'</span> + prefix + <span class="hljs-string">'reset '</span> + prefix + <span class="hljs-string">'fade"&gt;&lt;/div&gt;'</span>
                ).appendTo(self.getContainerElm());
              }

              Delay.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                $modalBlockEl.addClass(prefix + <span class="hljs-string">'in'</span>);
                $(self.getEl()).addClass(prefix + <span class="hljs-string">'in'</span>);
              });

              hasModal = <span class="hljs-literal">true</span>;
            }

            addRemove(<span class="hljs-literal">true</span>, self);
          }
        });

        self.on(<span class="hljs-string">'show'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          self.parents().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
            <span class="hljs-keyword">if</span> (ctrl.state.get(<span class="hljs-string">'fixed'</span>)) {
              self.fixed(<span class="hljs-literal">true</span>);
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          });
        });

        <span class="hljs-keyword">if</span> (settings.popover) {
          self._preBodyHtml = <span class="hljs-string">'&lt;div class="'</span> + self.classPrefix + <span class="hljs-string">'arrow"&gt;&lt;/div&gt;'</span>;
          self.classes.add(<span class="hljs-string">'popover'</span>).add(<span class="hljs-string">'bottom'</span>).add(self.isRtl() ? <span class="hljs-string">'end'</span> : <span class="hljs-string">'start'</span>);
        }

        self.aria(<span class="hljs-string">'label'</span>, settings.ariaLabel);
        self.aria(<span class="hljs-string">'labelledby'</span>, self._id);
        self.aria(<span class="hljs-string">'describedby'</span>, self.describedBy || self._id + <span class="hljs-string">'-none'</span>);
      },

      <span class="hljs-attr">fixed</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'fixed'</span>) != state) {
          <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'rendered'</span>)) {
            <span class="hljs-keyword">var</span> viewport = DomUtils.getViewPort();

            <span class="hljs-keyword">if</span> (state) {
              self.layoutRect().y -= viewport.y;
            } <span class="hljs-keyword">else</span> {
              self.layoutRect().y += viewport.y;
            }
          }

          self.classes.toggle(<span class="hljs-string">'fixed'</span>, state);
          self.state.set(<span class="hljs-string">'fixed'</span>, state);
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Shows the current float panel.
       *
       * @method show
       * @return {tinymce.ui.FloatPanel} Current floatpanel instance.
       */</span>
      show: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, i, state = self._super();

        i = visiblePanels.length;
        <span class="hljs-keyword">while</span> (i--) {
          <span class="hljs-keyword">if</span> (visiblePanels[i] === self) {
            <span class="hljs-keyword">break</span>;
          }
        }

        <span class="hljs-keyword">if</span> (i === <span class="hljs-number">-1</span>) {
          visiblePanels.push(self);
        }

        <span class="hljs-keyword">return</span> state;
      },

      <span class="hljs-comment">/**
       * Hides the current float panel.
       *
       * @method hide
       * @return {tinymce.ui.FloatPanel} Current floatpanel instance.
       */</span>
      hide: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        removeVisiblePanel(<span class="hljs-keyword">this</span>);
        addRemove(<span class="hljs-literal">false</span>, <span class="hljs-keyword">this</span>);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._super();
      },

      <span class="hljs-comment">/**
       * Hide all visible float panels with he autohide setting enabled. This is for
       * manually hiding floating menus or panels.
       *
       * @method hideAll
       */</span>
      hideAll: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        FloatPanel.hideAll();
      },

      <span class="hljs-comment">/**
       * Closes the float panel. This will remove the float panel from page and fire the close event.
       *
       * @method close
       */</span>
      close: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (!self.fire(<span class="hljs-string">'close'</span>).isDefaultPrevented()) {
          self.remove();
          addRemove(<span class="hljs-literal">false</span>, self);
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Removes the float panel from page.
       *
       * @method remove
       */</span>
      remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        removeVisiblePanel(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">this</span>._super();
      },

      <span class="hljs-attr">postRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (self.settings.bodyRole) {
          <span class="hljs-keyword">this</span>.getEl(<span class="hljs-string">'body'</span>).setAttribute(<span class="hljs-string">'role'</span>, self.settings.bodyRole);
        }

        <span class="hljs-keyword">return</span> self._super();
      }
    });

    <span class="hljs-comment">/**
     * Hide all visible float panels with he autohide setting enabled. This is for
     * manually hiding floating menus or panels.
     *
     * @static
     * @method hideAll
     */</span>
    FloatPanel.hideAll = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> i = visiblePanels.length;

      <span class="hljs-keyword">while</span> (i--) {
        <span class="hljs-keyword">var</span> panel = visiblePanels[i];

        <span class="hljs-keyword">if</span> (panel &amp;&amp; panel.settings.autohide) {
          panel.hide();
          visiblePanels.splice(i, <span class="hljs-number">1</span>);
        }
      }
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeVisiblePanel</span>(<span class="hljs-params">panel</span>) </span>{
      <span class="hljs-keyword">var</span> i;

      i = visiblePanels.length;
      <span class="hljs-keyword">while</span> (i--) {
        <span class="hljs-keyword">if</span> (visiblePanels[i] === panel) {
          visiblePanels.splice(i, <span class="hljs-number">1</span>);
        }
      }

      i = zOrder.length;
      <span class="hljs-keyword">while</span> (i--) {
        <span class="hljs-keyword">if</span> (zOrder[i] === panel) {
          zOrder.splice(i, <span class="hljs-number">1</span>);
        }
      }
    }

    <span class="hljs-keyword">return</span> FloatPanel;
  }
);

<span class="hljs-comment">/**
 * Window.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a new window.
 *
 * @-x-less Window.less
 * @class tinymce.ui.Window
 * @extends tinymce.ui.FloatPanel
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Window'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.FloatPanel"</span>,
    <span class="hljs-string">"tinymce.core.ui.Panel"</span>,
    <span class="hljs-string">"tinymce.core.ui.DomUtils"</span>,
    <span class="hljs-string">"tinymce.core.dom.DomQuery"</span>,
    <span class="hljs-string">"tinymce.core.ui.DragHelper"</span>,
    <span class="hljs-string">"tinymce.core.ui.BoxUtils"</span>,
    <span class="hljs-string">"tinymce.core.Env"</span>,
    <span class="hljs-string">"tinymce.core.util.Delay"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">FloatPanel, Panel, DomUtils, $, DragHelper, BoxUtils, Env, Delay</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> windows = [], oldMetaValue = <span class="hljs-string">''</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleFullScreenState</span>(<span class="hljs-params">state</span>) </span>{
      <span class="hljs-keyword">var</span> noScaleMetaValue = <span class="hljs-string">'width=device-width,initial-scale=1.0,user-scalable=0,minimum-scale=1.0,maximum-scale=1.0'</span>,
        viewport = $(<span class="hljs-string">"meta[name=viewport]"</span>)[<span class="hljs-number">0</span>],
        contentValue;

      <span class="hljs-keyword">if</span> (Env.overrideViewPort === <span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (!viewport) {
        viewport = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'meta'</span>);
        viewport.setAttribute(<span class="hljs-string">'name'</span>, <span class="hljs-string">'viewport'</span>);
        <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'head'</span>)[<span class="hljs-number">0</span>].appendChild(viewport);
      }

      contentValue = viewport.getAttribute(<span class="hljs-string">'content'</span>);
      <span class="hljs-keyword">if</span> (contentValue &amp;&amp; <span class="hljs-keyword">typeof</span> oldMetaValue != <span class="hljs-string">'undefined'</span>) {
        oldMetaValue = contentValue;
      }

      viewport.setAttribute(<span class="hljs-string">'content'</span>, state ? noScaleMetaValue : oldMetaValue);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleBodyFullScreenClasses</span>(<span class="hljs-params">classPrefix, state</span>) </span>{
      <span class="hljs-keyword">if</span> (checkFullscreenWindows() &amp;&amp; state === <span class="hljs-literal">false</span>) {
        $([<span class="hljs-built_in">document</span>.documentElement, <span class="hljs-built_in">document</span>.body]).removeClass(classPrefix + <span class="hljs-string">'fullscreen'</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkFullscreenWindows</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; windows.length; i++) {
        <span class="hljs-keyword">if</span> (windows[i]._fullscreen) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleWindowResize</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!Env.desktop) {
        <span class="hljs-keyword">var</span> lastSize = {
          <span class="hljs-attr">w</span>: <span class="hljs-built_in">window</span>.innerWidth,
          <span class="hljs-attr">h</span>: <span class="hljs-built_in">window</span>.innerHeight
        };

        Delay.setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> w = <span class="hljs-built_in">window</span>.innerWidth,
            h = <span class="hljs-built_in">window</span>.innerHeight;

          <span class="hljs-keyword">if</span> (lastSize.w != w || lastSize.h != h) {
            lastSize = {
              <span class="hljs-attr">w</span>: w,
              <span class="hljs-attr">h</span>: h
            };

            $(<span class="hljs-built_in">window</span>).trigger(<span class="hljs-string">'resize'</span>);
          }
        }, <span class="hljs-number">100</span>);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reposition</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> i, rect = DomUtils.getWindowSize(), layoutRect;

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; windows.length; i++) {
          layoutRect = windows[i].layoutRect();

          windows[i].moveTo(
            windows[i].settings.x || <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, rect.w / <span class="hljs-number">2</span> - layoutRect.w / <span class="hljs-number">2</span>),
            windows[i].settings.y || <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, rect.h / <span class="hljs-number">2</span> - layoutRect.h / <span class="hljs-number">2</span>)
          );
        }
      }

      $(<span class="hljs-built_in">window</span>).on(<span class="hljs-string">'resize'</span>, reposition);
    }

    <span class="hljs-keyword">var</span> Window = FloatPanel.extend({
      <span class="hljs-attr">modal</span>: <span class="hljs-literal">true</span>,

      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">border</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">layout</span>: <span class="hljs-string">'flex'</span>,
        <span class="hljs-attr">containerCls</span>: <span class="hljs-string">'panel'</span>,
        <span class="hljs-attr">role</span>: <span class="hljs-string">'dialog'</span>,
        <span class="hljs-attr">callbacks</span>: {
          <span class="hljs-attr">submit</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>.fire(<span class="hljs-string">'submit'</span>, { <span class="hljs-attr">data</span>: <span class="hljs-keyword">this</span>.toJSON() });
          },

          <span class="hljs-attr">close</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>.close();
          }
        }
      },

      <span class="hljs-comment">/**
       * Constructs a instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super(settings);

        <span class="hljs-keyword">if</span> (self.isRtl()) {
          self.classes.add(<span class="hljs-string">'rtl'</span>);
        }

        self.classes.add(<span class="hljs-string">'window'</span>);
        self.bodyClasses.add(<span class="hljs-string">'window-body'</span>);
        self.state.set(<span class="hljs-string">'fixed'</span>, <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1499">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1499">&#182;</a>
              </div>
              <p>Create statusbar</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (settings.buttons) {
          self.statusbar = <span class="hljs-keyword">new</span> Panel({
            <span class="hljs-attr">layout</span>: <span class="hljs-string">'flex'</span>,
            <span class="hljs-attr">border</span>: <span class="hljs-string">'1 0 0 0'</span>,
            <span class="hljs-attr">spacing</span>: <span class="hljs-number">3</span>,
            <span class="hljs-attr">padding</span>: <span class="hljs-number">10</span>,
            <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>,
            <span class="hljs-attr">pack</span>: self.isRtl() ? <span class="hljs-string">'start'</span> : <span class="hljs-string">'end'</span>,
            <span class="hljs-attr">defaults</span>: {
              <span class="hljs-attr">type</span>: <span class="hljs-string">'button'</span>
            },
            <span class="hljs-attr">items</span>: settings.buttons
          });

          self.statusbar.classes.add(<span class="hljs-string">'foot'</span>);
          self.statusbar.parent(self);
        }

        self.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> closeClass = self.classPrefix + <span class="hljs-string">'close'</span>;

          <span class="hljs-keyword">if</span> (DomUtils.hasClass(e.target, closeClass) || DomUtils.hasClass(e.target.parentNode, closeClass)) {
            self.close();
          }
        });

        self.on(<span class="hljs-string">'cancel'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          self.close();
        });

        self.aria(<span class="hljs-string">'describedby'</span>, self.describedBy || self._id + <span class="hljs-string">'-none'</span>);
        self.aria(<span class="hljs-string">'label'</span>, settings.title);
        self._fullscreen = <span class="hljs-literal">false</span>;
      },

      <span class="hljs-comment">/**
       * Recalculates the positions of the controls in the current container.
       * This is invoked by the reflow method and shouldn't be called directly.
       *
       * @method recalc
       */</span>
      recalc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, statusbar = self.statusbar, layoutRect, width, x, needsRecalc;

        <span class="hljs-keyword">if</span> (self._fullscreen) {
          self.layoutRect(DomUtils.getWindowSize());
          self.layoutRect().contentH = self.layoutRect().innerH;
        }

        self._super();

        layoutRect = self.layoutRect();</pre></div></div>
            
        </li>
        
        
        <li id="section-1500">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1500">&#182;</a>
              </div>
              <p>Resize window based on title width</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self.settings.title &amp;&amp; !self._fullscreen) {
          width = layoutRect.headerW;
          <span class="hljs-keyword">if</span> (width &gt; layoutRect.w) {
            x = layoutRect.x - <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, width / <span class="hljs-number">2</span>);
            self.layoutRect({ <span class="hljs-attr">w</span>: width, <span class="hljs-attr">x</span>: x });
            needsRecalc = <span class="hljs-literal">true</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1501">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1501">&#182;</a>
              </div>
              <p>Resize window based on statusbar width</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (statusbar) {
          statusbar.layoutRect({ <span class="hljs-attr">w</span>: self.layoutRect().innerW }).recalc();

          width = statusbar.layoutRect().minW + layoutRect.deltaW;
          <span class="hljs-keyword">if</span> (width &gt; layoutRect.w) {
            x = layoutRect.x - <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, width - layoutRect.w);
            self.layoutRect({ <span class="hljs-attr">w</span>: width, <span class="hljs-attr">x</span>: x });
            needsRecalc = <span class="hljs-literal">true</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1502">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1502">&#182;</a>
              </div>
              <p>Recalc body and disable auto resize</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (needsRecalc) {
          self.recalc();
        }
      },

      <span class="hljs-comment">/**
       * Initializes the current controls layout rect.
       * This will be executed by the layout managers to determine the
       * default minWidth/minHeight etc.
       *
       * @method initLayoutRect
       * @return {Object} Layout rect instance.
       */</span>
      initLayoutRect: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, layoutRect = self._super(), deltaH = <span class="hljs-number">0</span>, headEl;</pre></div></div>
            
        </li>
        
        
        <li id="section-1503">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1503">&#182;</a>
              </div>
              <p>Reserve vertical space for title</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self.settings.title &amp;&amp; !self._fullscreen) {
          headEl = self.getEl(<span class="hljs-string">'head'</span>);

          <span class="hljs-keyword">var</span> size = DomUtils.getSize(headEl);

          layoutRect.headerW = size.width;
          layoutRect.headerH = size.height;

          deltaH += layoutRect.headerH;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1504">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1504">&#182;</a>
              </div>
              <p>Reserve vertical space for statusbar</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self.statusbar) {
          deltaH += self.statusbar.layoutRect().h;
        }

        layoutRect.deltaH += deltaH;
        layoutRect.minH += deltaH;</pre></div></div>
            
        </li>
        
        
        <li id="section-1505">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1505">&#182;</a>
              </div>
              <p>layoutRect.innerH -= deltaH;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        layoutRect.h += deltaH;

        <span class="hljs-keyword">var</span> rect = DomUtils.getWindowSize();

        layoutRect.x = self.settings.x || <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, rect.w / <span class="hljs-number">2</span> - layoutRect.w / <span class="hljs-number">2</span>);
        layoutRect.y = self.settings.y || <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, rect.h / <span class="hljs-number">2</span> - layoutRect.h / <span class="hljs-number">2</span>);

        <span class="hljs-keyword">return</span> layoutRect;
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, layout = self._layout, id = self._id, prefix = self.classPrefix;
        <span class="hljs-keyword">var</span> settings = self.settings, headerHtml = <span class="hljs-string">''</span>, footerHtml = <span class="hljs-string">''</span>, html = settings.html;

        self.preRender();
        layout.preRender(self);

        <span class="hljs-keyword">if</span> (settings.title) {
          headerHtml = (
            <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'-head" class="'</span> + prefix + <span class="hljs-string">'window-head"&gt;'</span> +
            <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'-title" class="'</span> + prefix + <span class="hljs-string">'title"&gt;'</span> + self.encode(settings.title) + <span class="hljs-string">'&lt;/div&gt;'</span> +
            <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'-dragh" class="'</span> + prefix + <span class="hljs-string">'dragh"&gt;&lt;/div&gt;'</span> +
            <span class="hljs-string">'&lt;button type="button" class="'</span> + prefix + <span class="hljs-string">'close" aria-hidden="true"&gt;'</span> +
            <span class="hljs-string">'&lt;i class="mce-ico mce-i-remove"&gt;&lt;/i&gt;'</span> +
            <span class="hljs-string">'&lt;/button&gt;'</span> +
            <span class="hljs-string">'&lt;/div&gt;'</span>
          );
        }

        <span class="hljs-keyword">if</span> (settings.url) {
          html = <span class="hljs-string">'&lt;iframe src="'</span> + settings.url + <span class="hljs-string">'" tabindex="-1"&gt;&lt;/iframe&gt;'</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> html == <span class="hljs-string">"undefined"</span>) {
          html = layout.renderHtml(self);
        }

        <span class="hljs-keyword">if</span> (self.statusbar) {
          footerHtml = self.statusbar.renderHtml();
        }

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'" hidefocus="1"&gt;'</span> +
          <span class="hljs-string">'&lt;div class="'</span> + self.classPrefix + <span class="hljs-string">'reset" role="application"&gt;'</span> +
          headerHtml +
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'-body" class="'</span> + self.bodyClasses + <span class="hljs-string">'"&gt;'</span> +
          html +
          <span class="hljs-string">'&lt;/div&gt;'</span> +
          footerHtml +
          <span class="hljs-string">'&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-comment">/**
       * Switches the window fullscreen mode.
       *
       * @method fullscreen
       * @param {Boolean} state True/false state.
       * @return {tinymce.ui.Window} Current window instance.
       */</span>
      fullscreen: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, documentElement = <span class="hljs-built_in">document</span>.documentElement, slowRendering, prefix = self.classPrefix, layoutRect;

        <span class="hljs-keyword">if</span> (state != self._fullscreen) {
          $(<span class="hljs-built_in">window</span>).on(<span class="hljs-string">'resize'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> time;

            <span class="hljs-keyword">if</span> (self._fullscreen) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1506">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1506">&#182;</a>
              </div>
              <p>Time the layout time if its to slow use a timeout to not hog the CPU</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (!slowRendering) {
                time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();

                <span class="hljs-keyword">var</span> rect = DomUtils.getWindowSize();
                self.moveTo(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>).resizeTo(rect.w, rect.h);

                <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()) - time &gt; <span class="hljs-number">50</span>) {
                  slowRendering = <span class="hljs-literal">true</span>;
                }
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (!self._timer) {
                  self._timer = Delay.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">var</span> rect = DomUtils.getWindowSize();
                    self.moveTo(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>).resizeTo(rect.w, rect.h);

                    self._timer = <span class="hljs-number">0</span>;
                  }, <span class="hljs-number">50</span>);
                }
              }
            }
          });

          layoutRect = self.layoutRect();
          self._fullscreen = state;

          <span class="hljs-keyword">if</span> (!state) {
            self.borderBox = BoxUtils.parseBox(self.settings.border);
            self.getEl(<span class="hljs-string">'head'</span>).style.display = <span class="hljs-string">''</span>;
            layoutRect.deltaH += layoutRect.headerH;
            $([documentElement, <span class="hljs-built_in">document</span>.body]).removeClass(prefix + <span class="hljs-string">'fullscreen'</span>);
            self.classes.remove(<span class="hljs-string">'fullscreen'</span>);
            self.moveTo(self._initial.x, self._initial.y).resizeTo(self._initial.w, self._initial.h);
          } <span class="hljs-keyword">else</span> {
            self._initial = { <span class="hljs-attr">x</span>: layoutRect.x, <span class="hljs-attr">y</span>: layoutRect.y, <span class="hljs-attr">w</span>: layoutRect.w, <span class="hljs-attr">h</span>: layoutRect.h };

            self.borderBox = BoxUtils.parseBox(<span class="hljs-string">'0'</span>);
            self.getEl(<span class="hljs-string">'head'</span>).style.display = <span class="hljs-string">'none'</span>;
            layoutRect.deltaH -= layoutRect.headerH + <span class="hljs-number">2</span>;
            $([documentElement, <span class="hljs-built_in">document</span>.body]).addClass(prefix + <span class="hljs-string">'fullscreen'</span>);
            self.classes.add(<span class="hljs-string">'fullscreen'</span>);

            <span class="hljs-keyword">var</span> rect = DomUtils.getWindowSize();
            self.moveTo(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>).resizeTo(rect.w, rect.h);
          }
        }

        <span class="hljs-keyword">return</span> self.reflow();
      },

      <span class="hljs-comment">/**
       * Called after the control has been rendered.
       *
       * @method postRender
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, startPos;

        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          self.classes.add(<span class="hljs-string">'in'</span>);
          self.fire(<span class="hljs-string">'open'</span>);
        }, <span class="hljs-number">0</span>);

        self._super();

        <span class="hljs-keyword">if</span> (self.statusbar) {
          self.statusbar.postRender();
        }

        self.focus();

        <span class="hljs-keyword">this</span>.dragHelper = <span class="hljs-keyword">new</span> DragHelper(self._id + <span class="hljs-string">'-dragh'</span>, {
          <span class="hljs-attr">start</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            startPos = {
              <span class="hljs-attr">x</span>: self.layoutRect().x,
              <span class="hljs-attr">y</span>: self.layoutRect().y
            };
          },

          <span class="hljs-attr">drag</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            self.moveTo(startPos.x + e.deltaX, startPos.y + e.deltaY);
          }
        });

        self.on(<span class="hljs-string">'submit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (!e.isDefaultPrevented()) {
            self.close();
          }
        });

        windows.push(self);
        toggleFullScreenState(<span class="hljs-literal">true</span>);
      },

      <span class="hljs-comment">/**
       * Fires a submit event with the serialized form.
       *
       * @method submit
       * @return {Object} Event arguments object.
       */</span>
      submit: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.fire(<span class="hljs-string">'submit'</span>, { <span class="hljs-attr">data</span>: <span class="hljs-keyword">this</span>.toJSON() });
      },

      <span class="hljs-comment">/**
       * Removes the current control from DOM and from UI collections.
       *
       * @method remove
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, i;

        self.dragHelper.destroy();
        self._super();

        <span class="hljs-keyword">if</span> (self.statusbar) {
          <span class="hljs-keyword">this</span>.statusbar.remove();
        }

        toggleBodyFullScreenClasses(self.classPrefix, <span class="hljs-literal">false</span>);

        i = windows.length;
        <span class="hljs-keyword">while</span> (i--) {
          <span class="hljs-keyword">if</span> (windows[i] === self) {
            windows.splice(i, <span class="hljs-number">1</span>);
          }
        }

        toggleFullScreenState(windows.length &gt; <span class="hljs-number">0</span>);
      },

      <span class="hljs-comment">/**
       * Returns the contentWindow object of the iframe if it exists.
       *
       * @method getContentWindow
       * @return {Window} window object or null.
       */</span>
      getContentWindow: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> ifr = <span class="hljs-keyword">this</span>.getEl().getElementsByTagName(<span class="hljs-string">'iframe'</span>)[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">return</span> ifr ? ifr.contentWindow : <span class="hljs-literal">null</span>;
      }
    });

    handleWindowResize();

    <span class="hljs-keyword">return</span> Window;
  }
);
<span class="hljs-comment">/**
 * MessageBox.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class is used to create MessageBoxes like alerts/confirms etc.
 *
 * @class tinymce.ui.MessageBox
 * @extends tinymce.ui.FloatPanel
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.MessageBox'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Window"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Window</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> MessageBox = Window.extend({
      <span class="hljs-comment">/**
       * Constructs a instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        settings = {
          <span class="hljs-attr">border</span>: <span class="hljs-number">1</span>,
          <span class="hljs-attr">padding</span>: <span class="hljs-number">20</span>,
          <span class="hljs-attr">layout</span>: <span class="hljs-string">'flex'</span>,
          <span class="hljs-attr">pack</span>: <span class="hljs-string">"center"</span>,
          <span class="hljs-attr">align</span>: <span class="hljs-string">"center"</span>,
          <span class="hljs-attr">containerCls</span>: <span class="hljs-string">'panel'</span>,
          <span class="hljs-attr">autoScroll</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">buttons</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">"button"</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">"Ok"</span>, <span class="hljs-attr">action</span>: <span class="hljs-string">"ok"</span> },
          <span class="hljs-attr">items</span>: {
            <span class="hljs-attr">type</span>: <span class="hljs-string">"label"</span>,
            <span class="hljs-attr">multiline</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">maxWidth</span>: <span class="hljs-number">500</span>,
            <span class="hljs-attr">maxHeight</span>: <span class="hljs-number">200</span>
          }
        };

        <span class="hljs-keyword">this</span>._super(settings);
      },

      <span class="hljs-attr">Statics</span>: {
        <span class="hljs-comment">/**
         * Ok buttons constant.
         *
         * @static
         * @final
         * @field {Number} OK
         */</span>
        OK: <span class="hljs-number">1</span>,

        <span class="hljs-comment">/**
         * Ok/cancel buttons constant.
         *
         * @static
         * @final
         * @field {Number} OK_CANCEL
         */</span>
        OK_CANCEL: <span class="hljs-number">2</span>,

        <span class="hljs-comment">/**
         * yes/no buttons constant.
         *
         * @static
         * @final
         * @field {Number} YES_NO
         */</span>
        YES_NO: <span class="hljs-number">3</span>,

        <span class="hljs-comment">/**
         * yes/no/cancel buttons constant.
         *
         * @static
         * @final
         * @field {Number} YES_NO_CANCEL
         */</span>
        YES_NO_CANCEL: <span class="hljs-number">4</span>,

        <span class="hljs-comment">/**
         * Constructs a new message box and renders it to the body element.
         *
         * @static
         * @method msgBox
         * @param {Object} settings Name/value object with settings.
         */</span>
        msgBox: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
          <span class="hljs-keyword">var</span> buttons, callback = settings.callback || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ };

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createButton</span>(<span class="hljs-params">text, status, primary</span>) </span>{
            <span class="hljs-keyword">return</span> {
              <span class="hljs-attr">type</span>: <span class="hljs-string">"button"</span>,
              <span class="hljs-attr">text</span>: text,
              <span class="hljs-attr">subtype</span>: primary ? <span class="hljs-string">'primary'</span> : <span class="hljs-string">''</span>,
              <span class="hljs-attr">onClick</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
                e.control.parents()[<span class="hljs-number">1</span>].close();
                callback(status);
              }
            };
          }

          <span class="hljs-keyword">switch</span> (settings.buttons) {
            <span class="hljs-keyword">case</span> MessageBox.OK_CANCEL:
              buttons = [
                createButton(<span class="hljs-string">'Ok'</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>),
                createButton(<span class="hljs-string">'Cancel'</span>, <span class="hljs-literal">false</span>)
              ];
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> MessageBox.YES_NO:
            <span class="hljs-keyword">case</span> MessageBox.YES_NO_CANCEL:
              buttons = [
                createButton(<span class="hljs-string">'Yes'</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>),
                createButton(<span class="hljs-string">'No'</span>, <span class="hljs-number">0</span>)
              ];

              <span class="hljs-keyword">if</span> (settings.buttons == MessageBox.YES_NO_CANCEL) {
                buttons.push(createButton(<span class="hljs-string">'Cancel'</span>, <span class="hljs-number">-1</span>));
              }
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">default</span>:
              buttons = [
                createButton(<span class="hljs-string">'Ok'</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>)
              ];
              <span class="hljs-keyword">break</span>;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Window({
            <span class="hljs-attr">padding</span>: <span class="hljs-number">20</span>,
            <span class="hljs-attr">x</span>: settings.x,
            <span class="hljs-attr">y</span>: settings.y,
            <span class="hljs-attr">minWidth</span>: <span class="hljs-number">300</span>,
            <span class="hljs-attr">minHeight</span>: <span class="hljs-number">100</span>,
            <span class="hljs-attr">layout</span>: <span class="hljs-string">"flex"</span>,
            <span class="hljs-attr">pack</span>: <span class="hljs-string">"center"</span>,
            <span class="hljs-attr">align</span>: <span class="hljs-string">"center"</span>,
            <span class="hljs-attr">buttons</span>: buttons,
            <span class="hljs-attr">title</span>: settings.title,
            <span class="hljs-attr">role</span>: <span class="hljs-string">'alertdialog'</span>,
            <span class="hljs-attr">items</span>: {
              <span class="hljs-attr">type</span>: <span class="hljs-string">"label"</span>,
              <span class="hljs-attr">multiline</span>: <span class="hljs-literal">true</span>,
              <span class="hljs-attr">maxWidth</span>: <span class="hljs-number">500</span>,
              <span class="hljs-attr">maxHeight</span>: <span class="hljs-number">200</span>,
              <span class="hljs-attr">text</span>: settings.text
            },
            <span class="hljs-attr">onPostRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">this</span>.aria(<span class="hljs-string">'describedby'</span>, <span class="hljs-keyword">this</span>.items()[<span class="hljs-number">0</span>]._id);
            },
            <span class="hljs-attr">onClose</span>: settings.onClose,
            <span class="hljs-attr">onCancel</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              callback(<span class="hljs-literal">false</span>);
            }
          }).renderTo(<span class="hljs-built_in">document</span>.body).reflow();
        },

        <span class="hljs-comment">/**
         * Creates a new alert dialog.
         *
         * @method alert
         * @param {Object} settings Settings for the alert dialog.
         * @param {function} [callback] Callback to execute when the user makes a choice.
         */</span>
        alert: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings, callback</span>) </span>{
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> settings == <span class="hljs-string">"string"</span>) {
            settings = { <span class="hljs-attr">text</span>: settings };
          }

          settings.callback = callback;
          <span class="hljs-keyword">return</span> MessageBox.msgBox(settings);
        },

        <span class="hljs-comment">/**
         * Creates a new confirm dialog.
         *
         * @method confirm
         * @param {Object} settings Settings for the confirm dialog.
         * @param {function} [callback] Callback to execute when the user makes a choice.
         */</span>
        confirm: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings, callback</span>) </span>{
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> settings == <span class="hljs-string">"string"</span>) {
            settings = { <span class="hljs-attr">text</span>: settings };
          }

          settings.callback = callback;
          settings.buttons = MessageBox.OK_CANCEL;

          <span class="hljs-keyword">return</span> MessageBox.msgBox(settings);
        }
      }
    });

    <span class="hljs-keyword">return</span> MessageBox;
  }
);

<span class="hljs-comment">/**
 * WindowManager.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class handles the creation of native windows and dialogs. This class can be extended to provide for example inline dialogs.
 *
 * @class tinymce.WindowManager
 * @example
 * // Opens a new dialog with the file.htm file and the size 320x240
 * // It also adds a custom parameter this can be retrieved by using tinyMCEPopup.getWindowArg inside the dialog.
 * tinymce.activeEditor.windowManager.open({
 *    url: 'file.htm',
 *    width: 320,
 *    height: 240
 * }, {
 *    custom_param: 1
 * });
 *
 * // Displays an alert box using the active editors window manager instance
 * tinymce.activeEditor.windowManager.alert('Hello world!');
 *
 * // Displays an confirm box and an alert message will be displayed depending on what you choose in the confirm
 * tinymce.activeEditor.windowManager.confirm("Do you want to do something", function(s) {
 *    if (s)
 *       tinymce.activeEditor.windowManager.alert("Ok");
 *    else
 *       tinymce.activeEditor.windowManager.alert("Cancel");
 * });
 */</span>
define(
  <span class="hljs-string">'tinymce.core.WindowManager'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Window"</span>,
    <span class="hljs-string">"tinymce.core.ui.MessageBox"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Window, MessageBox</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, windows = [];

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTopMostWindow</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (windows.length) {
          <span class="hljs-keyword">return</span> windows[windows.length - <span class="hljs-number">1</span>];
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fireOpenEvent</span>(<span class="hljs-params">win</span>) </span>{
        editor.fire(<span class="hljs-string">'OpenWindow'</span>, {
          <span class="hljs-attr">win</span>: win
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fireCloseEvent</span>(<span class="hljs-params">win</span>) </span>{
        editor.fire(<span class="hljs-string">'CloseWindow'</span>, {
          <span class="hljs-attr">win</span>: win
        });
      }

      self.windows = windows;

      editor.on(<span class="hljs-string">'remove'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> i = windows.length;

        <span class="hljs-keyword">while</span> (i--) {
          windows[i].close();
        }
      });

      <span class="hljs-comment">/**
       * Opens a new window.
       *
       * @method open
       * @param {Object} args Optional name/value settings collection contains things like width/height/url etc.
       * @param {Object} params Options like title, file, width, height etc.
       * @option {String} title Window title.
       * @option {String} file URL of the file to open in the window.
       * @option {Number} width Width in pixels.
       * @option {Number} height Height in pixels.
       * @option {Boolean} autoScroll Specifies whether the popup window can have scrollbars if required (i.e. content
       * larger than the popup size specified).
       */</span>
      self.open = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, params</span>) </span>{
        <span class="hljs-keyword">var</span> win;

        editor.editorManager.setActive(editor);

        args.title = args.title || <span class="hljs-string">' '</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1507">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1507">&#182;</a>
              </div>
              <p>Handle URL</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        args.url = args.url || args.file; <span class="hljs-comment">// Legacy</span>
        <span class="hljs-keyword">if</span> (args.url) {
          args.width = <span class="hljs-built_in">parseInt</span>(args.width || <span class="hljs-number">320</span>, <span class="hljs-number">10</span>);
          args.height = <span class="hljs-built_in">parseInt</span>(args.height || <span class="hljs-number">240</span>, <span class="hljs-number">10</span>);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1508">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1508">&#182;</a>
              </div>
              <p>Handle body</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (args.body) {
          args.items = {
            <span class="hljs-attr">defaults</span>: args.defaults,
            <span class="hljs-attr">type</span>: args.bodyType || <span class="hljs-string">'form'</span>,
            <span class="hljs-attr">items</span>: args.body,
            <span class="hljs-attr">data</span>: args.data,
            <span class="hljs-attr">callbacks</span>: args.commands
          };
        }

        <span class="hljs-keyword">if</span> (!args.url &amp;&amp; !args.buttons) {
          args.buttons = [
            {
              <span class="hljs-attr">text</span>: <span class="hljs-string">'Ok'</span>, <span class="hljs-attr">subtype</span>: <span class="hljs-string">'primary'</span>, <span class="hljs-attr">onclick</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                win.find(<span class="hljs-string">'form'</span>)[<span class="hljs-number">0</span>].submit();
              }
            },

            {
              <span class="hljs-attr">text</span>: <span class="hljs-string">'Cancel'</span>, <span class="hljs-attr">onclick</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                win.close();
              }
            }
          ];
        }

        win = <span class="hljs-keyword">new</span> Window(args);
        windows.push(win);

        win.on(<span class="hljs-string">'close'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> i = windows.length;

          <span class="hljs-keyword">while</span> (i--) {
            <span class="hljs-keyword">if</span> (windows[i] === win) {
              windows.splice(i, <span class="hljs-number">1</span>);
            }
          }

          <span class="hljs-keyword">if</span> (!windows.length) {
            editor.focus();
          }

          fireCloseEvent(win);
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-1509">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1509">&#182;</a>
              </div>
              <p>Handle data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (args.data) {
          win.on(<span class="hljs-string">'postRender'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>.find(<span class="hljs-string">'*'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
              <span class="hljs-keyword">var</span> name = ctrl.name();

              <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> args.data) {
                ctrl.value(args.data[name]);
              }
            });
          });
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1510">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1510">&#182;</a>
              </div>
              <p>store args and parameters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        win.features = args || {};
        win.params = params || {};</pre></div></div>
            
        </li>
        
        
        <li id="section-1511">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1511">&#182;</a>
              </div>
              <p>Takes a snapshot in the FocusManager of the selection before focus is lost to dialog</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (windows.length === <span class="hljs-number">1</span>) {
          editor.nodeChanged();
        }

        win = win.renderTo().reflow();

        fireOpenEvent(win);

        <span class="hljs-keyword">return</span> win;
      };

      <span class="hljs-comment">/**
       * Creates a alert dialog. Please don't use the blocking behavior of this
       * native version use the callback method instead then it can be extended.
       *
       * @method alert
       * @param {String} message Text to display in the new alert dialog.
       * @param {function} callback Callback function to be executed after the user has selected ok.
       * @param {Object} scope Optional scope to execute the callback in.
       * @example
       * // Displays an alert box using the active editors window manager instance
       * tinymce.activeEditor.windowManager.alert('Hello world!');
       */</span>
      self.alert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message, callback, scope</span>) </span>{
        <span class="hljs-keyword">var</span> win;

        win = MessageBox.alert(message, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (callback) {
            callback.call(scope || <span class="hljs-keyword">this</span>);
          } <span class="hljs-keyword">else</span> {
            editor.focus();
          }
        });

        win.on(<span class="hljs-string">'close'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          fireCloseEvent(win);
        });

        fireOpenEvent(win);
      };

      <span class="hljs-comment">/**
       * Creates a confirm dialog. Please don't use the blocking behavior of this
       * native version use the callback method instead then it can be extended.
       *
       * @method confirm
       * @param {String} message Text to display in the new confirm dialog.
       * @param {function} callback Callback function to be executed after the user has selected ok or cancel.
       * @param {Object} scope Optional scope to execute the callback in.
       * @example
       * // Displays an confirm box and an alert message will be displayed depending on what you choose in the confirm
       * tinymce.activeEditor.windowManager.confirm("Do you want to do something", function(s) {
       *    if (s)
       *       tinymce.activeEditor.windowManager.alert("Ok");
       *    else
       *       tinymce.activeEditor.windowManager.alert("Cancel");
       * });
       */</span>
      self.confirm = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message, callback, scope</span>) </span>{
        <span class="hljs-keyword">var</span> win;

        win = MessageBox.confirm(message, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
          callback.call(scope || <span class="hljs-keyword">this</span>, state);
        });

        win.on(<span class="hljs-string">'close'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          fireCloseEvent(win);
        });

        fireOpenEvent(win);
      };

      <span class="hljs-comment">/**
       * Closes the top most window.
       *
       * @method close
       */</span>
      self.close = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (getTopMostWindow()) {
          getTopMostWindow().close();
        }
      };

      <span class="hljs-comment">/**
       * Returns the params of the last window open call. This can be used in iframe based
       * dialog to get params passed from the tinymce plugin.
       *
       * @example
       * var dialogArguments = top.tinymce.activeEditor.windowManager.getParams();
       *
       * @method getParams
       * @return {Object} Name/value object with parameters passed from windowManager.open call.
       */</span>
      self.getParams = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> getTopMostWindow() ? getTopMostWindow().params : <span class="hljs-literal">null</span>;
      };

      <span class="hljs-comment">/**
       * Sets the params of the last opened window.
       *
       * @method setParams
       * @param {Object} params Params object to set for the last opened window.
       */</span>
      self.setParams = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>{
        <span class="hljs-keyword">if</span> (getTopMostWindow()) {
          getTopMostWindow().params = params;
        }
      };

      <span class="hljs-comment">/**
       * Returns the currently opened window objects.
       *
       * @method getWindows
       * @return {Array} Array of the currently opened windows.
       */</span>
      self.getWindows = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> windows;
      };
    };
  }
);

<span class="hljs-comment">/**
 * Tooltip.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a tooltip instance.
 *
 * @-x-less ToolTip.less
 * @class tinymce.ui.ToolTip
 * @extends tinymce.ui.Control
 * @mixes tinymce.ui.Movable
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Tooltip'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Control"</span>,
    <span class="hljs-string">"tinymce.core.ui.Movable"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Control, Movable</span>) </span>{
    <span class="hljs-keyword">return</span> Control.extend({
      <span class="hljs-attr">Mixins</span>: [Movable],

      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">classes</span>: <span class="hljs-string">'widget tooltip tooltip-n'</span>
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, prefix = self.classPrefix;

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'" role="presentation"&gt;'</span> +
          <span class="hljs-string">'&lt;div class="'</span> + prefix + <span class="hljs-string">'tooltip-arrow"&gt;&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;div class="'</span> + prefix + <span class="hljs-string">'tooltip-inner"&gt;'</span> + self.encode(self.state.get(<span class="hljs-string">'text'</span>)) + <span class="hljs-string">'&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.state.on(<span class="hljs-string">'change:text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.getEl().lastChild.innerHTML = self.encode(e.value);
        });

        <span class="hljs-keyword">return</span> self._super();
      },

      <span class="hljs-comment">/**
       * Repaints the control after a layout operation.
       *
       * @method repaint
       */</span>
      repaint: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, style, rect;

        style = self.getEl().style;
        rect = self._layoutRect;

        style.left = rect.x + <span class="hljs-string">'px'</span>;
        style.top = rect.y + <span class="hljs-string">'px'</span>;
        style.zIndex = <span class="hljs-number">0xFFFF</span> + <span class="hljs-number">0xFFFF</span>;
      }
    });
  }
);
<span class="hljs-comment">/**
 * Widget.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Widget base class a widget is a control that has a tooltip and some basic states.
 *
 * @class tinymce.ui.Widget
 * @extends tinymce.ui.Control
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Widget'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Control"</span>,
    <span class="hljs-string">"tinymce.core.ui.Tooltip"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Control, Tooltip</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> tooltip;

    <span class="hljs-keyword">var</span> Widget = Control.extend({
      <span class="hljs-comment">/**
       * Constructs a instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {String} tooltip Tooltip text to display when hovering.
       * @setting {Boolean} autofocus True if the control should be focused when rendered.
       * @setting {String} text Text to display inside widget.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super(settings);
        settings = self.settings;
        self.canFocus = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">if</span> (settings.tooltip &amp;&amp; Widget.tooltips !== <span class="hljs-literal">false</span>) {
          self.on(<span class="hljs-string">'mouseenter'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">var</span> tooltip = self.tooltip().moveTo(<span class="hljs-number">-0xFFFF</span>);

            <span class="hljs-keyword">if</span> (e.control == self) {
              <span class="hljs-keyword">var</span> rel = tooltip.text(settings.tooltip).show().testMoveRel(self.getEl(), [<span class="hljs-string">'bc-tc'</span>, <span class="hljs-string">'bc-tl'</span>, <span class="hljs-string">'bc-tr'</span>]);

              tooltip.classes.toggle(<span class="hljs-string">'tooltip-n'</span>, rel == <span class="hljs-string">'bc-tc'</span>);
              tooltip.classes.toggle(<span class="hljs-string">'tooltip-nw'</span>, rel == <span class="hljs-string">'bc-tl'</span>);
              tooltip.classes.toggle(<span class="hljs-string">'tooltip-ne'</span>, rel == <span class="hljs-string">'bc-tr'</span>);

              tooltip.moveRel(self.getEl(), rel);
            } <span class="hljs-keyword">else</span> {
              tooltip.hide();
            }
          });

          self.on(<span class="hljs-string">'mouseleave mousedown click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            self.tooltip().hide();
          });
        }

        self.aria(<span class="hljs-string">'label'</span>, settings.ariaLabel || settings.tooltip);
      },

      <span class="hljs-comment">/**
       * Returns the current tooltip instance.
       *
       * @method tooltip
       * @return {tinymce.ui.Tooltip} Tooltip instance.
       */</span>
      tooltip: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!tooltip) {
          tooltip = <span class="hljs-keyword">new</span> Tooltip({ <span class="hljs-attr">type</span>: <span class="hljs-string">'tooltip'</span> });
          tooltip.renderTo();
        }

        <span class="hljs-keyword">return</span> tooltip;
      },

      <span class="hljs-comment">/**
       * Called after the control has been rendered.
       *
       * @method postRender
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, settings = self.settings;

        self._super();

        <span class="hljs-keyword">if</span> (!self.parent() &amp;&amp; (settings.width || settings.height)) {
          self.initLayoutRect();
          self.repaint();
        }

        <span class="hljs-keyword">if</span> (settings.autofocus) {
          self.focus();
        }
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disable</span>(<span class="hljs-params">state</span>) </span>{
          self.aria(<span class="hljs-string">'disabled'</span>, state);
          self.classes.toggle(<span class="hljs-string">'disabled'</span>, state);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">active</span>(<span class="hljs-params">state</span>) </span>{
          self.aria(<span class="hljs-string">'pressed'</span>, state);
          self.classes.toggle(<span class="hljs-string">'active'</span>, state);
        }

        self.state.on(<span class="hljs-string">'change:disabled'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          disable(e.value);
        });

        self.state.on(<span class="hljs-string">'change:active'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          active(e.value);
        });

        <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'disabled'</span>)) {
          disable(<span class="hljs-literal">true</span>);
        }

        <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'active'</span>)) {
          active(<span class="hljs-literal">true</span>);
        }

        <span class="hljs-keyword">return</span> self._super();
      },

      <span class="hljs-comment">/**
       * Removes the current control from DOM and from UI collections.
       *
       * @method remove
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._super();

        <span class="hljs-keyword">if</span> (tooltip) {
          tooltip.remove();
          tooltip = <span class="hljs-literal">null</span>;
        }
      }
    });

    <span class="hljs-keyword">return</span> Widget;
  }
);

<span class="hljs-comment">/**
 * Progress.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Progress control.
 *
 * @-x-less Progress.less
 * @class tinymce.ui.Progress
 * @extends tinymce.ui.Control
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Progress'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">value</span>: <span class="hljs-number">0</span>
      },

      <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super(settings);
        self.classes.add(<span class="hljs-string">'progress'</span>);

        <span class="hljs-keyword">if</span> (!self.settings.filter) {
          self.settings.filter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round(value);
          };
        }
      },

      <span class="hljs-attr">renderHtml</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, id = self._id, prefix = <span class="hljs-keyword">this</span>.classPrefix;

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'"&gt;'</span> +
          <span class="hljs-string">'&lt;div class="'</span> + prefix + <span class="hljs-string">'bar-container"&gt;'</span> +
          <span class="hljs-string">'&lt;div class="'</span> + prefix + <span class="hljs-string">'bar"&gt;&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;div class="'</span> + prefix + <span class="hljs-string">'text"&gt;0%&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-attr">postRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super();
        self.value(self.settings.value);

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setValue</span>(<span class="hljs-params">value</span>) </span>{
          value = self.settings.filter(value);
          self.getEl().lastChild.innerHTML = value + <span class="hljs-string">'%'</span>;
          self.getEl().firstChild.firstChild.style.width = value + <span class="hljs-string">'%'</span>;
        }

        self.state.on(<span class="hljs-string">'change:value'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          setValue(e.value);
        });

        setValue(self.state.get(<span class="hljs-string">'value'</span>));

        <span class="hljs-keyword">return</span> self._super();
      }
    });
  }
);
<span class="hljs-comment">/**
 * Notification.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a notification instance.
 *
 * @-x-less Notification.less
 * @class tinymce.ui.Notification
 * @extends tinymce.ui.Container
 * @mixes tinymce.ui.Movable
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Notification'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Control"</span>,
    <span class="hljs-string">"tinymce.core.ui.Movable"</span>,
    <span class="hljs-string">"tinymce.core.ui.Progress"</span>,
    <span class="hljs-string">"tinymce.core.util.Delay"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Control, Movable, Progress, Delay</span>) </span>{
    <span class="hljs-keyword">return</span> Control.extend({
      <span class="hljs-attr">Mixins</span>: [Movable],

      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">classes</span>: <span class="hljs-string">'widget notification'</span>
      },

      <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super(settings);

        <span class="hljs-keyword">if</span> (settings.text) {
          self.text(settings.text);
        }

        <span class="hljs-keyword">if</span> (settings.icon) {
          self.icon = settings.icon;
        }

        <span class="hljs-keyword">if</span> (settings.color) {
          self.color = settings.color;
        }

        <span class="hljs-keyword">if</span> (settings.type) {
          self.classes.add(<span class="hljs-string">'notification-'</span> + settings.type);
        }

        <span class="hljs-keyword">if</span> (settings.timeout &amp;&amp; (settings.timeout &lt; <span class="hljs-number">0</span> || settings.timeout &gt; <span class="hljs-number">0</span>) &amp;&amp; !settings.closeButton) {
          self.closeButton = <span class="hljs-literal">false</span>;
        } <span class="hljs-keyword">else</span> {
          self.classes.add(<span class="hljs-string">'has-close'</span>);
          self.closeButton = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (settings.progressBar) {
          self.progressBar = <span class="hljs-keyword">new</span> Progress();
        }

        self.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (e.target.className.indexOf(self.classPrefix + <span class="hljs-string">'close'</span>) != <span class="hljs-number">-1</span>) {
            self.close();
          }
        });
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, prefix = self.classPrefix, icon = <span class="hljs-string">''</span>, closeButton = <span class="hljs-string">''</span>, progressBar = <span class="hljs-string">''</span>, notificationStyle = <span class="hljs-string">''</span>;

        <span class="hljs-keyword">if</span> (self.icon) {
          icon = <span class="hljs-string">'&lt;i class="'</span> + prefix + <span class="hljs-string">'ico'</span> + <span class="hljs-string">' '</span> + prefix + <span class="hljs-string">'i-'</span> + self.icon + <span class="hljs-string">'"&gt;&lt;/i&gt;'</span>;
        }

        <span class="hljs-keyword">if</span> (self.color) {
          notificationStyle = <span class="hljs-string">' style="background-color: '</span> + self.color + <span class="hljs-string">'"'</span>;
        }

        <span class="hljs-keyword">if</span> (self.closeButton) {
          closeButton = <span class="hljs-string">'&lt;button type="button" class="'</span> + prefix + <span class="hljs-string">'close" aria-hidden="true"&gt;\u00d7&lt;/button&gt;'</span>;
        }

        <span class="hljs-keyword">if</span> (self.progressBar) {
          progressBar = self.progressBar.renderHtml();
        }

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'"'</span> + notificationStyle + <span class="hljs-string">' role="presentation"&gt;'</span> +
          icon +
          <span class="hljs-string">'&lt;div class="'</span> + prefix + <span class="hljs-string">'notification-inner"&gt;'</span> + self.state.get(<span class="hljs-string">'text'</span>) + <span class="hljs-string">'&lt;/div&gt;'</span> +
          progressBar +
          closeButton +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-attr">postRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        Delay.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          self.$el.addClass(self.classPrefix + <span class="hljs-string">'in'</span>);
        });

        <span class="hljs-keyword">return</span> self._super();
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.state.on(<span class="hljs-string">'change:text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.getEl().childNodes[<span class="hljs-number">1</span>].innerHTML = e.value;
        });
        <span class="hljs-keyword">if</span> (self.progressBar) {
          self.progressBar.bindStates();
        }
        <span class="hljs-keyword">return</span> self._super();
      },

      <span class="hljs-attr">close</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (!self.fire(<span class="hljs-string">'close'</span>).isDefaultPrevented()) {
          self.remove();
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Repaints the control after a layout operation.
       *
       * @method repaint
       */</span>
      repaint: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, style, rect;

        style = self.getEl().style;
        rect = self._layoutRect;

        style.left = rect.x + <span class="hljs-string">'px'</span>;
        style.top = rect.y + <span class="hljs-string">'px'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1512">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1512">&#182;</a>
              </div>
              <p>Hardcoded arbitrary z-value because we want the
notifications under the other windows</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        style.zIndex = <span class="hljs-number">0xFFFF</span> - <span class="hljs-number">1</span>;
      }
    });
  }
);
<span class="hljs-comment">/**
 * NotificationManager.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class handles the creation of TinyMCE's notifications.
 *
 * @class tinymce.NotificationManager
 * @example
 * // Opens a new notification of type "error" with text "An error occurred."
 * tinymce.activeEditor.notificationManager.open({
 *    text: 'An error occurred.',
 *    type: 'error'
 * });
 */</span>
define(
  <span class="hljs-string">'tinymce.core.NotificationManager'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Notification"</span>,
    <span class="hljs-string">"tinymce.core.util.Delay"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Notification, Delay, Tools</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, notifications = [];

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLastNotification</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (notifications.length) {
          <span class="hljs-keyword">return</span> notifications[notifications.length - <span class="hljs-number">1</span>];
        }
      }

      self.notifications = notifications;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resizeWindowEvent</span>(<span class="hljs-params"></span>) </span>{
        Delay.requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          prePositionNotifications();
          positionNotifications();
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1513">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1513">&#182;</a>
              </div>
              <p>Since the viewport will change based on the present notifications, we need to move them all to the
top left of the viewport to give an accurate size measurement so we can position them later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prePositionNotifications</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; notifications.length; i++) {
          notifications[i].moveTo(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">positionNotifications</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (notifications.length &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">var</span> firstItem = notifications.slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">var</span> container = editor.inline ? editor.getElement() : editor.getContentAreaContainer();
          firstItem.moveRel(container, <span class="hljs-string">'tc-tc'</span>);
          <span class="hljs-keyword">if</span> (notifications.length &gt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; notifications.length; i++) {
              notifications[i].moveRel(notifications[i - <span class="hljs-number">1</span>].getEl(), <span class="hljs-string">'bc-tc'</span>);
            }
          }
        }
      }

      editor.on(<span class="hljs-string">'remove'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> i = notifications.length;

        <span class="hljs-keyword">while</span> (i--) {
          notifications[i].close();
        }
      });

      editor.on(<span class="hljs-string">'ResizeEditor'</span>, positionNotifications);
      editor.on(<span class="hljs-string">'ResizeWindow'</span>, resizeWindowEvent);

      <span class="hljs-comment">/**
       * Opens a new notification.
       *
       * @method open
       * @param {Object} args Optional name/value settings collection contains things like timeout/color/message etc.
       */</span>
      self.open = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1514">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1514">&#182;</a>
              </div>
              <p>Never open notification if editor has been removed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (editor.removed) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> notif;

        editor.editorManager.setActive(editor);

        <span class="hljs-keyword">var</span> duplicate = findDuplicateMessage(notifications, args);

        <span class="hljs-keyword">if</span> (duplicate === <span class="hljs-literal">null</span>) {
          notif = <span class="hljs-keyword">new</span> Notification(args);
          notifications.push(notif);</pre></div></div>
            
        </li>
        
        
        <li id="section-1515">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1515">&#182;</a>
              </div>
              <p>If we have a timeout value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (args.timeout &gt; <span class="hljs-number">0</span>) {
            notif.timer = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              notif.close();
            }, args.timeout);
          }

          notif.on(<span class="hljs-string">'close'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> i = notifications.length;

            <span class="hljs-keyword">if</span> (notif.timer) {
              editor.getWin().clearTimeout(notif.timer);
            }

            <span class="hljs-keyword">while</span> (i--) {
              <span class="hljs-keyword">if</span> (notifications[i] === notif) {
                notifications.splice(i, <span class="hljs-number">1</span>);
              }
            }

            positionNotifications();
          });

          notif.renderTo();

          positionNotifications();
        } <span class="hljs-keyword">else</span> {
          notif = duplicate;
        }

        <span class="hljs-keyword">return</span> notif;
      };

      <span class="hljs-comment">/**
       * Closes the top most notification.
       *
       * @method close
       */</span>
      self.close = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (getLastNotification()) {
          getLastNotification().close();
        }
      };

      <span class="hljs-comment">/**
       * Returns the currently opened notification objects.
       *
       * @method getNotifications
       * @return {Array} Array of the currently opened notifications.
       */</span>
      self.getNotifications = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> notifications;
      };

      editor.on(<span class="hljs-string">'SkinLoaded'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> serviceMessage = editor.settings.service_message;

        <span class="hljs-keyword">if</span> (serviceMessage) {
          editor.notificationManager.open({
            <span class="hljs-attr">text</span>: serviceMessage,
            <span class="hljs-attr">type</span>: <span class="hljs-string">'warning'</span>,
            <span class="hljs-attr">timeout</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">icon</span>: <span class="hljs-string">''</span>
          });
        }
      });

      <span class="hljs-comment">/**
       * Finds any existing notification with the same properties as the new one.
       * Returns either the found notification or null.
       *
       * @param {Notification[]} notificationArray - Array of current notifications
       * @param {type: string, } newNotification - New notification object
       * @returns {?Notification}
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findDuplicateMessage</span>(<span class="hljs-params">notificationArray, newNotification</span>) </span>{
        <span class="hljs-keyword">if</span> (!isPlainTextNotification(newNotification)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">var</span> filteredNotifications = Tools.grep(notificationArray, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">notification</span>) </span>{
          <span class="hljs-keyword">return</span> isSameNotification(newNotification, notification);
        });

        <span class="hljs-keyword">return</span> filteredNotifications.length === <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : filteredNotifications[<span class="hljs-number">0</span>];
      }

      <span class="hljs-comment">/**
       * Checks if the passed in args object has the same
       * type and text properties as the sent in notification.
       *
       * @param {type: string, text: string} a - New notification args object
       * @param {Notification} b - Old notification
       * @returns {boolean}
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSameNotification</span>(<span class="hljs-params">a, b</span>) </span>{
        <span class="hljs-keyword">return</span> a.type === b.settings.type &amp;&amp; a.text === b.settings.text;
      }

      <span class="hljs-comment">/**
       * Checks that the notification does not have a progressBar
       * or timeour property.
       *
       * @param {Notification} notification - Notification to check
       * @returns {boolean}
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPlainTextNotification</span>(<span class="hljs-params">notification</span>) </span>{
        <span class="hljs-keyword">return</span> !notification.progressBar &amp;&amp; !notification.timeout;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1516">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1516">&#182;</a>
              </div>
              <p>self.positionNotifications = positionNotifications;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    };
  }
);

<span class="hljs-comment">/**
 * EditorObservable.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This mixin contains the event logic for the tinymce.Editor class.
 *
 * @mixin tinymce.EditorObservable
 * @extends tinymce.util.Observable
 */</span>
define(
  <span class="hljs-string">'tinymce.core.EditorObservable'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Observable"</span>,
    <span class="hljs-string">"tinymce.core.dom.DOMUtils"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Observable, DOMUtils, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> DOM = DOMUtils.DOM, customEventRootDelegates;

    <span class="hljs-comment">/**
     * Returns the event target so for the specified event. Some events fire
     * only on document, some fire on documentElement etc. This also handles the
     * custom event root setting where it returns that element instead of the body.
     *
     * @private
     * @param {tinymce.Editor} editor Editor instance to get event target from.
     * @param {String} eventName Name of the event for example "click".
     * @return {Element/Document} HTML Element or document target to bind on.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventTarget</span>(<span class="hljs-params">editor, eventName</span>) </span>{
      <span class="hljs-keyword">if</span> (eventName == <span class="hljs-string">'selectionchange'</span>) {
        <span class="hljs-keyword">return</span> editor.getDoc();
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1517">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1517">&#182;</a>
              </div>
              <p>Need to bind mousedown/mouseup etc to document not body in iframe mode
Since the user might click on the HTML element not the BODY</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!editor.inline &amp;&amp; <span class="hljs-regexp">/^mouse|touch|click|contextmenu|drop|dragover|dragend/</span>.test(eventName)) {
        <span class="hljs-keyword">return</span> editor.getDoc().documentElement;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1518">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1518">&#182;</a>
              </div>
              <p>Bind to event root instead of body if its defined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (editor.settings.event_root) {
        <span class="hljs-keyword">if</span> (!editor.eventRoot) {
          editor.eventRoot = DOM.select(editor.settings.event_root)[<span class="hljs-number">0</span>];
        }

        <span class="hljs-keyword">return</span> editor.eventRoot;
      }

      <span class="hljs-keyword">return</span> editor.getBody();
    }

    <span class="hljs-comment">/**
     * Binds a event delegate for the specified name this delegate will fire
     * the event to the editor dispatcher.
     *
     * @private
     * @param {tinymce.Editor} editor Editor instance to get event target from.
     * @param {String} eventName Name of the event for example "click".
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindEventDelegate</span>(<span class="hljs-params">editor, eventName</span>) </span>{
      <span class="hljs-keyword">var</span> eventRootElm = getEventTarget(editor, eventName), delegate;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isListening</span>(<span class="hljs-params">editor</span>) </span>{
        <span class="hljs-keyword">return</span> !editor.hidden &amp;&amp; !editor.readonly;
      }

      <span class="hljs-keyword">if</span> (!editor.delegates) {
        editor.delegates = {};
      }

      <span class="hljs-keyword">if</span> (editor.delegates[eventName]) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (editor.settings.event_root) {
        <span class="hljs-keyword">if</span> (!customEventRootDelegates) {
          customEventRootDelegates = {};
          editor.editorManager.on(<span class="hljs-string">'removeEditor'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> name;

            <span class="hljs-keyword">if</span> (!editor.editorManager.activeEditor) {
              <span class="hljs-keyword">if</span> (customEventRootDelegates) {
                <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> customEventRootDelegates) {
                  editor.dom.unbind(getEventTarget(editor, name));
                }

                customEventRootDelegates = <span class="hljs-literal">null</span>;
              }
            }
          });
        }

        <span class="hljs-keyword">if</span> (customEventRootDelegates[eventName]) {
          <span class="hljs-keyword">return</span>;
        }

        delegate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> target = e.target, editors = editor.editorManager.editors, i = editors.length;

          <span class="hljs-keyword">while</span> (i--) {
            <span class="hljs-keyword">var</span> body = editors[i].getBody();

            <span class="hljs-keyword">if</span> (body === target || DOM.isChildOf(target, body)) {
              <span class="hljs-keyword">if</span> (isListening(editors[i])) {
                editors[i].fire(eventName, e);
              }
            }
          }
        };

        customEventRootDelegates[eventName] = delegate;
        DOM.bind(eventRootElm, eventName, delegate);
      } <span class="hljs-keyword">else</span> {
        delegate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (isListening(editor)) {
            editor.fire(eventName, e);
          }
        };

        DOM.bind(eventRootElm, eventName, delegate);
        editor.delegates[eventName] = delegate;
      }
    }

    <span class="hljs-keyword">var</span> EditorObservable = {
      <span class="hljs-comment">/**
       * Bind any pending event delegates. This gets executed after the target body/document is created.
       *
       * @private
       */</span>
      bindPendingEventDelegates: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        Tools.each(self._pendingNativeEvents, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          bindEventDelegate(self, name);
        });
      },

      <span class="hljs-comment">/**
       * Toggles a native event on/off this is called by the EventDispatcher when
       * the first native event handler is added and when the last native event handler is removed.
       *
       * @private
       */</span>
      toggleNativeEvent: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, state</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1519">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1519">&#182;</a>
              </div>
              <p>Never bind focus/blur since the FocusManager fakes those</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">"focus"</span> || name == <span class="hljs-string">"blur"</span>) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (state) {
          <span class="hljs-keyword">if</span> (self.initialized) {
            bindEventDelegate(self, name);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (!self._pendingNativeEvents) {
              self._pendingNativeEvents = [name];
            } <span class="hljs-keyword">else</span> {
              self._pendingNativeEvents.push(name);
            }
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.initialized) {
          self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
          <span class="hljs-keyword">delete</span> self.delegates[name];
        }
      },

      <span class="hljs-comment">/**
       * Unbinds all native event handlers that means delegates, custom events bound using the Events API etc.
       *
       * @private
       */</span>
      unbindAllNativeEvents: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, name;

        <span class="hljs-keyword">if</span> (self.delegates) {
          <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> self.delegates) {
            self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
          }

          <span class="hljs-keyword">delete</span> self.delegates;
        }

        <span class="hljs-keyword">if</span> (!self.inline) {
          self.getBody().onload = <span class="hljs-literal">null</span>;
          self.dom.unbind(self.getWin());
          self.dom.unbind(self.getDoc());
        }

        self.dom.unbind(self.getBody());
        self.dom.unbind(self.getContainer());
      }
    };

    EditorObservable = Tools.extend({}, Observable, EditorObservable);

    <span class="hljs-keyword">return</span> EditorObservable;
  }
);

<span class="hljs-comment">/**
 * Shortcuts.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Contains all logic for handling of keyboard shortcuts.
 *
 * @class tinymce.Shortcuts
 * @example
 * editor.shortcuts.add('ctrl+a', function() {});
 * editor.shortcuts.add('meta+a', function() {}); // "meta" maps to Command on Mac and Ctrl on PC
 * editor.shortcuts.add('ctrl+alt+a', function() {});
 * editor.shortcuts.add('access+a', function() {}); // "access" maps to ctrl+alt on Mac and shift+alt on PC
 */</span>
define(
  <span class="hljs-string">'tinymce.core.Shortcuts'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.Env"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Tools, Env</span>) </span>{
    <span class="hljs-keyword">var</span> each = Tools.each, explode = Tools.explode;

    <span class="hljs-keyword">var</span> keyCodeLookup = {
      <span class="hljs-string">"f9"</span>: <span class="hljs-number">120</span>,
      <span class="hljs-string">"f10"</span>: <span class="hljs-number">121</span>,
      <span class="hljs-string">"f11"</span>: <span class="hljs-number">122</span>
    };

    <span class="hljs-keyword">var</span> modifierNames = Tools.makeMap(<span class="hljs-string">'alt,ctrl,shift,meta,access'</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, shortcuts = {}, pendingPatterns = [];

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseShortcut</span>(<span class="hljs-params">pattern</span>) </span>{
        <span class="hljs-keyword">var</span> id, key, shortcut = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-1520">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1520">&#182;</a>
              </div>
              <p>Parse modifiers and keys ctrl+alt+b for example</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        each(explode(pattern, <span class="hljs-string">'+'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
          <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">in</span> modifierNames) {
            shortcut[value] = <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1521">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1521">&#182;</a>
              </div>
              <p>Allow numeric keycodes like ctrl+219 for ctrl+[</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^[0-9]{2,}$/</span>.test(value)) {
              shortcut.keyCode = <span class="hljs-built_in">parseInt</span>(value, <span class="hljs-number">10</span>);
            } <span class="hljs-keyword">else</span> {
              shortcut.charCode = value.charCodeAt(<span class="hljs-number">0</span>);
              shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(<span class="hljs-number">0</span>);
            }
          }
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-1522">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1522">&#182;</a>
              </div>
              <p>Generate unique id for modifier combination and set default state for unused modifiers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        id = [shortcut.keyCode];
        <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> modifierNames) {
          <span class="hljs-keyword">if</span> (shortcut[key]) {
            id.push(key);
          } <span class="hljs-keyword">else</span> {
            shortcut[key] = <span class="hljs-literal">false</span>;
          }
        }
        shortcut.id = id.join(<span class="hljs-string">','</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1523">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1523">&#182;</a>
              </div>
              <p>Handle special access modifier differently depending on Mac/Win</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (shortcut.access) {
          shortcut.alt = <span class="hljs-literal">true</span>;

          <span class="hljs-keyword">if</span> (Env.mac) {
            shortcut.ctrl = <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            shortcut.shift = <span class="hljs-literal">true</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1524">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1524">&#182;</a>
              </div>
              <p>Handle special meta modifier differently depending on Mac/Win</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (shortcut.meta) {
          <span class="hljs-keyword">if</span> (Env.mac) {
            shortcut.meta = <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            shortcut.ctrl = <span class="hljs-literal">true</span>;
            shortcut.meta = <span class="hljs-literal">false</span>;
          }
        }

        <span class="hljs-keyword">return</span> shortcut;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createShortcut</span>(<span class="hljs-params">pattern, desc, cmdFunc, scope</span>) </span>{
        <span class="hljs-keyword">var</span> shortcuts;

        shortcuts = Tools.map(explode(pattern, <span class="hljs-string">'&gt;'</span>), parseShortcut);
        shortcuts[shortcuts.length - <span class="hljs-number">1</span>] = Tools.extend(shortcuts[shortcuts.length - <span class="hljs-number">1</span>], {
          <span class="hljs-attr">func</span>: cmdFunc,
          <span class="hljs-attr">scope</span>: scope || editor
        });

        <span class="hljs-keyword">return</span> Tools.extend(shortcuts[<span class="hljs-number">0</span>], {
          <span class="hljs-attr">desc</span>: editor.translate(desc),
          <span class="hljs-attr">subpatterns</span>: shortcuts.slice(<span class="hljs-number">1</span>)
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasModifier</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">return</span> e.altKey || e.ctrlKey || e.metaKey;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunctionKey</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">return</span> e.type === <span class="hljs-string">"keydown"</span> &amp;&amp; e.keyCode &gt;= <span class="hljs-number">112</span> &amp;&amp; e.keyCode &lt;= <span class="hljs-number">123</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchShortcut</span>(<span class="hljs-params">e, shortcut</span>) </span>{
        <span class="hljs-keyword">if</span> (!shortcut) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">if</span> (shortcut.ctrl != e.ctrlKey || shortcut.meta != e.metaKey) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">if</span> (shortcut.alt != e.altKey || shortcut.shift != e.shiftKey) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">if</span> (e.keyCode == shortcut.keyCode || (e.charCode &amp;&amp; e.charCode == shortcut.charCode)) {
          e.preventDefault();
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executeShortcutAction</span>(<span class="hljs-params">shortcut</span>) </span>{
        <span class="hljs-keyword">return</span> shortcut.func ? shortcut.func.call(shortcut.scope) : <span class="hljs-literal">null</span>;
      }

      editor.on(<span class="hljs-string">'keyup keypress keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> ((hasModifier(e) || isFunctionKey(e)) &amp;&amp; !e.isDefaultPrevented()) {
          each(shortcuts, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">shortcut</span>) </span>{
            <span class="hljs-keyword">if</span> (matchShortcut(e, shortcut)) {
              pendingPatterns = shortcut.subpatterns.slice(<span class="hljs-number">0</span>);

              <span class="hljs-keyword">if</span> (e.type == <span class="hljs-string">"keydown"</span>) {
                executeShortcutAction(shortcut);
              }

              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
          });

          <span class="hljs-keyword">if</span> (matchShortcut(e, pendingPatterns[<span class="hljs-number">0</span>])) {
            <span class="hljs-keyword">if</span> (pendingPatterns.length === <span class="hljs-number">1</span>) {
              <span class="hljs-keyword">if</span> (e.type == <span class="hljs-string">"keydown"</span>) {
                executeShortcutAction(pendingPatterns[<span class="hljs-number">0</span>]);
              }
            }

            pendingPatterns.shift();
          }
        }
      });

      <span class="hljs-comment">/**
       * Adds a keyboard shortcut for some command or function.
       *
       * @method add
       * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
       * @param {String} desc Text description for the command.
       * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.
       * @param {Object} scope Optional scope to execute the function in.
       * @return {Boolean} true/false state if the shortcut was added or not.
       */</span>
      self.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern, desc, cmdFunc, scope</span>) </span>{
        <span class="hljs-keyword">var</span> cmd;

        cmd = cmdFunc;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cmdFunc === <span class="hljs-string">'string'</span>) {
          cmdFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            editor.execCommand(cmd, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);
          };
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Tools.isArray(cmd)) {
          cmdFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            editor.execCommand(cmd[<span class="hljs-number">0</span>], cmd[<span class="hljs-number">1</span>], cmd[<span class="hljs-number">2</span>]);
          };
        }

        each(explode(Tools.trim(pattern.toLowerCase())), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern</span>) </span>{
          <span class="hljs-keyword">var</span> shortcut = createShortcut(pattern, desc, cmdFunc, scope);
          shortcuts[shortcut.id] = shortcut;
        });

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      };

      <span class="hljs-comment">/**
       * Remove a keyboard shortcut by pattern.
       *
       * @method remove
       * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
       * @return {Boolean} true/false state if the shortcut was removed or not.
       */</span>
      self.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern</span>) </span>{
        <span class="hljs-keyword">var</span> shortcut = createShortcut(pattern);

        <span class="hljs-keyword">if</span> (shortcuts[shortcut.id]) {
          <span class="hljs-keyword">delete</span> shortcuts[shortcut.id];
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      };
    };
  }
);

defineGlobal(<span class="hljs-string">"global!window"</span>, <span class="hljs-built_in">window</span>);
<span class="hljs-comment">/**
 * ErrorReporter.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Various error reporting helper functions.
 *
 * @class tinymce.ErrorReporter
 * @private
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ErrorReporter'</span>,
  [
    <span class="hljs-string">"tinymce.core.AddOnManager"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">AddOnManager</span>) </span>{
    <span class="hljs-keyword">var</span> PluginManager = AddOnManager.PluginManager;

    <span class="hljs-keyword">var</span> resolvePluginName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">targetUrl, suffix</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> PluginManager.urls) {
        <span class="hljs-keyword">var</span> matchUrl = PluginManager.urls[name] + <span class="hljs-string">'/plugin'</span> + suffix + <span class="hljs-string">'.js'</span>;
        <span class="hljs-keyword">if</span> (matchUrl === targetUrl) {
          <span class="hljs-keyword">return</span> name;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    };

    <span class="hljs-keyword">var</span> pluginUrlToMessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, url</span>) </span>{
      <span class="hljs-keyword">var</span> plugin = resolvePluginName(url, editor.suffix);
      <span class="hljs-keyword">return</span> plugin ?
        <span class="hljs-string">'Failed to load plugin: '</span> + plugin + <span class="hljs-string">' from url '</span> + url :
        <span class="hljs-string">'Failed to load plugin url: '</span> + url;
    };

    <span class="hljs-keyword">var</span> displayNotification = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, message</span>) </span>{
      editor.notificationManager.open({
        <span class="hljs-attr">type</span>: <span class="hljs-string">'error'</span>,
        <span class="hljs-attr">text</span>: message
      });
    };

    <span class="hljs-keyword">var</span> displayError = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, message</span>) </span>{
      <span class="hljs-keyword">if</span> (editor._skinLoaded) {
        displayNotification(editor, message);
      } <span class="hljs-keyword">else</span> {
        editor.on(<span class="hljs-string">'SkinLoaded'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          displayNotification(editor, message);
        });
      }
    };

    <span class="hljs-keyword">var</span> uploadError = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, message</span>) </span>{
      displayError(editor, <span class="hljs-string">'Failed to upload image: '</span> + message);
    };

    <span class="hljs-keyword">var</span> pluginLoadError = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, url</span>) </span>{
      displayError(editor, pluginUrlToMessage(editor, url));
    };

    <span class="hljs-keyword">var</span> contentCssError = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, urls</span>) </span>{
      displayError(editor, <span class="hljs-string">'Failed to load content css: '</span> + urls[<span class="hljs-number">0</span>]);
    };

    <span class="hljs-keyword">var</span> initError = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>{
      <span class="hljs-keyword">var</span> <span class="hljs-built_in">console</span> = <span class="hljs-built_in">window</span>.console;
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">console</span> &amp;&amp; !<span class="hljs-built_in">window</span>.test) { <span class="hljs-comment">// Skip test env</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">console</span>.error) {
          <span class="hljs-built_in">console</span>.error.apply(<span class="hljs-built_in">console</span>, <span class="hljs-built_in">arguments</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-built_in">console</span>.log.apply(<span class="hljs-built_in">console</span>, <span class="hljs-built_in">arguments</span>);
        }
      }
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">pluginLoadError</span>: pluginLoadError,
      <span class="hljs-attr">uploadError</span>: uploadError,
      <span class="hljs-attr">displayError</span>: displayError,
      <span class="hljs-attr">contentCssError</span>: contentCssError,
      <span class="hljs-attr">initError</span>: initError
    };
  }
);
<span class="hljs-comment">/**
 * CaretContainerInput.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module shows the invisble block that the caret is currently in when contents is added to that block.
 */</span>
define(
  <span class="hljs-string">'tinymce.core.caret.CaretContainerInput'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretContainer'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, CaretContainer</span>) </span>{
    <span class="hljs-keyword">var</span> findBlockCaretContainer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">return</span> editor.dom.select(<span class="hljs-string">'*[data-mce-caret]'</span>)[<span class="hljs-number">0</span>];
    };

    <span class="hljs-keyword">var</span> removeIeControlRect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      editor.selection.setRng(editor.selection.getRng());
    };

    <span class="hljs-keyword">var</span> showBlockCaretContainer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, blockCaretContainer</span>) </span>{
      <span class="hljs-keyword">if</span> (blockCaretContainer.hasAttribute(<span class="hljs-string">'data-mce-caret'</span>)) {
        CaretContainer.showCaretContainerBlock(blockCaretContainer);
        removeIeControlRect(editor);
        editor.selection.scrollIntoView(blockCaretContainer);
      }
    };

    <span class="hljs-keyword">var</span> handleBlockContainer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, e</span>) </span>{
      <span class="hljs-keyword">var</span> blockCaretContainer = findBlockCaretContainer(editor);

      <span class="hljs-keyword">if</span> (!blockCaretContainer) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (e.type === <span class="hljs-string">'compositionstart'</span>) {
        e.preventDefault();
        e.stopPropagation();
        showBlockCaretContainer(blockCaretContainer);
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (CaretContainer.hasContent(blockCaretContainer)) {
        showBlockCaretContainer(editor, blockCaretContainer);
      }
    };

    <span class="hljs-keyword">var</span> setup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      editor.on(<span class="hljs-string">'keyup compositionstart'</span>, Fun.curry(handleBlockContainer, editor));
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">setup</span>: setup
    };
  }
);
<span class="hljs-comment">/**
 * Uploader.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Upload blobs or blob infos to the specified URL or handler.
 *
 * @private
 * @class tinymce.file.Uploader
 * @example
 * var uploader = new Uploader({
 *     url: '/upload.php',
 *     basePath: '/base/path',
 *     credentials: true,
 *     handler: function(data, success, failure) {
 *         ...
 *     }
 * });
 *
 * uploader.upload(blobInfos).then(function(result) {
 *     ...
 * });
 */</span>
define(
  <span class="hljs-string">'tinymce.core.file.Uploader'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Promise"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.util.Fun"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Promise, Tools, Fun</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">uploadStatus, settings</span>) </span>{
      <span class="hljs-keyword">var</span> pendingPromises = {};

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pathJoin</span>(<span class="hljs-params">path1, path2</span>) </span>{
        <span class="hljs-keyword">if</span> (path1) {
          <span class="hljs-keyword">return</span> path1.replace(<span class="hljs-regexp">/\/$/</span>, <span class="hljs-string">''</span>) + <span class="hljs-string">'/'</span> + path2.replace(<span class="hljs-regexp">/^\//</span>, <span class="hljs-string">''</span>);
        }

        <span class="hljs-keyword">return</span> path2;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultHandler</span>(<span class="hljs-params">blobInfo, success, failure, progress</span>) </span>{
        <span class="hljs-keyword">var</span> xhr, formData;

        xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
        xhr.open(<span class="hljs-string">'POST'</span>, settings.url);
        xhr.withCredentials = settings.credentials;

        xhr.upload.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          progress(e.loaded / e.total * <span class="hljs-number">100</span>);
        };

        xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          failure(<span class="hljs-string">"Image upload failed due to a XHR Transport error. Code: "</span> + xhr.status);
        };

        xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> json;

          <span class="hljs-keyword">if</span> (xhr.status != <span class="hljs-number">200</span>) {
            failure(<span class="hljs-string">"HTTP Error: "</span> + xhr.status);
            <span class="hljs-keyword">return</span>;
          }

          json = <span class="hljs-built_in">JSON</span>.parse(xhr.responseText);

          <span class="hljs-keyword">if</span> (!json || <span class="hljs-keyword">typeof</span> json.location != <span class="hljs-string">"string"</span>) {
            failure(<span class="hljs-string">"Invalid JSON: "</span> + xhr.responseText);
            <span class="hljs-keyword">return</span>;
          }

          success(pathJoin(settings.basePath, json.location));
        };

        formData = <span class="hljs-keyword">new</span> FormData();
        formData.append(<span class="hljs-string">'file'</span>, blobInfo.blob(), blobInfo.filename());

        xhr.send(formData);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noUpload</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
          resolve([]);
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlerSuccess</span>(<span class="hljs-params">blobInfo, url</span>) </span>{
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">url</span>: url,
          <span class="hljs-attr">blobInfo</span>: blobInfo,
          <span class="hljs-attr">status</span>: <span class="hljs-literal">true</span>
        };
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlerFailure</span>(<span class="hljs-params">blobInfo, error</span>) </span>{
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">url</span>: <span class="hljs-string">''</span>,
          <span class="hljs-attr">blobInfo</span>: blobInfo,
          <span class="hljs-attr">status</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">error</span>: error
        };
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePending</span>(<span class="hljs-params">blobUri, result</span>) </span>{
        Tools.each(pendingPromises[blobUri], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
          resolve(result);
        });

        <span class="hljs-keyword">delete</span> pendingPromises[blobUri];
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uploadBlobInfo</span>(<span class="hljs-params">blobInfo, handler, openNotification</span>) </span>{
        uploadStatus.markPending(blobInfo.blobUri());

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
          <span class="hljs-keyword">var</span> notification, progress;

          <span class="hljs-keyword">var</span> noop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          };

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">var</span> closeNotification = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">if</span> (notification) {
                notification.close();
                progress = noop; <span class="hljs-comment">// Once it's closed it's closed</span>
              }
            };

            <span class="hljs-keyword">var</span> success = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
              closeNotification();
              uploadStatus.markUploaded(blobInfo.blobUri(), url);
              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
              resolve(handlerSuccess(blobInfo, url));
            };

            <span class="hljs-keyword">var</span> failure = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
              closeNotification();
              uploadStatus.removeFailed(blobInfo.blobUri());
              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));
              resolve(handlerFailure(blobInfo, error));
            };

            progress = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">percent</span>) </span>{
              <span class="hljs-keyword">if</span> (percent &lt; <span class="hljs-number">0</span> || percent &gt; <span class="hljs-number">100</span>) {
                <span class="hljs-keyword">return</span>;
              }

              <span class="hljs-keyword">if</span> (!notification) {
                notification = openNotification();
              }

              notification.progressBar.value(percent);
            };

            handler(blobInfo, success, failure, progress);
          } <span class="hljs-keyword">catch</span> (ex) {
            resolve(handlerFailure(blobInfo, ex.message));
          }
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDefaultHandler</span>(<span class="hljs-params">handler</span>) </span>{
        <span class="hljs-keyword">return</span> handler === defaultHandler;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pendingUploadBlobInfo</span>(<span class="hljs-params">blobInfo</span>) </span>{
        <span class="hljs-keyword">var</span> blobUri = blobInfo.blobUri();

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
          pendingPromises[blobUri] = pendingPromises[blobUri] || [];
          pendingPromises[blobUri].push(resolve);
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uploadBlobs</span>(<span class="hljs-params">blobInfos, openNotification</span>) </span>{
        blobInfos = Tools.grep(blobInfos, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blobInfo</span>) </span>{
          <span class="hljs-keyword">return</span> !uploadStatus.isUploaded(blobInfo.blobUri());
        });

        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(Tools.map(blobInfos, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blobInfo</span>) </span>{
          <span class="hljs-keyword">return</span> uploadStatus.isPending(blobInfo.blobUri()) ?
            pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, settings.handler, openNotification);
        }));
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upload</span>(<span class="hljs-params">blobInfos, openNotification</span>) </span>{
        <span class="hljs-keyword">return</span> (!settings.url &amp;&amp; isDefaultHandler(settings.handler)) ? noUpload() : uploadBlobs(blobInfos, openNotification);
      }

      settings = Tools.extend({
        <span class="hljs-attr">credentials</span>: <span class="hljs-literal">false</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1525">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1525">&#182;</a>
              </div>
              <p>We are adding a notify argument to this (at the moment, until it doesnt work)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        handler: defaultHandler
      }, settings);

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">upload</span>: upload
      };
    };
  }
);
<span class="hljs-comment">/**
 * Conversions.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Converts blob/uris back and forth.
 *
 * @private
 * @class tinymce.file.Conversions
 */</span>
define(
  <span class="hljs-string">'tinymce.core.file.Conversions'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Promise"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Promise</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">blobUriToBlob</span>(<span class="hljs-params">url</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{

        <span class="hljs-keyword">var</span> rejectWithError = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          reject(<span class="hljs-string">"Cannot convert "</span> + url + <span class="hljs-string">" to Blob. Resource might not exist or is inaccessible."</span>);
        };

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();

          xhr.open(<span class="hljs-string">'GET'</span>, url, <span class="hljs-literal">true</span>);
          xhr.responseType = <span class="hljs-string">'blob'</span>;

          xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status == <span class="hljs-number">200</span>) {
              resolve(<span class="hljs-keyword">this</span>.response);
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1526">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1526">&#182;</a>
              </div>
              <p>IE11 makes it into onload but responds with status 500</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              rejectWithError();
            }
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-1527">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1527">&#182;</a>
              </div>
              <p>Chrome fires an error event instead of the exception
Also there seems to be no way to intercept the message that is logged to the console</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          xhr.onerror = rejectWithError;

          xhr.send();
        } <span class="hljs-keyword">catch</span> (ex) {
          rejectWithError();
        }
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseDataUri</span>(<span class="hljs-params">uri</span>) </span>{
      <span class="hljs-keyword">var</span> type, matches;

      uri = <span class="hljs-built_in">decodeURIComponent</span>(uri).split(<span class="hljs-string">','</span>);

      matches = <span class="hljs-regexp">/data:([^;]+)/</span>.exec(uri[<span class="hljs-number">0</span>]);
      <span class="hljs-keyword">if</span> (matches) {
        type = matches[<span class="hljs-number">1</span>];
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">type</span>: type,
        <span class="hljs-attr">data</span>: uri[<span class="hljs-number">1</span>]
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dataUriToBlob</span>(<span class="hljs-params">uri</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
        <span class="hljs-keyword">var</span> str, arr, i;

        uri = parseDataUri(uri);</pre></div></div>
            
        </li>
        
        
        <li id="section-1528">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1528">&#182;</a>
              </div>
              <p>Might throw error if data isnt proper base64</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">try</span> {
          str = atob(uri.data);
        } <span class="hljs-keyword">catch</span> (e) {
          resolve(<span class="hljs-keyword">new</span> Blob([]));
          <span class="hljs-keyword">return</span>;
        }

        arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(str.length);

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
          arr[i] = str.charCodeAt(i);
        }

        resolve(<span class="hljs-keyword">new</span> Blob([arr], { <span class="hljs-attr">type</span>: uri.type }));
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uriToBlob</span>(<span class="hljs-params">url</span>) </span>{
      <span class="hljs-keyword">if</span> (url.indexOf(<span class="hljs-string">'blob:'</span>) === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> blobUriToBlob(url);
      }

      <span class="hljs-keyword">if</span> (url.indexOf(<span class="hljs-string">'data:'</span>) === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> dataUriToBlob(url);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">blobToDataUri</span>(<span class="hljs-params">blob</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
        <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> FileReader();

        reader.onloadend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          resolve(reader.result);
        };

        reader.readAsDataURL(blob);
      });
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">uriToBlob</span>: uriToBlob,
      <span class="hljs-attr">blobToDataUri</span>: blobToDataUri,
      <span class="hljs-attr">parseDataUri</span>: parseDataUri
    };
  }
);
<span class="hljs-comment">/**
 * ImageScanner.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Finds images with data uris or blob uris. If data uris are found it will convert them into blob uris.
 *
 * @private
 * @class tinymce.file.ImageScanner
 */</span>
define(
  <span class="hljs-string">'tinymce.core.file.ImageScanner'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Promise"</span>,
    <span class="hljs-string">"tinymce.core.util.Arr"</span>,
    <span class="hljs-string">"tinymce.core.util.Fun"</span>,
    <span class="hljs-string">"tinymce.core.file.Conversions"</span>,
    <span class="hljs-string">"tinymce.core.Env"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Promise, Arr, Fun, Conversions, Env</span>) </span>{
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">var</span> uniqueId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prefix</span>) </span>{
      <span class="hljs-keyword">return</span> (prefix || <span class="hljs-string">'blobid'</span>) + (count++);
    };

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">uploadStatus, blobCache</span>) </span>{
      <span class="hljs-keyword">var</span> cachedPromises = {};

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findAll</span>(<span class="hljs-params">elm, predicate</span>) </span>{
        <span class="hljs-keyword">var</span> images, promises;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">imageToBlobInfo</span>(<span class="hljs-params">img, resolve, reject</span>) </span>{
          <span class="hljs-keyword">var</span> base64, blobInfo;

          <span class="hljs-keyword">if</span> (img.src.indexOf(<span class="hljs-string">'blob:'</span>) === <span class="hljs-number">0</span>) {
            blobInfo = blobCache.getByUri(img.src);

            <span class="hljs-keyword">if</span> (blobInfo) {
              resolve({
                <span class="hljs-attr">image</span>: img,
                <span class="hljs-attr">blobInfo</span>: blobInfo
              });
            } <span class="hljs-keyword">else</span> {
              Conversions.uriToBlob(img.src).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blob</span>) </span>{
                Conversions.blobToDataUri(blob).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dataUri</span>) </span>{
                  base64 = Conversions.parseDataUri(dataUri).data;
                  blobInfo = blobCache.create(uniqueId(), blob, base64);
                  blobCache.add(blobInfo);

                  resolve({
                    <span class="hljs-attr">image</span>: img,
                    <span class="hljs-attr">blobInfo</span>: blobInfo
                  });
                });
              }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
                reject(err);
              });
            }

            <span class="hljs-keyword">return</span>;
          }

          base64 = Conversions.parseDataUri(img.src).data;
          blobInfo = blobCache.findFirst(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cachedBlobInfo</span>) </span>{
            <span class="hljs-keyword">return</span> cachedBlobInfo.base64() === base64;
          });

          <span class="hljs-keyword">if</span> (blobInfo) {
            resolve({
              <span class="hljs-attr">image</span>: img,
              <span class="hljs-attr">blobInfo</span>: blobInfo
            });
          } <span class="hljs-keyword">else</span> {
            Conversions.uriToBlob(img.src).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blob</span>) </span>{
              blobInfo = blobCache.create(uniqueId(), blob, base64);
              blobCache.add(blobInfo);

              resolve({
                <span class="hljs-attr">image</span>: img,
                <span class="hljs-attr">blobInfo</span>: blobInfo
              });
            }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
              reject(err);
            });
          }
        }

        <span class="hljs-keyword">if</span> (!predicate) {
          predicate = Fun.constant(<span class="hljs-literal">true</span>);
        }

        images = Arr.filter(elm.getElementsByTagName(<span class="hljs-string">'img'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">img</span>) </span>{
          <span class="hljs-keyword">var</span> src = img.src;

          <span class="hljs-keyword">if</span> (!Env.fileApi) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

          <span class="hljs-keyword">if</span> (img.hasAttribute(<span class="hljs-string">'data-mce-bogus'</span>)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

          <span class="hljs-keyword">if</span> (img.hasAttribute(<span class="hljs-string">'data-mce-placeholder'</span>)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

          <span class="hljs-keyword">if</span> (!src || src == Env.transparentSrc) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

          <span class="hljs-keyword">if</span> (src.indexOf(<span class="hljs-string">'blob:'</span>) === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> !uploadStatus.isUploaded(src);
          }

          <span class="hljs-keyword">if</span> (src.indexOf(<span class="hljs-string">'data:'</span>) === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> predicate(img);
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        });

        promises = Arr.map(images, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">img</span>) </span>{
          <span class="hljs-keyword">var</span> newPromise;

          <span class="hljs-keyword">if</span> (cachedPromises[img.src]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1529">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1529">&#182;</a>
              </div>
              <p>Since the cached promise will return the cached image
We need to wrap it and resolve with the actual image</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
              cachedPromises[img.src].then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">imageInfo</span>) </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> imageInfo === <span class="hljs-string">'string'</span>) { <span class="hljs-comment">// error apparently</span>
                  <span class="hljs-keyword">return</span> imageInfo;
                }
                resolve({
                  <span class="hljs-attr">image</span>: img,
                  <span class="hljs-attr">blobInfo</span>: imageInfo.blobInfo
                });
              });
            });
          }

          newPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
            imageToBlobInfo(img, resolve, reject);
          }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
            <span class="hljs-keyword">delete</span> cachedPromises[result.image.src];
            <span class="hljs-keyword">return</span> result;
          })[<span class="hljs-string">'catch'</span>](<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
            <span class="hljs-keyword">delete</span> cachedPromises[img.src];
            <span class="hljs-keyword">return</span> error;
          });

          cachedPromises[img.src] = newPromise;

          <span class="hljs-keyword">return</span> newPromise;
        });

        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(promises);
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">findAll</span>: findAll
      };
    };
  }
);
<span class="hljs-comment">/**
 * Uuid.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Generates unique ids.
 *
 * @class tinymce.util.Uuid
 * @private
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.Uuid'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">var</span> seed = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> rnd = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">0xFFFFFFFF</span>).toString(<span class="hljs-number">36</span>);
      };

      <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();
      <span class="hljs-keyword">return</span> <span class="hljs-string">'s'</span> + now.toString(<span class="hljs-number">36</span>) + rnd() + rnd() + rnd();
    };

    <span class="hljs-keyword">var</span> uuid = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prefix</span>) </span>{
      <span class="hljs-keyword">return</span> prefix + (count++) + seed();
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">uuid</span>: uuid
    };
  }
);

defineGlobal(<span class="hljs-string">"global!URL"</span>, URL);
<span class="hljs-comment">/**
 * BlobCache.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Hold blob info objects where a blob has extra internal information.
 *
 * @private
 * @class tinymce.file.BlobCache
 */</span>
define(
  <span class="hljs-string">'tinymce.core.file.BlobCache'</span>,
  [
    <span class="hljs-string">'tinymce.core.util.Arr'</span>,
    <span class="hljs-string">'tinymce.core.util.Fun'</span>,
    <span class="hljs-string">'tinymce.core.util.Uuid'</span>,
    <span class="hljs-string">'global!URL'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Fun, Uuid, URL</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> cache = [], constant = Fun.constant;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mimeToExt</span>(<span class="hljs-params">mime</span>) </span>{
        <span class="hljs-keyword">var</span> mimes = {
          <span class="hljs-string">'image/jpeg'</span>: <span class="hljs-string">'jpg'</span>,
          <span class="hljs-string">'image/jpg'</span>: <span class="hljs-string">'jpg'</span>,
          <span class="hljs-string">'image/gif'</span>: <span class="hljs-string">'gif'</span>,
          <span class="hljs-string">'image/png'</span>: <span class="hljs-string">'png'</span>
        };

        <span class="hljs-keyword">return</span> mimes[mime.toLowerCase()] || <span class="hljs-string">'dat'</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">o, blob, base64, filename</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> o === <span class="hljs-string">'object'</span> ? toBlobInfo(o) : toBlobInfo({
          <span class="hljs-attr">id</span>: o,
          <span class="hljs-attr">name</span>: filename,
          <span class="hljs-attr">blob</span>: blob,
          <span class="hljs-attr">base64</span>: base64
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toBlobInfo</span>(<span class="hljs-params">o</span>) </span>{
        <span class="hljs-keyword">var</span> id, name;

        <span class="hljs-keyword">if</span> (!o.blob || !o.base64) {
          <span class="hljs-keyword">throw</span> <span class="hljs-string">"blob and base64 representations of the image are required for BlobInfo to be created"</span>;
        }

        id = o.id || Uuid.uuid(<span class="hljs-string">'blobid'</span>);
        name = o.name || id;

        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">id</span>: constant(id),
          <span class="hljs-attr">name</span>: constant(name),
          <span class="hljs-attr">filename</span>: constant(name + <span class="hljs-string">'.'</span> + mimeToExt(o.blob.type)),
          <span class="hljs-attr">blob</span>: constant(o.blob),
          <span class="hljs-attr">base64</span>: constant(o.base64),
          <span class="hljs-attr">blobUri</span>: constant(o.blobUri || URL.createObjectURL(o.blob)),
          <span class="hljs-attr">uri</span>: constant(o.uri)
        };
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">blobInfo</span>) </span>{
        <span class="hljs-keyword">if</span> (!get(blobInfo.id())) {
          cache.push(blobInfo);
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">id</span>) </span>{
        <span class="hljs-keyword">return</span> findFirst(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cachedBlobInfo</span>) </span>{
          <span class="hljs-keyword">return</span> cachedBlobInfo.id() === id;
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFirst</span>(<span class="hljs-params">predicate</span>) </span>{
        <span class="hljs-keyword">return</span> Arr.filter(cache, predicate)[<span class="hljs-number">0</span>];
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getByUri</span>(<span class="hljs-params">blobUri</span>) </span>{
        <span class="hljs-keyword">return</span> findFirst(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blobInfo</span>) </span>{
          <span class="hljs-keyword">return</span> blobInfo.blobUri() == blobUri;
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeByUri</span>(<span class="hljs-params">blobUri</span>) </span>{
        cache = Arr.filter(cache, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blobInfo</span>) </span>{
          <span class="hljs-keyword">if</span> (blobInfo.blobUri() === blobUri) {
            URL.revokeObjectURL(blobInfo.blobUri());
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destroy</span>(<span class="hljs-params"></span>) </span>{
        Arr.each(cache, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cachedBlobInfo</span>) </span>{
          URL.revokeObjectURL(cachedBlobInfo.blobUri());
        });

        cache = [];
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">create</span>: create,
        <span class="hljs-attr">add</span>: add,
        <span class="hljs-attr">get</span>: get,
        <span class="hljs-attr">getByUri</span>: getByUri,
        <span class="hljs-attr">findFirst</span>: findFirst,
        <span class="hljs-attr">removeByUri</span>: removeByUri,
        <span class="hljs-attr">destroy</span>: destroy
      };
    };
  }
);
<span class="hljs-comment">/**
 * UploadStatus.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Holds the current status of a blob uri, if it's pending or uploaded and what the result urls was.
 *
 * @private
 * @class tinymce.file.UploadStatus
 */</span>
define(
  <span class="hljs-string">'tinymce.core.file.UploadStatus'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> PENDING = <span class="hljs-number">1</span>, UPLOADED = <span class="hljs-number">2</span>;
      <span class="hljs-keyword">var</span> blobUriStatuses = {};

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStatus</span>(<span class="hljs-params">status, resultUri</span>) </span>{
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">status</span>: status,
          <span class="hljs-attr">resultUri</span>: resultUri
        };
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasBlobUri</span>(<span class="hljs-params">blobUri</span>) </span>{
        <span class="hljs-keyword">return</span> blobUri <span class="hljs-keyword">in</span> blobUriStatuses;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getResultUri</span>(<span class="hljs-params">blobUri</span>) </span>{
        <span class="hljs-keyword">var</span> result = blobUriStatuses[blobUri];

        <span class="hljs-keyword">return</span> result ? result.resultUri : <span class="hljs-literal">null</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPending</span>(<span class="hljs-params">blobUri</span>) </span>{
        <span class="hljs-keyword">return</span> hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : <span class="hljs-literal">false</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUploaded</span>(<span class="hljs-params">blobUri</span>) </span>{
        <span class="hljs-keyword">return</span> hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : <span class="hljs-literal">false</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markPending</span>(<span class="hljs-params">blobUri</span>) </span>{
        blobUriStatuses[blobUri] = createStatus(PENDING, <span class="hljs-literal">null</span>);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markUploaded</span>(<span class="hljs-params">blobUri, resultUri</span>) </span>{
        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeFailed</span>(<span class="hljs-params">blobUri</span>) </span>{
        <span class="hljs-keyword">delete</span> blobUriStatuses[blobUri];
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destroy</span>(<span class="hljs-params"></span>) </span>{
        blobUriStatuses = {};
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">hasBlobUri</span>: hasBlobUri,
        <span class="hljs-attr">getResultUri</span>: getResultUri,
        <span class="hljs-attr">isPending</span>: isPending,
        <span class="hljs-attr">isUploaded</span>: isUploaded,
        <span class="hljs-attr">markPending</span>: markPending,
        <span class="hljs-attr">markUploaded</span>: markUploaded,
        <span class="hljs-attr">removeFailed</span>: removeFailed,
        <span class="hljs-attr">destroy</span>: destroy
      };
    };
  }
);
<span class="hljs-comment">/**
 * EditorUpload.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Handles image uploads, updates undo stack and patches over various internal functions.
 *
 * @private
 * @class tinymce.EditorUpload
 */</span>
define(
  <span class="hljs-string">'tinymce.core.EditorUpload'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Arr"</span>,
    <span class="hljs-string">"tinymce.core.file.Uploader"</span>,
    <span class="hljs-string">"tinymce.core.file.ImageScanner"</span>,
    <span class="hljs-string">"tinymce.core.file.BlobCache"</span>,
    <span class="hljs-string">"tinymce.core.file.UploadStatus"</span>,
    <span class="hljs-string">"tinymce.core.ErrorReporter"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Uploader, ImageScanner, BlobCache, UploadStatus, ErrorReporter</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> blobCache = <span class="hljs-keyword">new</span> BlobCache(), uploader, imageScanner, settings = editor.settings;
      <span class="hljs-keyword">var</span> uploadStatus = <span class="hljs-keyword">new</span> UploadStatus();

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aliveGuard</span>(<span class="hljs-params">callback</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
          <span class="hljs-keyword">if</span> (editor.selection) {
            <span class="hljs-keyword">return</span> callback(result);
          }

          <span class="hljs-keyword">return</span> [];
        };
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cacheInvalidator</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'?'</span> + (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).getTime();
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1530">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1530">&#182;</a>
              </div>
              <p>Replaces strings without regexps to avoid FF regexp to big issue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceString</span>(<span class="hljs-params">content, search, replace</span>) </span>{
        <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">do</span> {
          index = content.indexOf(search, index);

          <span class="hljs-keyword">if</span> (index !== <span class="hljs-number">-1</span>) {
            content = content.substring(<span class="hljs-number">0</span>, index) + replace + content.substr(index + search.length);
            index += replace.length - search.length + <span class="hljs-number">1</span>;
          }
        } <span class="hljs-keyword">while</span> (index !== <span class="hljs-number">-1</span>);

        <span class="hljs-keyword">return</span> content;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceImageUrl</span>(<span class="hljs-params">content, targetUrl, replacementUrl</span>) </span>{
        content = replaceString(content, <span class="hljs-string">'src="'</span> + targetUrl + <span class="hljs-string">'"'</span>, <span class="hljs-string">'src="'</span> + replacementUrl + <span class="hljs-string">'"'</span>);
        content = replaceString(content, <span class="hljs-string">'data-mce-src="'</span> + targetUrl + <span class="hljs-string">'"'</span>, <span class="hljs-string">'data-mce-src="'</span> + replacementUrl + <span class="hljs-string">'"'</span>);

        <span class="hljs-keyword">return</span> content;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceUrlInUndoStack</span>(<span class="hljs-params">targetUrl, replacementUrl</span>) </span>{
        Arr.each(editor.undoManager.data, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">level</span>) </span>{
          <span class="hljs-keyword">if</span> (level.type === <span class="hljs-string">'fragmented'</span>) {
            level.fragments = Arr.map(level.fragments, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fragment</span>) </span>{
              <span class="hljs-keyword">return</span> replaceImageUrl(fragment, targetUrl, replacementUrl);
            });
          } <span class="hljs-keyword">else</span> {
            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
          }
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">openNotification</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> editor.notificationManager.open({
          <span class="hljs-attr">text</span>: editor.translate(<span class="hljs-string">'Image uploading...'</span>),
          <span class="hljs-attr">type</span>: <span class="hljs-string">'info'</span>,
          <span class="hljs-attr">timeout</span>: <span class="hljs-number">-1</span>,
          <span class="hljs-attr">progressBar</span>: <span class="hljs-literal">true</span>
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceImageUri</span>(<span class="hljs-params">image, resultUri</span>) </span>{
        blobCache.removeByUri(image.src);
        replaceUrlInUndoStack(image.src, resultUri);

        editor.$(image).attr({
          <span class="hljs-attr">src</span>: settings.images_reuse_filename ? resultUri + cacheInvalidator() : resultUri,
          <span class="hljs-string">'data-mce-src'</span>: editor.convertURL(resultUri, <span class="hljs-string">'src'</span>)
        });
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uploadImages</span>(<span class="hljs-params">callback</span>) </span>{
        <span class="hljs-keyword">if</span> (!uploader) {
          uploader = <span class="hljs-keyword">new</span> Uploader(uploadStatus, {
            <span class="hljs-attr">url</span>: settings.images_upload_url,
            <span class="hljs-attr">basePath</span>: settings.images_upload_base_path,
            <span class="hljs-attr">credentials</span>: settings.images_upload_credentials,
            <span class="hljs-attr">handler</span>: settings.images_upload_handler
          });
        }

        <span class="hljs-keyword">return</span> scanForImages().then(aliveGuard(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">imageInfos</span>) </span>{
          <span class="hljs-keyword">var</span> blobInfos;

          blobInfos = Arr.map(imageInfos, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">imageInfo</span>) </span>{
            <span class="hljs-keyword">return</span> imageInfo.blobInfo;
          });

          <span class="hljs-keyword">return</span> uploader.upload(blobInfos, openNotification).then(aliveGuard(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
            <span class="hljs-keyword">var</span> filteredResult = Arr.map(result, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">uploadInfo, index</span>) </span>{
              <span class="hljs-keyword">var</span> image = imageInfos[index].image;

              <span class="hljs-keyword">if</span> (uploadInfo.status &amp;&amp; editor.settings.images_replace_blob_uris !== <span class="hljs-literal">false</span>) {
                replaceImageUri(image, uploadInfo.url);
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (uploadInfo.error) {
                ErrorReporter.uploadError(editor, uploadInfo.error);
              }

              <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">element</span>: image,
                <span class="hljs-attr">status</span>: uploadInfo.status
              };
            });

            <span class="hljs-keyword">if</span> (callback) {
              callback(filteredResult);
            }

            <span class="hljs-keyword">return</span> filteredResult;
          }));
        }));
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uploadImagesAuto</span>(<span class="hljs-params">callback</span>) </span>{
        <span class="hljs-keyword">if</span> (settings.automatic_uploads !== <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">return</span> uploadImages(callback);
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidDataUriImage</span>(<span class="hljs-params">imgElm</span>) </span>{
        <span class="hljs-keyword">return</span> settings.images_dataimg_filter ? settings.images_dataimg_filter(imgElm) : <span class="hljs-literal">true</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanForImages</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!imageScanner) {
          imageScanner = <span class="hljs-keyword">new</span> ImageScanner(uploadStatus, blobCache);
        }

        <span class="hljs-keyword">return</span> imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
          result = Arr.filter(result, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resultItem</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1531">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1531">&#182;</a>
              </div>
              <p>ImageScanner internally converts images that it finds, but it may fail to do so if image source is inaccessible.
In such case resultItem will contain appropriate text error message, instead of image data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> resultItem === <span class="hljs-string">'string'</span>) {
              ErrorReporter.displayError(editor, resultItem);
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          });

          Arr.each(result, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resultItem</span>) </span>{
            replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
            resultItem.image.src = resultItem.blobInfo.blobUri();
            resultItem.image.removeAttribute(<span class="hljs-string">'data-mce-src'</span>);
          });

          <span class="hljs-keyword">return</span> result;
        }));
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destroy</span>(<span class="hljs-params"></span>) </span>{
        blobCache.destroy();
        uploadStatus.destroy();
        imageScanner = uploader = <span class="hljs-literal">null</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceBlobUris</span>(<span class="hljs-params">content</span>) </span>{
        <span class="hljs-keyword">return</span> content.replace(<span class="hljs-regexp">/src="(blob:[^"]+)"/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match, blobUri</span>) </span>{
          <span class="hljs-keyword">var</span> resultUri = uploadStatus.getResultUri(blobUri);

          <span class="hljs-keyword">if</span> (resultUri) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'src="'</span> + resultUri + <span class="hljs-string">'"'</span>;
          }

          <span class="hljs-keyword">var</span> blobInfo = blobCache.getByUri(blobUri);

          <span class="hljs-keyword">if</span> (!blobInfo) {
            blobInfo = Arr.reduce(editor.editorManager.editors, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result, editor</span>) </span>{
              <span class="hljs-keyword">return</span> result || editor.editorUpload &amp;&amp; editor.editorUpload.blobCache.getByUri(blobUri);
            }, <span class="hljs-literal">null</span>);
          }

          <span class="hljs-keyword">if</span> (blobInfo) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'src="data:'</span> + blobInfo.blob().type + <span class="hljs-string">';base64,'</span> + blobInfo.base64() + <span class="hljs-string">'"'</span>;
          }

          <span class="hljs-keyword">return</span> match;
        });
      }

      editor.on(<span class="hljs-string">'setContent'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (editor.settings.automatic_uploads !== <span class="hljs-literal">false</span>) {
          uploadImagesAuto();
        } <span class="hljs-keyword">else</span> {
          scanForImages();
        }
      });

      editor.on(<span class="hljs-string">'RawSaveContent'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        e.content = replaceBlobUris(e.content);
      });

      editor.on(<span class="hljs-string">'getContent'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (e.source_view || e.format == <span class="hljs-string">'raw'</span>) {
          <span class="hljs-keyword">return</span>;
        }

        e.content = replaceBlobUris(e.content);
      });

      editor.on(<span class="hljs-string">'PostRender'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        editor.parser.addNodeFilter(<span class="hljs-string">'img'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">images</span>) </span>{
          Arr.each(images, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">img</span>) </span>{
            <span class="hljs-keyword">var</span> src = img.attr(<span class="hljs-string">'src'</span>);

            <span class="hljs-keyword">if</span> (blobCache.getByUri(src)) {
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">var</span> resultUri = uploadStatus.getResultUri(src);
            <span class="hljs-keyword">if</span> (resultUri) {
              img.attr(<span class="hljs-string">'src'</span>, resultUri);
            }
          });
        });
      });

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">blobCache</span>: blobCache,
        <span class="hljs-attr">uploadImages</span>: uploadImages,
        <span class="hljs-attr">uploadImagesAuto</span>: uploadImagesAuto,
        <span class="hljs-attr">scanForImages</span>: scanForImages,
        <span class="hljs-attr">destroy</span>: destroy
      };
    };
  }
);
<span class="hljs-comment">/**
 * ForceBlocks.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Makes sure that everything gets wrapped in paragraphs.
 *
 * @private
 * @class tinymce.ForceBlocks
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ForceBlocks'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun</span>) </span>{
    <span class="hljs-keyword">var</span> addRootBlocks = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> settings = editor.settings, dom = editor.dom, selection = editor.selection;
      <span class="hljs-keyword">var</span> schema = editor.schema, blockElements = schema.getBlockElements();
      <span class="hljs-keyword">var</span> node = selection.getStart(), rootNode = editor.getBody(), rng;
      <span class="hljs-keyword">var</span> startContainer, startOffset, endContainer, endOffset, rootBlockNode;
      <span class="hljs-keyword">var</span> tempNode, offset = <span class="hljs-number">-0xFFFFFF</span>, wrapped, restoreSelection;
      <span class="hljs-keyword">var</span> tmpRng, rootNodeName, forcedRootBlock;

      forcedRootBlock = settings.forced_root_block;

      <span class="hljs-keyword">if</span> (!node || node.nodeType !== <span class="hljs-number">1</span> || !forcedRootBlock) {
        <span class="hljs-keyword">return</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1532">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1532">&#182;</a>
              </div>
              <p>Check if node is wrapped in block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">while</span> (node &amp;&amp; node !== rootNode) {
        <span class="hljs-keyword">if</span> (blockElements[node.nodeName]) {
          <span class="hljs-keyword">return</span>;
        }

        node = node.parentNode;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1533">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1533">&#182;</a>
              </div>
              <p>Get current selection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      rng = selection.getRng();
      <span class="hljs-keyword">if</span> (rng.setStart) {
        startContainer = rng.startContainer;
        startOffset = rng.startOffset;
        endContainer = rng.endContainer;
        endOffset = rng.endOffset;

        <span class="hljs-keyword">try</span> {
          restoreSelection = editor.getDoc().activeElement === rootNode;
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1534">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1534">&#182;</a>
              </div>
              <p>IE throws unspecified error here sometimes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1535">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1535">&#182;</a>
              </div>
              <p>Force control range into text range</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (rng.item) {
          node = rng.item(<span class="hljs-number">0</span>);
          rng = editor.getDoc().body.createTextRange();
          rng.moveToElementText(node);
        }

        restoreSelection = rng.parentElement().ownerDocument === editor.getDoc();
        tmpRng = rng.duplicate();
        tmpRng.collapse(<span class="hljs-literal">true</span>);
        startOffset = tmpRng.move(<span class="hljs-string">'character'</span>, offset) * <span class="hljs-number">-1</span>;

        <span class="hljs-keyword">if</span> (!tmpRng.collapsed) {
          tmpRng = rng.duplicate();
          tmpRng.collapse(<span class="hljs-literal">false</span>);
          endOffset = (tmpRng.move(<span class="hljs-string">'character'</span>, offset) * <span class="hljs-number">-1</span>) - startOffset;
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1536">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1536">&#182;</a>
              </div>
              <p>Wrap non block elements and text nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      node = rootNode.firstChild;
      rootNodeName = rootNode.nodeName.toLowerCase();
      <span class="hljs-keyword">while</span> (node) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1537">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1537">&#182;</a>
              </div>
              <p>TODO: Break this up, too complex</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (((node.nodeType === <span class="hljs-number">3</span> || (node.nodeType == <span class="hljs-number">1</span> &amp;&amp; !blockElements[node.nodeName]))) &amp;&amp;
          schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase())) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1538">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1538">&#182;</a>
              </div>
              <p>Remove empty text nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">3</span> &amp;&amp; node.nodeValue.length === <span class="hljs-number">0</span>) {
            tempNode = node;
            node = node.nextSibling;
            dom.remove(tempNode);
            <span class="hljs-keyword">continue</span>;
          }

          <span class="hljs-keyword">if</span> (!rootBlockNode) {
            rootBlockNode = dom.create(forcedRootBlock, editor.settings.forced_root_block_attrs);
            node.parentNode.insertBefore(rootBlockNode, node);
            wrapped = <span class="hljs-literal">true</span>;
          }

          tempNode = node;
          node = node.nextSibling;
          rootBlockNode.appendChild(tempNode);
        } <span class="hljs-keyword">else</span> {
          rootBlockNode = <span class="hljs-literal">null</span>;
          node = node.nextSibling;
        }
      }

      <span class="hljs-keyword">if</span> (wrapped &amp;&amp; restoreSelection) {
        <span class="hljs-keyword">if</span> (rng.setStart) {
          rng.setStart(startContainer, startOffset);
          rng.setEnd(endContainer, endOffset);
          selection.setRng(rng);
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1539">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1539">&#182;</a>
              </div>
              <p>Only select if the previous selection was inside the document to prevent auto focus in quirks mode</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">try</span> {
            rng = editor.getDoc().body.createTextRange();
            rng.moveToElementText(rootNode);
            rng.collapse(<span class="hljs-literal">true</span>);
            rng.moveStart(<span class="hljs-string">'character'</span>, startOffset);

            <span class="hljs-keyword">if</span> (endOffset &gt; <span class="hljs-number">0</span>) {
              rng.moveEnd(<span class="hljs-string">'character'</span>, endOffset);
            }

            rng.select();
          } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1540">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1540">&#182;</a>
              </div>
              <p>Ignore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          }
        }

        editor.nodeChanged();
      }
    };

    <span class="hljs-keyword">var</span> setup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">if</span> (editor.settings.forced_root_block) {
        editor.on(<span class="hljs-string">'NodeChange'</span>, Fun.curry(addRootBlocks, editor));
      }
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">setup</span>: setup
    };
  }
);
define(
  <span class="hljs-string">'ephox.katamari.api.Merger'</span>,

  [
    <span class="hljs-string">'ephox.katamari.api.Type'</span>,
    <span class="hljs-string">'global!Array'</span>,
    <span class="hljs-string">'global!Error'</span>
  ],

  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Type, Array, Error</span>) </span>{

    <span class="hljs-keyword">var</span> shallow = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">old, nu</span>) </span>{
      <span class="hljs-keyword">return</span> nu;
    };

    <span class="hljs-keyword">var</span> deep = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">old, nu</span>) </span>{
      <span class="hljs-keyword">var</span> bothObjects = Type.isObject(old) &amp;&amp; Type.isObject(nu);
      <span class="hljs-keyword">return</span> bothObjects ? deepMerge(old, nu) : nu;
    };

    <span class="hljs-keyword">var</span> baseMerge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">merger</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1541">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1541">&#182;</a>
              </div>
              <p>Dont use array slice(arguments), makes the whole function unoptimisable on Chrome</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> objects = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">arguments</span>.length);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; objects.length; i++) objects[i] = <span class="hljs-built_in">arguments</span>[i];

        <span class="hljs-keyword">if</span> (objects.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Can\'t merge zero objects'</span>);

        <span class="hljs-keyword">var</span> ret = {};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; objects.length; j++) {
          <span class="hljs-keyword">var</span> curObject = objects[j];
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> curObject) <span class="hljs-keyword">if</span> (curObject.hasOwnProperty(key)) {
            ret[key] = merger(ret[key], curObject[key]);
          }
        }
        <span class="hljs-keyword">return</span> ret;
      };
    };

    <span class="hljs-keyword">var</span> deepMerge = baseMerge(deep);
    <span class="hljs-keyword">var</span> merge = baseMerge(shallow);

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">deepMerge</span>: deepMerge,
      <span class="hljs-attr">merge</span>: merge
    };
  }
);
<span class="hljs-comment">/**
 * MatchKeys.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.keyboard.MatchKeys'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'ephox.katamari.api.Merger'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Fun, Merger</span>) </span>{
    <span class="hljs-keyword">var</span> defaultPatterns = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">patterns</span>) </span>{
      <span class="hljs-keyword">return</span> Arr.map(patterns, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern</span>) </span>{
        <span class="hljs-keyword">return</span> Merger.merge({
          <span class="hljs-attr">shiftKey</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">altKey</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">ctrlKey</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">metaKey</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">keyCode</span>: <span class="hljs-number">0</span>,
          <span class="hljs-attr">action</span>: Fun.noop
        }, pattern);
      });
    };

    <span class="hljs-keyword">var</span> matchesEvent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern, evt</span>) </span>{
      <span class="hljs-keyword">return</span> (
        evt.keyCode === pattern.keyCode &amp;&amp;
        evt.shiftKey === pattern.shiftKey &amp;&amp;
        evt.altKey === pattern.altKey &amp;&amp;
        evt.ctrlKey === pattern.ctrlKey &amp;&amp;
        evt.metaKey === pattern.metaKey
      );
    };

    <span class="hljs-keyword">var</span> match = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">patterns, evt</span>) </span>{
      <span class="hljs-keyword">return</span> Arr.bind(defaultPatterns(patterns), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern</span>) </span>{
        <span class="hljs-keyword">return</span> matchesEvent(pattern, evt) ? [pattern] : [ ];
      });
    };

    <span class="hljs-keyword">var</span> action = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
      <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> f.apply(<span class="hljs-literal">null</span>, args);
      };
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">match</span>: match,
      <span class="hljs-attr">action</span>: action
    };
  }
);
<span class="hljs-comment">/**
 * ArrowKeys.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.keyboard.ArrowKeys'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'ephox.katamari.api.Cell'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.BoundarySelection'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.MatchKeys'</span>,
    <span class="hljs-string">'tinymce.core.util.VK'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, Cell, BoundarySelection, MatchKeys, VK</span>) </span>{
    <span class="hljs-keyword">var</span> setup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caret</span>) </span>{
      editor.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>{
        <span class="hljs-keyword">var</span> matches = MatchKeys.match([
          { <span class="hljs-attr">keyCode</span>: VK.RIGHT, <span class="hljs-attr">action</span>: BoundarySelection.move(editor, caret, <span class="hljs-literal">true</span>) },
          { <span class="hljs-attr">keyCode</span>: VK.LEFT, <span class="hljs-attr">action</span>: BoundarySelection.move(editor, caret, <span class="hljs-literal">false</span>) }
        ], evt);

        Arr.find(matches, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern</span>) </span>{
          <span class="hljs-keyword">return</span> pattern.action();
        }).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) </span>{
          evt.preventDefault();
        });
      });
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">setup</span>: setup
    };
  }
);

<span class="hljs-comment">/**
 * DeleteBackspaceKeys.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.keyboard.DeleteBackspaceKeys'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'tinymce.core.delete.BlockBoundaryDelete'</span>,
    <span class="hljs-string">'tinymce.core.delete.BlockRangeDelete'</span>,
    <span class="hljs-string">'tinymce.core.delete.CefDelete'</span>,
    <span class="hljs-string">'tinymce.core.delete.InlineBoundaryDelete'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.MatchKeys'</span>,
    <span class="hljs-string">'tinymce.core.util.VK'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, BlockBoundaryDelete, BlockRangeDelete, CefDelete, InlineBoundaryDelete, MatchKeys, VK</span>) </span>{
    <span class="hljs-keyword">var</span> setupKeyDownHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caret</span>) </span>{
      editor.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>{
        <span class="hljs-keyword">var</span> matches = MatchKeys.match([
          { <span class="hljs-attr">keyCode</span>: VK.BACKSPACE, <span class="hljs-attr">action</span>: MatchKeys.action(InlineBoundaryDelete.backspaceDelete, editor, caret, <span class="hljs-literal">false</span>) },
          { <span class="hljs-attr">keyCode</span>: VK.DELETE, <span class="hljs-attr">action</span>: MatchKeys.action(InlineBoundaryDelete.backspaceDelete, editor, caret, <span class="hljs-literal">true</span>) },
          { <span class="hljs-attr">keyCode</span>: VK.BACKSPACE, <span class="hljs-attr">action</span>: MatchKeys.action(CefDelete.backspaceDelete, editor, <span class="hljs-literal">false</span>) },
          { <span class="hljs-attr">keyCode</span>: VK.DELETE, <span class="hljs-attr">action</span>: MatchKeys.action(CefDelete.backspaceDelete, editor, <span class="hljs-literal">true</span>) },
          { <span class="hljs-attr">keyCode</span>: VK.BACKSPACE, <span class="hljs-attr">action</span>: MatchKeys.action(BlockRangeDelete.backspaceDelete, editor, <span class="hljs-literal">false</span>) },
          { <span class="hljs-attr">keyCode</span>: VK.DELETE, <span class="hljs-attr">action</span>: MatchKeys.action(BlockRangeDelete.backspaceDelete, editor, <span class="hljs-literal">true</span>) },
          { <span class="hljs-attr">keyCode</span>: VK.BACKSPACE, <span class="hljs-attr">action</span>: MatchKeys.action(BlockBoundaryDelete.backspaceDelete, editor, <span class="hljs-literal">false</span>) },
          { <span class="hljs-attr">keyCode</span>: VK.DELETE, <span class="hljs-attr">action</span>: MatchKeys.action(BlockBoundaryDelete.backspaceDelete, editor, <span class="hljs-literal">true</span>) }
        ], evt);

        Arr.find(matches, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern</span>) </span>{
          <span class="hljs-keyword">return</span> pattern.action();
        }).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) </span>{
          evt.preventDefault();
        });
      });
    };

    <span class="hljs-keyword">var</span> setupKeyUpHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      editor.on(<span class="hljs-string">'keyup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>{
        <span class="hljs-keyword">var</span> matches = MatchKeys.match([
          { <span class="hljs-attr">keyCode</span>: VK.BACKSPACE, <span class="hljs-attr">action</span>: MatchKeys.action(CefDelete.paddEmptyElement, editor) },
          { <span class="hljs-attr">keyCode</span>: VK.DELETE, <span class="hljs-attr">action</span>: MatchKeys.action(CefDelete.paddEmptyElement, editor) }
        ], evt);

        Arr.find(matches, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern</span>) </span>{
          <span class="hljs-keyword">return</span> pattern.action();
        });
      });
    };

    <span class="hljs-keyword">var</span> setup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caret</span>) </span>{
      setupKeyDownHandler(editor, caret);
      setupKeyUpHandler(editor);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">setup</span>: setup
    };
  }
);

<span class="hljs-comment">/**
 * EnterKey.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Contains logic for handling the enter key to split/generate block elements.
 */</span>
define(
  <span class="hljs-string">'tinymce.core.keyboard.EnterKey'</span>,
  [
    <span class="hljs-string">'tinymce.core.caret.CaretContainer'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.dom.RangeUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.TreeWalker'</span>,
    <span class="hljs-string">'tinymce.core.Env'</span>,
    <span class="hljs-string">'tinymce.core.text.Zwsp'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">CaretContainer, NodeType, RangeUtils, TreeWalker, Env, Zwsp, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> isIE = Env.ie &amp;&amp; Env.ie &lt; <span class="hljs-number">11</span>;

    <span class="hljs-keyword">var</span> isEmptyAnchor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> elm &amp;&amp; elm.nodeName === <span class="hljs-string">"A"</span> &amp;&amp; Tools.trim(Zwsp.trim(elm.innerText || elm.textContent)).length === <span class="hljs-number">0</span>;
    };

    <span class="hljs-keyword">var</span> isTableCell = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> node &amp;&amp; <span class="hljs-regexp">/^(TD|TH|CAPTION)$/</span>.test(node.nodeName);
    };

    <span class="hljs-keyword">var</span> emptyBlock = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1542">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1542">&#182;</a>
              </div>
              <p>BR is needed in empty blocks on non IE browsers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      elm.innerHTML = !isIE ? <span class="hljs-string">'&lt;br data-mce-bogus="1"&gt;'</span> : <span class="hljs-string">''</span>;
    };

    <span class="hljs-keyword">var</span> containerAndSiblingName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">container, nodeName</span>) </span>{
      <span class="hljs-keyword">return</span> container.nodeName === nodeName || (container.previousSibling &amp;&amp; container.previousSibling.nodeName === nodeName);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-1543">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1543">&#182;</a>
              </div>
              <p>Returns true if the block can be split into two blocks or not</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> canSplitBlock = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dom, node</span>) </span>{
      <span class="hljs-keyword">return</span> node &amp;&amp;
        dom.isBlock(node) &amp;&amp;
        !<span class="hljs-regexp">/^(TD|TH|CAPTION|FORM)$/</span>.test(node.nodeName) &amp;&amp;
        !<span class="hljs-regexp">/^(fixed|absolute)/i</span>.test(node.style.position) &amp;&amp;
        dom.getContentEditable(node) !== <span class="hljs-string">"true"</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-1544">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1544">&#182;</a>
              </div>
              <p>Renders empty block on IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> renderBlockOnIE = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dom, selection, block</span>) </span>{
      <span class="hljs-keyword">var</span> oldRng;

      <span class="hljs-keyword">if</span> (dom.isBlock(block)) {
        oldRng = selection.getRng();
        block.appendChild(dom.create(<span class="hljs-string">'span'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'\u00a0'</span>));
        selection.select(block);
        block.lastChild.outerHTML = <span class="hljs-string">''</span>;
        selection.setRng(oldRng);
      }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-1545">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1545">&#182;</a>
              </div>
              <p>Remove the first empty inline element of the block so this: <p><b><em></em></b>x</p> becomes this: <p>x</p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> trimInlineElementsOnLeftSideOfBlock = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dom, nonEmptyElementsMap, block</span>) </span>{
      <span class="hljs-keyword">var</span> node = block, firstChilds = [], i;

      <span class="hljs-keyword">if</span> (!node) {
        <span class="hljs-keyword">return</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1546">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1546">&#182;</a>
              </div>
              <p>Find inner most first child ex: <p><i><b>*</b></i></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">while</span> ((node = node.firstChild)) {
        <span class="hljs-keyword">if</span> (dom.isBlock(node)) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (node.nodeType == <span class="hljs-number">1</span> &amp;&amp; !nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
          firstChilds.push(node);
        }
      }

      i = firstChilds.length;
      <span class="hljs-keyword">while</span> (i--) {
        node = firstChilds[i];
        <span class="hljs-keyword">if</span> (!node.hasChildNodes() || (node.firstChild == node.lastChild &amp;&amp; node.firstChild.nodeValue === <span class="hljs-string">''</span>)) {
          dom.remove(node);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (isEmptyAnchor(node)) {
            dom.remove(node);
          }
        }
      }
    };

    <span class="hljs-keyword">var</span> normalizeZwspOffset = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">start, container, offset</span>) </span>{
      <span class="hljs-keyword">if</span> (NodeType.isText(container) === <span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">return</span> offset;
      } <span class="hljs-keyword">if</span> (start) {
        <span class="hljs-keyword">return</span> offset === <span class="hljs-number">1</span> &amp;&amp; container.data.charAt(offset - <span class="hljs-number">1</span>) === Zwsp.ZWSP ? <span class="hljs-number">0</span> : offset;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> offset === container.data.length - <span class="hljs-number">1</span> &amp;&amp; container.data.charAt(offset) === Zwsp.ZWSP ? container.data.length : offset;
      }
    };

    <span class="hljs-keyword">var</span> includeZwspInRange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rng</span>) </span>{
      <span class="hljs-keyword">var</span> newRng = rng.cloneRange();
      newRng.setStart(rng.startContainer, normalizeZwspOffset(<span class="hljs-literal">true</span>, rng.startContainer, rng.startOffset));
      newRng.setEnd(rng.endContainer, normalizeZwspOffset(<span class="hljs-literal">false</span>, rng.endContainer, rng.endOffset));
      <span class="hljs-keyword">return</span> newRng;
    };

    <span class="hljs-keyword">var</span> firstNonWhiteSpaceNodeSibling = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">while</span> (node) {
        <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span> || (node.nodeType === <span class="hljs-number">3</span> &amp;&amp; node.data &amp;&amp; <span class="hljs-regexp">/[\r\n\s]/</span>.test(node.data))) {
          <span class="hljs-keyword">return</span> node;
        }

        node = node.nextSibling;
      }
    };

    <span class="hljs-keyword">var</span> setup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> dom = editor.dom, selection = editor.selection, settings = editor.settings;
      <span class="hljs-keyword">var</span> undoManager = editor.undoManager, schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements(),
        moveCaretBeforeOnEnterElementsMap = schema.getMoveCaretBeforeOnEnterElements();

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleEnterKey</span>(<span class="hljs-params">evt</span>) </span>{
        <span class="hljs-keyword">var</span> rng, tmpRng, editableRoot, container, offset, parentBlock, documentMode, shiftKey,
          newBlock, fragment, containerBlock, parentBlockName, containerBlockName, newBlockName, isAfterLastNodeInContainer;</pre></div></div>
            
        </li>
        
        
        <li id="section-1547">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1547">&#182;</a>
              </div>
              <p>Moves the caret to a suitable position within the root for example in the first non
pure whitespace text node or before an image</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveToCaretPosition</span>(<span class="hljs-params">root</span>) </span>{
          <span class="hljs-keyword">var</span> walker, node, rng, lastNode = root, tempElm;

          <span class="hljs-keyword">if</span> (!root) {
            <span class="hljs-keyword">return</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1548">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1548">&#182;</a>
              </div>
              <p>Old IE versions doesnt properly render blocks with br elements in them
For example <p><br></p> wont be rendered correctly in a contentEditable area
until you remove the br producing <p></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (Env.ie &amp;&amp; Env.ie &lt; <span class="hljs-number">9</span> &amp;&amp; parentBlock &amp;&amp; parentBlock.firstChild) {
            <span class="hljs-keyword">if</span> (parentBlock.firstChild == parentBlock.lastChild &amp;&amp; parentBlock.firstChild.tagName == <span class="hljs-string">'BR'</span>) {
              dom.remove(parentBlock.firstChild);
            }
          }

          <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(LI|DT|DD)$/</span>.test(root.nodeName)) {
            <span class="hljs-keyword">var</span> firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);

            <span class="hljs-keyword">if</span> (firstChild &amp;&amp; <span class="hljs-regexp">/^(UL|OL|DL)$/</span>.test(firstChild.nodeName)) {
              root.insertBefore(dom.doc.createTextNode(<span class="hljs-string">'\u00a0'</span>), root.firstChild);
            }
          }

          rng = dom.createRng();</pre></div></div>
            
        </li>
        
        
        <li id="section-1549">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1549">&#182;</a>
              </div>
              <p>Normalize whitespace to remove empty text nodes. Fix for: #6904
Gecko will be able to place the caret in empty text nodes but it wont render propery
Older IE versions will sometimes crash so for now ignore all IE versions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!Env.ie) {
            root.normalize();
          }

          <span class="hljs-keyword">if</span> (root.hasChildNodes()) {
            walker = <span class="hljs-keyword">new</span> TreeWalker(root, root);

            <span class="hljs-keyword">while</span> ((node = walker.current())) {
              <span class="hljs-keyword">if</span> (node.nodeType == <span class="hljs-number">3</span>) {
                rng.setStart(node, <span class="hljs-number">0</span>);
                rng.setEnd(node, <span class="hljs-number">0</span>);
                <span class="hljs-keyword">break</span>;
              }

              <span class="hljs-keyword">if</span> (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
                rng.setStartBefore(node);
                rng.setEndBefore(node);
                <span class="hljs-keyword">break</span>;
              }

              lastNode = node;
              node = walker.next();
            }

            <span class="hljs-keyword">if</span> (!node) {
              rng.setStart(lastNode, <span class="hljs-number">0</span>);
              rng.setEnd(lastNode, <span class="hljs-number">0</span>);
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (root.nodeName == <span class="hljs-string">'BR'</span>) {
              <span class="hljs-keyword">if</span> (root.nextSibling &amp;&amp; dom.isBlock(root.nextSibling)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1550">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1550">&#182;</a>
              </div>
              <p>Trick on older IE versions to render the caret before the BR between two lists</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (!documentMode || documentMode &lt; <span class="hljs-number">9</span>) {
                  tempElm = dom.create(<span class="hljs-string">'br'</span>);
                  root.parentNode.insertBefore(tempElm, root);
                }

                rng.setStartBefore(root);
                rng.setEndBefore(root);
              } <span class="hljs-keyword">else</span> {
                rng.setStartAfter(root);
                rng.setEndAfter(root);
              }
            } <span class="hljs-keyword">else</span> {
              rng.setStart(root, <span class="hljs-number">0</span>);
              rng.setEnd(root, <span class="hljs-number">0</span>);
            }
          }

          selection.setRng(rng);</pre></div></div>
            
        </li>
        
        
        <li id="section-1551">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1551">&#182;</a>
              </div>
              <p>Remove tempElm created for old IE:s</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          dom.remove(tempElm);
          selection.scrollIntoView(root);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setForcedBlockAttrs</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> forcedRootBlockName = settings.forced_root_block;

          <span class="hljs-keyword">if</span> (forcedRootBlockName &amp;&amp; forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
            dom.setAttribs(node, settings.forced_root_block_attrs);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1552">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1552">&#182;</a>
              </div>
              <p>Creates a new block element by cloning the current one or creating a new one if the name is specified
This function will also copy any text formatting from the parent block and add it to the new one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createNewBlock</span>(<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">var</span> node = container, block, clonedNode, caretNode, textInlineElements = schema.getTextInlineElements();

          <span class="hljs-keyword">if</span> (name || parentBlockName == <span class="hljs-string">"TABLE"</span> || parentBlockName == <span class="hljs-string">"HR"</span>) {
            block = dom.create(name || newBlockName);
            setForcedBlockAttrs(block);
          } <span class="hljs-keyword">else</span> {
            block = parentBlock.cloneNode(<span class="hljs-literal">false</span>);
          }

          caretNode = block;

          <span class="hljs-keyword">if</span> (settings.keep_styles === <span class="hljs-literal">false</span>) {
            dom.setAttrib(block, <span class="hljs-string">'style'</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// wipe out any styles that came over with the block</span>
            dom.setAttrib(block, <span class="hljs-string">'class'</span>, <span class="hljs-literal">null</span>);
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1553">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1553">&#182;</a>
              </div>
              <p>Clone any parent styles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">do</span> {
              <span class="hljs-keyword">if</span> (textInlineElements[node.nodeName]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1554">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1554">&#182;</a>
              </div>
              <p>Never clone a caret containers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (node.id == <span class="hljs-string">'_mce_caret'</span>) {
                  <span class="hljs-keyword">continue</span>;
                }

                clonedNode = node.cloneNode(<span class="hljs-literal">false</span>);
                dom.setAttrib(clonedNode, <span class="hljs-string">'id'</span>, <span class="hljs-string">''</span>); <span class="hljs-comment">// Remove ID since it needs to be document unique</span>

                <span class="hljs-keyword">if</span> (block.hasChildNodes()) {
                  clonedNode.appendChild(block.firstChild);
                  block.appendChild(clonedNode);
                } <span class="hljs-keyword">else</span> {
                  caretNode = clonedNode;
                  block.appendChild(clonedNode);
                }
              }
            } <span class="hljs-keyword">while</span> ((node = node.parentNode) &amp;&amp; node != editableRoot);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1555">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1555">&#182;</a>
              </div>
              <p>BR is needed in empty blocks on non IE browsers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!isIE) {
            caretNode.innerHTML = <span class="hljs-string">'&lt;br data-mce-bogus="1"&gt;'</span>;
          }

          <span class="hljs-keyword">return</span> block;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1556">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1556">&#182;</a>
              </div>
              <p>Returns true/false if the caret is at the start/end of the parent block element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCaretAtStartOrEndOfBlock</span>(<span class="hljs-params">start</span>) </span>{
          <span class="hljs-keyword">var</span> walker, node, name, normalizedOffset;

          normalizedOffset = normalizeZwspOffset(start, container, offset);</pre></div></div>
            
        </li>
        
        
        <li id="section-1557">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1557">&#182;</a>
              </div>
              <p>Caret is in the middle of a text node like a|b</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">3</span> &amp;&amp; (start ? normalizedOffset &gt; <span class="hljs-number">0</span> : normalizedOffset &lt; container.nodeValue.length)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1558">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1558">&#182;</a>
              </div>
              <p>If after the last element in block node edge case for #5091</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (container.parentNode == parentBlock &amp;&amp; isAfterLastNodeInContainer &amp;&amp; !start) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1559">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1559">&#182;</a>
              </div>
              <p>If the caret if before the first element in parentBlock</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (start &amp;&amp; container.nodeType == <span class="hljs-number">1</span> &amp;&amp; container == parentBlock.firstChild) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1560">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1560">&#182;</a>
              </div>
              <p>Caret can be before/after a table or a hr</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (containerAndSiblingName(container, <span class="hljs-string">'TABLE'</span>) || containerAndSiblingName(container, <span class="hljs-string">'HR'</span>)) {
            <span class="hljs-keyword">return</span> (isAfterLastNodeInContainer &amp;&amp; !start) || (!isAfterLastNodeInContainer &amp;&amp; start);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1561">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1561">&#182;</a>
              </div>
              <p>Walk the DOM and look for text nodes or non empty elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          walker = <span class="hljs-keyword">new</span> TreeWalker(container, parentBlock);</pre></div></div>
            
        </li>
        
        
        <li id="section-1562">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1562">&#182;</a>
              </div>
              <p>If caret is in beginning or end of a text block then jump to the next/previous node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">3</span>) {
            <span class="hljs-keyword">if</span> (start &amp;&amp; normalizedOffset === <span class="hljs-number">0</span>) {
              walker.prev();
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!start &amp;&amp; normalizedOffset == container.nodeValue.length) {
              walker.next();
            }
          }

          <span class="hljs-keyword">while</span> ((node = walker.current())) {
            <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1563">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1563">&#182;</a>
              </div>
              <p>Ignore bogus elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (!node.getAttribute(<span class="hljs-string">'data-mce-bogus'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1564">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1564">&#182;</a>
              </div>
              <p>Keep empty elements like <img /> <input /> but not trailing br:s like <p>text|<br></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                name = node.nodeName.toLowerCase();
                <span class="hljs-keyword">if</span> (nonEmptyElementsMap[name] &amp;&amp; name !== <span class="hljs-string">'br'</span>) {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
              }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">3</span> &amp;&amp; !<span class="hljs-regexp">/^[ \t\r\n]*$/</span>.test(node.nodeValue)) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-keyword">if</span> (start) {
              walker.prev();
            } <span class="hljs-keyword">else</span> {
              walker.next();
            }
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1565">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1565">&#182;</a>
              </div>
              <p>Wraps any text nodes or inline elements in the specified forced root block name</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapSelfAndSiblingsInDefaultBlock</span>(<span class="hljs-params">container, offset</span>) </span>{
          <span class="hljs-keyword">var</span> newBlock, parentBlock, startNode, node, next, rootBlockName, blockName = newBlockName || <span class="hljs-string">'P'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1566">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1566">&#182;</a>
              </div>
              <p>Not in a block element or in a table cell or caption</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          parentBlock = dom.getParent(container, dom.isBlock);
          <span class="hljs-keyword">if</span> (!parentBlock || !canSplitBlock(dom, parentBlock)) {
            parentBlock = parentBlock || editableRoot;

            <span class="hljs-keyword">if</span> (parentBlock == editor.getBody() || isTableCell(parentBlock)) {
              rootBlockName = parentBlock.nodeName.toLowerCase();
            } <span class="hljs-keyword">else</span> {
              rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();
            }

            <span class="hljs-keyword">if</span> (!parentBlock.hasChildNodes()) {
              newBlock = dom.create(blockName);
              setForcedBlockAttrs(newBlock);
              parentBlock.appendChild(newBlock);
              rng.setStart(newBlock, <span class="hljs-number">0</span>);
              rng.setEnd(newBlock, <span class="hljs-number">0</span>);
              <span class="hljs-keyword">return</span> newBlock;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1567">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1567">&#182;</a>
              </div>
              <p>Find parent that is the first child of parentBlock</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            node = container;
            <span class="hljs-keyword">while</span> (node.parentNode != parentBlock) {
              node = node.parentNode;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1568">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1568">&#182;</a>
              </div>
              <p>Loop left to find start node start wrapping at</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">while</span> (node &amp;&amp; !dom.isBlock(node)) {
              startNode = node;
              node = node.previousSibling;
            }

            <span class="hljs-keyword">if</span> (startNode &amp;&amp; schema.isValidChild(rootBlockName, blockName.toLowerCase())) {
              newBlock = dom.create(blockName);
              setForcedBlockAttrs(newBlock);
              startNode.parentNode.insertBefore(newBlock, startNode);</pre></div></div>
            
        </li>
        
        
        <li id="section-1569">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1569">&#182;</a>
              </div>
              <p>Start wrapping until we hit a block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              node = startNode;
              <span class="hljs-keyword">while</span> (node &amp;&amp; !dom.isBlock(node)) {
                next = node.nextSibling;
                newBlock.appendChild(node);
                node = next;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-1570">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1570">&#182;</a>
              </div>
              <p>Restore range to its past location</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              rng.setStart(container, offset);
              rng.setEnd(container, offset);
            }
          }

          <span class="hljs-keyword">return</span> container;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1571">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1571">&#182;</a>
              </div>
              <p>Inserts a block or br before/after or in the middle of a split list of the LI is empty</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleEmptyListItem</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFirstOrLastLi</span>(<span class="hljs-params">first</span>) </span>{
            <span class="hljs-keyword">var</span> node = containerBlock[first ? <span class="hljs-string">'firstChild'</span> : <span class="hljs-string">'lastChild'</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-1572">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1572">&#182;</a>
              </div>
              <p>Find first/last element since there might be whitespace there</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">while</span> (node) {
              <span class="hljs-keyword">if</span> (node.nodeType == <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">break</span>;
              }

              node = node[first ? <span class="hljs-string">'nextSibling'</span> : <span class="hljs-string">'previousSibling'</span>];
            }

            <span class="hljs-keyword">return</span> node === parentBlock;
          }

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContainerBlock</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> containerBlockParent = containerBlock.parentNode;

            <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(LI|DT|DD)$/</span>.test(containerBlockParent.nodeName)) {
              <span class="hljs-keyword">return</span> containerBlockParent;
            }

            <span class="hljs-keyword">return</span> containerBlock;
          }

          <span class="hljs-keyword">if</span> (containerBlock == editor.getBody()) {
            <span class="hljs-keyword">return</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1573">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1573">&#182;</a>
              </div>
              <p>Check if we are in an nested list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> containerBlockParentName = containerBlock.parentNode.nodeName;
          <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(OL|UL|LI)$/</span>.test(containerBlockParentName)) {
            newBlockName = <span class="hljs-string">'LI'</span>;
          }

          newBlock = newBlockName ? createNewBlock(newBlockName) : dom.create(<span class="hljs-string">'BR'</span>);

          <span class="hljs-keyword">if</span> (isFirstOrLastLi(<span class="hljs-literal">true</span>) &amp;&amp; isFirstOrLastLi()) {
            <span class="hljs-keyword">if</span> (containerBlockParentName == <span class="hljs-string">'LI'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1574">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1574">&#182;</a>
              </div>
              <p>Nested list is inside a LI</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              dom.insertAfter(newBlock, getContainerBlock());
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1575">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1575">&#182;</a>
              </div>
              <p>Is first and last list item then replace the OL/UL with a text block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              dom.replace(newBlock, containerBlock);
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isFirstOrLastLi(<span class="hljs-literal">true</span>)) {
            <span class="hljs-keyword">if</span> (containerBlockParentName == <span class="hljs-string">'LI'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1576">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1576">&#182;</a>
              </div>
              <p>List nested in an LI then move the list to a new sibling LI</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              dom.insertAfter(newBlock, getContainerBlock());
              newBlock.appendChild(dom.doc.createTextNode(<span class="hljs-string">' '</span>)); <span class="hljs-comment">// Needed for IE so the caret can be placed</span>
              newBlock.appendChild(containerBlock);
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1577">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1577">&#182;</a>
              </div>
              <p>First LI in list then remove LI and add text block before list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              containerBlock.parentNode.insertBefore(newBlock, containerBlock);
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isFirstOrLastLi()) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1578">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1578">&#182;</a>
              </div>
              <p>Last LI in list then remove LI and add text block after list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            dom.insertAfter(newBlock, getContainerBlock());
            renderBlockOnIE(dom, selection, newBlock);
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1579">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1579">&#182;</a>
              </div>
              <p>Middle LI in list the split the list and insert a text block in the middle
Extract after fragment and insert it after the current block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            containerBlock = getContainerBlock();
            tmpRng = rng.cloneRange();
            tmpRng.setStartAfter(parentBlock);
            tmpRng.setEndAfter(containerBlock);
            fragment = tmpRng.extractContents();

            <span class="hljs-keyword">if</span> (newBlockName == <span class="hljs-string">'LI'</span> &amp;&amp; fragment.firstChild.nodeName == <span class="hljs-string">'LI'</span>) {
              newBlock = fragment.firstChild;
              dom.insertAfter(fragment, containerBlock);
            } <span class="hljs-keyword">else</span> {
              dom.insertAfter(fragment, containerBlock);
              dom.insertAfter(newBlock, containerBlock);
            }
          }

          dom.remove(parentBlock);
          moveToCaretPosition(newBlock);
          undoManager.add();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1580">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1580">&#182;</a>
              </div>
              <p>Inserts a BR element if the forced_root_block option is set to false or empty string</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertBr</span>(<span class="hljs-params"></span>) </span>{
          editor.execCommand(<span class="hljs-string">"InsertLineBreak"</span>, <span class="hljs-literal">false</span>, evt);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1581">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1581">&#182;</a>
              </div>
              <p>Trims any linebreaks at the beginning of node user for example when pressing enter in a PRE element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimLeadingLineBreaks</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">3</span>) {
              node.nodeValue = node.nodeValue.replace(<span class="hljs-regexp">/^[\r\n]+/</span>, <span class="hljs-string">''</span>);
            }

            node = node.firstChild;
          } <span class="hljs-keyword">while</span> (node);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEditableRoot</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> root = dom.getRoot(), parent, editableRoot;</pre></div></div>
            
        </li>
        
        
        <li id="section-1582">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1582">&#182;</a>
              </div>
              <p>Get all parents until we hit a non editable parent or the root</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          parent = node;
          <span class="hljs-keyword">while</span> (parent !== root &amp;&amp; dom.getContentEditable(parent) !== <span class="hljs-string">"false"</span>) {
            <span class="hljs-keyword">if</span> (dom.getContentEditable(parent) === <span class="hljs-string">"true"</span>) {
              editableRoot = parent;
            }

            parent = parent.parentNode;
          }

          <span class="hljs-keyword">return</span> parent !== root ? editableRoot : root;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1583">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1583">&#182;</a>
              </div>
              <p>Adds a BR at the end of blocks that only contains an IMG or INPUT since
these might be floated and then they wont expand the block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addBrToBlockIfNeeded</span>(<span class="hljs-params">block</span>) </span>{
          <span class="hljs-keyword">var</span> lastChild;</pre></div></div>
            
        </li>
        
        
        <li id="section-1584">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1584">&#182;</a>
              </div>
              <p>IE will render the blocks correctly other browsers needs a BR</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!isIE) {
            block.normalize(); <span class="hljs-comment">// Remove empty text nodes that got left behind by the extract</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1585">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1585">&#182;</a>
              </div>
              <p>Check if the block is empty or contains a floated last child</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            lastChild = block.lastChild;
            <span class="hljs-keyword">if</span> (!lastChild || (<span class="hljs-regexp">/^(left|right)$/gi</span>.test(dom.getStyle(lastChild, <span class="hljs-string">'float'</span>, <span class="hljs-literal">true</span>)))) {
              dom.add(block, <span class="hljs-string">'br'</span>);
            }
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertNewBlockAfter</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1586">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1586">&#182;</a>
              </div>
              <p>If the caret is at the end of a header we produce a P tag after it similar to Word unless we are in a hgroup</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(H[1-6]|PRE|FIGURE)$/</span>.test(parentBlockName) &amp;&amp; containerBlockName != <span class="hljs-string">'HGROUP'</span>) {
            newBlock = createNewBlock(newBlockName);
          } <span class="hljs-keyword">else</span> {
            newBlock = createNewBlock();
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1587">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1587">&#182;</a>
              </div>
              <p>Split the current container block element if enter is pressed inside an empty inner block element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (settings.end_container_on_empty_block &amp;&amp; canSplitBlock(dom, containerBlock) &amp;&amp; dom.isEmpty(parentBlock)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1588">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1588">&#182;</a>
              </div>
              <p>Split container block for example a BLOCKQUOTE at the current blockParent location for example a P</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            newBlock = dom.split(containerBlock, parentBlock);
          } <span class="hljs-keyword">else</span> {
            dom.insertAfter(newBlock, parentBlock);
          }

          moveToCaretPosition(newBlock);
        }

        rng = selection.getRng(<span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1589">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1589">&#182;</a>
              </div>
              <p>Event is blocked by some other handler for example the lists plugin</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (evt.isDefaultPrevented()) {
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1590">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1590">&#182;</a>
              </div>
              <p>Delete any selected contents</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!rng.collapsed) {
          editor.execCommand(<span class="hljs-string">'Delete'</span>);
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1591">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1591">&#182;</a>
              </div>
              <p>Setup range items and newBlockName</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">new</span> RangeUtils(dom).normalize(rng);
        container = rng.startContainer;
        offset = rng.startOffset;
        newBlockName = (settings.force_p_newlines ? <span class="hljs-string">'p'</span> : <span class="hljs-string">''</span>) || settings.forced_root_block;
        newBlockName = newBlockName ? newBlockName.toUpperCase() : <span class="hljs-string">''</span>;
        documentMode = dom.doc.documentMode;
        shiftKey = evt.shiftKey;</pre></div></div>
            
        </li>
        
        
        <li id="section-1592">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1592">&#182;</a>
              </div>
              <p>Resolve node index</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (container.nodeType == <span class="hljs-number">1</span> &amp;&amp; container.hasChildNodes()) {
          isAfterLastNodeInContainer = offset &gt; container.childNodes.length - <span class="hljs-number">1</span>;

          container = container.childNodes[<span class="hljs-built_in">Math</span>.min(offset, container.childNodes.length - <span class="hljs-number">1</span>)] || container;
          <span class="hljs-keyword">if</span> (isAfterLastNodeInContainer &amp;&amp; container.nodeType == <span class="hljs-number">3</span>) {
            offset = container.nodeValue.length;
          } <span class="hljs-keyword">else</span> {
            offset = <span class="hljs-number">0</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1593">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1593">&#182;</a>
              </div>
              <p>Get editable root node, normally the body element but sometimes a div or span</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        editableRoot = getEditableRoot(container);</pre></div></div>
            
        </li>
        
        
        <li id="section-1594">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1594">&#182;</a>
              </div>
              <p>If there is no editable root then enter is done inside a contentEditable false element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!editableRoot) {
          <span class="hljs-keyword">return</span>;
        }

        undoManager.beforeChange();</pre></div></div>
            
        </li>
        
        
        <li id="section-1595">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1595">&#182;</a>
              </div>
              <p>If editable root isnt block nor the root of the editor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!dom.isBlock(editableRoot) &amp;&amp; editableRoot != dom.getRoot()) {
          <span class="hljs-keyword">if</span> (!newBlockName || shiftKey) {
            insertBr();
          }

          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1596">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1596">&#182;</a>
              </div>
              <p>Wrap the current node and its sibling in a default block if its needed.
for example this <td>text|<b>text2</b></td> will become this <td><p>text|<b>text2</p></b></td>
This wont happen if root blocks are disabled or the shiftKey is pressed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((newBlockName &amp;&amp; !shiftKey) || (!newBlockName &amp;&amp; shiftKey)) {
          container = wrapSelfAndSiblingsInDefaultBlock(container, offset);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1597">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1597">&#182;</a>
              </div>
              <p>Find parent block and setup empty block paddings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        parentBlock = dom.getParent(container, dom.isBlock);
        containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1598">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1598">&#182;</a>
              </div>
              <p>Setup block names</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : <span class="hljs-string">''</span>; <span class="hljs-comment">// IE &lt; 9 &amp; HTML5</span>
        containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : <span class="hljs-string">''</span>; <span class="hljs-comment">// IE &lt; 9 &amp; HTML5</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1599">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1599">&#182;</a>
              </div>
              <p>Enter inside block contained within a LI then split or insert before/after LI</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (containerBlockName == <span class="hljs-string">'LI'</span> &amp;&amp; !evt.ctrlKey) {
          parentBlock = containerBlock;
          parentBlockName = containerBlockName;
        }

        <span class="hljs-keyword">if</span> (editor.undoManager.typing) {
          editor.undoManager.typing = <span class="hljs-literal">false</span>;
          editor.undoManager.add();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1600">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1600">&#182;</a>
              </div>
              <p>Handle enter in list item</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(LI|DT|DD)$/</span>.test(parentBlockName)) {
          <span class="hljs-keyword">if</span> (!newBlockName &amp;&amp; shiftKey) {
            insertBr();
            <span class="hljs-keyword">return</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1601">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1601">&#182;</a>
              </div>
              <p>Handle enter inside an empty list item</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (dom.isEmpty(parentBlock)) {
            handleEmptyListItem();
            <span class="hljs-keyword">return</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1602">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1602">&#182;</a>
              </div>
              <p>Dont split PRE tags but insert a BR instead easier when writing code samples etc</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (parentBlockName == <span class="hljs-string">'PRE'</span> &amp;&amp; settings.br_in_pre !== <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">if</span> (!shiftKey) {
            insertBr();
            <span class="hljs-keyword">return</span>;
          }
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1603">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1603">&#182;</a>
              </div>
              <p>If no root block is configured then insert a BR by default or if the shiftKey is pressed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> ((!newBlockName &amp;&amp; !shiftKey &amp;&amp; parentBlockName != <span class="hljs-string">'LI'</span>) || (newBlockName &amp;&amp; shiftKey)) {
            insertBr();
            <span class="hljs-keyword">return</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1604">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1604">&#182;</a>
              </div>
              <p>If parent block is root then never insert new blocks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (newBlockName &amp;&amp; parentBlock === editor.getBody()) {
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1605">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1605">&#182;</a>
              </div>
              <p>Default block name if its not configured</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        newBlockName = newBlockName || <span class="hljs-string">'P'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1606">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1606">&#182;</a>
              </div>
              <p>Insert new block before/after the parent block depending on caret location</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (CaretContainer.isCaretContainerBlock(parentBlock)) {
          newBlock = CaretContainer.showCaretContainerBlock(parentBlock);
          <span class="hljs-keyword">if</span> (dom.isEmpty(parentBlock)) {
            emptyBlock(parentBlock);
          }
          moveToCaretPosition(newBlock);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isCaretAtStartOrEndOfBlock()) {
          insertNewBlockAfter();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isCaretAtStartOrEndOfBlock(<span class="hljs-literal">true</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1607">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1607">&#182;</a>
              </div>
              <p>Insert new block before</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);
          renderBlockOnIE(dom, selection, newBlock);</pre></div></div>
            
        </li>
        
        
        <li id="section-1608">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1608">&#182;</a>
              </div>
              <p>Adjust caret position if HR</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          containerAndSiblingName(parentBlock, <span class="hljs-string">'HR'</span>) ? moveToCaretPosition(newBlock) : moveToCaretPosition(parentBlock);
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1609">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1609">&#182;</a>
              </div>
              <p>Extract after fragment and insert it after the current block</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          tmpRng = includeZwspInRange(rng).cloneRange();
          tmpRng.setEndAfter(parentBlock);
          fragment = tmpRng.extractContents();
          trimLeadingLineBreaks(fragment);
          newBlock = fragment.firstChild;
          dom.insertAfter(fragment, parentBlock);
          trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);
          addBrToBlockIfNeeded(parentBlock);

          <span class="hljs-keyword">if</span> (dom.isEmpty(parentBlock)) {
            emptyBlock(parentBlock);
          }

          newBlock.normalize();</pre></div></div>
            
        </li>
        
        
        <li id="section-1610">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1610">&#182;</a>
              </div>
              <p>New block might become empty if its <p><b>a |</b></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (dom.isEmpty(newBlock)) {
            dom.remove(newBlock);
            insertNewBlockAfter();
          } <span class="hljs-keyword">else</span> {
            moveToCaretPosition(newBlock);
          }
        }

        dom.setAttrib(newBlock, <span class="hljs-string">'id'</span>, <span class="hljs-string">''</span>); <span class="hljs-comment">// Remove ID since it needs to be document unique</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1611">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1611">&#182;</a>
              </div>
              <p>Allow custom handling of new blocks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        editor.fire(<span class="hljs-string">'NewBlock'</span>, { <span class="hljs-attr">newBlock</span>: newBlock });

        undoManager.typing = <span class="hljs-literal">false</span>;
        undoManager.add();
      }

      editor.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>{
        <span class="hljs-keyword">if</span> (evt.keyCode == <span class="hljs-number">13</span>) {
          <span class="hljs-keyword">if</span> (handleEnterKey(evt) !== <span class="hljs-literal">false</span>) {
            evt.preventDefault();
          }
        }
      });
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">setup</span>: setup
    };
  }
);

<span class="hljs-comment">/**
 * InsertSpace.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.keyboard.InsertSpace'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Fun'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.BoundaryLocation'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, CaretPosition, NodeType, BoundaryLocation</span>) </span>{
    <span class="hljs-keyword">var</span> isValidInsertPoint = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">location, caretPosition</span>) </span>{
      <span class="hljs-keyword">return</span> isAtStartOrEnd(location) &amp;&amp; NodeType.isText(caretPosition.container());
    };

    <span class="hljs-keyword">var</span> insertNbspAtPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caretPosition</span>) </span>{
      <span class="hljs-keyword">var</span> container = caretPosition.container();
      <span class="hljs-keyword">var</span> offset = caretPosition.offset();

      container.insertData(offset, <span class="hljs-string">'\u00a0'</span>);
      editor.selection.setCursorLocation(container, offset + <span class="hljs-number">1</span>);
    };

    <span class="hljs-keyword">var</span> insertAtLocation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caretPosition, location</span>) </span>{
      <span class="hljs-keyword">if</span> (isValidInsertPoint(location, caretPosition)) {
        insertNbspAtPosition(editor, caretPosition);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    };

    <span class="hljs-keyword">var</span> insertAtCaret = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());
      <span class="hljs-keyword">var</span> boundaryLocation = BoundaryLocation.readLocation(editor.getBody(), caretPosition);
      <span class="hljs-keyword">return</span> boundaryLocation.map(Fun.curry(insertAtLocation, editor, caretPosition)).getOr(<span class="hljs-literal">false</span>);
    };

    <span class="hljs-keyword">var</span> isAtStartOrEnd = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">location</span>) </span>{
      <span class="hljs-keyword">return</span> location.fold(
        Fun.constant(<span class="hljs-literal">false</span>), <span class="hljs-comment">// Before</span>
        Fun.constant(<span class="hljs-literal">true</span>),  <span class="hljs-comment">// Start</span>
        Fun.constant(<span class="hljs-literal">true</span>),  <span class="hljs-comment">// End</span>
        Fun.constant(<span class="hljs-literal">false</span>)  <span class="hljs-comment">// After</span>
      );
    };

    <span class="hljs-keyword">var</span> insertAtSelection = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">return</span> editor.selection.isCollapsed() ? insertAtCaret(editor) : <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">insertAtSelection</span>: insertAtSelection
    };
  }
);

<span class="hljs-comment">/**
 * SpaceKey.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.keyboard.SpaceKey'</span>,
  [
    <span class="hljs-string">'ephox.katamari.api.Arr'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.InsertSpace'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.MatchKeys'</span>,
    <span class="hljs-string">'tinymce.core.util.VK'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, InsertSpace, MatchKeys, VK</span>) </span>{
    <span class="hljs-keyword">var</span> setupKeyDownHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, caret</span>) </span>{
      editor.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>{
        <span class="hljs-keyword">var</span> matches = MatchKeys.match([
          { <span class="hljs-attr">keyCode</span>: VK.SPACEBAR, <span class="hljs-attr">action</span>: MatchKeys.action(InsertSpace.insertAtSelection, editor) }
        ], evt);

        Arr.find(matches, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern</span>) </span>{
          <span class="hljs-keyword">return</span> pattern.action();
        }).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) </span>{
          evt.preventDefault();
        });
      });
    };

    <span class="hljs-keyword">var</span> setup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      setupKeyDownHandler(editor);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">setup</span>: setup
    };
  }
);

<span class="hljs-comment">/**
 * KeyboardOverrides.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.keyboard.KeyboardOverrides'</span>,
  [
    <span class="hljs-string">'tinymce.core.keyboard.ArrowKeys'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.BoundarySelection'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.DeleteBackspaceKeys'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.EnterKey'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.SpaceKey'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ArrowKeys, BoundarySelection, DeleteBackspaceKeys, EnterKey, SpaceKey</span>) </span>{
    <span class="hljs-keyword">var</span> setup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> caret = BoundarySelection.setupSelectedState(editor);

      ArrowKeys.setup(editor, caret);
      DeleteBackspaceKeys.setup(editor, caret);
      EnterKey.setup(editor);
      SpaceKey.setup(editor);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">setup</span>: setup
    };
  }
);
<span class="hljs-comment">/**
 * NodeChange.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class handles the nodechange event dispatching both manual and through selection change events.
 *
 * @class tinymce.NodeChange
 * @private
 */</span>
define(
  <span class="hljs-string">'tinymce.core.NodeChange'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.RangeUtils"</span>,
    <span class="hljs-string">"tinymce.core.Env"</span>,
    <span class="hljs-string">"tinymce.core.util.Delay"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">RangeUtils, Env, Delay</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> lastRng, lastPath = [];

      <span class="hljs-comment">/**
       * Returns true/false if the current element path has been changed or not.
       *
       * @private
       * @return {Boolean} True if the element path is the same false if it's not.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSameElementPath</span>(<span class="hljs-params">startElm</span>) </span>{
        <span class="hljs-keyword">var</span> i, currentPath;

        currentPath = editor.$(startElm).parentsUntil(editor.getBody()).add(startElm);
        <span class="hljs-keyword">if</span> (currentPath.length === lastPath.length) {
          <span class="hljs-keyword">for</span> (i = currentPath.length; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-keyword">if</span> (currentPath[i] !== lastPath[i]) {
              <span class="hljs-keyword">break</span>;
            }
          }

          <span class="hljs-keyword">if</span> (i === <span class="hljs-number">-1</span>) {
            lastPath = currentPath;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        }

        lastPath = currentPath;

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1612">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1612">&#182;</a>
              </div>
              <p>Gecko doesnt support the selectionchange event</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!(<span class="hljs-string">'onselectionchange'</span> <span class="hljs-keyword">in</span> editor.getDoc())) {
        editor.on(<span class="hljs-string">'NodeChange Click MouseUp KeyUp Focus'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> nativeRng, fakeRng;</pre></div></div>
            
        </li>
        
        
        <li id="section-1613">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1613">&#182;</a>
              </div>
              <p>Since DOM Ranges mutate on modification
of the DOM we need to clone its contents</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          nativeRng = editor.selection.getRng();
          fakeRng = {
            <span class="hljs-attr">startContainer</span>: nativeRng.startContainer,
            <span class="hljs-attr">startOffset</span>: nativeRng.startOffset,
            <span class="hljs-attr">endContainer</span>: nativeRng.endContainer,
            <span class="hljs-attr">endOffset</span>: nativeRng.endOffset
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-1614">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1614">&#182;</a>
              </div>
              <p>Always treat nodechange as a selectionchange since applying
formatting to the current range wouldnt update the range but its parent</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (e.type == <span class="hljs-string">'nodechange'</span> || !RangeUtils.compareRanges(fakeRng, lastRng)) {
            editor.fire(<span class="hljs-string">'SelectionChange'</span>);
          }

          lastRng = fakeRng;
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1615">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1615">&#182;</a>
              </div>
              <p>IE has a bug where it fires a selectionchange on right click that has a range at the start of the body
When the contextmenu event fires the selection is located at the right location</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      editor.on(<span class="hljs-string">'contextmenu'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        editor.fire(<span class="hljs-string">'SelectionChange'</span>);
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-1616">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1616">&#182;</a>
              </div>
              <p>Selection change is delayed ~200ms on IE when you click inside the current range</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      editor.on(<span class="hljs-string">'SelectionChange'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> startElm = editor.selection.getStart(<span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1617">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1617">&#182;</a>
              </div>
              <p>IE 8 will fire a selectionchange event with an incorrect selection
when focusing out of table cells. Click inside cell -&gt; toolbar = Invalid SelectionChange event</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!Env.range &amp;&amp; editor.selection.isCollapsed()) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (!isSameElementPath(startElm) &amp;&amp; editor.dom.isChildOf(startElm, editor.getBody())) {
          editor.nodeChanged({ <span class="hljs-attr">selectionChange</span>: <span class="hljs-literal">true</span> });
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-1618">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1618">&#182;</a>
              </div>
              <p>Fire an extra nodeChange on mouseup for compatibility reasons</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      editor.on(<span class="hljs-string">'MouseUp'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (!e.isDefaultPrevented()) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1619">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1619">&#182;</a>
              </div>
              <p>Delay nodeChanged call for WebKit edge case issue where the range
isnt updated until after you click outside a selected image</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (editor.selection.getNode().nodeName == <span class="hljs-string">'IMG'</span>) {
            Delay.setEditorTimeout(editor, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              editor.nodeChanged();
            });
          } <span class="hljs-keyword">else</span> {
            editor.nodeChanged();
          }
        }
      });

      <span class="hljs-comment">/**
       * Dispatches out a onNodeChange event to all observers. This method should be called when you
       * need to update the UI states or element path etc.
       *
       * @method nodeChanged
       * @param {Object} args Optional args to pass to NodeChange event handlers.
       */</span>
      <span class="hljs-keyword">this</span>.nodeChanged = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>{
        <span class="hljs-keyword">var</span> selection = editor.selection, node, parents, root;</pre></div></div>
            
        </li>
        
        
        <li id="section-1620">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1620">&#182;</a>
              </div>
              <p>Fix for bug #1896577 it seems that this can not be fired while the editor is loading</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (editor.initialized &amp;&amp; selection &amp;&amp; !editor.settings.disable_nodechange &amp;&amp; !editor.readonly) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1621">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1621">&#182;</a>
              </div>
              <p>Get start node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          root = editor.getBody();
          node = selection.getStart(<span class="hljs-literal">true</span>) || root;</pre></div></div>
            
        </li>
        
        
        <li id="section-1622">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1622">&#182;</a>
              </div>
              <p>Make sure the node is within the editor root or is the editor root</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (node.ownerDocument != editor.getDoc() || !editor.dom.isChildOf(node, root)) {
            node = root;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1623">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1623">&#182;</a>
              </div>
              <p>Get parents and add them to object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          parents = [];
          editor.dom.getParent(node, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">if</span> (node === root) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            parents.push(node);
          });

          args = args || {};
          args.element = node;
          args.parents = parents;

          editor.fire(<span class="hljs-string">'NodeChange'</span>, args);
        }
      };
    };
  }
);

<span class="hljs-comment">/**
 * FakeCaret.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module contains logic for rendering a fake visual caret.
 *
 * @private
 * @class tinymce.caret.FakeCaret
 */</span>
define(
  <span class="hljs-string">'tinymce.core.caret.FakeCaret'</span>,
  [
    <span class="hljs-string">'tinymce.core.caret.CaretContainer'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretContainerRemove'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretPosition'</span>,
    <span class="hljs-string">'tinymce.core.dom.DomQuery'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.dom.RangeUtils'</span>,
    <span class="hljs-string">'tinymce.core.geom.ClientRect'</span>,
    <span class="hljs-string">'tinymce.core.util.Delay'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">CaretContainer, CaretContainerRemove, CaretPosition, DomQuery, NodeType, RangeUtils, ClientRect, Delay</span>) </span>{
    <span class="hljs-keyword">var</span> isContentEditableFalse = NodeType.isContentEditableFalse;

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootNode, isBlock</span>) </span>{
      <span class="hljs-keyword">var</span> cursorInterval, $lastVisualCaret, caretContainerNode;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAbsoluteClientRect</span>(<span class="hljs-params">node, before</span>) </span>{
        <span class="hljs-keyword">var</span> clientRect = ClientRect.collapse(node.getBoundingClientRect(), before),
          docElm, scrollX, scrollY, margin, rootRect;

        <span class="hljs-keyword">if</span> (rootNode.tagName == <span class="hljs-string">'BODY'</span>) {
          docElm = rootNode.ownerDocument.documentElement;
          scrollX = rootNode.scrollLeft || docElm.scrollLeft;
          scrollY = rootNode.scrollTop || docElm.scrollTop;
        } <span class="hljs-keyword">else</span> {
          rootRect = rootNode.getBoundingClientRect();
          scrollX = rootNode.scrollLeft - rootRect.left;
          scrollY = rootNode.scrollTop - rootRect.top;
        }

        clientRect.left += scrollX;
        clientRect.right += scrollX;
        clientRect.top += scrollY;
        clientRect.bottom += scrollY;
        clientRect.width = <span class="hljs-number">1</span>;

        margin = node.offsetWidth - node.clientWidth;

        <span class="hljs-keyword">if</span> (margin &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">if</span> (before) {
            margin *= <span class="hljs-number">-1</span>;
          }

          clientRect.left += margin;
          clientRect.right += margin;
        }

        <span class="hljs-keyword">return</span> clientRect;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimInlineCaretContainers</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> contentEditableFalseNodes, node, sibling, i, data;

        contentEditableFalseNodes = DomQuery(<span class="hljs-string">'*[contentEditable=false]'</span>, rootNode);
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; contentEditableFalseNodes.length; i++) {
          node = contentEditableFalseNodes[i];

          sibling = node.previousSibling;
          <span class="hljs-keyword">if</span> (CaretContainer.endsWithCaretContainer(sibling)) {
            data = sibling.data;

            <span class="hljs-keyword">if</span> (data.length == <span class="hljs-number">1</span>) {
              sibling.parentNode.removeChild(sibling);
            } <span class="hljs-keyword">else</span> {
              sibling.deleteData(data.length - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
            }
          }

          sibling = node.nextSibling;
          <span class="hljs-keyword">if</span> (CaretContainer.startsWithCaretContainer(sibling)) {
            data = sibling.data;

            <span class="hljs-keyword">if</span> (data.length == <span class="hljs-number">1</span>) {
              sibling.parentNode.removeChild(sibling);
            } <span class="hljs-keyword">else</span> {
              sibling.deleteData(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
            }
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span>(<span class="hljs-params">before, node</span>) </span>{
        <span class="hljs-keyword">var</span> clientRect, rng;

        hide();

        <span class="hljs-keyword">if</span> (isBlock(node)) {
          caretContainerNode = CaretContainer.insertBlock(<span class="hljs-string">'p'</span>, node, before);
          clientRect = getAbsoluteClientRect(node, before);
          DomQuery(caretContainerNode).css(<span class="hljs-string">'top'</span>, clientRect.top);

          $lastVisualCaret = DomQuery(<span class="hljs-string">'&lt;div class="mce-visual-caret" data-mce-bogus="all"&gt;&lt;/div&gt;'</span>).css(clientRect).appendTo(rootNode);

          <span class="hljs-keyword">if</span> (before) {
            $lastVisualCaret.addClass(<span class="hljs-string">'mce-visual-caret-before'</span>);
          }

          startBlink();

          rng = node.ownerDocument.createRange();
          rng.setStart(caretContainerNode, <span class="hljs-number">0</span>);
          rng.setEnd(caretContainerNode, <span class="hljs-number">0</span>);
        } <span class="hljs-keyword">else</span> {
          caretContainerNode = CaretContainer.insertInline(node, before);
          rng = node.ownerDocument.createRange();

          <span class="hljs-keyword">if</span> (isContentEditableFalse(caretContainerNode.nextSibling)) {
            rng.setStart(caretContainerNode, <span class="hljs-number">0</span>);
            rng.setEnd(caretContainerNode, <span class="hljs-number">0</span>);
          } <span class="hljs-keyword">else</span> {
            rng.setStart(caretContainerNode, <span class="hljs-number">1</span>);
            rng.setEnd(caretContainerNode, <span class="hljs-number">1</span>);
          }

          <span class="hljs-keyword">return</span> rng;
        }

        <span class="hljs-keyword">return</span> rng;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hide</span>(<span class="hljs-params"></span>) </span>{
        trimInlineCaretContainers();

        <span class="hljs-keyword">if</span> (caretContainerNode) {
          CaretContainerRemove.remove(caretContainerNode);
          caretContainerNode = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">if</span> ($lastVisualCaret) {
          $lastVisualCaret.remove();
          $lastVisualCaret = <span class="hljs-literal">null</span>;
        }

        clearInterval(cursorInterval);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startBlink</span>(<span class="hljs-params"></span>) </span>{
        cursorInterval = Delay.setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          DomQuery(<span class="hljs-string">'div.mce-visual-caret'</span>, rootNode).toggleClass(<span class="hljs-string">'mce-visual-caret-hidden'</span>);
        }, <span class="hljs-number">500</span>);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destroy</span>(<span class="hljs-params"></span>) </span>{
        Delay.clearInterval(cursorInterval);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCss</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'.mce-visual-caret {'</span> +
          <span class="hljs-string">'position: absolute;'</span> +
          <span class="hljs-string">'background-color: black;'</span> +
          <span class="hljs-string">'background-color: currentcolor;'</span> +
          <span class="hljs-string">'}'</span> +
          <span class="hljs-string">'.mce-visual-caret-hidden {'</span> +
          <span class="hljs-string">'display: none;'</span> +
          <span class="hljs-string">'}'</span> +
          <span class="hljs-string">'*[data-mce-caret] {'</span> +
          <span class="hljs-string">'position: absolute;'</span> +
          <span class="hljs-string">'left: -1000px;'</span> +
          <span class="hljs-string">'right: auto;'</span> +
          <span class="hljs-string">'top: 0;'</span> +
          <span class="hljs-string">'margin: 0;'</span> +
          <span class="hljs-string">'padding: 0;'</span> +
          <span class="hljs-string">'}'</span>
        );
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">show</span>: show,
        <span class="hljs-attr">hide</span>: hide,
        <span class="hljs-attr">getCss</span>: getCss,
        <span class="hljs-attr">destroy</span>: destroy
      };
    };
  }
);
<span class="hljs-comment">/**
 * Dimensions.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module measures nodes and returns client rects. The client rects has an
 * extra node property.
 *
 * @private
 * @class tinymce.dom.Dimensions
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.Dimensions'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Arr"</span>,
    <span class="hljs-string">"tinymce.core.dom.NodeType"</span>,
    <span class="hljs-string">"tinymce.core.geom.ClientRect"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Arr, NodeType, ClientRect</span>) </span>{

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getClientRects</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArrayWithNode</span>(<span class="hljs-params">clientRects</span>) </span>{
        <span class="hljs-keyword">return</span> Arr.map(clientRects, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clientRect</span>) </span>{
          clientRect = ClientRect.clone(clientRect);
          clientRect.node = node;

          <span class="hljs-keyword">return</span> clientRect;
        });
      }

      <span class="hljs-keyword">if</span> (Arr.isArray(node)) {
        <span class="hljs-keyword">return</span> Arr.reduce(node, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result, node</span>) </span>{
          <span class="hljs-keyword">return</span> result.concat(getClientRects(node));
        }, []);
      }

      <span class="hljs-keyword">if</span> (NodeType.isElement(node)) {
        <span class="hljs-keyword">return</span> toArrayWithNode(node.getClientRects());
      }

      <span class="hljs-keyword">if</span> (NodeType.isText(node)) {
        <span class="hljs-keyword">var</span> rng = node.ownerDocument.createRange();

        rng.setStart(node, <span class="hljs-number">0</span>);
        rng.setEnd(node, node.data.length);

        <span class="hljs-keyword">return</span> toArrayWithNode(rng.getClientRects());
      }
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">/**
       * Returns the client rects for a specific node.
       *
       * @method getClientRects
       * @param {Array/DOMNode} node Node or array of nodes to get client rects on.
       * @param {Array} Array of client rects with a extra node property.
       */</span>
      getClientRects: getClientRects
    };
  }
);
<span class="hljs-comment">/**
 * LineWalker.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module lets you walk the document line by line
 * returing nodes and client rects for each line.
 *
 * @private
 * @class tinymce.caret.LineWalker
 */</span>
define(
  <span class="hljs-string">'tinymce.core.caret.LineWalker'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Fun"</span>,
    <span class="hljs-string">"tinymce.core.util.Arr"</span>,
    <span class="hljs-string">"tinymce.core.dom.Dimensions"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretCandidate"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretUtils"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretWalker"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretPosition"</span>,
    <span class="hljs-string">"tinymce.core.geom.ClientRect"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, Arr, Dimensions, CaretCandidate, CaretUtils, CaretWalker, CaretPosition, ClientRect</span>) </span>{
    <span class="hljs-keyword">var</span> curry = Fun.curry;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findUntil</span>(<span class="hljs-params">direction, rootNode, predicateFn, node</span>) </span>{
      <span class="hljs-keyword">while</span> ((node = CaretUtils.findNode(node, direction, CaretCandidate.isEditableCaretCandidate, rootNode))) {
        <span class="hljs-keyword">if</span> (predicateFn(node)) {
          <span class="hljs-keyword">return</span>;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walkUntil</span>(<span class="hljs-params">direction, isAboveFn, isBeflowFn, rootNode, predicateFn, caretPosition</span>) </span>{
      <span class="hljs-keyword">var</span> line = <span class="hljs-number">0</span>, node, result = [], targetClientRect;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> i, clientRect, clientRects;

        clientRects = Dimensions.getClientRects(node);
        <span class="hljs-keyword">if</span> (direction == <span class="hljs-number">-1</span>) {
          clientRects = clientRects.reverse();
        }

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; clientRects.length; i++) {
          clientRect = clientRects[i];
          <span class="hljs-keyword">if</span> (isBeflowFn(clientRect, targetClientRect)) {
            <span class="hljs-keyword">continue</span>;
          }

          <span class="hljs-keyword">if</span> (result.length &gt; <span class="hljs-number">0</span> &amp;&amp; isAboveFn(clientRect, Arr.last(result))) {
            line++;
          }

          clientRect.line = line;

          <span class="hljs-keyword">if</span> (predicateFn(clientRect)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }

          result.push(clientRect);
        }
      }

      targetClientRect = Arr.last(caretPosition.getClientRects());
      <span class="hljs-keyword">if</span> (!targetClientRect) {
        <span class="hljs-keyword">return</span> result;
      }

      node = caretPosition.getNode();
      add(node);
      findUntil(direction, rootNode, add, node);

      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aboveLineNumber</span>(<span class="hljs-params">lineNumber, clientRect</span>) </span>{
      <span class="hljs-keyword">return</span> clientRect.line &gt; lineNumber;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLine</span>(<span class="hljs-params">lineNumber, clientRect</span>) </span>{
      <span class="hljs-keyword">return</span> clientRect.line === lineNumber;
    }

    <span class="hljs-keyword">var</span> upUntil = curry(walkUntil, <span class="hljs-number">-1</span>, ClientRect.isAbove, ClientRect.isBelow);
    <span class="hljs-keyword">var</span> downUntil = curry(walkUntil, <span class="hljs-number">1</span>, ClientRect.isBelow, ClientRect.isAbove);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">positionsUntil</span>(<span class="hljs-params">direction, rootNode, predicateFn, node</span>) </span>{
      <span class="hljs-keyword">var</span> caretWalker = <span class="hljs-keyword">new</span> CaretWalker(rootNode), walkFn, isBelowFn, isAboveFn,
        caretPosition, result = [], line = <span class="hljs-number">0</span>, clientRect, targetClientRect;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getClientRect</span>(<span class="hljs-params">caretPosition</span>) </span>{
        <span class="hljs-keyword">if</span> (direction == <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">return</span> Arr.last(caretPosition.getClientRects());
        }

        <span class="hljs-keyword">return</span> Arr.last(caretPosition.getClientRects());
      }

      <span class="hljs-keyword">if</span> (direction == <span class="hljs-number">1</span>) {
        walkFn = caretWalker.next;
        isBelowFn = ClientRect.isBelow;
        isAboveFn = ClientRect.isAbove;
        caretPosition = CaretPosition.after(node);
      } <span class="hljs-keyword">else</span> {
        walkFn = caretWalker.prev;
        isBelowFn = ClientRect.isAbove;
        isAboveFn = ClientRect.isBelow;
        caretPosition = CaretPosition.before(node);
      }

      targetClientRect = getClientRect(caretPosition);

      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">if</span> (!caretPosition.isVisible()) {
          <span class="hljs-keyword">continue</span>;
        }

        clientRect = getClientRect(caretPosition);

        <span class="hljs-keyword">if</span> (isAboveFn(clientRect, targetClientRect)) {
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (result.length &gt; <span class="hljs-number">0</span> &amp;&amp; isBelowFn(clientRect, Arr.last(result))) {
          line++;
        }

        clientRect = ClientRect.clone(clientRect);
        clientRect.position = caretPosition;
        clientRect.line = line;

        <span class="hljs-keyword">if</span> (predicateFn(clientRect)) {
          <span class="hljs-keyword">return</span> result;
        }

        result.push(clientRect);
      } <span class="hljs-keyword">while</span> ((caretPosition = walkFn(caretPosition)));

      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">upUntil</span>: upUntil,
      <span class="hljs-attr">downUntil</span>: downUntil,

      <span class="hljs-comment">/**
       * Find client rects with line and caret position until the predicate returns true.
       *
       * @method positionsUntil
       * @param {Number} direction Direction forward/backward 1/-1.
       * @param {DOMNode} rootNode Root node to walk within.
       * @param {function} predicateFn Gets the client rect as it's input.
       * @param {DOMNode} node Node to start walking from.
       * @return {Array} Array of client rects with line and position properties.
       */</span>
      positionsUntil: positionsUntil,

      <span class="hljs-attr">isAboveLine</span>: curry(aboveLineNumber),
      <span class="hljs-attr">isLine</span>: curry(isLine)
    };
  }
);
<span class="hljs-comment">/**
 * LineUtils.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Utility functions for working with lines.
 *
 * @private
 * @class tinymce.caret.LineUtils
 */</span>
define(
  <span class="hljs-string">'tinymce.core.caret.LineUtils'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Fun"</span>,
    <span class="hljs-string">"tinymce.core.util.Arr"</span>,
    <span class="hljs-string">"tinymce.core.dom.NodeType"</span>,
    <span class="hljs-string">"tinymce.core.dom.Dimensions"</span>,
    <span class="hljs-string">"tinymce.core.geom.ClientRect"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretUtils"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretCandidate"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Fun, Arr, NodeType, Dimensions, ClientRect, CaretUtils, CaretCandidate</span>) </span>{
    <span class="hljs-keyword">var</span> isContentEditableFalse = NodeType.isContentEditableFalse,
      findNode = CaretUtils.findNode,
      curry = Fun.curry;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">distanceToRectLeft</span>(<span class="hljs-params">clientRect, clientX</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(clientRect.left - clientX);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">distanceToRectRight</span>(<span class="hljs-params">clientRect, clientX</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(clientRect.right - clientX);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findClosestClientRect</span>(<span class="hljs-params">clientRects, clientX</span>) </span>{
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isInside</span>(<span class="hljs-params">clientX, clientRect</span>) </span>{
        <span class="hljs-keyword">return</span> clientX &gt;= clientRect.left &amp;&amp; clientX &lt;= clientRect.right;
      }

      <span class="hljs-keyword">return</span> Arr.reduce(clientRects, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">oldClientRect, clientRect</span>) </span>{
        <span class="hljs-keyword">var</span> oldDistance, newDistance;

        oldDistance = <span class="hljs-built_in">Math</span>.min(distanceToRectLeft(oldClientRect, clientX), distanceToRectRight(oldClientRect, clientX));
        newDistance = <span class="hljs-built_in">Math</span>.min(distanceToRectLeft(clientRect, clientX), distanceToRectRight(clientRect, clientX));

        <span class="hljs-keyword">if</span> (isInside(clientX, clientRect)) {
          <span class="hljs-keyword">return</span> clientRect;
        }

        <span class="hljs-keyword">if</span> (isInside(clientX, oldClientRect)) {
          <span class="hljs-keyword">return</span> oldClientRect;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1624">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1624">&#182;</a>
              </div>
              <p>cE=false has higher priority</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (newDistance == oldDistance &amp;&amp; isContentEditableFalse(clientRect.node)) {
          <span class="hljs-keyword">return</span> clientRect;
        }

        <span class="hljs-keyword">if</span> (newDistance &lt; oldDistance) {
          <span class="hljs-keyword">return</span> clientRect;
        }

        <span class="hljs-keyword">return</span> oldClientRect;
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walkUntil</span>(<span class="hljs-params">direction, rootNode, predicateFn, node</span>) </span>{
      <span class="hljs-keyword">while</span> ((node = findNode(node, direction, CaretCandidate.isEditableCaretCandidate, rootNode))) {
        <span class="hljs-keyword">if</span> (predicateFn(node)) {
          <span class="hljs-keyword">return</span>;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLineNodeRects</span>(<span class="hljs-params">rootNode, targetNodeRect</span>) </span>{
      <span class="hljs-keyword">var</span> clientRects = [];

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collect</span>(<span class="hljs-params">checkPosFn, node</span>) </span>{
        <span class="hljs-keyword">var</span> lineRects;

        lineRects = Arr.filter(Dimensions.getClientRects(node), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clientRect</span>) </span>{
          <span class="hljs-keyword">return</span> !checkPosFn(clientRect, targetNodeRect);
        });

        clientRects = clientRects.concat(lineRects);

        <span class="hljs-keyword">return</span> lineRects.length === <span class="hljs-number">0</span>;
      }

      clientRects.push(targetNodeRect);
      walkUntil(<span class="hljs-number">-1</span>, rootNode, curry(collect, ClientRect.isAbove), targetNodeRect.node);
      walkUntil(<span class="hljs-number">1</span>, rootNode, curry(collect, ClientRect.isBelow), targetNodeRect.node);

      <span class="hljs-keyword">return</span> clientRects;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContentEditableFalseChildren</span>(<span class="hljs-params">rootNode</span>) </span>{
      <span class="hljs-keyword">return</span> Arr.filter(Arr.toArray(rootNode.getElementsByTagName(<span class="hljs-string">'*'</span>)), isContentEditableFalse);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">caretInfo</span>(<span class="hljs-params">clientRect, clientX</span>) </span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">node</span>: clientRect.node,
        <span class="hljs-attr">before</span>: distanceToRectLeft(clientRect, clientX) &lt; distanceToRectRight(clientRect, clientX)
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closestCaret</span>(<span class="hljs-params">rootNode, clientX, clientY</span>) </span>{
      <span class="hljs-keyword">var</span> contentEditableFalseNodeRects, closestNodeRect;

      contentEditableFalseNodeRects = Dimensions.getClientRects(getContentEditableFalseChildren(rootNode));
      contentEditableFalseNodeRects = Arr.filter(contentEditableFalseNodeRects, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clientRect</span>) </span>{
        <span class="hljs-keyword">return</span> clientY &gt;= clientRect.top &amp;&amp; clientY &lt;= clientRect.bottom;
      });

      closestNodeRect = findClosestClientRect(contentEditableFalseNodeRects, clientX);
      <span class="hljs-keyword">if</span> (closestNodeRect) {
        closestNodeRect = findClosestClientRect(findLineNodeRects(rootNode, closestNodeRect), clientX);
        <span class="hljs-keyword">if</span> (closestNodeRect &amp;&amp; isContentEditableFalse(closestNodeRect.node)) {
          <span class="hljs-keyword">return</span> caretInfo(closestNodeRect, clientX);
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">findClosestClientRect</span>: findClosestClientRect,
      <span class="hljs-attr">findLineNodeRects</span>: findLineNodeRects,
      <span class="hljs-attr">closestCaret</span>: closestCaret
    };
  }
);
<span class="hljs-comment">/**
 * MousePosition.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module calculates an absolute coordinate inside the editor body for both local and global mouse events.
 *
 * @private
 * @class tinymce.dom.MousePosition
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.MousePosition'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> getAbsolutePosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">var</span> doc, docElem, win, clientRect;

      clientRect = elm.getBoundingClientRect();
      doc = elm.ownerDocument;
      docElem = doc.documentElement;
      win = doc.defaultView;

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">top</span>: clientRect.top + win.pageYOffset - docElem.clientTop,
        <span class="hljs-attr">left</span>: clientRect.left + win.pageXOffset - docElem.clientLeft
      };
    };

    <span class="hljs-keyword">var</span> getBodyPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">return</span> editor.inline ? getAbsolutePosition(editor.getBody()) : { <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">top</span>: <span class="hljs-number">0</span> };
    };

    <span class="hljs-keyword">var</span> getScrollPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> body = editor.getBody();
      <span class="hljs-keyword">return</span> editor.inline ? { <span class="hljs-attr">left</span>: body.scrollLeft, <span class="hljs-attr">top</span>: body.scrollTop } : { <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">top</span>: <span class="hljs-number">0</span> };
    };

    <span class="hljs-keyword">var</span> getBodyScroll = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> body = editor.getBody(), docElm = editor.getDoc().documentElement;
      <span class="hljs-keyword">var</span> inlineScroll = { <span class="hljs-attr">left</span>: body.scrollLeft, <span class="hljs-attr">top</span>: body.scrollTop };
      <span class="hljs-keyword">var</span> iframeScroll = { <span class="hljs-attr">left</span>: body.scrollLeft || docElm.scrollLeft, <span class="hljs-attr">top</span>: body.scrollTop || docElm.scrollTop };

      <span class="hljs-keyword">return</span> editor.inline ? inlineScroll : iframeScroll;
    };

    <span class="hljs-keyword">var</span> getMousePosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, event</span>) </span>{
      <span class="hljs-keyword">if</span> (event.target.ownerDocument !== editor.getDoc()) {
        <span class="hljs-keyword">var</span> iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
        <span class="hljs-keyword">var</span> scrollPosition = getBodyScroll(editor);

        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">left</span>: event.pageX - iframePosition.left + scrollPosition.left,
          <span class="hljs-attr">top</span>: event.pageY - iframePosition.top + scrollPosition.top
        };
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">left</span>: event.pageX,
        <span class="hljs-attr">top</span>: event.pageY
      };
    };

    <span class="hljs-keyword">var</span> calculatePosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">bodyPosition, scrollPosition, mousePosition</span>) </span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">pageX</span>: (mousePosition.left - bodyPosition.left) + scrollPosition.left,
        <span class="hljs-attr">pageY</span>: (mousePosition.top - bodyPosition.top) + scrollPosition.top
      };
    };

    <span class="hljs-keyword">var</span> calc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, event</span>) </span>{
      <span class="hljs-keyword">return</span> calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">calc</span>: calc
    };
  }
);

<span class="hljs-comment">/**
 * DragDropOverrides.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module contains logic overriding the drag/drop logic of the editor.
 *
 * @private
 * @class tinymce.DragDropOverrides
 */</span>
define(
  <span class="hljs-string">'tinymce.core.DragDropOverrides'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.NodeType"</span>,
    <span class="hljs-string">"tinymce.core.util.Arr"</span>,
    <span class="hljs-string">"tinymce.core.util.Fun"</span>,
    <span class="hljs-string">"tinymce.core.util.Delay"</span>,
    <span class="hljs-string">"tinymce.core.dom.DOMUtils"</span>,
    <span class="hljs-string">"tinymce.core.dom.MousePosition"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">
    NodeType, Arr, Fun, Delay, DOMUtils, MousePosition
  </span>) </span>{
    <span class="hljs-keyword">var</span> isContentEditableFalse = NodeType.isContentEditableFalse,
      isContentEditableTrue = NodeType.isContentEditableTrue;

    <span class="hljs-keyword">var</span> isDraggable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootElm, elm</span>) </span>{
      <span class="hljs-keyword">return</span> isContentEditableFalse(elm) &amp;&amp; elm !== rootElm;
    };

    <span class="hljs-keyword">var</span> isValidDropTarget = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, targetElement, dragElement</span>) </span>{
      <span class="hljs-keyword">if</span> (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">if</span> (isContentEditableFalse(targetElement)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    };

    <span class="hljs-keyword">var</span> cloneElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">var</span> cloneElm = elm.cloneNode(<span class="hljs-literal">true</span>);
      cloneElm.removeAttribute(<span class="hljs-string">'data-mce-selected'</span>);
      <span class="hljs-keyword">return</span> cloneElm;
    };

    <span class="hljs-keyword">var</span> createGhost = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, elm, width, height</span>) </span>{
      <span class="hljs-keyword">var</span> clonedElm = elm.cloneNode(<span class="hljs-literal">true</span>);

      editor.dom.setStyles(clonedElm, { <span class="hljs-attr">width</span>: width, <span class="hljs-attr">height</span>: height });
      editor.dom.setAttrib(clonedElm, <span class="hljs-string">'data-mce-selected'</span>, <span class="hljs-literal">null</span>);

      <span class="hljs-keyword">var</span> ghostElm = editor.dom.create(<span class="hljs-string">'div'</span>, {
        <span class="hljs-string">'class'</span>: <span class="hljs-string">'mce-drag-container'</span>,
        <span class="hljs-string">'data-mce-bogus'</span>: <span class="hljs-string">'all'</span>,
        <span class="hljs-attr">unselectable</span>: <span class="hljs-string">'on'</span>,
        <span class="hljs-attr">contenteditable</span>: <span class="hljs-string">'false'</span>
      });

      editor.dom.setStyles(ghostElm, {
        <span class="hljs-attr">position</span>: <span class="hljs-string">'absolute'</span>,
        <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>,
        <span class="hljs-attr">overflow</span>: <span class="hljs-string">'hidden'</span>,
        <span class="hljs-attr">border</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">padding</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">margin</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">width</span>: width,
        <span class="hljs-attr">height</span>: height
      });

      editor.dom.setStyles(clonedElm, {
        <span class="hljs-attr">margin</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">boxSizing</span>: <span class="hljs-string">'border-box'</span>
      });

      ghostElm.appendChild(clonedElm);

      <span class="hljs-keyword">return</span> ghostElm;
    };

    <span class="hljs-keyword">var</span> appendGhostToBody = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ghostElm, bodyElm</span>) </span>{
      <span class="hljs-keyword">if</span> (ghostElm.parentNode !== bodyElm) {
        bodyElm.appendChild(ghostElm);
      }
    };

    <span class="hljs-keyword">var</span> moveGhost = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ghostElm, position, width, height, maxX, maxY</span>) </span>{
      <span class="hljs-keyword">var</span> overflowX = <span class="hljs-number">0</span>, overflowY = <span class="hljs-number">0</span>;

      ghostElm.style.left = position.pageX + <span class="hljs-string">'px'</span>;
      ghostElm.style.top = position.pageY + <span class="hljs-string">'px'</span>;

      <span class="hljs-keyword">if</span> (position.pageX + width &gt; maxX) {
        overflowX = (position.pageX + width) - maxX;
      }

      <span class="hljs-keyword">if</span> (position.pageY + height &gt; maxY) {
        overflowY = (position.pageY + height) - maxY;
      }

      ghostElm.style.width = (width - overflowX) + <span class="hljs-string">'px'</span>;
      ghostElm.style.height = (height - overflowY) + <span class="hljs-string">'px'</span>;
    };

    <span class="hljs-keyword">var</span> removeElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">if</span> (elm &amp;&amp; elm.parentNode) {
        elm.parentNode.removeChild(elm);
      }
    };

    <span class="hljs-keyword">var</span> isLeftMouseButtonPressed = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
      <span class="hljs-keyword">return</span> e.button === <span class="hljs-number">0</span>;
    };

    <span class="hljs-keyword">var</span> hasDraggableElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
      <span class="hljs-keyword">return</span> state.element;
    };

    <span class="hljs-keyword">var</span> applyRelPos = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state, position</span>) </span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">pageX</span>: position.pageX - state.relX,
        <span class="hljs-attr">pageY</span>: position.pageY + <span class="hljs-number">5</span>
      };
    };

    <span class="hljs-keyword">var</span> start = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state, editor</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (isLeftMouseButtonPressed(e)) {
          <span class="hljs-keyword">var</span> ceElm = Arr.find(editor.dom.getParents(e.target), Fun.or(isContentEditableFalse, isContentEditableTrue));

          <span class="hljs-keyword">if</span> (isDraggable(editor.getBody(), ceElm)) {
            <span class="hljs-keyword">var</span> elmPos = editor.dom.getPos(ceElm);
            <span class="hljs-keyword">var</span> bodyElm = editor.getBody();
            <span class="hljs-keyword">var</span> docElm = editor.getDoc().documentElement;

            state.element = ceElm;
            state.screenX = e.screenX;
            state.screenY = e.screenY;
            state.maxX = (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - <span class="hljs-number">2</span>;
            state.maxY = (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - <span class="hljs-number">2</span>;
            state.relX = e.pageX - elmPos.x;
            state.relY = e.pageY - elmPos.y;
            state.width = ceElm.offsetWidth;
            state.height = ceElm.offsetHeight;
            state.ghost = createGhost(editor, ceElm, state.width, state.height);
          }
        }
      };
    };

    <span class="hljs-keyword">var</span> move = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state, editor</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1625">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1625">&#182;</a>
              </div>
              <p>Reduces laggy drag behavior on Gecko</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> throttledPlaceCaretAt = Delay.throttle(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clientX, clientY</span>) </span>{
        editor._selectionOverrides.hideFakeCaret();
        editor.selection.placeCaretAt(clientX, clientY);
      }, <span class="hljs-number">0</span>);

      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> movement = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.abs(e.screenX - state.screenX), <span class="hljs-built_in">Math</span>.abs(e.screenY - state.screenY));

        <span class="hljs-keyword">if</span> (hasDraggableElement(state) &amp;&amp; !state.dragging &amp;&amp; movement &gt; <span class="hljs-number">10</span>) {
          <span class="hljs-keyword">var</span> args = editor.fire(<span class="hljs-string">'dragstart'</span>, { <span class="hljs-attr">target</span>: state.element });
          <span class="hljs-keyword">if</span> (args.isDefaultPrevented()) {
            <span class="hljs-keyword">return</span>;
          }

          state.dragging = <span class="hljs-literal">true</span>;
          editor.focus();
        }

        <span class="hljs-keyword">if</span> (state.dragging) {
          <span class="hljs-keyword">var</span> targetPos = applyRelPos(state, MousePosition.calc(editor, e));

          appendGhostToBody(state.ghost, editor.getBody());
          moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY);

          throttledPlaceCaretAt(e.clientX, e.clientY);
        }
      };
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-1626">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1626">&#182;</a>
              </div>
              <p>Returns the raw element instead of the fake cE=false element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> getRawTarget = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
      <span class="hljs-keyword">var</span> rng = selection.getSel().getRangeAt(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">var</span> startContainer = rng.startContainer;
      <span class="hljs-keyword">return</span> startContainer.nodeType === <span class="hljs-number">3</span> ? startContainer.parentNode : startContainer;
    };

    <span class="hljs-keyword">var</span> drop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state, editor</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (state.dragging) {
          <span class="hljs-keyword">if</span> (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {
            <span class="hljs-keyword">var</span> targetClone = cloneElement(state.element);

            <span class="hljs-keyword">var</span> args = editor.fire(<span class="hljs-string">'drop'</span>, {
              <span class="hljs-attr">targetClone</span>: targetClone,
              <span class="hljs-attr">clientX</span>: e.clientX,
              <span class="hljs-attr">clientY</span>: e.clientY
            });

            <span class="hljs-keyword">if</span> (!args.isDefaultPrevented()) {
              targetClone = args.targetClone;

              editor.undoManager.transact(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                removeElement(state.element);
                editor.insertContent(editor.dom.getOuterHTML(targetClone));
                editor._selectionOverrides.hideFakeCaret();
              });
            }
          }
        }

        removeDragState(state);
      };
    };

    <span class="hljs-keyword">var</span> stop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state, editor</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        removeDragState(state);
        <span class="hljs-keyword">if</span> (state.dragging) {
          editor.fire(<span class="hljs-string">'dragend'</span>);
        }
      };
    };

    <span class="hljs-keyword">var</span> removeDragState = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
      state.dragging = <span class="hljs-literal">false</span>;
      state.element = <span class="hljs-literal">null</span>;
      removeElement(state.ghost);
    };

    <span class="hljs-keyword">var</span> bindFakeDragEvents = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> state = {}, pageDom, dragStartHandler, dragHandler, dropHandler, dragEndHandler, rootDocument;

      pageDom = DOMUtils.DOM;
      rootDocument = <span class="hljs-built_in">document</span>;
      dragStartHandler = start(state, editor);
      dragHandler = move(state, editor);
      dropHandler = drop(state, editor);
      dragEndHandler = stop(state, editor);

      editor.on(<span class="hljs-string">'mousedown'</span>, dragStartHandler);
      editor.on(<span class="hljs-string">'mousemove'</span>, dragHandler);
      editor.on(<span class="hljs-string">'mouseup'</span>, dropHandler);

      pageDom.bind(rootDocument, <span class="hljs-string">'mousemove'</span>, dragHandler);
      pageDom.bind(rootDocument, <span class="hljs-string">'mouseup'</span>, dragEndHandler);

      editor.on(<span class="hljs-string">'remove'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        pageDom.unbind(rootDocument, <span class="hljs-string">'mousemove'</span>, dragHandler);
        pageDom.unbind(rootDocument, <span class="hljs-string">'mouseup'</span>, dragEndHandler);
      });
    };

    <span class="hljs-keyword">var</span> blockIeDrop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      editor.on(<span class="hljs-string">'drop'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1627">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1627">&#182;</a>
              </div>
              <p>FF doesnt pass out clientX/clientY for drop since this is for IE we just use null instead</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> realTarget = <span class="hljs-keyword">typeof</span> e.clientX !== <span class="hljs-string">'undefined'</span> ? editor.getDoc().elementFromPoint(e.clientX, e.clientY) : <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (isContentEditableFalse(realTarget) || isContentEditableFalse(editor.dom.getContentEditableParent(realTarget))) {
          e.preventDefault();
        }
      });
    };

    <span class="hljs-keyword">var</span> init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      bindFakeDragEvents(editor);
      blockIeDrop(editor);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">init</span>: init
    };
  }
);

<span class="hljs-comment">/**
 * SelectionOverrides.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module contains logic overriding the selection with keyboard/mouse
 * around contentEditable=false regions.
 *
 * @example
 * // Disable the default cE=false selection
 * tinymce.activeEditor.on('ShowCaret BeforeObjectSelected', function(e) {
 *     e.preventDefault();
 * });
 *
 * @private
 * @class tinymce.SelectionOverrides
 */</span>
define(
  <span class="hljs-string">'tinymce.core.SelectionOverrides'</span>,
  [
    <span class="hljs-string">"tinymce.core.Env"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretWalker"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretPosition"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretContainer"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretContainerRemove"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretUtils"</span>,
    <span class="hljs-string">"tinymce.core.caret.FakeCaret"</span>,
    <span class="hljs-string">"tinymce.core.caret.LineWalker"</span>,
    <span class="hljs-string">"tinymce.core.caret.LineUtils"</span>,
    <span class="hljs-string">"tinymce.core.dom.NodeType"</span>,
    <span class="hljs-string">"tinymce.core.dom.RangeUtils"</span>,
    <span class="hljs-string">"tinymce.core.geom.ClientRect"</span>,
    <span class="hljs-string">"tinymce.core.util.VK"</span>,
    <span class="hljs-string">"tinymce.core.util.Fun"</span>,
    <span class="hljs-string">"tinymce.core.util.Arr"</span>,
    <span class="hljs-string">"tinymce.core.util.Delay"</span>,
    <span class="hljs-string">"tinymce.core.DragDropOverrides"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">
    Env, CaretWalker, CaretPosition, CaretContainer, CaretContainerRemove, CaretUtils, FakeCaret, LineWalker,
    LineUtils, NodeType, RangeUtils, ClientRect, VK, Fun, Arr, Delay, DragDropOverrides
</span>) </span>{
    <span class="hljs-keyword">var</span> curry = Fun.curry,
      isContentEditableTrue = NodeType.isContentEditableTrue,
      isContentEditableFalse = NodeType.isContentEditableFalse,
      isAfterContentEditableFalse = CaretUtils.isAfterContentEditableFalse,
      isBeforeContentEditableFalse = CaretUtils.isBeforeContentEditableFalse,
      getSelectedNode = RangeUtils.getSelectedNode;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getVisualCaretPosition</span>(<span class="hljs-params">walkFn, caretPosition</span>) </span>{
      <span class="hljs-keyword">while</span> ((caretPosition = walkFn(caretPosition))) {
        <span class="hljs-keyword">if</span> (caretPosition.isVisible()) {
          <span class="hljs-keyword">return</span> caretPosition;
        }
      }

      <span class="hljs-keyword">return</span> caretPosition;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SelectionOverrides</span>(<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> rootNode = editor.getBody(), caretWalker = <span class="hljs-keyword">new</span> CaretWalker(rootNode);
      <span class="hljs-keyword">var</span> getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
      <span class="hljs-keyword">var</span> getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev),
        fakeCaret = <span class="hljs-keyword">new</span> FakeCaret(editor.getBody(), isBlock),
        realSelectionId = <span class="hljs-string">'sel-'</span> + editor.dom.uniqueId(),
        selectedContentEditableNode;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFakeSelectionElement</span>(<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">return</span> editor.dom.hasClass(elm, <span class="hljs-string">'mce-offscreen-selection'</span>);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRealSelectionElement</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> container = editor.dom.get(realSelectionId);
        <span class="hljs-keyword">return</span> container ? container.getElementsByTagName(<span class="hljs-string">'*'</span>)[<span class="hljs-number">0</span>] : container;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBlock</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> editor.dom.isBlock(node);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setRange</span>(<span class="hljs-params">range</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1628">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1628">&#182;</a>
              </div>
              <p>console.log(setRange, range);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (range) {
          editor.selection.setRng(range);
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRange</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> editor.selection.getRng();
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scrollIntoView</span>(<span class="hljs-params">node, alignToTop</span>) </span>{
        editor.selection.scrollIntoView(node, alignToTop);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showCaret</span>(<span class="hljs-params">direction, node, before</span>) </span>{
        <span class="hljs-keyword">var</span> e;

        e = editor.fire(<span class="hljs-string">'ShowCaret'</span>, {
          <span class="hljs-attr">target</span>: node,
          <span class="hljs-attr">direction</span>: direction,
          <span class="hljs-attr">before</span>: before
        });

        <span class="hljs-keyword">if</span> (e.isDefaultPrevented()) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        scrollIntoView(node, direction === <span class="hljs-number">-1</span>);

        <span class="hljs-keyword">return</span> fakeCaret.show(before, node);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectNode</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> e;

        e = editor.fire(<span class="hljs-string">'BeforeObjectSelected'</span>, { <span class="hljs-attr">target</span>: node });
        <span class="hljs-keyword">if</span> (e.isDefaultPrevented()) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> getNodeRange(node);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNodeRange</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> rng = node.ownerDocument.createRange();

        rng.selectNode(node);

        <span class="hljs-keyword">return</span> rng;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isMoveInsideSameBlock</span>(<span class="hljs-params">fromCaretPosition, toCaretPosition</span>) </span>{
        <span class="hljs-keyword">var</span> inSameBlock = CaretUtils.isInSameBlock(fromCaretPosition, toCaretPosition);</pre></div></div>
            
        </li>
        
        
        <li id="section-1629">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1629">&#182;</a>
              </div>
              <p>Handle bogus BR <p>abc|<br></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!inSameBlock &amp;&amp; NodeType.isBr(fromCaretPosition.getNode())) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> inSameBlock;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNormalizedRangeEndPoint</span>(<span class="hljs-params">direction, range</span>) </span>{
        range = CaretUtils.normalizeRange(direction, rootNode, range);

        <span class="hljs-keyword">if</span> (direction == <span class="hljs-number">-1</span>) {
          <span class="hljs-keyword">return</span> CaretPosition.fromRangeStart(range);
        }

        <span class="hljs-keyword">return</span> CaretPosition.fromRangeEnd(range);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isRangeInCaretContainerBlock</span>(<span class="hljs-params">range</span>) </span>{
        <span class="hljs-keyword">return</span> CaretContainer.isCaretContainerBlock(range.startContainer);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveToCeFalseHorizontally</span>(<span class="hljs-params">direction, getNextPosFn, isBeforeContentEditableFalseFn, range</span>) </span>{
        <span class="hljs-keyword">var</span> node, caretPosition, peekCaretPosition, rangeIsInContainerBlock;

        <span class="hljs-keyword">if</span> (!range.collapsed) {
          node = getSelectedNode(range);
          <span class="hljs-keyword">if</span> (isContentEditableFalse(node)) {
            <span class="hljs-keyword">return</span> showCaret(direction, node, direction == <span class="hljs-number">-1</span>);
          }
        }

        rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);
        caretPosition = getNormalizedRangeEndPoint(direction, range);

        <span class="hljs-keyword">if</span> (isBeforeContentEditableFalseFn(caretPosition)) {
          <span class="hljs-keyword">return</span> selectNode(caretPosition.getNode(direction == <span class="hljs-number">-1</span>));
        }

        caretPosition = getNextPosFn(caretPosition);
        <span class="hljs-keyword">if</span> (!caretPosition) {
          <span class="hljs-keyword">if</span> (rangeIsInContainerBlock) {
            <span class="hljs-keyword">return</span> range;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">if</span> (isBeforeContentEditableFalseFn(caretPosition)) {
          <span class="hljs-keyword">return</span> showCaret(direction, caretPosition.getNode(direction == <span class="hljs-number">-1</span>), direction == <span class="hljs-number">1</span>);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1630">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1630">&#182;</a>
              </div>
              <p>Peek ahead for handling of ab|c<span cE=false> -&gt; abc|<span cE=false></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        peekCaretPosition = getNextPosFn(caretPosition);
        <span class="hljs-keyword">if</span> (isBeforeContentEditableFalseFn(peekCaretPosition)) {
          <span class="hljs-keyword">if</span> (isMoveInsideSameBlock(caretPosition, peekCaretPosition)) {
            <span class="hljs-keyword">return</span> showCaret(direction, peekCaretPosition.getNode(direction == <span class="hljs-number">-1</span>), direction == <span class="hljs-number">1</span>);
          }
        }

        <span class="hljs-keyword">if</span> (rangeIsInContainerBlock) {
          <span class="hljs-keyword">return</span> renderRangeCaret(caretPosition.toRange());
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveToCeFalseVertically</span>(<span class="hljs-params">direction, walkerFn, range</span>) </span>{
        <span class="hljs-keyword">var</span> caretPosition, linePositions, nextLinePositions,
          closestNextLineRect, caretClientRect, clientX,
          dist1, dist2, contentEditableFalseNode;

        contentEditableFalseNode = getSelectedNode(range);
        caretPosition = getNormalizedRangeEndPoint(direction, range);
        linePositions = walkerFn(rootNode, LineWalker.isAboveLine(<span class="hljs-number">1</span>), caretPosition);
        nextLinePositions = Arr.filter(linePositions, LineWalker.isLine(<span class="hljs-number">1</span>));
        caretClientRect = Arr.last(caretPosition.getClientRects());

        <span class="hljs-keyword">if</span> (isBeforeContentEditableFalse(caretPosition)) {
          contentEditableFalseNode = caretPosition.getNode();
        }

        <span class="hljs-keyword">if</span> (isAfterContentEditableFalse(caretPosition)) {
          contentEditableFalseNode = caretPosition.getNode(<span class="hljs-literal">true</span>);
        }

        <span class="hljs-keyword">if</span> (!caretClientRect) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        clientX = caretClientRect.left;

        closestNextLineRect = LineUtils.findClosestClientRect(nextLinePositions, clientX);
        <span class="hljs-keyword">if</span> (closestNextLineRect) {
          <span class="hljs-keyword">if</span> (isContentEditableFalse(closestNextLineRect.node)) {
            dist1 = <span class="hljs-built_in">Math</span>.abs(clientX - closestNextLineRect.left);
            dist2 = <span class="hljs-built_in">Math</span>.abs(clientX - closestNextLineRect.right);

            <span class="hljs-keyword">return</span> showCaret(direction, closestNextLineRect.node, dist1 &lt; dist2);
          }
        }

        <span class="hljs-keyword">if</span> (contentEditableFalseNode) {
          <span class="hljs-keyword">var</span> caretPositions = LineWalker.positionsUntil(direction, rootNode, LineWalker.isAboveLine(<span class="hljs-number">1</span>), contentEditableFalseNode);

          closestNextLineRect = LineUtils.findClosestClientRect(Arr.filter(caretPositions, LineWalker.isLine(<span class="hljs-number">1</span>)), clientX);
          <span class="hljs-keyword">if</span> (closestNextLineRect) {
            <span class="hljs-keyword">return</span> renderRangeCaret(closestNextLineRect.position.toRange());
          }

          closestNextLineRect = Arr.last(Arr.filter(caretPositions, LineWalker.isLine(<span class="hljs-number">0</span>)));
          <span class="hljs-keyword">if</span> (closestNextLineRect) {
            <span class="hljs-keyword">return</span> renderRangeCaret(closestNextLineRect.position.toRange());
          }
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exitPreBlock</span>(<span class="hljs-params">direction, range</span>) </span>{
        <span class="hljs-keyword">var</span> pre, caretPos, newBlock;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTextBlock</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> textBlock = editor.dom.create(editor.settings.forced_root_block);

          <span class="hljs-keyword">if</span> (!Env.ie || Env.ie &gt;= <span class="hljs-number">11</span>) {
            textBlock.innerHTML = <span class="hljs-string">'&lt;br data-mce-bogus="1"&gt;'</span>;
          }

          <span class="hljs-keyword">return</span> textBlock;
        }

        <span class="hljs-keyword">if</span> (range.collapsed &amp;&amp; editor.settings.forced_root_block) {
          pre = editor.dom.getParent(range.startContainer, <span class="hljs-string">'PRE'</span>);
          <span class="hljs-keyword">if</span> (!pre) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (direction == <span class="hljs-number">1</span>) {
            caretPos = getNextVisualCaretPosition(CaretPosition.fromRangeStart(range));
          } <span class="hljs-keyword">else</span> {
            caretPos = getPrevVisualCaretPosition(CaretPosition.fromRangeStart(range));
          }

          <span class="hljs-keyword">if</span> (!caretPos) {
            newBlock = createTextBlock();

            <span class="hljs-keyword">if</span> (direction == <span class="hljs-number">1</span>) {
              editor.$(pre).after(newBlock);
            } <span class="hljs-keyword">else</span> {
              editor.$(pre).before(newBlock);
            }

            editor.selection.select(newBlock, <span class="hljs-literal">true</span>);
            editor.selection.collapse();
          }
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveH</span>(<span class="hljs-params">direction, getNextPosFn, isBeforeContentEditableFalseFn, range</span>) </span>{
        <span class="hljs-keyword">var</span> newRange;

        newRange = moveToCeFalseHorizontally(direction, getNextPosFn, isBeforeContentEditableFalseFn, range);
        <span class="hljs-keyword">if</span> (newRange) {
          <span class="hljs-keyword">return</span> newRange;
        }

        newRange = exitPreBlock(direction, range);
        <span class="hljs-keyword">if</span> (newRange) {
          <span class="hljs-keyword">return</span> newRange;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveV</span>(<span class="hljs-params">direction, walkerFn, range</span>) </span>{
        <span class="hljs-keyword">var</span> newRange;

        newRange = moveToCeFalseVertically(direction, walkerFn, range);
        <span class="hljs-keyword">if</span> (newRange) {
          <span class="hljs-keyword">return</span> newRange;
        }

        newRange = exitPreBlock(direction, range);
        <span class="hljs-keyword">if</span> (newRange) {
          <span class="hljs-keyword">return</span> newRange;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showBlockCaretContainer</span>(<span class="hljs-params">blockCaretContainer</span>) </span>{
        <span class="hljs-keyword">if</span> (blockCaretContainer.hasAttribute(<span class="hljs-string">'data-mce-caret'</span>)) {
          CaretContainer.showCaretContainerBlock(blockCaretContainer);
          setRange(getRange()); <span class="hljs-comment">// Removes control rect on IE</span>
          scrollIntoView(blockCaretContainer[<span class="hljs-number">0</span>]);
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderCaretAtRange</span>(<span class="hljs-params">range</span>) </span>{
        <span class="hljs-keyword">var</span> caretPosition, ceRoot;

        range = CaretUtils.normalizeRange(<span class="hljs-number">1</span>, rootNode, range);
        caretPosition = CaretPosition.fromRangeStart(range);

        <span class="hljs-keyword">if</span> (isContentEditableFalse(caretPosition.getNode())) {
          <span class="hljs-keyword">return</span> showCaret(<span class="hljs-number">1</span>, caretPosition.getNode(), !caretPosition.isAtEnd());
        }

        <span class="hljs-keyword">if</span> (isContentEditableFalse(caretPosition.getNode(<span class="hljs-literal">true</span>))) {
          <span class="hljs-keyword">return</span> showCaret(<span class="hljs-number">1</span>, caretPosition.getNode(<span class="hljs-literal">true</span>), <span class="hljs-literal">false</span>);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1631">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1631">&#182;</a>
              </div>
              <p>TODO: Should render caret before/after depending on where you click on the page forces after now</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        ceRoot = editor.dom.getParent(caretPosition.getNode(), Fun.or(isContentEditableFalse, isContentEditableTrue));
        <span class="hljs-keyword">if</span> (isContentEditableFalse(ceRoot)) {
          <span class="hljs-keyword">return</span> showCaret(<span class="hljs-number">1</span>, ceRoot, <span class="hljs-literal">false</span>);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderRangeCaret</span>(<span class="hljs-params">range</span>) </span>{
        <span class="hljs-keyword">var</span> caretRange;

        <span class="hljs-keyword">if</span> (!range || !range.collapsed) {
          <span class="hljs-keyword">return</span> range;
        }

        caretRange = renderCaretAtRange(range);
        <span class="hljs-keyword">if</span> (caretRange) {
          <span class="hljs-keyword">return</span> caretRange;
        }

        <span class="hljs-keyword">return</span> range;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerEvents</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> right = curry(moveH, <span class="hljs-number">1</span>, getNextVisualCaretPosition, isBeforeContentEditableFalse);
        <span class="hljs-keyword">var</span> left = curry(moveH, <span class="hljs-number">-1</span>, getPrevVisualCaretPosition, isAfterContentEditableFalse);
        <span class="hljs-keyword">var</span> up = curry(moveV, <span class="hljs-number">-1</span>, LineWalker.upUntil);
        <span class="hljs-keyword">var</span> down = curry(moveV, <span class="hljs-number">1</span>, LineWalker.downUntil);

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">override</span>(<span class="hljs-params">evt, moveFn</span>) </span>{
          <span class="hljs-keyword">if</span> (evt.isDefaultPrevented() === <span class="hljs-literal">false</span>) {
            <span class="hljs-keyword">var</span> range = moveFn(getRange());

            <span class="hljs-keyword">if</span> (range) {
              evt.preventDefault();
              setRange(range);
            }
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContentEditableRoot</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">var</span> root = editor.getBody();

          <span class="hljs-keyword">while</span> (node &amp;&amp; node != root) {
            <span class="hljs-keyword">if</span> (isContentEditableTrue(node) || isContentEditableFalse(node)) {
              <span class="hljs-keyword">return</span> node;
            }

            node = node.parentNode;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isXYWithinRange</span>(<span class="hljs-params">clientX, clientY, range</span>) </span>{
          <span class="hljs-keyword">if</span> (range.collapsed) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

          <span class="hljs-keyword">return</span> Arr.reduce(range.getClientRects(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state, rect</span>) </span>{
            <span class="hljs-keyword">return</span> state || ClientRect.containsXY(rect, clientX, clientY);
          }, <span class="hljs-literal">false</span>);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1632">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1632">&#182;</a>
              </div>
              <p>Some browsers (Chrome) lets you place the caret after a cE=false
Make sure we render the caret container in this case</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        editor.on(<span class="hljs-string">'mouseup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> range = getRange();

          <span class="hljs-keyword">if</span> (range.collapsed) {
            setRange(renderCaretAtRange(range));
          }
        });

        editor.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> contentEditableRoot;

          contentEditableRoot = getContentEditableRoot(e.target);
          <span class="hljs-keyword">if</span> (contentEditableRoot) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1633">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1633">&#182;</a>
              </div>
              <p>Prevent clicks on links in a cE=false element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (isContentEditableFalse(contentEditableRoot)) {
              e.preventDefault();
              editor.focus();
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1634">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1634">&#182;</a>
              </div>
              <p>Removes fake selection if a cE=true is clicked within a cE=false like the toc title</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (isContentEditableTrue(contentEditableRoot)) {
              <span class="hljs-keyword">if</span> (editor.dom.isChildOf(contentEditableRoot, editor.selection.getNode())) {
                removeContentEditableSelection();
              }
            }
          }
        });

        editor.on(<span class="hljs-string">'blur NewBlock'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          removeContentEditableSelection();
          hideFakeCaret();
        });

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleTouchSelect</span>(<span class="hljs-params">editor</span>) </span>{
          <span class="hljs-keyword">var</span> moved = <span class="hljs-literal">false</span>;

          editor.on(<span class="hljs-string">'touchstart'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            moved = <span class="hljs-literal">false</span>;
          });

          editor.on(<span class="hljs-string">'touchmove'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            moved = <span class="hljs-literal">true</span>;
          });

          editor.on(<span class="hljs-string">'touchend'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">var</span> contentEditableRoot = getContentEditableRoot(e.target);

            <span class="hljs-keyword">if</span> (isContentEditableFalse(contentEditableRoot)) {
              <span class="hljs-keyword">if</span> (!moved) {
                e.preventDefault();
                setContentEditableSelection(selectNode(contentEditableRoot));
              }
            }
          });
        }

        <span class="hljs-keyword">var</span> hasNormalCaretPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
          <span class="hljs-keyword">var</span> caretWalker = <span class="hljs-keyword">new</span> CaretWalker(elm);

          <span class="hljs-keyword">if</span> (!elm.firstChild) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

          <span class="hljs-keyword">var</span> startPos = CaretPosition.before(elm.firstChild);
          <span class="hljs-keyword">var</span> newPos = caretWalker.next(startPos);

          <span class="hljs-keyword">return</span> newPos &amp;&amp; !isBeforeContentEditableFalse(newPos) &amp;&amp; !isAfterContentEditableFalse(newPos);
        };

        <span class="hljs-keyword">var</span> isInSameBlock = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node1, node2</span>) </span>{
          <span class="hljs-keyword">var</span> block1 = editor.dom.getParent(node1, editor.dom.isBlock);
          <span class="hljs-keyword">var</span> block2 = editor.dom.getParent(node2, editor.dom.isBlock);
          <span class="hljs-keyword">return</span> block1 === block2;
        };

        <span class="hljs-keyword">var</span> isContentKey = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (e.keyCode &gt;= <span class="hljs-number">112</span> &amp;&amp; e.keyCode &lt;= <span class="hljs-number">123</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-1635">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1635">&#182;</a>
              </div>
              <p>Checks if the target node is in a block and if that block has a caret position better than the
suggested caretNode this is to prevent the caret from being sucked in towards a cE=false block if
they are adjacent on the vertical axis</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> hasBetterMouseTarget = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">targetNode, caretNode</span>) </span>{
          <span class="hljs-keyword">var</span> targetBlock = editor.dom.getParent(targetNode, editor.dom.isBlock);
          <span class="hljs-keyword">var</span> caretBlock = editor.dom.getParent(caretNode, editor.dom.isBlock);

          <span class="hljs-keyword">return</span> targetBlock &amp;&amp; !isInSameBlock(targetBlock, caretBlock) &amp;&amp; hasNormalCaretPosition(targetBlock);
        };

        handleTouchSelect(editor);

        editor.on(<span class="hljs-string">'mousedown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> contentEditableRoot;

          contentEditableRoot = getContentEditableRoot(e.target);
          <span class="hljs-keyword">if</span> (contentEditableRoot) {
            <span class="hljs-keyword">if</span> (isContentEditableFalse(contentEditableRoot)) {
              e.preventDefault();
              setContentEditableSelection(selectNode(contentEditableRoot));
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1636">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1636">&#182;</a>
              </div>
              <p>Check that were not attempting a shift + click select within a contenteditable=true element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (!(isContentEditableTrue(contentEditableRoot) &amp;&amp; e.shiftKey) &amp;&amp; !isXYWithinRange(e.clientX, e.clientY, editor.selection.getRng())) {
                editor.selection.placeCaretAt(e.clientX, e.clientY);
              }
            }
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1637">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1637">&#182;</a>
              </div>
              <p>Remove needs to be called here since the mousedown might alter the selection without calling selection.setRng
and therefore not fire the AfterSetSelectionRange event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            removeContentEditableSelection();
            hideFakeCaret();

            <span class="hljs-keyword">var</span> caretInfo = LineUtils.closestCaret(rootNode, e.clientX, e.clientY);
            <span class="hljs-keyword">if</span> (caretInfo) {
              <span class="hljs-keyword">if</span> (!hasBetterMouseTarget(e.target, caretInfo.node)) {
                e.preventDefault();
                editor.getBody().focus();
                setRange(showCaret(<span class="hljs-number">1</span>, caretInfo.node, caretInfo.before));
              }
            }
          }
        });

        editor.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (VK.modifierPressed(e)) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">switch</span> (e.keyCode) {
            <span class="hljs-keyword">case</span> VK.RIGHT:
              override(e, right);
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> VK.DOWN:
              override(e, down);
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> VK.LEFT:
              override(e, left);
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> VK.UP:
              override(e, up);
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">default</span>:
              <span class="hljs-keyword">if</span> (isContentEditableFalse(editor.selection.getNode()) &amp;&amp; isContentKey(e)) {
                e.preventDefault();
              }
              <span class="hljs-keyword">break</span>;
          }
        });

        editor.on(<span class="hljs-string">'getSelectionRange'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> rng = e.range;

          <span class="hljs-keyword">if</span> (selectedContentEditableNode) {
            <span class="hljs-keyword">if</span> (!selectedContentEditableNode.parentNode) {
              selectedContentEditableNode = <span class="hljs-literal">null</span>;
              <span class="hljs-keyword">return</span>;
            }

            rng = rng.cloneRange();
            rng.selectNode(selectedContentEditableNode);
            e.range = rng;
          }
        });

        editor.on(<span class="hljs-string">'setSelectionRange'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> rng;

          rng = setContentEditableSelection(e.range, e.forward);
          <span class="hljs-keyword">if</span> (rng) {
            e.range = rng;
          }
        });

        editor.on(<span class="hljs-string">'AfterSetSelectionRange'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> rng = e.range;

          <span class="hljs-keyword">if</span> (!isRangeInCaretContainer(rng)) {
            hideFakeCaret();
          }

          <span class="hljs-keyword">if</span> (!isFakeSelectionElement(rng.startContainer.parentNode)) {
            removeContentEditableSelection();
          }
        });

        editor.on(<span class="hljs-string">'focus'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1638">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1638">&#182;</a>
              </div>
              <p>Make sure we have a proper fake caret on focus</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          Delay.setEditorTimeout(editor, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            editor.selection.setRng(renderRangeCaret(editor.selection.getRng()));
          }, <span class="hljs-number">0</span>);
        });

        editor.on(<span class="hljs-string">'copy'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> clipboardData = e.clipboardData;</pre></div></div>
            
        </li>
        
        
        <li id="section-1639">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1639">&#182;</a>
              </div>
              <p>Make sure we get proper html/text for the fake cE=false selection
Doesnt work at all on Edge since it doesnt have proper clipboardData support</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!e.isDefaultPrevented() &amp;&amp; e.clipboardData &amp;&amp; !Env.ie) {
            <span class="hljs-keyword">var</span> realSelectionElement = getRealSelectionElement();
            <span class="hljs-keyword">if</span> (realSelectionElement) {
              e.preventDefault();
              clipboardData.clearData();
              clipboardData.setData(<span class="hljs-string">'text/html'</span>, realSelectionElement.outerHTML);
              clipboardData.setData(<span class="hljs-string">'text/plain'</span>, realSelectionElement.outerText);
            }
          }
        });

        DragDropOverrides.init(editor);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCss</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> styles = editor.contentStyles, rootClass = <span class="hljs-string">'.mce-content-body'</span>;

        styles.push(fakeCaret.getCss());
        styles.push(
          rootClass + <span class="hljs-string">' .mce-offscreen-selection {'</span> +
          <span class="hljs-string">'position: absolute;'</span> +
          <span class="hljs-string">'left: -9999999999px;'</span> +
          <span class="hljs-string">'max-width: 1000000px;'</span> +
          <span class="hljs-string">'}'</span> +
          rootClass + <span class="hljs-string">' *[contentEditable=false] {'</span> +
          <span class="hljs-string">'cursor: default;'</span> +
          <span class="hljs-string">'}'</span> +
          rootClass + <span class="hljs-string">' *[contentEditable=true] {'</span> +
          <span class="hljs-string">'cursor: text;'</span> +
          <span class="hljs-string">'}'</span>
        );
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isWithinCaretContainer</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> (
          CaretContainer.isCaretContainer(node) ||
          CaretContainer.startsWithCaretContainer(node) ||
          CaretContainer.endsWithCaretContainer(node)
        );
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isRangeInCaretContainer</span>(<span class="hljs-params">rng</span>) </span>{
        <span class="hljs-keyword">return</span> isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setContentEditableSelection</span>(<span class="hljs-params">range, forward</span>) </span>{
        <span class="hljs-keyword">var</span> node, $ = editor.$, dom = editor.dom, $realSelectionContainer, sel,
          startContainer, startOffset, endOffset, e, caretPosition, targetClone, origTargetClone;

        <span class="hljs-keyword">if</span> (!range) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">if</span> (range.collapsed) {
          <span class="hljs-keyword">if</span> (!isRangeInCaretContainer(range)) {
            <span class="hljs-keyword">if</span> (forward === <span class="hljs-literal">false</span>) {
              caretPosition = getNormalizedRangeEndPoint(<span class="hljs-number">-1</span>, range);

              <span class="hljs-keyword">if</span> (isContentEditableFalse(caretPosition.getNode(<span class="hljs-literal">true</span>))) {
                <span class="hljs-keyword">return</span> showCaret(<span class="hljs-number">-1</span>, caretPosition.getNode(<span class="hljs-literal">true</span>), <span class="hljs-literal">false</span>);
              }

              <span class="hljs-keyword">if</span> (isContentEditableFalse(caretPosition.getNode())) {
                <span class="hljs-keyword">return</span> showCaret(<span class="hljs-number">-1</span>, caretPosition.getNode(), !caretPosition.isAtEnd());
              }
            } <span class="hljs-keyword">else</span> {
              caretPosition = getNormalizedRangeEndPoint(<span class="hljs-number">1</span>, range);

              <span class="hljs-keyword">if</span> (isContentEditableFalse(caretPosition.getNode())) {
                <span class="hljs-keyword">return</span> showCaret(<span class="hljs-number">1</span>, caretPosition.getNode(), !caretPosition.isAtEnd());
              }

              <span class="hljs-keyword">if</span> (isContentEditableFalse(caretPosition.getNode(<span class="hljs-literal">true</span>))) {
                <span class="hljs-keyword">return</span> showCaret(<span class="hljs-number">1</span>, caretPosition.getNode(<span class="hljs-literal">true</span>), <span class="hljs-literal">false</span>);
              }
            }
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        startContainer = range.startContainer;
        startOffset = range.startOffset;
        endOffset = range.endOffset;</pre></div></div>
            
        </li>
        
        
        <li id="section-1640">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1640">&#182;</a>
              </div>
              <p>Normalizes <span cE=false>[</span>] to [<span cE=false></span>]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (startContainer.nodeType == <span class="hljs-number">3</span> &amp;&amp; startOffset == <span class="hljs-number">0</span> &amp;&amp; isContentEditableFalse(startContainer.parentNode)) {
          startContainer = startContainer.parentNode;
          startOffset = dom.nodeIndex(startContainer);
          startContainer = startContainer.parentNode;
        }

        <span class="hljs-keyword">if</span> (startContainer.nodeType != <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">if</span> (endOffset == startOffset + <span class="hljs-number">1</span>) {
          node = startContainer.childNodes[startOffset];
        }

        <span class="hljs-keyword">if</span> (!isContentEditableFalse(node)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        targetClone = origTargetClone = node.cloneNode(<span class="hljs-literal">true</span>);
        e = editor.fire(<span class="hljs-string">'ObjectSelected'</span>, { <span class="hljs-attr">target</span>: node, <span class="hljs-attr">targetClone</span>: targetClone });
        <span class="hljs-keyword">if</span> (e.isDefaultPrevented()) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        targetClone = e.targetClone;
        $realSelectionContainer = $(<span class="hljs-string">'#'</span> + realSelectionId);
        <span class="hljs-keyword">if</span> ($realSelectionContainer.length === <span class="hljs-number">0</span>) {
          $realSelectionContainer = $(
            <span class="hljs-string">'&lt;div data-mce-bogus="all" class="mce-offscreen-selection"&gt;&lt;/div&gt;'</span>
          ).attr(<span class="hljs-string">'id'</span>, realSelectionId);

          $realSelectionContainer.appendTo(editor.getBody());
        }

        range = editor.dom.createRng();</pre></div></div>
            
        </li>
        
        
        <li id="section-1641">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1641">&#182;</a>
              </div>
              <p>WHY is IE making things so hard! Copy on <i contentEditable="false">x</i> produces: <em>x</em>
This is a ridiculous hack where we place the selection from a block over the inline element
so that just the inline element is copied as is and not converted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (targetClone === origTargetClone &amp;&amp; Env.ie) {
          $realSelectionContainer.empty().append(<span class="hljs-string">'&lt;p style="font-size: 0" data-mce-bogus="all"&gt;\u00a0&lt;/p&gt;'</span>).append(targetClone);
          range.setStartAfter($realSelectionContainer[<span class="hljs-number">0</span>].firstChild.firstChild);
          range.setEndAfter(targetClone);
        } <span class="hljs-keyword">else</span> {
          $realSelectionContainer.empty().append(<span class="hljs-string">'\u00a0'</span>).append(targetClone).append(<span class="hljs-string">'\u00a0'</span>);
          range.setStart($realSelectionContainer[<span class="hljs-number">0</span>].firstChild, <span class="hljs-number">1</span>);
          range.setEnd($realSelectionContainer[<span class="hljs-number">0</span>].lastChild, <span class="hljs-number">0</span>);
        }

        $realSelectionContainer.css({
          <span class="hljs-attr">top</span>: dom.getPos(node, editor.getBody()).y
        });

        $realSelectionContainer[<span class="hljs-number">0</span>].focus();
        sel = editor.selection.getSel();
        sel.removeAllRanges();
        sel.addRange(range);

        editor.$(<span class="hljs-string">'*[data-mce-selected]'</span>).removeAttr(<span class="hljs-string">'data-mce-selected'</span>);
        node.setAttribute(<span class="hljs-string">'data-mce-selected'</span>, <span class="hljs-number">1</span>);
        selectedContentEditableNode = node;
        hideFakeCaret();

        <span class="hljs-keyword">return</span> range;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeContentEditableSelection</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (selectedContentEditableNode) {
          selectedContentEditableNode.removeAttribute(<span class="hljs-string">'data-mce-selected'</span>);
          editor.$(<span class="hljs-string">'#'</span> + realSelectionId).remove();
          selectedContentEditableNode = <span class="hljs-literal">null</span>;
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destroy</span>(<span class="hljs-params"></span>) </span>{
        fakeCaret.destroy();
        selectedContentEditableNode = <span class="hljs-literal">null</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hideFakeCaret</span>(<span class="hljs-params"></span>) </span>{
        fakeCaret.hide();
      }

      <span class="hljs-keyword">if</span> (Env.ceFalse) {
        registerEvents();
        addCss();
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">showBlockCaretContainer</span>: showBlockCaretContainer,
        <span class="hljs-attr">hideFakeCaret</span>: hideFakeCaret,
        <span class="hljs-attr">destroy</span>: destroy
      };
    }

    <span class="hljs-keyword">return</span> SelectionOverrides;
  }
);

<span class="hljs-comment">/**
 * NodePath.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Handles paths of nodes within an element.
 *
 * @private
 * @class tinymce.dom.NodePath
 */</span>
define(
  <span class="hljs-string">'tinymce.core.dom.NodePath'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.DOMUtils"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">DOMUtils</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">rootNode, targetNode, normalized</span>) </span>{
      <span class="hljs-keyword">var</span> path = [];

      <span class="hljs-keyword">for</span> (; targetNode &amp;&amp; targetNode != rootNode; targetNode = targetNode.parentNode) {
        path.push(DOMUtils.nodeIndex(targetNode, normalized));
      }

      <span class="hljs-keyword">return</span> path;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">rootNode, path</span>) </span>{
      <span class="hljs-keyword">var</span> i, node, children;

      <span class="hljs-keyword">for</span> (node = rootNode, i = path.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        children = node.childNodes;

        <span class="hljs-keyword">if</span> (path[i] &gt; children.length - <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        node = children[path[i]];
      }

      <span class="hljs-keyword">return</span> node;
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">create</span>: create,
      <span class="hljs-attr">resolve</span>: resolve
    };
  }
);
<span class="hljs-comment">/**
 * Quirks.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 *
 * @ignore-file
 */</span>

<span class="hljs-comment">/**
 * This file includes fixes for various browser quirks it's made to make it easy to add/remove browser specific fixes.
 *
 * @private
 * @class tinymce.util.Quirks
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.Quirks'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.VK"</span>,
    <span class="hljs-string">"tinymce.core.dom.RangeUtils"</span>,
    <span class="hljs-string">"tinymce.core.dom.TreeWalker"</span>,
    <span class="hljs-string">"tinymce.core.dom.NodePath"</span>,
    <span class="hljs-string">"tinymce.core.html.Node"</span>,
    <span class="hljs-string">"tinymce.core.html.Entities"</span>,
    <span class="hljs-string">"tinymce.core.Env"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.util.Delay"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretContainer"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretPosition"</span>,
    <span class="hljs-string">"tinymce.core.caret.CaretWalker"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">VK, RangeUtils, TreeWalker, NodePath, Node, Entities, Env, Tools, Delay, CaretContainer, CaretPosition, CaretWalker</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> each = Tools.each;
      <span class="hljs-keyword">var</span> BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection,
        settings = editor.settings, parser = editor.parser, serializer = editor.serializer;
      <span class="hljs-keyword">var</span> isGecko = Env.gecko, isIE = Env.ie, isWebKit = Env.webkit;
      <span class="hljs-keyword">var</span> mceInternalUrlPrefix = <span class="hljs-string">'data:text/mce-internal,'</span>;
      <span class="hljs-keyword">var</span> mceInternalDataType = isIE ? <span class="hljs-string">'Text'</span> : <span class="hljs-string">'URL'</span>;

      <span class="hljs-comment">/**
       * Executes a command with a specific state this can be to enable/disable browser editing features.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setEditorCommandState</span>(<span class="hljs-params">cmd, state</span>) </span>{
        <span class="hljs-keyword">try</span> {
          editor.getDoc().execCommand(cmd, <span class="hljs-literal">false</span>, state);
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1642">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1642">&#182;</a>
              </div>
              <p>Ignore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }
      }

      <span class="hljs-comment">/**
       * Returns current IE document mode.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDocumentMode</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> documentMode = editor.getDoc().documentMode;

        <span class="hljs-keyword">return</span> documentMode ? documentMode : <span class="hljs-number">6</span>;
      }

      <span class="hljs-comment">/**
       * Returns true/false if the event is prevented or not.
       *
       * @private
       * @param {Event} e Event object.
       * @return {Boolean} true/false if the event is prevented or not.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDefaultPrevented</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">return</span> e.isDefaultPrevented();
      }

      <span class="hljs-comment">/**
       * Sets Text/URL data on the event's dataTransfer object to a special data:text/mce-internal url.
       * This is to workaround the inability to set custom contentType on IE and Safari.
       * The editor's selected content is encoded into this url so drag and drop between editors will work.
       *
       * @private
       * @param {DragEvent} e Event object
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setMceInternalContent</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> selectionHtml, internalContent;

        <span class="hljs-keyword">if</span> (e.dataTransfer) {
          <span class="hljs-keyword">if</span> (editor.selection.isCollapsed() &amp;&amp; e.target.tagName == <span class="hljs-string">'IMG'</span>) {
            selection.select(e.target);
          }

          selectionHtml = editor.selection.getContent();</pre></div></div>
            
        </li>
        
        
        <li id="section-1643">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1643">&#182;</a>
              </div>
              <p>Safari/IE doesnt support custom dataTransfer items so we can only use URL and Text</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (selectionHtml.length &gt; <span class="hljs-number">0</span>) {
            internalContent = mceInternalUrlPrefix + <span class="hljs-built_in">escape</span>(editor.id) + <span class="hljs-string">','</span> + <span class="hljs-built_in">escape</span>(selectionHtml);
            e.dataTransfer.setData(mceInternalDataType, internalContent);
          }
        }
      }

      <span class="hljs-comment">/**
       * Gets content of special data:text/mce-internal url on the event's dataTransfer object.
       * This is to workaround the inability to set custom contentType on IE and Safari.
       * The editor's selected content is encoded into this url so drag and drop between editors will work.
       *
       * @private
       * @param {DragEvent} e Event object
       * @returns {String} mce-internal content
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMceInternalContent</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> internalContent;

        <span class="hljs-keyword">if</span> (e.dataTransfer) {
          internalContent = e.dataTransfer.getData(mceInternalDataType);

          <span class="hljs-keyword">if</span> (internalContent &amp;&amp; internalContent.indexOf(mceInternalUrlPrefix) &gt;= <span class="hljs-number">0</span>) {
            internalContent = internalContent.substr(mceInternalUrlPrefix.length).split(<span class="hljs-string">','</span>);

            <span class="hljs-keyword">return</span> {
              <span class="hljs-attr">id</span>: <span class="hljs-built_in">unescape</span>(internalContent[<span class="hljs-number">0</span>]),
              <span class="hljs-attr">html</span>: <span class="hljs-built_in">unescape</span>(internalContent[<span class="hljs-number">1</span>])
            };
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-comment">/**
       * Inserts contents using the paste clipboard command if it's available if it isn't it will fallback
       * to the core command.
       *
       * @private
       * @param {String} content Content to insert at selection.
       * @param {Boolean} internal State if the paste is to be considered internal or external.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertClipboardContents</span>(<span class="hljs-params">content, internal</span>) </span>{
        <span class="hljs-keyword">if</span> (editor.queryCommandSupported(<span class="hljs-string">'mceInsertClipboardContent'</span>)) {
          editor.execCommand(<span class="hljs-string">'mceInsertClipboardContent'</span>, <span class="hljs-literal">false</span>, { <span class="hljs-attr">content</span>: content, <span class="hljs-attr">internal</span>: internal });
        } <span class="hljs-keyword">else</span> {
          editor.execCommand(<span class="hljs-string">'mceInsertContent'</span>, <span class="hljs-literal">false</span>, content);
        }
      }

      <span class="hljs-comment">/**
       * Makes sure that the editor body becomes empty when backspace or delete is pressed in empty editors.
       *
       * For example:
       * &lt;p&gt;&lt;b&gt;|&lt;/b&gt;&lt;/p&gt;
       *
       * Or:
       * &lt;h1&gt;|&lt;/h1&gt;
       *
       * Or:
       * [&lt;h1&gt;&lt;/h1&gt;]
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">emptyEditorWhenDeleting</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serializeRng</span>(<span class="hljs-params">rng</span>) </span>{
          <span class="hljs-keyword">var</span> body = dom.create(<span class="hljs-string">"body"</span>);
          <span class="hljs-keyword">var</span> contents = rng.cloneContents();
          body.appendChild(contents);
          <span class="hljs-keyword">return</span> selection.serializer.serialize(body, { <span class="hljs-attr">format</span>: <span class="hljs-string">'html'</span> });
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">allContentsSelected</span>(<span class="hljs-params">rng</span>) </span>{
          <span class="hljs-keyword">if</span> (!rng.setStart) {
            <span class="hljs-keyword">if</span> (rng.item) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-keyword">var</span> bodyRng = rng.duplicate();
            bodyRng.moveToElementText(editor.getBody());
            <span class="hljs-keyword">return</span> RangeUtils.compareRanges(rng, bodyRng);
          }

          <span class="hljs-keyword">var</span> selection = serializeRng(rng);

          <span class="hljs-keyword">var</span> allRng = dom.createRng();
          allRng.selectNode(editor.getBody());

          <span class="hljs-keyword">var</span> allSelection = serializeRng(allRng);
          <span class="hljs-keyword">return</span> selection === allSelection;
        }

        editor.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> keyCode = e.keyCode, isCollapsed, body;</pre></div></div>
            
        </li>
        
        
        <li id="section-1644">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1644">&#182;</a>
              </div>
              <p>Empty the editor if its needed for example backspace at <p><b>|</b></p></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!isDefaultPrevented(e) &amp;&amp; (keyCode == DELETE || keyCode == BACKSPACE)) {
            isCollapsed = editor.selection.isCollapsed();
            body = editor.getBody();</pre></div></div>
            
        </li>
        
        
        <li id="section-1645">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1645">&#182;</a>
              </div>
              <p>Selection is collapsed but the editor isnt empty</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (isCollapsed &amp;&amp; !dom.isEmpty(body)) {
              <span class="hljs-keyword">return</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1646">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1646">&#182;</a>
              </div>
              <p>Selection isnt collapsed but not all the contents is selected</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!isCollapsed &amp;&amp; !allContentsSelected(editor.selection.getRng())) {
              <span class="hljs-keyword">return</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1647">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1647">&#182;</a>
              </div>
              <p>Manually empty the editor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            e.preventDefault();
            editor.setContent(<span class="hljs-string">''</span>);

            <span class="hljs-keyword">if</span> (body.firstChild &amp;&amp; dom.isBlock(body.firstChild)) {
              editor.selection.setCursorLocation(body.firstChild, <span class="hljs-number">0</span>);
            } <span class="hljs-keyword">else</span> {
              editor.selection.setCursorLocation(body, <span class="hljs-number">0</span>);
            }

            editor.nodeChanged();
          }
        });
      }

      <span class="hljs-comment">/**
       * WebKit doesn't select all the nodes in the body when you press Ctrl+A.
       * IE selects more than the contents &lt;body&gt;[&lt;p&gt;a&lt;/p&gt;]&lt;/body&gt; instead of &lt;body&gt;&lt;p&gt;[a]&lt;/p]&lt;/body&gt; see bug #6438
       * This selects the whole body so that backspace/delete logic will delete everything
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectAll</span>(<span class="hljs-params"></span>) </span>{
        editor.shortcuts.add(<span class="hljs-string">'meta+a'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'SelectAll'</span>);
      }

      <span class="hljs-comment">/**
       * WebKit has a weird issue where it some times fails to properly convert keypresses to input method keystrokes.
       * The IME on Mac doesn't initialize when it doesn't fire a proper focus event.
       *
       * This seems to happen when the user manages to click the documentElement element then the window doesn't get proper focus until
       * you enter a character into the editor.
       *
       * It also happens when the first focus in made to the body.
       *
       * See: https://bugs.webkit.org/show_bug.cgi?id=83566
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inputMethodFocus</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!editor.settings.content_editable) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1648">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1648">&#182;</a>
              </div>
              <p>Case 1 IME doesnt initialize if you focus the document
Disabled since it was interferring with the cE=false logic
Also coultnt reproduce the issue on Safari 9</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/*dom.bind(editor.getDoc(), 'focusin', function() {
            selection.setRng(selection.getRng());
          });*/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1649">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1649">&#182;</a>
              </div>
              <p>Case 2 IME doesnt initialize if you click the documentElement it also doesnt properly fire the focusin event
Needs to be both down/up due to weird rendering bug on Chrome Windows</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          dom.bind(editor.getDoc(), <span class="hljs-string">'mousedown mouseup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">var</span> rng;

            <span class="hljs-keyword">if</span> (e.target == editor.getDoc().documentElement) {
              rng = selection.getRng();
              editor.getBody().focus();

              <span class="hljs-keyword">if</span> (e.type == <span class="hljs-string">'mousedown'</span>) {
                <span class="hljs-keyword">if</span> (CaretContainer.isCaretContainer(rng.startContainer)) {
                  <span class="hljs-keyword">return</span>;
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-1650">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1650">&#182;</a>
              </div>
              <p>Edge case for mousedown, drag select and mousedown again within selection on Chrome Windows to render caret</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                selection.placeCaretAt(e.clientX, e.clientY);
              } <span class="hljs-keyword">else</span> {
                selection.setRng(rng);
              }
            }
          });
        }
      }

      <span class="hljs-comment">/**
       * Backspacing in FireFox/IE from a paragraph into a horizontal rule results in a floating text node because the
       * browser just deletes the paragraph - the browser fails to merge the text node with a horizontal rule so it is
       * left there. TinyMCE sees a floating text node and wraps it in a paragraph on the key up event (ForceBlocks.js
       * addRootBlocks), meaning the action does nothing. With this code, FireFox/IE matche the behaviour of other
       * browsers.
       *
       * It also fixes a bug on Firefox where it's impossible to delete HR elements.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeHrOnBackspace</span>(<span class="hljs-params"></span>) </span>{
        editor.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (!isDefaultPrevented(e) &amp;&amp; e.keyCode === BACKSPACE) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1651">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1651">&#182;</a>
              </div>
              <p>Check if there is any HR elements this is faster since getRng on IE 7 &amp; 8 is slow</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!editor.getBody().getElementsByTagName(<span class="hljs-string">'hr'</span>).length) {
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (selection.isCollapsed() &amp;&amp; selection.getRng(<span class="hljs-literal">true</span>).startOffset === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">var</span> node = selection.getNode();
              <span class="hljs-keyword">var</span> previousSibling = node.previousSibling;

              <span class="hljs-keyword">if</span> (node.nodeName == <span class="hljs-string">'HR'</span>) {
                dom.remove(node);
                e.preventDefault();
                <span class="hljs-keyword">return</span>;
              }

              <span class="hljs-keyword">if</span> (previousSibling &amp;&amp; previousSibling.nodeName &amp;&amp; previousSibling.nodeName.toLowerCase() === <span class="hljs-string">"hr"</span>) {
                dom.remove(previousSibling);
                e.preventDefault();
              }
            }
          }
        });
      }

      <span class="hljs-comment">/**
       * Firefox 3.x has an issue where the body element won't get proper focus if you click out
       * side it's rectangle.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">focusBody</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1652">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1652">&#182;</a>
              </div>
              <p>Fix for a focus bug in FF 3.x where the body element
wouldnt get proper focus if the user clicked on the HTML element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.Range.prototype.getClientRects) { <span class="hljs-comment">// Detect getClientRects got introduced in FF 4</span>
          editor.on(<span class="hljs-string">'mousedown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">if</span> (!isDefaultPrevented(e) &amp;&amp; e.target.nodeName === <span class="hljs-string">"HTML"</span>) {
              <span class="hljs-keyword">var</span> body = editor.getBody();</pre></div></div>
            
        </li>
        
        
        <li id="section-1653">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1653">&#182;</a>
              </div>
              <p>Blur the body its focused but not correctly focused</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              body.blur();</pre></div></div>
            
        </li>
        
        
        <li id="section-1654">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1654">&#182;</a>
              </div>
              <p>Refocus the body after a little while</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              Delay.setEditorTimeout(editor, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                body.focus();
              });
            }
          });
        }
      }

      <span class="hljs-comment">/**
       * WebKit has a bug where it isn't possible to select image, hr or anchor elements
       * by clicking on them so we need to fake that.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectControlElements</span>(<span class="hljs-params"></span>) </span>{
        editor.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> target = e.target;</pre></div></div>
            
        </li>
        
        
        <li id="section-1655">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1655">&#182;</a>
              </div>
              <p>Workaround for bug, <a href="http://bugs.webkit.org/show_bug.cgi?id=12250">http://bugs.webkit.org/show_bug.cgi?id=12250</a>
WebKit cant even do simple things like selecting an image
Needs to be the setBaseAndExtend or it will fail to select floated images</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(IMG|HR)$/</span>.test(target.nodeName) &amp;&amp; dom.getContentEditableParent(target) !== <span class="hljs-string">"false"</span>) {
            e.preventDefault();
            editor.selection.select(target);
            editor.nodeChanged();
          }

          <span class="hljs-keyword">if</span> (target.nodeName == <span class="hljs-string">'A'</span> &amp;&amp; dom.hasClass(target, <span class="hljs-string">'mce-item-anchor'</span>)) {
            e.preventDefault();
            selection.select(target);
          }
        });
      }

      <span class="hljs-comment">/**
       * Fixes a Gecko bug where the style attribute gets added to the wrong element when deleting between two block elements.
       *
       * Fixes do backspace/delete on this:
       * &lt;p&gt;bla[ck&lt;/p&gt;&lt;p style="color:red"&gt;r]ed&lt;/p&gt;
       *
       * Would become:
       * &lt;p&gt;bla|ed&lt;/p&gt;
       *
       * Instead of:
       * &lt;p style="color:red"&gt;bla|ed&lt;/p&gt;
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeStylesWhenDeletingAcrossBlockElements</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAttributeApplyFunction</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> template = dom.getAttribs(selection.getStart().cloneNode(<span class="hljs-literal">false</span>));

          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> target = selection.getStart();

            <span class="hljs-keyword">if</span> (target !== editor.getBody()) {
              dom.setAttrib(target, <span class="hljs-string">"style"</span>, <span class="hljs-literal">null</span>);

              each(template, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">attr</span>) </span>{
                target.setAttributeNode(attr.cloneNode(<span class="hljs-literal">true</span>));
              });
            }
          };
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSelectionAcrossElements</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> !selection.isCollapsed() &amp;&amp;
            dom.getParent(selection.getStart(), dom.isBlock) != dom.getParent(selection.getEnd(), dom.isBlock);
        }

        editor.on(<span class="hljs-string">'keypress'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> applyAttributes;

          <span class="hljs-keyword">if</span> (!isDefaultPrevented(e) &amp;&amp; (e.keyCode == <span class="hljs-number">8</span> || e.keyCode == <span class="hljs-number">46</span>) &amp;&amp; isSelectionAcrossElements()) {
            applyAttributes = getAttributeApplyFunction();
            editor.getDoc().execCommand(<span class="hljs-string">'delete'</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);
            applyAttributes();
            e.preventDefault();
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        });

        dom.bind(editor.getDoc(), <span class="hljs-string">'cut'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> applyAttributes;

          <span class="hljs-keyword">if</span> (!isDefaultPrevented(e) &amp;&amp; isSelectionAcrossElements()) {
            applyAttributes = getAttributeApplyFunction();

            Delay.setEditorTimeout(editor, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              applyAttributes();
            });
          }
        });
      }

      <span class="hljs-comment">/**
       * Screen readers on IE needs to have the role application set on the body.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureBodyHasRoleApplication</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">document</span>.body.setAttribute(<span class="hljs-string">"role"</span>, <span class="hljs-string">"application"</span>);
      }

      <span class="hljs-comment">/**
       * Backspacing into a table behaves differently depending upon browser type.
       * Therefore, disable Backspace when cursor immediately follows a table.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disableBackspaceIntoATable</span>(<span class="hljs-params"></span>) </span>{
        editor.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (!isDefaultPrevented(e) &amp;&amp; e.keyCode === BACKSPACE) {
            <span class="hljs-keyword">if</span> (selection.isCollapsed() &amp;&amp; selection.getRng(<span class="hljs-literal">true</span>).startOffset === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">var</span> previousSibling = selection.getNode().previousSibling;
              <span class="hljs-keyword">if</span> (previousSibling &amp;&amp; previousSibling.nodeName &amp;&amp; previousSibling.nodeName.toLowerCase() === <span class="hljs-string">"table"</span>) {
                e.preventDefault();
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
            }
          }
        });
      }

      <span class="hljs-comment">/**
       * Old IE versions can't properly render BR elements in PRE tags white in contentEditable mode. So this
       * logic adds a \n before the BR so that it will get rendered.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addNewLinesBeforeBrInPre</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1656">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1656">&#182;</a>
              </div>
              <p>IE8+ rendering mode does the right thing with BR in PRE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (getDocumentMode() &gt; <span class="hljs-number">7</span>) {
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1657">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1657">&#182;</a>
              </div>
              <p>Enable display: none in area and add a specific class that hides all BR elements in PRE to
avoid the caret from getting stuck at the BR elements while pressing the right arrow key</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        setEditorCommandState(<span class="hljs-string">'RespectVisibilityInDesign'</span>, <span class="hljs-literal">true</span>);
        editor.contentStyles.push(<span class="hljs-string">'.mceHideBrInPre pre br {display: none}'</span>);
        dom.addClass(editor.getBody(), <span class="hljs-string">'mceHideBrInPre'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1658">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1658">&#182;</a>
              </div>
              <p>Adds a \n before all BR elements in PRE to get them visual</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        parser.addNodeFilter(<span class="hljs-string">'pre'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
          <span class="hljs-keyword">var</span> i = nodes.length, brNodes, j, brElm, sibling;

          <span class="hljs-keyword">while</span> (i--) {
            brNodes = nodes[i].getAll(<span class="hljs-string">'br'</span>);
            j = brNodes.length;
            <span class="hljs-keyword">while</span> (j--) {
              brElm = brNodes[j];</pre></div></div>
            
        </li>
        
        
        <li id="section-1659">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1659">&#182;</a>
              </div>
              <p>Add \n before BR in PRE elements on older IE:s so the new lines get rendered</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              sibling = brElm.prev;
              <span class="hljs-keyword">if</span> (sibling &amp;&amp; sibling.type === <span class="hljs-number">3</span> &amp;&amp; sibling.value.charAt(sibling.value - <span class="hljs-number">1</span>) != <span class="hljs-string">'\n'</span>) {
                sibling.value += <span class="hljs-string">'\n'</span>;
              } <span class="hljs-keyword">else</span> {
                brElm.parent.insert(<span class="hljs-keyword">new</span> Node(<span class="hljs-string">'#text'</span>, <span class="hljs-number">3</span>), brElm, <span class="hljs-literal">true</span>).value = <span class="hljs-string">'\n'</span>;
              }
            }
          }
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-1660">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1660">&#182;</a>
              </div>
              <p>Removes any \n before BR elements in PRE since other browsers and in contentEditable=false mode they will be visible</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        serializer.addNodeFilter(<span class="hljs-string">'pre'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
          <span class="hljs-keyword">var</span> i = nodes.length, brNodes, j, brElm, sibling;

          <span class="hljs-keyword">while</span> (i--) {
            brNodes = nodes[i].getAll(<span class="hljs-string">'br'</span>);
            j = brNodes.length;
            <span class="hljs-keyword">while</span> (j--) {
              brElm = brNodes[j];
              sibling = brElm.prev;
              <span class="hljs-keyword">if</span> (sibling &amp;&amp; sibling.type == <span class="hljs-number">3</span>) {
                sibling.value = sibling.value.replace(<span class="hljs-regexp">/\r?\n$/</span>, <span class="hljs-string">''</span>);
              }
            }
          }
        });
      }

      <span class="hljs-comment">/**
       * Moves style width/height to attribute width/height when the user resizes an image on IE.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removePreSerializedStylesWhenSelectingControls</span>(<span class="hljs-params"></span>) </span>{
        dom.bind(editor.getBody(), <span class="hljs-string">'mouseup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> value, node = selection.getNode();</pre></div></div>
            
        </li>
        
        
        <li id="section-1661">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1661">&#182;</a>
              </div>
              <p>Moved styles to attributes on IMG eements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (node.nodeName == <span class="hljs-string">'IMG'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1662">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1662">&#182;</a>
              </div>
              <p>Convert style width to width attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ((value = dom.getStyle(node, <span class="hljs-string">'width'</span>))) {
              dom.setAttrib(node, <span class="hljs-string">'width'</span>, value.replace(<span class="hljs-regexp">/[^0-9%]+/g</span>, <span class="hljs-string">''</span>));
              dom.setStyle(node, <span class="hljs-string">'width'</span>, <span class="hljs-string">''</span>);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1663">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1663">&#182;</a>
              </div>
              <p>Convert style height to height attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ((value = dom.getStyle(node, <span class="hljs-string">'height'</span>))) {
              dom.setAttrib(node, <span class="hljs-string">'height'</span>, value.replace(<span class="hljs-regexp">/[^0-9%]+/g</span>, <span class="hljs-string">''</span>));
              dom.setStyle(node, <span class="hljs-string">'height'</span>, <span class="hljs-string">''</span>);
            }
          }
        });
      }

      <span class="hljs-comment">/**
       * Removes a blockquote when backspace is pressed at the beginning of it.
       *
       * For example:
       * &lt;blockquote&gt;&lt;p&gt;|x&lt;/p&gt;&lt;/blockquote&gt;
       *
       * Becomes:
       * &lt;p&gt;|x&lt;/p&gt;
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeBlockQuoteOnBackSpace</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1664">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1664">&#182;</a>
              </div>
              <p>Add block quote deletion handler</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        editor.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> rng, container, offset, root, parent;

          <span class="hljs-keyword">if</span> (isDefaultPrevented(e) || e.keyCode != VK.BACKSPACE) {
            <span class="hljs-keyword">return</span>;
          }

          rng = selection.getRng();
          container = rng.startContainer;
          offset = rng.startOffset;
          root = dom.getRoot();
          parent = container;

          <span class="hljs-keyword">if</span> (!rng.collapsed || offset !== <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">while</span> (parent &amp;&amp; parent.parentNode &amp;&amp; parent.parentNode.firstChild == parent &amp;&amp; parent.parentNode != root) {
            parent = parent.parentNode;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1665">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1665">&#182;</a>
              </div>
              <p>Is the cursor at the beginning of a blockquote?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (parent.tagName === <span class="hljs-string">'BLOCKQUOTE'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1666">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1666">&#182;</a>
              </div>
              <p>Remove the blockquote</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            editor.formatter.toggle(<span class="hljs-string">'blockquote'</span>, <span class="hljs-literal">null</span>, parent);</pre></div></div>
            
        </li>
        
        
        <li id="section-1667">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1667">&#182;</a>
              </div>
              <p>Move the caret to the beginning of container</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            rng = dom.createRng();
            rng.setStart(container, <span class="hljs-number">0</span>);
            rng.setEnd(container, <span class="hljs-number">0</span>);
            selection.setRng(rng);
          }
        });
      }

      <span class="hljs-comment">/**
       * Sets various Gecko editing options on mouse down and before a execCommand to disable inline table editing that is broken etc.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setGeckoEditingOptions</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setOpts</span>(<span class="hljs-params"></span>) </span>{
          refreshContentEditable();

          setEditorCommandState(<span class="hljs-string">"StyleWithCSS"</span>, <span class="hljs-literal">false</span>);
          setEditorCommandState(<span class="hljs-string">"enableInlineTableEditing"</span>, <span class="hljs-literal">false</span>);

          <span class="hljs-keyword">if</span> (!settings.object_resizing) {
            setEditorCommandState(<span class="hljs-string">"enableObjectResizing"</span>, <span class="hljs-literal">false</span>);
          }
        }

        <span class="hljs-keyword">if</span> (!settings.readonly) {
          editor.on(<span class="hljs-string">'BeforeExecCommand MouseDown'</span>, setOpts);
        }
      }

      <span class="hljs-comment">/**
       * Fixes a gecko link bug, when a link is placed at the end of block elements there is
       * no way to move the caret behind the link. This fix adds a bogus br element after the link.
       *
       * For example this:
       * &lt;p&gt;&lt;b&gt;&lt;a href="#"&gt;x&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;
       *
       * Becomes this:
       * &lt;p&gt;&lt;b&gt;&lt;a href="#"&gt;x&lt;/a&gt;&lt;/b&gt;&lt;br&gt;&lt;/p&gt;
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addBrAfterLastLinks</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fixLinks</span>(<span class="hljs-params"></span>) </span>{
          each(dom.select(<span class="hljs-string">'a'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">var</span> parentNode = node.parentNode, root = dom.getRoot();

            <span class="hljs-keyword">if</span> (parentNode.lastChild === node) {
              <span class="hljs-keyword">while</span> (parentNode &amp;&amp; !dom.isBlock(parentNode)) {
                <span class="hljs-keyword">if</span> (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {
                  <span class="hljs-keyword">return</span>;
                }

                parentNode = parentNode.parentNode;
              }

              dom.add(parentNode, <span class="hljs-string">'br'</span>, { <span class="hljs-string">'data-mce-bogus'</span>: <span class="hljs-number">1</span> });
            }
          });
        }

        editor.on(<span class="hljs-string">'SetContent ExecCommand'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (e.type == <span class="hljs-string">"setcontent"</span> || e.command === <span class="hljs-string">'mceInsertLink'</span>) {
            fixLinks();
          }
        });
      }

      <span class="hljs-comment">/**
       * WebKit will produce DIV elements here and there by default. But since TinyMCE uses paragraphs by
       * default we want to change that behavior.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDefaultBlockType</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (settings.forced_root_block) {
          editor.on(<span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            setEditorCommandState(<span class="hljs-string">'DefaultParagraphSeparator'</span>, settings.forced_root_block);
          });
        }
      }

      <span class="hljs-comment">/**
       * Deletes the selected image on IE instead of navigating to previous page.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteControlItemOnBackSpace</span>(<span class="hljs-params"></span>) </span>{
        editor.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> rng;

          <span class="hljs-keyword">if</span> (!isDefaultPrevented(e) &amp;&amp; e.keyCode == BACKSPACE) {
            rng = editor.getDoc().selection.createRange();
            <span class="hljs-keyword">if</span> (rng &amp;&amp; rng.item) {
              e.preventDefault();
              editor.undoManager.beforeChange();
              dom.remove(rng.item(<span class="hljs-number">0</span>));
              editor.undoManager.add();
            }
          }
        });
      }

      <span class="hljs-comment">/**
       * IE10 doesn't properly render block elements with the right height until you add contents to them.
       * This fixes that by adding a padding-right to all empty text block elements.
       * See: https://connect.microsoft.com/IE/feedback/details/743881
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderEmptyBlocksFix</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> emptyBlocksCSS;</pre></div></div>
            
        </li>
        
        
        <li id="section-1668">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1668">&#182;</a>
              </div>
              <p>IE10+</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (getDocumentMode() &gt;= <span class="hljs-number">10</span>) {
          emptyBlocksCSS = <span class="hljs-string">''</span>;
          each(<span class="hljs-string">'p div h1 h2 h3 h4 h5 h6'</span>.split(<span class="hljs-string">' '</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, i</span>) </span>{
            emptyBlocksCSS += (i &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">','</span> : <span class="hljs-string">''</span>) + name + <span class="hljs-string">':empty'</span>;
          });

          editor.contentStyles.push(emptyBlocksCSS + <span class="hljs-string">'{padding-right: 1px !important}'</span>);
        }
      }

      <span class="hljs-comment">/**
       * Old IE versions can't retain contents within noscript elements so this logic will store the contents
       * as a attribute and the insert that value as it's raw text when the DOM is serialized.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">keepNoScriptContents</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (getDocumentMode() &lt; <span class="hljs-number">9</span>) {
          parser.addNodeFilter(<span class="hljs-string">'noscript'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
            <span class="hljs-keyword">var</span> i = nodes.length, node, textNode;

            <span class="hljs-keyword">while</span> (i--) {
              node = nodes[i];
              textNode = node.firstChild;

              <span class="hljs-keyword">if</span> (textNode) {
                node.attr(<span class="hljs-string">'data-mce-innertext'</span>, textNode.value);
              }
            }
          });

          serializer.addNodeFilter(<span class="hljs-string">'noscript'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
            <span class="hljs-keyword">var</span> i = nodes.length, node, textNode, value;

            <span class="hljs-keyword">while</span> (i--) {
              node = nodes[i];
              textNode = nodes[i].firstChild;

              <span class="hljs-keyword">if</span> (textNode) {
                textNode.value = Entities.decode(textNode.value);
              } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1669">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1669">&#182;</a>
              </div>
              <p>Old IE cant retain noscript value so an attribute is used to store it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                value = node.attributes.map[<span class="hljs-string">'data-mce-innertext'</span>];
                <span class="hljs-keyword">if</span> (value) {
                  node.attr(<span class="hljs-string">'data-mce-innertext'</span>, <span class="hljs-literal">null</span>);
                  textNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'#text'</span>, <span class="hljs-number">3</span>);
                  textNode.value = value;
                  textNode.raw = <span class="hljs-literal">true</span>;
                  node.append(textNode);
                }
              }
            }
          });
        }
      }

      <span class="hljs-comment">/**
       * IE has an issue where you can't select/move the caret by clicking outside the body if the document is in standards mode.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fixCaretSelectionOfDocumentElementOnIe</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> doc = dom.doc, body = doc.body, started, startRng, htmlElm;</pre></div></div>
            
        </li>
        
        
        <li id="section-1670">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1670">&#182;</a>
              </div>
              <p>Return range from point or null if it failed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rngFromPoint</span>(<span class="hljs-params">x, y</span>) </span>{
          <span class="hljs-keyword">var</span> rng = body.createTextRange();

          <span class="hljs-keyword">try</span> {
            rng.moveToPoint(x, y);
          } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1671">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1671">&#182;</a>
              </div>
              <p>IE sometimes throws and exception, so lets just ignore it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            rng = <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">return</span> rng;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1672">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1672">&#182;</a>
              </div>
              <p>Fires while the selection is changing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionChange</span>(<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> pointRng;</pre></div></div>
            
        </li>
        
        
        <li id="section-1673">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1673">&#182;</a>
              </div>
              <p>Check if the button is down or not</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (e.button) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1674">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1674">&#182;</a>
              </div>
              <p>Create range from mouse position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            pointRng = rngFromPoint(e.x, e.y);

            <span class="hljs-keyword">if</span> (pointRng) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1675">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1675">&#182;</a>
              </div>
              <p>Check if pointRange is before/after selection then change the endPoint</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (pointRng.compareEndPoints(<span class="hljs-string">'StartToStart'</span>, startRng) &gt; <span class="hljs-number">0</span>) {
                pointRng.setEndPoint(<span class="hljs-string">'StartToStart'</span>, startRng);
              } <span class="hljs-keyword">else</span> {
                pointRng.setEndPoint(<span class="hljs-string">'EndToEnd'</span>, startRng);
              }

              pointRng.select();
            }
          } <span class="hljs-keyword">else</span> {
            endSelection();
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1676">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1676">&#182;</a>
              </div>
              <p>Removes listeners</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endSelection</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> rng = doc.selection.createRange();</pre></div></div>
            
        </li>
        
        
        <li id="section-1677">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1677">&#182;</a>
              </div>
              <p>If the range is collapsed then use the last start range</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (startRng &amp;&amp; !rng.item &amp;&amp; rng.compareEndPoints(<span class="hljs-string">'StartToEnd'</span>, rng) === <span class="hljs-number">0</span>) {
            startRng.select();
          }

          dom.unbind(doc, <span class="hljs-string">'mouseup'</span>, endSelection);
          dom.unbind(doc, <span class="hljs-string">'mousemove'</span>, selectionChange);
          startRng = started = <span class="hljs-number">0</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1678">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1678">&#182;</a>
              </div>
              <p>Make HTML element unselectable since we are going to handle selection by hand</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        doc.documentElement.unselectable = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1679">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1679">&#182;</a>
              </div>
              <p>Detect when user selects outside BODY</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        dom.bind(doc, <span class="hljs-string">'mousedown contextmenu'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (e.target.nodeName === <span class="hljs-string">'HTML'</span>) {
            <span class="hljs-keyword">if</span> (started) {
              endSelection();
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1680">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1680">&#182;</a>
              </div>
              <p>Detect vertical scrollbar, since IE will fire a mousedown on the scrollbar and have target set as HTML</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            htmlElm = doc.documentElement;
            <span class="hljs-keyword">if</span> (htmlElm.scrollHeight &gt; htmlElm.clientHeight) {
              <span class="hljs-keyword">return</span>;
            }

            started = <span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1681">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1681">&#182;</a>
              </div>
              <p>Setup start position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            startRng = rngFromPoint(e.x, e.y);
            <span class="hljs-keyword">if</span> (startRng) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1682">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1682">&#182;</a>
              </div>
              <p>Listen for selection change events</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              dom.bind(doc, <span class="hljs-string">'mouseup'</span>, endSelection);
              dom.bind(doc, <span class="hljs-string">'mousemove'</span>, selectionChange);

              dom.getRoot().focus();
              startRng.select();
            }
          }
        });
      }

      <span class="hljs-comment">/**
       * Fixes selection issues where the caret can be placed between two inline elements like &lt;b&gt;a&lt;/b&gt;|&lt;b&gt;b&lt;/b&gt;
       * this fix will lean the caret right into the closest inline element.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeSelection</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1683">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1683">&#182;</a>
              </div>
              <p>Normalize selection for example <b>a</b><i>|a</i> becomes <b>a|</b><i>a</i> except for Ctrl+A since it selects everything</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        editor.on(<span class="hljs-string">'keyup focusin mouseup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (e.keyCode != <span class="hljs-number">65</span> || !VK.metaKeyPressed(e)) {
            selection.normalize();
          }
        }, <span class="hljs-literal">true</span>);
      }

      <span class="hljs-comment">/**
       * Forces Gecko to render a broken image icon if it fails to load an image.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showBrokenImageIcon</span>(<span class="hljs-params"></span>) </span>{
        editor.contentStyles.push(
          <span class="hljs-string">'img:-moz-broken {'</span> +
          <span class="hljs-string">'-moz-force-broken-image-icon:1;'</span> +
          <span class="hljs-string">'min-width:24px;'</span> +
          <span class="hljs-string">'min-height:24px'</span> +
          <span class="hljs-string">'}'</span>
        );
      }

      <span class="hljs-comment">/**
       * iOS has a bug where it's impossible to type if the document has a touchstart event
       * bound and the user touches the document while having the on screen keyboard visible.
       *
       * The touch event moves the focus to the parent document while having the caret inside the iframe
       * this fix moves the focus back into the iframe document.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restoreFocusOnKeyDown</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!editor.inline) {
          editor.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.activeElement == <span class="hljs-built_in">document</span>.body) {
              editor.getWin().focus();
            }
          });
        }
      }

      <span class="hljs-comment">/**
       * IE 11 has an annoying issue where you can't move focus into the editor
       * by clicking on the white area HTML element. We used to be able to to fix this with
       * the fixCaretSelectionOfDocumentElementOnIe fix. But since M$ removed the selection
       * object it's not possible anymore. So we need to hack in a ungly CSS to force the
       * body to be at least 150px. If the user clicks the HTML element out side this 150px region
       * we simply move the focus into the first paragraph. Not ideal since you loose the
       * positioning of the caret but goot enough for most cases.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bodyHeight</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!editor.inline) {
          editor.contentStyles.push(<span class="hljs-string">'body {min-height: 150px}'</span>);
          editor.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">var</span> rng;

            <span class="hljs-keyword">if</span> (e.target.nodeName == <span class="hljs-string">'HTML'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1684">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1684">&#182;</a>
              </div>
              <p>Edge seems to only need focus if we set the range
the caret will become invisible and moved out of the iframe!!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (Env.ie &gt; <span class="hljs-number">11</span>) {
                editor.getBody().focus();
                <span class="hljs-keyword">return</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-1685">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1685">&#182;</a>
              </div>
              <p>Need to store away non collapsed ranges since the focus call will mess that up see #7382</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              rng = editor.selection.getRng();
              editor.getBody().focus();
              editor.selection.setRng(rng);
              editor.selection.normalize();
              editor.nodeChanged();
            }
          });
        }
      }

      <span class="hljs-comment">/**
       * Firefox on Mac OS will move the browser back to the previous page if you press CMD+Left arrow.
       * You might then loose all your work so we need to block that behavior and replace it with our own.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">blockCmdArrowNavigation</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (Env.mac) {
          editor.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">if</span> (VK.metaKeyPressed(e) &amp;&amp; !e.shiftKey &amp;&amp; (e.keyCode == <span class="hljs-number">37</span> || e.keyCode == <span class="hljs-number">39</span>)) {
              e.preventDefault();
              editor.selection.getSel().modify(<span class="hljs-string">'move'</span>, e.keyCode == <span class="hljs-number">37</span> ? <span class="hljs-string">'backward'</span> : <span class="hljs-string">'forward'</span>, <span class="hljs-string">'lineboundary'</span>);
            }
          });
        }
      }

      <span class="hljs-comment">/**
       * Disables the autolinking in IE 9+ this is then re-enabled by the autolink plugin.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disableAutoUrlDetect</span>(<span class="hljs-params"></span>) </span>{
        setEditorCommandState(<span class="hljs-string">"AutoUrlDetect"</span>, <span class="hljs-literal">false</span>);
      }

      <span class="hljs-comment">/**
       * iOS 7.1 introduced two new bugs:
       * 1) It's possible to open links within a contentEditable area by clicking on them.
       * 2) If you hold down the finger it will display the link/image touch callout menu.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tapLinksAndImages</span>(<span class="hljs-params"></span>) </span>{
        editor.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> elm = e.target;

          <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">if</span> (elm.tagName === <span class="hljs-string">'A'</span>) {
              e.preventDefault();
              <span class="hljs-keyword">return</span>;
            }
          } <span class="hljs-keyword">while</span> ((elm = elm.parentNode));
        });

        editor.contentStyles.push(<span class="hljs-string">'.mce-content-body {-webkit-touch-callout: none}'</span>);
      }

      <span class="hljs-comment">/**
       * iOS Safari and possible other browsers have a bug where it won't fire
       * a click event when a contentEditable is focused. This function fakes click events
       * by using touchstart/touchend and measuring the time and distance travelled.
       */</span>
      <span class="hljs-comment">/*
      function touchClickEvent() {
        editor.on('touchstart', function(e) {
          var elm, time, startTouch, changedTouches;

          elm = e.target;
          time = new Date().getTime();
          changedTouches = e.changedTouches;

          if (!changedTouches || changedTouches.length &gt; 1) {
            return;
          }

          startTouch = changedTouches[0];

          editor.once('touchend', function(e) {
            var endTouch = e.changedTouches[0], args;

            if (new Date().getTime() - time &gt; 500) {
              return;
            }

            if (Math.abs(startTouch.clientX - endTouch.clientX) &gt; 5) {
              return;
            }

            if (Math.abs(startTouch.clientY - endTouch.clientY) &gt; 5) {
              return;
            }

            args = {
              target: elm
            };

            each('pageX pageY clientX clientY screenX screenY'.split(' '), function(key) {
              args[key] = endTouch[key];
            });

            args = editor.fire('click', args);

            if (!args.isDefaultPrevented()) {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1686">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1686">&#182;</a>
              </div>
              <p>iOS WebKit cant place the caret properly once
you bind touch events so we need to do this manually
TODO: Expand to the closest word? Touble tap still works.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              editor.selection.placeCaretAt(endTouch.clientX, endTouch.clientY);
              editor.nodeChanged();
            }
          });
        });
      }
      */

      /**
       * WebKit has a bug where it will allow forms to be submitted if they are inside a contentEditable element.
       * For example this: &lt;form&gt;&lt;button&gt;&lt;/form&gt;
       */
      function blockFormSubmitInsideEditor() {
        editor.on('init', function () {
          editor.dom.bind(editor.getBody(), 'submit', function (e) {
            e.preventDefault();
          });
        });
      }

      /**
       * Sometimes WebKit/Blink generates BR elements with the Apple-interchange-newline class.
       *
       * Scenario:
       *  1) Create a table 2x2.
       *  2) Select and copy cells A2-B2.
       *  3) Paste and it will add BR element to table cell.
       */
      function removeAppleInterchangeBrs() {
        parser.addNodeFilter('br', function (nodes) {
          var i = nodes.length;

          while (i--) {
            if (nodes[i].attr('class') == 'Apple-interchange-newline') {
              nodes[i].remove();
            }
          }
        });
      }

      /**
       * IE cannot set custom contentType's on drag events, and also does not properly drag/drop between
       * editors. This uses a special data:text/mce-internal URL to pass data when drag/drop between editors.
       */
      function ieInternalDragAndDrop() {
        editor.on('dragstart', function (e) {
          setMceInternalContent(e);
        });

        editor.on('drop', function (e) {
          if (!isDefaultPrevented(e)) {
            var internalContent = getMceInternalContent(e);

            if (internalContent &amp;&amp; internalContent.id != editor.id) {
              e.preventDefault();

              var rng = RangeUtils.getCaretRangeFromPoint(e.x, e.y, editor.getDoc());
              selection.setRng(rng);
              insertClipboardContents(internalContent.html, true);
            }
          }
        });
      }

      function refreshContentEditable() {</pre></div></div>
            
        </li>
        
        
        <li id="section-1687">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1687">&#182;</a>
              </div>
              <p>No-op since Mozilla seems to have fixed the caret repaint issues</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isHidden</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> sel;

        <span class="hljs-keyword">if</span> (!isGecko) {
          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1688">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1688">&#182;</a>
              </div>
              <p>Weird, wheres that cursor selection?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        sel = editor.selection.getSel();
        <span class="hljs-keyword">return</span> (!sel || !sel.rangeCount || sel.rangeCount === <span class="hljs-number">0</span>);
      }

      <span class="hljs-comment">/**
       * Properly empties the editor if all contents is selected and deleted this to
       * prevent empty paragraphs from being produced at beginning/end of contents.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">emptyEditorOnDeleteEverything</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEverythingSelected</span>(<span class="hljs-params">editor</span>) </span>{
          <span class="hljs-keyword">var</span> caretWalker = <span class="hljs-keyword">new</span> CaretWalker(editor.getBody());
          <span class="hljs-keyword">var</span> rng = editor.selection.getRng();
          <span class="hljs-keyword">var</span> startCaretPos = CaretPosition.fromRangeStart(rng);
          <span class="hljs-keyword">var</span> endCaretPos = CaretPosition.fromRangeEnd(rng);
          <span class="hljs-keyword">var</span> prev = caretWalker.prev(startCaretPos);
          <span class="hljs-keyword">var</span> next = caretWalker.next(endCaretPos);

          <span class="hljs-keyword">return</span> !editor.selection.isCollapsed() &amp;&amp;
            (!prev || (prev.isAtStart() &amp;&amp; startCaretPos.isEqual(prev))) &amp;&amp;
            (!next || (next.isAtEnd() &amp;&amp; startCaretPos.isEqual(next)));
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1689">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1689">&#182;</a>
              </div>
              <p>Type over case delete and insert this wont cover typeover with a IME but at least it covers the common case</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        editor.on(<span class="hljs-string">'keypress'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (!isDefaultPrevented(e) &amp;&amp; !selection.isCollapsed() &amp;&amp; e.charCode &gt; <span class="hljs-number">31</span> &amp;&amp; !VK.metaKeyPressed(e)) {
            <span class="hljs-keyword">if</span> (isEverythingSelected(editor)) {
              e.preventDefault();
              editor.setContent(<span class="hljs-built_in">String</span>.fromCharCode(e.charCode));
              editor.selection.select(editor.getBody(), <span class="hljs-literal">true</span>);
              editor.selection.collapse(<span class="hljs-literal">false</span>);
              editor.nodeChanged();
            }
          }
        });

        editor.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> keyCode = e.keyCode;

          <span class="hljs-keyword">if</span> (!isDefaultPrevented(e) &amp;&amp; (keyCode == DELETE || keyCode == BACKSPACE)) {
            <span class="hljs-keyword">if</span> (isEverythingSelected(editor)) {
              e.preventDefault();
              editor.setContent(<span class="hljs-string">''</span>);
              editor.nodeChanged();
            }
          }
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1690">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1690">&#182;</a>
              </div>
              <p>All browsers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      removeBlockQuoteOnBackSpace();
      emptyEditorWhenDeleting();</pre></div></div>
            
        </li>
        
        
        <li id="section-1691">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1691">&#182;</a>
              </div>
              <p>Windows phone will return a range like [body, 0] on mousedown so
it will always normalize to the wrong location</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!Env.windowsPhone) {
        normalizeSelection();
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1692">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1692">&#182;</a>
              </div>
              <p>WebKit</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (isWebKit) {
        emptyEditorOnDeleteEverything();
        inputMethodFocus();
        selectControlElements();
        setDefaultBlockType();
        blockFormSubmitInsideEditor();
        disableBackspaceIntoATable();
        removeAppleInterchangeBrs();</pre></div></div>
            
        </li>
        
        
        <li id="section-1693">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1693">&#182;</a>
              </div>
              <p>touchClickEvent();</p>

            </div>
            
        </li>
        
        
        <li id="section-1694">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1694">&#182;</a>
              </div>
              <p>iOS</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (Env.iOS) {
          restoreFocusOnKeyDown();
          bodyHeight();
          tapLinksAndImages();
        } <span class="hljs-keyword">else</span> {
          selectAll();
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1695">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1695">&#182;</a>
              </div>
              <p>IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (isIE &amp;&amp; Env.ie &lt; <span class="hljs-number">11</span>) {
        removeHrOnBackspace();
        ensureBodyHasRoleApplication();
        addNewLinesBeforeBrInPre();
        removePreSerializedStylesWhenSelectingControls();
        deleteControlItemOnBackSpace();
        renderEmptyBlocksFix();
        keepNoScriptContents();
        fixCaretSelectionOfDocumentElementOnIe();
      }

      <span class="hljs-keyword">if</span> (Env.ie &gt;= <span class="hljs-number">11</span>) {
        bodyHeight();
        disableBackspaceIntoATable();
      }

      <span class="hljs-keyword">if</span> (Env.ie) {
        selectAll();
        disableAutoUrlDetect();
        ieInternalDragAndDrop();
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1696">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1696">&#182;</a>
              </div>
              <p>Gecko</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (isGecko) {
        emptyEditorOnDeleteEverything();
        removeHrOnBackspace();
        focusBody();
        removeStylesWhenDeletingAcrossBlockElements();
        setGeckoEditingOptions();
        addBrAfterLastLinks();
        showBrokenImageIcon();
        blockCmdArrowNavigation();
        disableBackspaceIntoATable();
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">refreshContentEditable</span>: refreshContentEditable,
        <span class="hljs-attr">isHidden</span>: isHidden
      };
    };
  }
);

<span class="hljs-comment">/**
 * InitContentBody.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.init.InitContentBody'</span>,
  [
    <span class="hljs-string">'global!document'</span>,
    <span class="hljs-string">'global!window'</span>,
    <span class="hljs-string">'tinymce.core.caret.CaretContainerInput'</span>,
    <span class="hljs-string">'tinymce.core.dom.DOMUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.Selection'</span>,
    <span class="hljs-string">'tinymce.core.dom.Serializer'</span>,
    <span class="hljs-string">'tinymce.core.EditorUpload'</span>,
    <span class="hljs-string">'tinymce.core.ErrorReporter'</span>,
    <span class="hljs-string">'tinymce.core.ForceBlocks'</span>,
    <span class="hljs-string">'tinymce.core.Formatter'</span>,
    <span class="hljs-string">'tinymce.core.html.DomParser'</span>,
    <span class="hljs-string">'tinymce.core.html.Node'</span>,
    <span class="hljs-string">'tinymce.core.html.Schema'</span>,
    <span class="hljs-string">'tinymce.core.keyboard.KeyboardOverrides'</span>,
    <span class="hljs-string">'tinymce.core.NodeChange'</span>,
    <span class="hljs-string">'tinymce.core.SelectionOverrides'</span>,
    <span class="hljs-string">'tinymce.core.UndoManager'</span>,
    <span class="hljs-string">'tinymce.core.util.Delay'</span>,
    <span class="hljs-string">'tinymce.core.util.Quirks'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">
    document, window, CaretContainerInput, DOMUtils, Selection, Serializer, EditorUpload, ErrorReporter, ForceBlocks, Formatter, DomParser, Node, Schema, KeyboardOverrides,
    NodeChange, SelectionOverrides, UndoManager, Delay, Quirks, Tools
  </span>) </span>{
    <span class="hljs-keyword">var</span> DOM = DOMUtils.DOM;

    <span class="hljs-keyword">var</span> createParser = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> parser = <span class="hljs-keyword">new</span> DomParser(editor.settings, editor.schema);</pre></div></div>
            
        </li>
        
        
        <li id="section-1697">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1697">&#182;</a>
              </div>
              <p>Convert src and href into data-mce-src, data-mce-href and data-mce-style</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      parser.addAttributeFilter(<span class="hljs-string">'src,href,style,tabindex'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes, name</span>) </span>{
        <span class="hljs-keyword">var</span> i = nodes.length, node, dom = editor.dom, value, internalName;

        <span class="hljs-keyword">while</span> (i--) {
          node = nodes[i];
          value = node.attr(name);
          internalName = <span class="hljs-string">'data-mce-'</span> + name;</pre></div></div>
            
        </li>
        
        
        <li id="section-1698">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1698">&#182;</a>
              </div>
              <p>Add internal attribute if we need to we dont on a refresh of the document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!node.attributes.map[internalName]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1699">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1699">&#182;</a>
              </div>
              <p>Dont duplicate these since they wont get modified by any browser</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (value.indexOf(<span class="hljs-string">'data:'</span>) === <span class="hljs-number">0</span> || value.indexOf(<span class="hljs-string">'blob:'</span>) === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-keyword">if</span> (name === <span class="hljs-string">"style"</span>) {
              value = dom.serializeStyle(dom.parseStyle(value), node.name);

              <span class="hljs-keyword">if</span> (!value.length) {
                value = <span class="hljs-literal">null</span>;
              }

              node.attr(internalName, value);
              node.attr(name, value);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name === <span class="hljs-string">"tabindex"</span>) {
              node.attr(internalName, value);
              node.attr(name, <span class="hljs-literal">null</span>);
            } <span class="hljs-keyword">else</span> {
              node.attr(internalName, editor.convertURL(value, name, node.name));
            }
          }
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-1700">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1700">&#182;</a>
              </div>
              <p>Keep scripts from executing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      parser.addNodeFilter(<span class="hljs-string">'script'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
        <span class="hljs-keyword">var</span> i = nodes.length, node, type;

        <span class="hljs-keyword">while</span> (i--) {
          node = nodes[i];
          type = node.attr(<span class="hljs-string">'type'</span>) || <span class="hljs-string">'no/type'</span>;
          <span class="hljs-keyword">if</span> (type.indexOf(<span class="hljs-string">'mce-'</span>) !== <span class="hljs-number">0</span>) {
            node.attr(<span class="hljs-string">'type'</span>, <span class="hljs-string">'mce-'</span> + type);
          }
        }
      });

      parser.addNodeFilter(<span class="hljs-string">'#cdata'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
        <span class="hljs-keyword">var</span> i = nodes.length, node;

        <span class="hljs-keyword">while</span> (i--) {
          node = nodes[i];
          node.type = <span class="hljs-number">8</span>;
          node.name = <span class="hljs-string">'#comment'</span>;
          node.value = <span class="hljs-string">'[CDATA['</span> + node.value + <span class="hljs-string">']]'</span>;
        }
      });

      parser.addNodeFilter(<span class="hljs-string">'p,h1,h2,h3,h4,h5,h6,div'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
        <span class="hljs-keyword">var</span> i = nodes.length, node, nonEmptyElements = editor.schema.getNonEmptyElements();

        <span class="hljs-keyword">while</span> (i--) {
          node = nodes[i];

          <span class="hljs-keyword">if</span> (node.isEmpty(nonEmptyElements) &amp;&amp; node.getAll(<span class="hljs-string">'br'</span>).length === <span class="hljs-number">0</span>) {
            node.append(<span class="hljs-keyword">new</span> Node(<span class="hljs-string">'br'</span>, <span class="hljs-number">1</span>)).shortEnded = <span class="hljs-literal">true</span>;
          }
        }
      });

      <span class="hljs-keyword">return</span> parser;
    };

    <span class="hljs-keyword">var</span> autoFocus = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">if</span> (editor.settings.auto_focus) {
        Delay.setEditorTimeout(editor, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> focusEditor;

          <span class="hljs-keyword">if</span> (editor.settings.auto_focus === <span class="hljs-literal">true</span>) {
            focusEditor = editor;
          } <span class="hljs-keyword">else</span> {
            focusEditor = editor.editorManager.get(editor.settings.auto_focus);
          }

          <span class="hljs-keyword">if</span> (!focusEditor.destroyed) {
            focusEditor.focus();
          }
        }, <span class="hljs-number">100</span>);
      }
    };

    <span class="hljs-keyword">var</span> initEditor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      editor.bindPendingEventDelegates();
      editor.initialized = <span class="hljs-literal">true</span>;
      editor.fire(<span class="hljs-string">'init'</span>);
      editor.focus(<span class="hljs-literal">true</span>);
      editor.nodeChanged({ <span class="hljs-attr">initial</span>: <span class="hljs-literal">true</span> });
      editor.execCallback(<span class="hljs-string">'init_instance_callback'</span>, editor);
      autoFocus(editor);
    };

    <span class="hljs-keyword">var</span> initContentBody = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, skipWrite</span>) </span>{
      <span class="hljs-keyword">var</span> settings = editor.settings, targetElm = editor.getElement(), doc = editor.getDoc(), body, contentCssText;</pre></div></div>
            
        </li>
        
        
        <li id="section-1701">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1701">&#182;</a>
              </div>
              <p>Restore visibility on target element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!settings.inline) {
        editor.getElement().style.visibility = editor.orgVisibility;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1702">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1702">&#182;</a>
              </div>
              <p>Setup iframe body</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!skipWrite &amp;&amp; !settings.content_editable) {
        doc.open();
        doc.write(editor.iframeHTML);
        doc.close();
      }

      <span class="hljs-keyword">if</span> (settings.content_editable) {
        editor.on(<span class="hljs-string">'remove'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> bodyEl = <span class="hljs-keyword">this</span>.getBody();

          DOM.removeClass(bodyEl, <span class="hljs-string">'mce-content-body'</span>);
          DOM.removeClass(bodyEl, <span class="hljs-string">'mce-edit-focus'</span>);
          DOM.setAttrib(bodyEl, <span class="hljs-string">'contentEditable'</span>, <span class="hljs-literal">null</span>);
        });

        DOM.addClass(targetElm, <span class="hljs-string">'mce-content-body'</span>);
        editor.contentDocument = doc = settings.content_document || <span class="hljs-built_in">document</span>;
        editor.contentWindow = settings.content_window || <span class="hljs-built_in">window</span>;
        editor.bodyElement = targetElm;</pre></div></div>
            
        </li>
        
        
        <li id="section-1703">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1703">&#182;</a>
              </div>
              <p>Prevent leak in IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        settings.content_document = settings.content_window = <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1704">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1704">&#182;</a>
              </div>
              <p>TODO: Fix this</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        settings.root_name = targetElm.nodeName.toLowerCase();
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1705">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1705">&#182;</a>
              </div>
              <p>It will not steal focus while setting contentEditable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      body = editor.getBody();
      body.disabled = <span class="hljs-literal">true</span>;
      editor.readonly = settings.readonly;

      <span class="hljs-keyword">if</span> (!editor.readonly) {
        <span class="hljs-keyword">if</span> (editor.inline &amp;&amp; DOM.getStyle(body, <span class="hljs-string">'position'</span>, <span class="hljs-literal">true</span>) === <span class="hljs-string">'static'</span>) {
          body.style.position = <span class="hljs-string">'relative'</span>;
        }

        body.contentEditable = editor.getParam(<span class="hljs-string">'content_editable_state'</span>, <span class="hljs-literal">true</span>);
      }

      body.disabled = <span class="hljs-literal">false</span>;

      editor.editorUpload = <span class="hljs-keyword">new</span> EditorUpload(editor);
      editor.schema = <span class="hljs-keyword">new</span> Schema(settings);
      editor.dom = <span class="hljs-keyword">new</span> DOMUtils(doc, {
        <span class="hljs-attr">keep_values</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">url_converter</span>: editor.convertURL,
        <span class="hljs-attr">url_converter_scope</span>: editor,
        <span class="hljs-attr">hex_colors</span>: settings.force_hex_style_colors,
        <span class="hljs-attr">class_filter</span>: settings.class_filter,
        <span class="hljs-attr">update_styles</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">root_element</span>: editor.inline ? editor.getBody() : <span class="hljs-literal">null</span>,
        <span class="hljs-attr">collect</span>: settings.content_editable,
        <span class="hljs-attr">schema</span>: editor.schema,
        <span class="hljs-attr">onSetAttrib</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          editor.fire(<span class="hljs-string">'SetAttrib'</span>, e);
        }
      });

      editor.parser = createParser(editor);
      editor.serializer = <span class="hljs-keyword">new</span> Serializer(settings, editor);
      editor.selection = <span class="hljs-keyword">new</span> Selection(editor.dom, editor.getWin(), editor.serializer, editor);
      editor.formatter = <span class="hljs-keyword">new</span> Formatter(editor);
      editor.undoManager = <span class="hljs-keyword">new</span> UndoManager(editor);
      editor._nodeChangeDispatcher = <span class="hljs-keyword">new</span> NodeChange(editor);
      editor._selectionOverrides = <span class="hljs-keyword">new</span> SelectionOverrides(editor);

      CaretContainerInput.setup(editor);
      KeyboardOverrides.setup(editor);
      ForceBlocks.setup(editor);

      editor.fire(<span class="hljs-string">'PreInit'</span>);

      <span class="hljs-keyword">if</span> (!settings.browser_spellcheck &amp;&amp; !settings.gecko_spellcheck) {
        doc.body.spellcheck = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Gecko</span>
        DOM.setAttrib(body, <span class="hljs-string">"spellcheck"</span>, <span class="hljs-string">"false"</span>);
      }

      editor.quirks = <span class="hljs-keyword">new</span> Quirks(editor);
      editor.fire(<span class="hljs-string">'PostRender'</span>);

      <span class="hljs-keyword">if</span> (settings.directionality) {
        body.dir = settings.directionality;
      }

      <span class="hljs-keyword">if</span> (settings.nowrap) {
        body.style.whiteSpace = <span class="hljs-string">"nowrap"</span>;
      }

      <span class="hljs-keyword">if</span> (settings.protect) {
        editor.on(<span class="hljs-string">'BeforeSetContent'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          Tools.each(settings.protect, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern</span>) </span>{
            e.content = e.content.replace(pattern, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
              <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;!--mce:protected '</span> + <span class="hljs-built_in">escape</span>(str) + <span class="hljs-string">'--&gt;'</span>;
            });
          });
        });
      }

      editor.on(<span class="hljs-string">'SetContent'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        editor.addVisual(editor.getBody());
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-1706">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1706">&#182;</a>
              </div>
              <p>Remove empty contents</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (settings.padd_empty_editor) {
        editor.on(<span class="hljs-string">'PostProcess'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          e.content = e.content.replace(<span class="hljs-regexp">/^(&lt;p[^&gt;]*&gt;(&amp;nbsp;|&amp;#160;|\s|\u00a0|&lt;br \/&gt;|)&lt;\/p&gt;[\r\n]*|&lt;br \/&gt;[\r\n]*)$/</span>, <span class="hljs-string">''</span>);
        });
      }

      editor.load({ <span class="hljs-attr">initial</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'html'</span> });
      editor.startContent = editor.getContent({ <span class="hljs-attr">format</span>: <span class="hljs-string">'raw'</span> });

      editor.on(<span class="hljs-string">'compositionstart compositionend'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        editor.composing = e.type === <span class="hljs-string">'compositionstart'</span>;
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-1707">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1707">&#182;</a>
              </div>
              <p>Add editor specific CSS styles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (editor.contentStyles.length &gt; <span class="hljs-number">0</span>) {
        contentCssText = <span class="hljs-string">''</span>;

        Tools.each(editor.contentStyles, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">style</span>) </span>{
          contentCssText += style + <span class="hljs-string">"\r\n"</span>;
        });

        editor.dom.addStyle(contentCssText);
      }

      editor.dom.styleSheetLoader.loadAll(
        editor.contentCSS,
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) </span>{
          initEditor(editor);
        },
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">urls</span>) </span>{
          initEditor(editor);
          ErrorReporter.contentCssError(editor, urls);
        }
      );
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">initContentBody</span>: initContentBody
    };
  }
);

<span class="hljs-comment">/**
 * PluginManager.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.PluginManager'</span>,
  [
    <span class="hljs-string">'tinymce.core.AddOnManager'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">AddOnManager</span>) </span>{
    <span class="hljs-keyword">return</span> AddOnManager.PluginManager;
  }
);

<span class="hljs-comment">/**
 * ThemeManager.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.ThemeManager'</span>,
  [
    <span class="hljs-string">'tinymce.core.AddOnManager'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">AddOnManager</span>) </span>{
    <span class="hljs-keyword">return</span> AddOnManager.ThemeManager;
  }
);

<span class="hljs-comment">/**
 * Init.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.init.Init'</span>,
  [
    <span class="hljs-string">'global!document'</span>,
    <span class="hljs-string">'global!window'</span>,
    <span class="hljs-string">'tinymce.core.dom.DOMUtils'</span>,
    <span class="hljs-string">'tinymce.core.Env'</span>,
    <span class="hljs-string">'tinymce.core.init.InitContentBody'</span>,
    <span class="hljs-string">'tinymce.core.PluginManager'</span>,
    <span class="hljs-string">'tinymce.core.ThemeManager'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>,
    <span class="hljs-string">'tinymce.core.util.Uuid'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">document, window, DOMUtils, Env, InitContentBody, PluginManager, ThemeManager, Tools, Uuid</span>) </span>{
    <span class="hljs-keyword">var</span> DOM = DOMUtils.DOM;

    <span class="hljs-keyword">var</span> initPlugin = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, initializedPlugins, plugin</span>) </span>{
      <span class="hljs-keyword">var</span> Plugin = PluginManager.get(plugin), pluginUrl, pluginInstance;

      pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(<span class="hljs-regexp">/\/$/</span>, <span class="hljs-string">''</span>);
      plugin = Tools.trim(plugin);
      <span class="hljs-keyword">if</span> (Plugin &amp;&amp; Tools.inArray(initializedPlugins, plugin) === <span class="hljs-number">-1</span>) {
        Tools.each(PluginManager.dependencies(plugin), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dep</span>) </span>{
          initPlugin(editor, initializedPlugins, dep);
        });

        <span class="hljs-keyword">if</span> (editor.plugins[plugin]) {
          <span class="hljs-keyword">return</span>;
        }

        pluginInstance = <span class="hljs-keyword">new</span> Plugin(editor, pluginUrl, editor.$);

        editor.plugins[plugin] = pluginInstance;

        <span class="hljs-keyword">if</span> (pluginInstance.init) {
          pluginInstance.init(editor, pluginUrl);
          initializedPlugins.push(plugin);
        }
      }
    };

    <span class="hljs-keyword">var</span> initPlugins = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> initializedPlugins = [];

      Tools.each(editor.settings.plugins.replace(<span class="hljs-regexp">/\-/g</span>, <span class="hljs-string">''</span>).split(<span class="hljs-regexp">/[ ,]/</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        initPlugin(editor, initializedPlugins, name);
      });
    };

    <span class="hljs-keyword">var</span> initTheme = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> Theme, settings = editor.settings;

      <span class="hljs-keyword">if</span> (settings.theme) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> settings.theme != <span class="hljs-string">"function"</span>) {
          settings.theme = settings.theme.replace(<span class="hljs-regexp">/-/</span>, <span class="hljs-string">''</span>);
          Theme = ThemeManager.get(settings.theme);
          editor.theme = <span class="hljs-keyword">new</span> Theme(editor, ThemeManager.urls[settings.theme]);

          <span class="hljs-keyword">if</span> (editor.theme.init) {
            editor.theme.init(editor, ThemeManager.urls[settings.theme] || editor.documentBaseUrl.replace(<span class="hljs-regexp">/\/$/</span>, <span class="hljs-string">''</span>), editor.$);
          }
        } <span class="hljs-keyword">else</span> {
          editor.theme = settings.theme;
        }
      }
    };

    <span class="hljs-keyword">var</span> measueBox = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> w, h, minHeight, re, o, settings = editor.settings, elm = editor.getElement();</pre></div></div>
            
        </li>
        
        
        <li id="section-1708">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1708">&#182;</a>
              </div>
              <p>Measure box</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (settings.render_ui &amp;&amp; editor.theme) {
        editor.orgDisplay = elm.style.display;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> settings.theme != <span class="hljs-string">"function"</span>) {
          w = settings.width || DOM.getStyle(elm, <span class="hljs-string">'width'</span>) || <span class="hljs-string">'100%'</span>;
          h = settings.height || DOM.getStyle(elm, <span class="hljs-string">'height'</span>) || elm.offsetHeight;
          minHeight = settings.min_height || <span class="hljs-number">100</span>;
          re = <span class="hljs-regexp">/^[0-9\.]+(|px)$/i</span>;

          <span class="hljs-keyword">if</span> (re.test(<span class="hljs-string">''</span> + w)) {
            w = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">parseInt</span>(w, <span class="hljs-number">10</span>), <span class="hljs-number">100</span>);
          }

          <span class="hljs-keyword">if</span> (re.test(<span class="hljs-string">''</span> + h)) {
            h = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">parseInt</span>(h, <span class="hljs-number">10</span>), minHeight);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1709">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1709">&#182;</a>
              </div>
              <p>Render UI</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          o = editor.theme.renderUI({
            <span class="hljs-attr">targetNode</span>: elm,
            <span class="hljs-attr">width</span>: w,
            <span class="hljs-attr">height</span>: h,
            <span class="hljs-attr">deltaWidth</span>: settings.delta_width,
            <span class="hljs-attr">deltaHeight</span>: settings.delta_height
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-1710">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1710">&#182;</a>
              </div>
              <p>Resize editor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!settings.content_editable) {
            h = (o.iframeHeight || h) + (<span class="hljs-keyword">typeof</span> h === <span class="hljs-string">'number'</span> ? (o.deltaHeight || <span class="hljs-number">0</span>) : <span class="hljs-string">''</span>);
            <span class="hljs-keyword">if</span> (h &lt; minHeight) {
              h = minHeight;
            }
          }
        } <span class="hljs-keyword">else</span> {
          o = settings.theme(editor, elm);

          <span class="hljs-keyword">if</span> (o.editorContainer.nodeType) {
            o.editorContainer.id = o.editorContainer.id || editor.id + <span class="hljs-string">"_parent"</span>;
          }

          <span class="hljs-keyword">if</span> (o.iframeContainer.nodeType) {
            o.iframeContainer.id = o.iframeContainer.id || editor.id + <span class="hljs-string">"_iframecontainer"</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1711">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1711">&#182;</a>
              </div>
              <p>Use specified iframe height or the targets offsetHeight</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          h = o.iframeHeight || elm.offsetHeight;
        }

        editor.editorContainer = o.editorContainer;
        o.height = h;
      }

      <span class="hljs-keyword">return</span> o;
    };

    <span class="hljs-keyword">var</span> createIframe = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, o</span>) </span>{
      <span class="hljs-keyword">var</span> settings = editor.settings, bodyId, bodyClass, url;

      editor.iframeHTML = settings.doctype + <span class="hljs-string">'&lt;html&gt;&lt;head&gt;'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1712">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1712">&#182;</a>
              </div>
              <p>We only need to override paths if we have to
IE has a bug where it remove site absolute urls to relative ones if this is specified</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (settings.document_base_url != editor.documentBaseUrl) {
        editor.iframeHTML += <span class="hljs-string">'&lt;base href="'</span> + editor.documentBaseURI.getURI() + <span class="hljs-string">'" /&gt;'</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1713">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1713">&#182;</a>
              </div>
              <p>IE8 doesnt support carets behind images setting ie7_compat would force IE8+ to run in IE7 compat mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!Env.caretAfter &amp;&amp; settings.ie7_compat) {
        editor.iframeHTML += <span class="hljs-string">'&lt;meta http-equiv="X-UA-Compatible" content="IE=7" /&gt;'</span>;
      }

      editor.iframeHTML += <span class="hljs-string">'&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;'</span>;

      bodyId = settings.body_id || <span class="hljs-string">'tinymce'</span>;
      <span class="hljs-keyword">if</span> (bodyId.indexOf(<span class="hljs-string">'='</span>) != <span class="hljs-number">-1</span>) {
        bodyId = editor.getParam(<span class="hljs-string">'body_id'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'hash'</span>);
        bodyId = bodyId[editor.id] || bodyId;
      }

      bodyClass = settings.body_class || <span class="hljs-string">''</span>;
      <span class="hljs-keyword">if</span> (bodyClass.indexOf(<span class="hljs-string">'='</span>) != <span class="hljs-number">-1</span>) {
        bodyClass = editor.getParam(<span class="hljs-string">'body_class'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'hash'</span>);
        bodyClass = bodyClass[editor.id] || <span class="hljs-string">''</span>;
      }

      <span class="hljs-keyword">if</span> (settings.content_security_policy) {
        editor.iframeHTML += <span class="hljs-string">'&lt;meta http-equiv="Content-Security-Policy" content="'</span> + settings.content_security_policy + <span class="hljs-string">'" /&gt;'</span>;
      }

      editor.iframeHTML += <span class="hljs-string">'&lt;/head&gt;&lt;body id="'</span> + bodyId +
        <span class="hljs-string">'" class="mce-content-body '</span> + bodyClass +
        <span class="hljs-string">'" data-id="'</span> + editor.id + <span class="hljs-string">'"&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt;'</span>;

      <span class="hljs-keyword">var</span> bodyUuid = Uuid.uuid(<span class="hljs-string">'mce'</span>);

      editor[bodyUuid] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        InitContentBody.initContentBody(editor);
      };

      <span class="hljs-comment">/*eslint no-script-url:0 */</span>
      <span class="hljs-keyword">var</span> domainRelaxUrl = <span class="hljs-string">'javascript:(function(){'</span> +
        <span class="hljs-string">'document.open();document.domain="'</span> + <span class="hljs-built_in">document</span>.domain + <span class="hljs-string">'";'</span> +
        <span class="hljs-string">'var ed = window.parent.tinymce.get("'</span> + editor.id + <span class="hljs-string">'");document.write(ed.iframeHTML);'</span> +
        <span class="hljs-string">'document.close();ed.'</span> + bodyUuid + <span class="hljs-string">'(true);})()'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1714">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1714">&#182;</a>
              </div>
              <p>Domain relaxing is required since the user has messed around with document.domain</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.domain != <span class="hljs-built_in">window</span>.location.hostname) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1715">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1715">&#182;</a>
              </div>
              <p>Edge seems to be able to handle domain relaxing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (Env.ie &amp;&amp; Env.ie &lt; <span class="hljs-number">12</span>) {
          url = domainRelaxUrl;
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1716">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1716">&#182;</a>
              </div>
              <p>Create iframe
TODO: ACC add the appropriate description on this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> ifr = DOM.create(<span class="hljs-string">'iframe'</span>, {
        <span class="hljs-attr">id</span>: editor.id + <span class="hljs-string">"_ifr"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1717">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1717">&#182;</a>
              </div>
              <p>src: url || javascript:, // Workaround for HTTPS warning in IE6/7</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        frameBorder: <span class="hljs-string">'0'</span>,
        <span class="hljs-attr">allowTransparency</span>: <span class="hljs-string">"true"</span>,
        <span class="hljs-attr">title</span>: editor.editorManager.translate(
          <span class="hljs-string">"Rich Text Area. Press ALT-F9 for menu. "</span> +
          <span class="hljs-string">"Press ALT-F10 for toolbar. Press ALT-0 for help"</span>
        ),
        <span class="hljs-attr">style</span>: {
          <span class="hljs-attr">width</span>: <span class="hljs-string">'100%'</span>,
          <span class="hljs-attr">height</span>: o.height,
          <span class="hljs-attr">display</span>: <span class="hljs-string">'block'</span> <span class="hljs-comment">// Important for Gecko to render the iframe correctly</span>
        }
      });

      ifr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        ifr.onload = <span class="hljs-literal">null</span>;
        editor.fire(<span class="hljs-string">"load"</span>);
      };

      DOM.setAttrib(ifr, <span class="hljs-string">"src"</span>, url || <span class="hljs-string">'javascript:""'</span>);

      editor.contentAreaContainer = o.iframeContainer;
      editor.iframeElement = ifr;

      DOM.add(o.iframeContainer, ifr);</pre></div></div>
            
        </li>
        
        
        <li id="section-1718">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1718">&#182;</a>
              </div>
              <p>Try accessing the document this will fail on IE when document.domain is set to the same as location.hostname
Then we have to force domain relaxing using the domainRelaxUrl approach very ugly!!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (Env.ie) {
        <span class="hljs-keyword">try</span> {
          editor.getDoc();
        } <span class="hljs-keyword">catch</span> (e) {
          ifr.src = url = domainRelaxUrl;
        }
      }

      <span class="hljs-keyword">return</span> url;
    };

    <span class="hljs-keyword">var</span> init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> settings = editor.settings, elm = editor.getElement();
      <span class="hljs-keyword">var</span> boxInfo, url;

      editor.rtl = settings.rtl_ui || editor.editorManager.i18n.rtl;
      editor.editorManager.i18n.setCode(settings.language);
      settings.aria_label = settings.aria_label || DOM.getAttrib(elm, <span class="hljs-string">'aria-label'</span>, editor.getLang(<span class="hljs-string">'aria.rich_text_area'</span>));

      editor.fire(<span class="hljs-string">'ScriptsLoaded'</span>);

      initTheme(editor);
      initPlugins(editor);
      boxInfo = measueBox(editor);</pre></div></div>
            
        </li>
        
        
        <li id="section-1719">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1719">&#182;</a>
              </div>
              <p>Load specified content CSS last</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (settings.content_css) {
        Tools.each(Tools.explode(settings.content_css), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">u</span>) </span>{
          editor.contentCSS.push(editor.documentBaseURI.toAbsolute(u));
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1720">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1720">&#182;</a>
              </div>
              <p>Load specified content CSS last</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (settings.content_style) {
        editor.contentStyles.push(settings.content_style);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1721">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1721">&#182;</a>
              </div>
              <p>Content editable mode ends here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (settings.content_editable) {
        <span class="hljs-keyword">return</span> InitContentBody.initContentBody(editor);
      }

      url = createIframe(editor, boxInfo);

      <span class="hljs-keyword">if</span> (boxInfo.editorContainer) {
        DOM.get(boxInfo.editorContainer).style.display = editor.orgDisplay;
        editor.hidden = DOM.isHidden(boxInfo.editorContainer);
      }

      editor.getElement().style.display = <span class="hljs-string">'none'</span>;
      DOM.setAttrib(editor.id, <span class="hljs-string">'aria-hidden'</span>, <span class="hljs-literal">true</span>);

      <span class="hljs-keyword">if</span> (!url) {
        InitContentBody.initContentBody(editor);
      }
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">init</span>: init
    };
  }
);

<span class="hljs-comment">/**
 * Render.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.init.Render'</span>,
  [
    <span class="hljs-string">'global!window'</span>,
    <span class="hljs-string">'tinymce.core.dom.DOMUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.EventUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.ScriptLoader'</span>,
    <span class="hljs-string">'tinymce.core.Env'</span>,
    <span class="hljs-string">'tinymce.core.ErrorReporter'</span>,
    <span class="hljs-string">'tinymce.core.init.Init'</span>,
    <span class="hljs-string">'tinymce.core.NotificationManager'</span>,
    <span class="hljs-string">'tinymce.core.PluginManager'</span>,
    <span class="hljs-string">'tinymce.core.ThemeManager'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>,
    <span class="hljs-string">'tinymce.core.WindowManager'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">window, DOMUtils, EventUtils, ScriptLoader, Env, ErrorReporter, Init, NotificationManager, PluginManager, ThemeManager, Tools, WindowManager</span>) </span>{
    <span class="hljs-keyword">var</span> DOM = DOMUtils.DOM;

    <span class="hljs-keyword">var</span> loadScripts = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, suffix</span>) </span>{
      <span class="hljs-keyword">var</span> settings = editor.settings, scriptLoader = ScriptLoader.ScriptLoader;

      <span class="hljs-keyword">if</span> (settings.language &amp;&amp; settings.language != <span class="hljs-string">'en'</span> &amp;&amp; !settings.language_url) {
        settings.language_url = editor.editorManager.baseURL + <span class="hljs-string">'/langs/'</span> + settings.language + <span class="hljs-string">'.js'</span>;
      }

      <span class="hljs-keyword">if</span> (settings.language_url) {
        scriptLoader.add(settings.language_url);
      }

      <span class="hljs-keyword">if</span> (settings.theme &amp;&amp; <span class="hljs-keyword">typeof</span> settings.theme != <span class="hljs-string">"function"</span> &amp;&amp;
        settings.theme.charAt(<span class="hljs-number">0</span>) != <span class="hljs-string">'-'</span> &amp;&amp; !ThemeManager.urls[settings.theme]) {
        <span class="hljs-keyword">var</span> themeUrl = settings.theme_url;

        <span class="hljs-keyword">if</span> (themeUrl) {
          themeUrl = editor.documentBaseURI.toAbsolute(themeUrl);
        } <span class="hljs-keyword">else</span> {
          themeUrl = <span class="hljs-string">'themes/'</span> + settings.theme + <span class="hljs-string">'/theme'</span> + suffix + <span class="hljs-string">'.js'</span>;
        }

        ThemeManager.load(settings.theme, themeUrl);
      }

      <span class="hljs-keyword">if</span> (Tools.isArray(settings.plugins)) {
        settings.plugins = settings.plugins.join(<span class="hljs-string">' '</span>);
      }

      Tools.each(settings.external_plugins, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url, name</span>) </span>{
        PluginManager.load(name, url);
        settings.plugins += <span class="hljs-string">' '</span> + name;
      });

      Tools.each(settings.plugins.split(<span class="hljs-regexp">/[ ,]/</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">plugin</span>) </span>{
        plugin = Tools.trim(plugin);

        <span class="hljs-keyword">if</span> (plugin &amp;&amp; !PluginManager.urls[plugin]) {
          <span class="hljs-keyword">if</span> (plugin.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'-'</span>) {
            plugin = plugin.substr(<span class="hljs-number">1</span>, plugin.length);

            <span class="hljs-keyword">var</span> dependencies = PluginManager.dependencies(plugin);

            Tools.each(dependencies, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dep</span>) </span>{
              <span class="hljs-keyword">var</span> defaultSettings = {
                <span class="hljs-attr">prefix</span>: <span class="hljs-string">'plugins/'</span>,
                <span class="hljs-attr">resource</span>: dep,
                <span class="hljs-attr">suffix</span>: <span class="hljs-string">'/plugin'</span> + suffix + <span class="hljs-string">'.js'</span>
              };

              dep = PluginManager.createUrl(defaultSettings, dep);
              PluginManager.load(dep.resource, dep);
            });
          } <span class="hljs-keyword">else</span> {
            PluginManager.load(plugin, {
              <span class="hljs-attr">prefix</span>: <span class="hljs-string">'plugins/'</span>,
              <span class="hljs-attr">resource</span>: plugin,
              <span class="hljs-attr">suffix</span>: <span class="hljs-string">'/plugin'</span> + suffix + <span class="hljs-string">'.js'</span>
            });
          }
        }
      });

      scriptLoader.loadQueue(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!editor.removed) {
          Init.init(editor);
        }
      }, editor, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">urls</span>) </span>{
        ErrorReporter.pluginLoadError(editor, urls[<span class="hljs-number">0</span>]);

        <span class="hljs-keyword">if</span> (!editor.removed) {
          Init.init(editor);
        }
      });
    };

    <span class="hljs-keyword">var</span> render = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> settings = editor.settings, id = editor.id;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readyHandler</span>(<span class="hljs-params"></span>) </span>{
        DOM.unbind(<span class="hljs-built_in">window</span>, <span class="hljs-string">'ready'</span>, readyHandler);
        editor.render();
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1722">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1722">&#182;</a>
              </div>
              <p>Page is not loaded yet, wait for it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!EventUtils.Event.domLoaded) {
        DOM.bind(<span class="hljs-built_in">window</span>, <span class="hljs-string">'ready'</span>, readyHandler);
        <span class="hljs-keyword">return</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1723">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1723">&#182;</a>
              </div>
              <p>Element not found, then skip initialization</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!editor.getElement()) {
        <span class="hljs-keyword">return</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1724">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1724">&#182;</a>
              </div>
              <p>No editable support old iOS versions etc</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!Env.contentEditable) {
        <span class="hljs-keyword">return</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1725">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1725">&#182;</a>
              </div>
              <p>Hide target element early to prevent content flashing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!settings.inline) {
        editor.orgVisibility = editor.getElement().style.visibility;
        editor.getElement().style.visibility = <span class="hljs-string">'hidden'</span>;
      } <span class="hljs-keyword">else</span> {
        editor.inline = <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">var</span> form = editor.getElement().form || DOM.getParent(id, <span class="hljs-string">'form'</span>);
      <span class="hljs-keyword">if</span> (form) {
        editor.formElement = form;</pre></div></div>
            
        </li>
        
        
        <li id="section-1726">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1726">&#182;</a>
              </div>
              <p>Add hidden input for non input elements inside form elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (settings.hidden_input &amp;&amp; !<span class="hljs-regexp">/TEXTAREA|INPUT/i</span>.test(editor.getElement().nodeName)) {
          DOM.insertAfter(DOM.create(<span class="hljs-string">'input'</span>, { <span class="hljs-attr">type</span>: <span class="hljs-string">'hidden'</span>, <span class="hljs-attr">name</span>: id }), id);
          editor.hasHiddenInput = <span class="hljs-literal">true</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1727">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1727">&#182;</a>
              </div>
              <p>Pass submit/reset from form to editor instance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        editor.formEventDelegate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          editor.fire(e.type, e);
        };

        DOM.bind(form, <span class="hljs-string">'submit reset'</span>, editor.formEventDelegate);</pre></div></div>
            
        </li>
        
        
        <li id="section-1728">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1728">&#182;</a>
              </div>
              <p>Reset contents in editor when the form is reset</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        editor.on(<span class="hljs-string">'reset'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          editor.setContent(editor.startContent, { <span class="hljs-attr">format</span>: <span class="hljs-string">'raw'</span> });
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-1729">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1729">&#182;</a>
              </div>
              <p>Check page uses id=submit or name=submit for its submit button</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (settings.submit_patch &amp;&amp; !form.submit.nodeType &amp;&amp; !form.submit.length &amp;&amp; !form._mceOldSubmit) {
          form._mceOldSubmit = form.submit;
          form.submit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            editor.editorManager.triggerSave();
            editor.setDirty(<span class="hljs-literal">false</span>);

            <span class="hljs-keyword">return</span> form._mceOldSubmit(form);
          };
        }
      }

      editor.windowManager = <span class="hljs-keyword">new</span> WindowManager(editor);
      editor.notificationManager = <span class="hljs-keyword">new</span> NotificationManager(editor);

      <span class="hljs-keyword">if</span> (settings.encoding === <span class="hljs-string">'xml'</span>) {
        editor.on(<span class="hljs-string">'GetContent'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (e.save) {
            e.content = DOM.encode(e.content);
          }
        });
      }

      <span class="hljs-keyword">if</span> (settings.add_form_submit_trigger) {
        editor.on(<span class="hljs-string">'submit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (editor.initialized) {
            editor.save();
          }
        });
      }

      <span class="hljs-keyword">if</span> (settings.add_unload_trigger) {
        editor._beforeUnload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (editor.initialized &amp;&amp; !editor.destroyed &amp;&amp; !editor.isHidden()) {
            editor.save({ <span class="hljs-attr">format</span>: <span class="hljs-string">'raw'</span>, <span class="hljs-attr">no_events</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">set_dirty</span>: <span class="hljs-literal">false</span> });
          }
        };

        editor.editorManager.on(<span class="hljs-string">'BeforeUnload'</span>, editor._beforeUnload);
      }

      editor.editorManager.add(editor);
      loadScripts(editor, editor.suffix);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">render</span>: render
    };
  }
);

<span class="hljs-comment">/**
 * Mode.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Mode switcher logic.
 *
 * @private
 * @class tinymce.Mode
 */</span>
define(
  <span class="hljs-string">'tinymce.core.Mode'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setEditorCommandState</span>(<span class="hljs-params">editor, cmd, state</span>) </span>{
      <span class="hljs-keyword">try</span> {
        editor.getDoc().execCommand(cmd, <span class="hljs-literal">false</span>, state);
      } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1730">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1730">&#182;</a>
              </div>
              <p>Ignore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickBlocker</span>(<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> target, handler;

      target = editor.getBody();

      handler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (editor.dom.getParents(e.target, <span class="hljs-string">'a'</span>).length &gt; <span class="hljs-number">0</span>) {
          e.preventDefault();
        }
      };

      editor.dom.bind(target, <span class="hljs-string">'click'</span>, handler);

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">unbind</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          editor.dom.unbind(target, <span class="hljs-string">'click'</span>, handler);
        }
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleReadOnly</span>(<span class="hljs-params">editor, state</span>) </span>{
      <span class="hljs-keyword">if</span> (editor._clickBlocker) {
        editor._clickBlocker.unbind();
        editor._clickBlocker = <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (state) {
        editor._clickBlocker = clickBlocker(editor);
        editor.selection.controlSelection.hideResizeRect();
        editor.readonly = <span class="hljs-literal">true</span>;
        editor.getBody().contentEditable = <span class="hljs-literal">false</span>;
      } <span class="hljs-keyword">else</span> {
        editor.readonly = <span class="hljs-literal">false</span>;
        editor.getBody().contentEditable = <span class="hljs-literal">true</span>;
        setEditorCommandState(editor, <span class="hljs-string">"StyleWithCSS"</span>, <span class="hljs-literal">false</span>);
        setEditorCommandState(editor, <span class="hljs-string">"enableInlineTableEditing"</span>, <span class="hljs-literal">false</span>);
        setEditorCommandState(editor, <span class="hljs-string">"enableObjectResizing"</span>, <span class="hljs-literal">false</span>);
        editor.focus();
        editor.nodeChanged();
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setMode</span>(<span class="hljs-params">editor, mode</span>) </span>{
      <span class="hljs-keyword">var</span> currentMode = editor.readonly ? <span class="hljs-string">'readonly'</span> : <span class="hljs-string">'design'</span>;

      <span class="hljs-keyword">if</span> (mode == currentMode) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (editor.initialized) {
        toggleReadOnly(editor, mode == <span class="hljs-string">'readonly'</span>);
      } <span class="hljs-keyword">else</span> {
        editor.on(<span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          toggleReadOnly(editor, mode == <span class="hljs-string">'readonly'</span>);
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1731">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1731">&#182;</a>
              </div>
              <p>Event is NOT preventable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      editor.fire(<span class="hljs-string">'SwitchMode'</span>, { <span class="hljs-attr">mode</span>: mode });
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">setMode</span>: setMode
    };
  }
);
<span class="hljs-comment">/**
 * Sidebar.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module handle sidebar instances for the editor.
 *
 * @class tinymce.ui.Sidebar
 * @private
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Sidebar'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">
  </span>) </span>{
    <span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, name, settings</span>) </span>{
      <span class="hljs-keyword">var</span> sidebars = editor.sidebars ? editor.sidebars : [];
      sidebars.push({ <span class="hljs-attr">name</span>: name, <span class="hljs-attr">settings</span>: settings });
      editor.sidebars = sidebars;
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">add</span>: add
    };
  }
);

<span class="hljs-comment">/**
 * Editor.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/*jshint scripturl:true */</span>

<span class="hljs-comment">/**
 * Include the base event class documentation.
 *
 * @include ../../../../../tools/docs/tinymce.Event.js
 */</span>

<span class="hljs-comment">/**
 * This class contains the core logic for a TinyMCE editor.
 *
 * @class tinymce.Editor
 * @mixes tinymce.util.Observable
 * @example
 * // Add a class to all paragraphs in the editor.
 * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'someclass');
 *
 * // Gets the current editors selection as text
 * tinymce.activeEditor.selection.getContent({format: 'text'});
 *
 * // Creates a new editor instance
 * var ed = new tinymce.Editor('textareaid', {
 *     some_setting: 1
 * }, tinymce.EditorManager);
 *
 * ed.render();
 */</span>
define(
  <span class="hljs-string">'tinymce.core.Editor'</span>,
  [
    <span class="hljs-string">'tinymce.core.AddOnManager'</span>,
    <span class="hljs-string">'tinymce.core.dom.DomQuery'</span>,
    <span class="hljs-string">'tinymce.core.dom.DOMUtils'</span>,
    <span class="hljs-string">'tinymce.core.EditorCommands'</span>,
    <span class="hljs-string">'tinymce.core.EditorObservable'</span>,
    <span class="hljs-string">'tinymce.core.Env'</span>,
    <span class="hljs-string">'tinymce.core.html.Serializer'</span>,
    <span class="hljs-string">'tinymce.core.init.Render'</span>,
    <span class="hljs-string">'tinymce.core.Mode'</span>,
    <span class="hljs-string">'tinymce.core.Shortcuts'</span>,
    <span class="hljs-string">'tinymce.core.ui.Sidebar'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>,
    <span class="hljs-string">'tinymce.core.util.URI'</span>,
    <span class="hljs-string">'tinymce.core.util.Uuid'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">
    AddOnManager, DomQuery, DOMUtils, EditorCommands, EditorObservable, Env, Serializer, Render, Mode,
    Shortcuts, Sidebar, Tools, URI, Uuid
  </span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1732">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1732">&#182;</a>
              </div>
              <p>Shorten these names</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> DOM = DOMUtils.DOM;
    <span class="hljs-keyword">var</span> extend = Tools.extend, each = Tools.each;
    <span class="hljs-keyword">var</span> trim = Tools.trim, resolve = Tools.resolve;
    <span class="hljs-keyword">var</span> isGecko = Env.gecko, ie = Env.ie;

    <span class="hljs-comment">/**
     * Include Editor API docs.
     *
     * @include ../../../../../tools/docs/tinymce.Editor.js
     */</span>

    <span class="hljs-comment">/**
     * Constructs a editor instance by id.
     *
     * @constructor
     * @method Editor
     * @param {String} id Unique id for the editor.
     * @param {Object} settings Settings for the editor.
     * @param {tinymce.EditorManager} editorManager EditorManager instance.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Editor</span>(<span class="hljs-params">id, settings, editorManager</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, documentBaseUrl, baseUri, defaultSettings;

      documentBaseUrl = self.documentBaseUrl = editorManager.documentBaseURL;
      baseUri = editorManager.baseURI;
      defaultSettings = editorManager.defaultSettings;

      <span class="hljs-comment">/**
       * Name/value collection with editor settings.
       *
       * @property settings
       * @type Object
       * @example
       * // Get the value of the theme setting
       * tinymce.activeEditor.windowManager.alert("You are using the " + tinymce.activeEditor.settings.theme + " theme");
       */</span>
      settings = extend({
        <span class="hljs-attr">id</span>: id,
        <span class="hljs-attr">theme</span>: <span class="hljs-string">'modern'</span>,
        <span class="hljs-attr">delta_width</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">delta_height</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">popup_css</span>: <span class="hljs-string">''</span>,
        <span class="hljs-attr">plugins</span>: <span class="hljs-string">''</span>,
        <span class="hljs-attr">document_base_url</span>: documentBaseUrl,
        <span class="hljs-attr">add_form_submit_trigger</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">submit_patch</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">add_unload_trigger</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">convert_urls</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">relative_urls</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">remove_script_host</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">object_resizing</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">doctype</span>: <span class="hljs-string">'&lt;!DOCTYPE html&gt;'</span>,
        <span class="hljs-attr">visual</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">font_size_style_values</span>: <span class="hljs-string">'xx-small,x-small,small,medium,large,x-large,xx-large'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1733">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1733">&#182;</a>
              </div>
              <p>See: <a href="http://www.w3.org/TR/CSS2/fonts.html#propdef-font-size">http://www.w3.org/TR/CSS2/fonts.html#propdef-font-size</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        font_size_legacy_values: <span class="hljs-string">'xx-small,small,medium,large,x-large,xx-large,300%'</span>,
        <span class="hljs-attr">forced_root_block</span>: <span class="hljs-string">'p'</span>,
        <span class="hljs-attr">hidden_input</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">padd_empty_editor</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">render_ui</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">indentation</span>: <span class="hljs-string">'30px'</span>,
        <span class="hljs-attr">inline_styles</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">convert_fonts_to_spans</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">indent</span>: <span class="hljs-string">'simple'</span>,
        <span class="hljs-attr">indent_before</span>: <span class="hljs-string">'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,'</span> +
        <span class="hljs-string">'tfoot,tbody,tr,section,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'</span>,
        <span class="hljs-attr">indent_after</span>: <span class="hljs-string">'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,'</span> +
        <span class="hljs-string">'tfoot,tbody,tr,section,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'</span>,
        <span class="hljs-attr">validate</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">entity_encoding</span>: <span class="hljs-string">'named'</span>,
        <span class="hljs-attr">url_converter</span>: self.convertURL,
        <span class="hljs-attr">url_converter_scope</span>: self,
        <span class="hljs-attr">ie7_compat</span>: <span class="hljs-literal">true</span>
      }, defaultSettings, settings);</pre></div></div>
            
        </li>
        
        
        <li id="section-1734">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1734">&#182;</a>
              </div>
              <p>Merge external_plugins</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (defaultSettings &amp;&amp; defaultSettings.external_plugins &amp;&amp; settings.external_plugins) {
        settings.external_plugins = extend({}, defaultSettings.external_plugins, settings.external_plugins);
      }

      self.settings = settings;
      AddOnManager.language = settings.language || <span class="hljs-string">'en'</span>;
      AddOnManager.languageLoad = settings.language_load;
      AddOnManager.baseURL = editorManager.baseURL;

      <span class="hljs-comment">/**
       * Editor instance id, normally the same as the div/textarea that was replaced.
       *
       * @property id
       * @type String
       */</span>
      self.id = settings.id = id;

      <span class="hljs-comment">/**
       * State to force the editor to return false on a isDirty call.
       *
       * @property isNotDirty
       * @type Boolean
       * @deprecated Use editor.setDirty instead.
       */</span>
      self.setDirty(<span class="hljs-literal">false</span>);

      <span class="hljs-comment">/**
       * Name/Value object containing plugin instances.
       *
       * @property plugins
       * @type Object
       * @example
       * // Execute a method inside a plugin directly
       * tinymce.activeEditor.plugins.someplugin.someMethod();
       */</span>
      self.plugins = {};

      <span class="hljs-comment">/**
       * URI object to document configured for the TinyMCE instance.
       *
       * @property documentBaseURI
       * @type tinymce.util.URI
       * @example
       * // Get relative URL from the location of document_base_url
       * tinymce.activeEditor.documentBaseURI.toRelative('/somedir/somefile.htm');
       *
       * // Get absolute URL from the location of document_base_url
       * tinymce.activeEditor.documentBaseURI.toAbsolute('somefile.htm');
       */</span>
      self.documentBaseURI = <span class="hljs-keyword">new</span> URI(settings.document_base_url || documentBaseUrl, {
        <span class="hljs-attr">base_uri</span>: baseUri
      });

      <span class="hljs-comment">/**
       * URI object to current document that holds the TinyMCE editor instance.
       *
       * @property baseURI
       * @type tinymce.util.URI
       * @example
       * // Get relative URL from the location of the API
       * tinymce.activeEditor.baseURI.toRelative('/somedir/somefile.htm');
       *
       * // Get absolute URL from the location of the API
       * tinymce.activeEditor.baseURI.toAbsolute('somefile.htm');
       */</span>
      self.baseURI = baseUri;

      <span class="hljs-comment">/**
       * Array with CSS files to load into the iframe.
       *
       * @property contentCSS
       * @type Array
       */</span>
      self.contentCSS = [];

      <span class="hljs-comment">/**
       * Array of CSS styles to add to head of document when the editor loads.
       *
       * @property contentStyles
       * @type Array
       */</span>
      self.contentStyles = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-1735">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1735">&#182;</a>
              </div>
              <p>Creates all events like onClick, onSetContent etc see Editor.Events.js for the actual logic</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      self.shortcuts = <span class="hljs-keyword">new</span> Shortcuts(self);
      self.loadedCSS = {};
      self.editorCommands = <span class="hljs-keyword">new</span> EditorCommands(self);
      self.suffix = editorManager.suffix;
      self.editorManager = editorManager;
      self.inline = settings.inline;
      self.settings.content_editable = self.inline;

      <span class="hljs-keyword">if</span> (settings.cache_suffix) {
        Env.cacheSuffix = settings.cache_suffix.replace(<span class="hljs-regexp">/^[\?\&amp;]+/</span>, <span class="hljs-string">''</span>);
      }

      <span class="hljs-keyword">if</span> (settings.override_viewport === <span class="hljs-literal">false</span>) {
        Env.overrideViewPort = <span class="hljs-literal">false</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1736">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1736">&#182;</a>
              </div>
              <p>Call setup</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      editorManager.fire(<span class="hljs-string">'SetupEditor'</span>, self);
      self.execCallback(<span class="hljs-string">'setup'</span>, self);

      <span class="hljs-comment">/**
       * Dom query instance with default scope to the editor document and default element is the body of the editor.
       *
       * @property $
       * @type tinymce.dom.DomQuery
       * @example
       * tinymce.activeEditor.$('p').css('color', 'red');
       * tinymce.activeEditor.$().append('&lt;p&gt;new&lt;/p&gt;');
       */</span>
      self.$ = DomQuery.overrideDefaults(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">context</span>: self.inline ? self.getBody() : self.getDoc(),
          <span class="hljs-attr">element</span>: self.getBody()
        };
      });
    }

    Editor.prototype = {
      <span class="hljs-comment">/**
       * Renders the editor/adds it to the page.
       *
       * @method render
       */</span>
      render: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        Render.render(<span class="hljs-keyword">this</span>);
      },

      <span class="hljs-comment">/**
       * Focuses/activates the editor. This will set this editor as the activeEditor in the tinymce collection
       * it will also place DOM focus inside the editor.
       *
       * @method focus
       * @param {Boolean} skipFocus Skip DOM focus. Just set is as the active editor.
       */</span>
      focus: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">skipFocus</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, selection = self.selection, contentEditable = self.settings.content_editable, rng;
        <span class="hljs-keyword">var</span> controlElm, doc = self.getDoc(), body = self.getBody(), contentEditableHost;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContentEditableHost</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">return</span> self.dom.getParent(node, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">return</span> self.dom.getContentEditable(node) === <span class="hljs-string">"true"</span>;
          });
        }

        <span class="hljs-keyword">if</span> (!skipFocus) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1737">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1737">&#182;</a>
              </div>
              <p>Get selected control element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          rng = selection.getRng();
          <span class="hljs-keyword">if</span> (rng.item) {
            controlElm = rng.item(<span class="hljs-number">0</span>);
          }

          self.quirks.refreshContentEditable();</pre></div></div>
            
        </li>
        
        
        <li id="section-1738">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1738">&#182;</a>
              </div>
              <p>Move focus to contentEditable=true child if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          contentEditableHost = getContentEditableHost(selection.getNode());
          <span class="hljs-keyword">if</span> (self.$.contains(body, contentEditableHost)) {
            contentEditableHost.focus();
            selection.normalize();
            self.editorManager.setActive(self);
            <span class="hljs-keyword">return</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1739">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1739">&#182;</a>
              </div>
              <p>Focus the window iframe</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!contentEditable) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1740">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1740">&#182;</a>
              </div>
              <p>WebKit needs this call to fire focusin event properly see #5948
But Opera pre Blink engine will produce an empty selection so skip Opera</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!Env.opera) {
              self.getBody().focus();
            }

            self.getWin().focus();
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1741">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1741">&#182;</a>
              </div>
              <p>Focus the body as well since its contentEditable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (isGecko || contentEditable) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1742">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1742">&#182;</a>
              </div>
              <p>Check for setActive since it doesnt scroll to the element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (body.setActive) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1743">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1743">&#182;</a>
              </div>
              <p>IE 11 sometimes throws Invalid function then fallback to focus</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">try</span> {
                body.setActive();
              } <span class="hljs-keyword">catch</span> (ex) {
                body.focus();
              }
            } <span class="hljs-keyword">else</span> {
              body.focus();
            }

            <span class="hljs-keyword">if</span> (contentEditable) {
              selection.normalize();
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1744">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1744">&#182;</a>
              </div>
              <p>Restore selected control element
This is needed when for example an image is selected within a
layer a call to focus will then remove the control selection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (controlElm &amp;&amp; controlElm.ownerDocument == doc) {
            rng = doc.body.createControlRange();
            rng.addElement(controlElm);
            rng.select();
          }
        }

        self.editorManager.setActive(self);
      },

      <span class="hljs-comment">/**
       * Executes a legacy callback. This method is useful to call old 2.x option callbacks.
       * There new event model is a better way to add callback so this method might be removed in the future.
       *
       * @method execCallback
       * @param {String} name Name of the callback to execute.
       * @return {Object} Return value passed from callback function.
       */</span>
      execCallback: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, callback = self.settings[name], scope;

        <span class="hljs-keyword">if</span> (!callback) {
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1745">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1745">&#182;</a>
              </div>
              <p>Look through lookup</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self.callbackLookup &amp;&amp; (scope = self.callbackLookup[name])) {
          callback = scope.func;
          scope = scope.scope;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'string'</span>) {
          scope = callback.replace(<span class="hljs-regexp">/\.\w+$/</span>, <span class="hljs-string">''</span>);
          scope = scope ? resolve(scope) : <span class="hljs-number">0</span>;
          callback = resolve(callback);
          self.callbackLookup = self.callbackLookup || {};
          self.callbackLookup[name] = { <span class="hljs-attr">func</span>: callback, <span class="hljs-attr">scope</span>: scope };
        }

        <span class="hljs-keyword">return</span> callback.apply(scope || self, <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
      },

      <span class="hljs-comment">/**
       * Translates the specified string by replacing variables with language pack items it will also check if there is
       * a key matching the input.
       *
       * @method translate
       * @param {String} text String to translate by the language pack data.
       * @return {String} Translated string.
       */</span>
      translate: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
        <span class="hljs-keyword">var</span> lang = <span class="hljs-keyword">this</span>.settings.language || <span class="hljs-string">'en'</span>, i18n = <span class="hljs-keyword">this</span>.editorManager.i18n;

        <span class="hljs-keyword">if</span> (!text) {
          <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
        }

        text = i18n.data[lang + <span class="hljs-string">'.'</span> + text] || text.replace(<span class="hljs-regexp">/\{\#([^\}]+)\}/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
          <span class="hljs-keyword">return</span> i18n.data[lang + <span class="hljs-string">'.'</span> + b] || <span class="hljs-string">'{#'</span> + b + <span class="hljs-string">'}'</span>;
        });

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.editorManager.translate(text);
      },

      <span class="hljs-comment">/**
       * Returns a language pack item by name/key.
       *
       * @method getLang
       * @param {String} name Name/key to get from the language pack.
       * @param {String} defaultVal Optional default value to retrieve.
       */</span>
      getLang: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, defaultVal</span>) </span>{
        <span class="hljs-keyword">return</span> (
          <span class="hljs-keyword">this</span>.editorManager.i18n.data[(<span class="hljs-keyword">this</span>.settings.language || <span class="hljs-string">'en'</span>) + <span class="hljs-string">'.'</span> + name] ||
          (defaultVal !== <span class="hljs-literal">undefined</span> ? defaultVal : <span class="hljs-string">'{#'</span> + name + <span class="hljs-string">'}'</span>)
        );
      },

      <span class="hljs-comment">/**
       * Returns a configuration parameter by name.
       *
       * @method getParam
       * @param {String} name Configruation parameter to retrieve.
       * @param {String} defaultVal Optional default value to return.
       * @param {String} type Optional type parameter.
       * @return {String} Configuration parameter value or default value.
       * @example
       * // Returns a specific config value from the currently active editor
       * var someval = tinymce.activeEditor.getParam('myvalue');
       *
       * // Returns a specific config value from a specific editor instance by id
       * var someval2 = tinymce.get('my_editor').getParam('myvalue');
       */</span>
      getParam: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, defaultVal, type</span>) </span>{
        <span class="hljs-keyword">var</span> value = name <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.settings ? <span class="hljs-keyword">this</span>.settings[name] : defaultVal, output;

        <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'hash'</span>) {
          output = {};

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>) {
            each(value.indexOf(<span class="hljs-string">'='</span>) &gt; <span class="hljs-number">0</span> ? value.split(<span class="hljs-regexp">/[;,](?![^=;,]*(?:[;,]|$))/</span>) : value.split(<span class="hljs-string">','</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
              value = value.split(<span class="hljs-string">'='</span>);

              <span class="hljs-keyword">if</span> (value.length &gt; <span class="hljs-number">1</span>) {
                output[trim(value[<span class="hljs-number">0</span>])] = trim(value[<span class="hljs-number">1</span>]);
              } <span class="hljs-keyword">else</span> {
                output[trim(value[<span class="hljs-number">0</span>])] = trim(value);
              }
            });
          } <span class="hljs-keyword">else</span> {
            output = value;
          }

          <span class="hljs-keyword">return</span> output;
        }

        <span class="hljs-keyword">return</span> value;
      },

      <span class="hljs-comment">/**
       * Dispatches out a onNodeChange event to all observers. This method should be called when you
       * need to update the UI states or element path etc.
       *
       * @method nodeChanged
       * @param {Object} args Optional args to pass to NodeChange event handlers.
       */</span>
      nodeChanged: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>{
        <span class="hljs-keyword">this</span>._nodeChangeDispatcher.nodeChanged(args);
      },

      <span class="hljs-comment">/**
       * Adds a button that later gets created by the theme in the editors toolbars.
       *
       * @method addButton
       * @param {String} name Button name to add.
       * @param {Object} settings Settings object with title, cmd etc.
       * @example
       * // Adds a custom button to the editor that inserts contents when clicked
       * tinymce.init({
       *    ...
       *
       *    toolbar: 'example'
       *
       *    setup: function(ed) {
       *       ed.addButton('example', {
       *          title: 'My title',
       *          image: '../js/tinymce/plugins/example/img/example.gif',
       *          onclick: function() {
       *             ed.insertContent('Hello world!!');
       *          }
       *       });
       *    }
       * });
       */</span>
      addButton: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (settings.cmd) {
          settings.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            self.execCommand(settings.cmd);
          };
        }

        <span class="hljs-keyword">if</span> (!settings.text &amp;&amp; !settings.icon) {
          settings.icon = name;
        }

        self.buttons = self.buttons || {};
        settings.tooltip = settings.tooltip || settings.title;
        self.buttons[name] = settings;
      },

      <span class="hljs-comment">/**
       * Adds a sidebar for the editor instance.
       *
       * @method addSidebar
       * @param {String} name Sidebar name to add.
       * @param {Object} settings Settings object with icon, onshow etc.
       * @example
       * // Adds a custom sidebar that when clicked logs the panel element
       * tinymce.init({
       *    ...
       *    setup: function(ed) {
       *       ed.addSidebar('example', {
       *          tooltip: 'My sidebar',
       *          icon: 'my-side-bar',
       *          onshow: function(api) {
       *             console.log(api.element());
       *          }
       *       });
       *    }
       * });
       */</span>
      addSidebar: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, settings</span>) </span>{
        <span class="hljs-keyword">return</span> Sidebar.add(<span class="hljs-keyword">this</span>, name, settings);
      },

      <span class="hljs-comment">/**
       * Adds a menu item to be used in the menus of the theme. There might be multiple instances
       * of this menu item for example it might be used in the main menus of the theme but also in
       * the context menu so make sure that it's self contained and supports multiple instances.
       *
       * @method addMenuItem
       * @param {String} name Menu item name to add.
       * @param {Object} settings Settings object with title, cmd etc.
       * @example
       * // Adds a custom menu item to the editor that inserts contents when clicked
       * // The context option allows you to add the menu item to an existing default menu
       * tinymce.init({
       *    ...
       *
       *    setup: function(ed) {
       *       ed.addMenuItem('example', {
       *          text: 'My menu item',
       *          context: 'tools',
       *          onclick: function() {
       *             ed.insertContent('Hello world!!');
       *          }
       *       });
       *    }
       * });
       */</span>
      addMenuItem: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (settings.cmd) {
          settings.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            self.execCommand(settings.cmd);
          };
        }

        self.menuItems = self.menuItems || {};
        self.menuItems[name] = settings;
      },

      <span class="hljs-comment">/**
       * Adds a contextual toolbar to be rendered when the selector matches.
       *
       * @method addContextToolbar
       * @param {function/string} predicate Predicate that needs to return true if provided strings get converted into CSS predicates.
       * @param {String/Array} items String or array with items to add to the context toolbar.
       */</span>
      addContextToolbar: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">predicate, items</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, selector;

        self.contextToolbars = self.contextToolbars || [];</pre></div></div>
            
        </li>
        
        
        <li id="section-1746">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1746">&#182;</a>
              </div>
              <p>Convert selector to predicate</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> predicate == <span class="hljs-string">"string"</span>) {
          selector = predicate;
          predicate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
            <span class="hljs-keyword">return</span> self.dom.is(elm, selector);
          };
        }

        self.contextToolbars.push({
          <span class="hljs-attr">id</span>: Uuid.uuid(<span class="hljs-string">'mcet'</span>),
          <span class="hljs-attr">predicate</span>: predicate,
          <span class="hljs-attr">items</span>: items
        });
      },

      <span class="hljs-comment">/**
       * Adds a custom command to the editor, you can also override existing commands with this method.
       * The command that you add can be executed with execCommand.
       *
       * @method addCommand
       * @param {String} name Command name to add/override.
       * @param {addCommandCallback} callback Function to execute when the command occurs.
       * @param {Object} scope Optional scope to execute the function in.
       * @example
       * // Adds a custom command that later can be executed using execCommand
       * tinymce.init({
       *    ...
       *
       *    setup: function(ed) {
       *       // Register example command
       *       ed.addCommand('mycommand', function(ui, v) {
       *          ed.windowManager.alert('Hello world!! Selection: ' + ed.selection.getContent({format: 'text'}));
       *       });
       *    }
       * });
       */</span>
      addCommand: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, callback, scope</span>) </span>{
        <span class="hljs-comment">/**
         * Callback function that gets called when a command is executed.
         *
         * @callback addCommandCallback
         * @param {Boolean} ui Display UI state true/false.
         * @param {Object} value Optional value for command.
         * @return {Boolean} True/false state if the command was handled or not.
         */</span>
        <span class="hljs-keyword">this</span>.editorCommands.addCommand(name, callback, scope);
      },

      <span class="hljs-comment">/**
       * Adds a custom query state command to the editor, you can also override existing commands with this method.
       * The command that you add can be executed with queryCommandState function.
       *
       * @method addQueryStateHandler
       * @param {String} name Command name to add/override.
       * @param {addQueryStateHandlerCallback} callback Function to execute when the command state retrieval occurs.
       * @param {Object} scope Optional scope to execute the function in.
       */</span>
      addQueryStateHandler: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, callback, scope</span>) </span>{
        <span class="hljs-comment">/**
         * Callback function that gets called when a queryCommandState is executed.
         *
         * @callback addQueryStateHandlerCallback
         * @return {Boolean} True/false state if the command is enabled or not like is it bold.
         */</span>
        <span class="hljs-keyword">this</span>.editorCommands.addQueryStateHandler(name, callback, scope);
      },

      <span class="hljs-comment">/**
       * Adds a custom query value command to the editor, you can also override existing commands with this method.
       * The command that you add can be executed with queryCommandValue function.
       *
       * @method addQueryValueHandler
       * @param {String} name Command name to add/override.
       * @param {addQueryValueHandlerCallback} callback Function to execute when the command value retrieval occurs.
       * @param {Object} scope Optional scope to execute the function in.
       */</span>
      addQueryValueHandler: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, callback, scope</span>) </span>{
        <span class="hljs-comment">/**
         * Callback function that gets called when a queryCommandValue is executed.
         *
         * @callback addQueryValueHandlerCallback
         * @return {Object} Value of the command or undefined.
         */</span>
        <span class="hljs-keyword">this</span>.editorCommands.addQueryValueHandler(name, callback, scope);
      },

      <span class="hljs-comment">/**
       * Adds a keyboard shortcut for some command or function.
       *
       * @method addShortcut
       * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
       * @param {String} desc Text description for the command.
       * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.
       * @param {Object} sc Optional scope to execute the function in.
       * @return {Boolean} true/false state if the shortcut was added or not.
       */</span>
      addShortcut: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern, desc, cmdFunc, scope</span>) </span>{
        <span class="hljs-keyword">this</span>.shortcuts.add(pattern, desc, cmdFunc, scope);
      },

      <span class="hljs-comment">/**
       * Executes a command on the current instance. These commands can be TinyMCE internal commands prefixed with "mce" or
       * they can be build in browser commands such as "Bold". A compleate list of browser commands is available on MSDN or Mozilla.org.
       * This function will dispatch the execCommand function on each plugin, theme or the execcommand_callback option if none of these
       * return true it will handle the command as a internal browser command.
       *
       * @method execCommand
       * @param {String} cmd Command name to execute, for example mceLink or Bold.
       * @param {Boolean} ui True/false state if a UI (dialog) should be presented or not.
       * @param {mixed} value Optional command value, this can be anything.
       * @param {Object} args Optional arguments object.
       */</span>
      execCommand: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cmd, ui, value, args</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.editorCommands.execCommand(cmd, ui, value, args);
      },

      <span class="hljs-comment">/**
       * Returns a command specific state, for example if bold is enabled or not.
       *
       * @method queryCommandState
       * @param {string} cmd Command to query state from.
       * @return {Boolean} Command specific state, for example if bold is enabled or not.
       */</span>
      queryCommandState: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cmd</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.editorCommands.queryCommandState(cmd);
      },

      <span class="hljs-comment">/**
       * Returns a command specific value, for example the current font size.
       *
       * @method queryCommandValue
       * @param {string} cmd Command to query value from.
       * @return {Object} Command specific value, for example the current font size.
       */</span>
      queryCommandValue: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cmd</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.editorCommands.queryCommandValue(cmd);
      },

      <span class="hljs-comment">/**
       * Returns true/false if the command is supported or not.
       *
       * @method queryCommandSupported
       * @param {String} cmd Command that we check support for.
       * @return {Boolean} true/false if the command is supported or not.
       */</span>
      queryCommandSupported: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cmd</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.editorCommands.queryCommandSupported(cmd);
      },

      <span class="hljs-comment">/**
       * Shows the editor and hides any textarea/div that the editor is supposed to replace.
       *
       * @method show
       */</span>
      show: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (self.hidden) {
          self.hidden = <span class="hljs-literal">false</span>;

          <span class="hljs-keyword">if</span> (self.inline) {
            self.getBody().contentEditable = <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            DOM.show(self.getContainer());
            DOM.hide(self.id);
          }

          self.load();
          self.fire(<span class="hljs-string">'show'</span>);
        }
      },

      <span class="hljs-comment">/**
       * Hides the editor and shows any textarea/div that the editor is supposed to replace.
       *
       * @method hide
       */</span>
      hide: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, doc = self.getDoc();

        <span class="hljs-keyword">if</span> (!self.hidden) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1747">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1747">&#182;</a>
              </div>
              <p>Fixed bug where IE has a blinking cursor left from the editor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (ie &amp;&amp; doc &amp;&amp; !self.inline) {
            doc.execCommand(<span class="hljs-string">'SelectAll'</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1748">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1748">&#182;</a>
              </div>
              <p>We must save before we hide so Safari doesnt crash</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          self.save();

          <span class="hljs-keyword">if</span> (self.inline) {
            self.getBody().contentEditable = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1749">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1749">&#182;</a>
              </div>
              <p>Make sure the editor gets blurred</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (self == self.editorManager.focusedEditor) {
              self.editorManager.focusedEditor = <span class="hljs-literal">null</span>;
            }
          } <span class="hljs-keyword">else</span> {
            DOM.hide(self.getContainer());
            DOM.setStyle(self.id, <span class="hljs-string">'display'</span>, self.orgDisplay);
          }

          self.hidden = <span class="hljs-literal">true</span>;
          self.fire(<span class="hljs-string">'hide'</span>);
        }
      },

      <span class="hljs-comment">/**
       * Returns true/false if the editor is hidden or not.
       *
       * @method isHidden
       * @return {Boolean} True/false if the editor is hidden or not.
       */</span>
      isHidden: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> !!<span class="hljs-keyword">this</span>.hidden;
      },

      <span class="hljs-comment">/**
       * Sets the progress state, this will display a throbber/progess for the editor.
       * This is ideal for asynchronous operations like an AJAX save call.
       *
       * @method setProgressState
       * @param {Boolean} state Boolean state if the progress should be shown or hidden.
       * @param {Number} time Optional time to wait before the progress gets shown.
       * @return {Boolean} Same as the input state.
       * @example
       * // Show progress for the active editor
       * tinymce.activeEditor.setProgressState(true);
       *
       * // Hide progress for the active editor
       * tinymce.activeEditor.setProgressState(false);
       *
       * // Show progress after 3 seconds
       * tinymce.activeEditor.setProgressState(true, 3000);
       */</span>
      setProgressState: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state, time</span>) </span>{
        <span class="hljs-keyword">this</span>.fire(<span class="hljs-string">'ProgressState'</span>, { <span class="hljs-attr">state</span>: state, <span class="hljs-attr">time</span>: time });
      },

      <span class="hljs-comment">/**
       * Loads contents from the textarea or div element that got converted into an editor instance.
       * This method will move the contents from that textarea or div into the editor by using setContent
       * so all events etc that method has will get dispatched as well.
       *
       * @method load
       * @param {Object} args Optional content object, this gets passed around through the whole load process.
       * @return {String} HTML string that got set into the editor.
       */</span>
      load: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, elm = self.getElement(), html;

        <span class="hljs-keyword">if</span> (elm) {
          args = args || {};
          args.load = <span class="hljs-literal">true</span>;

          html = self.setContent(elm.value !== <span class="hljs-literal">undefined</span> ? elm.value : elm.innerHTML, args);
          args.element = elm;

          <span class="hljs-keyword">if</span> (!args.no_events) {
            self.fire(<span class="hljs-string">'LoadContent'</span>, args);
          }

          args.element = elm = <span class="hljs-literal">null</span>;

          <span class="hljs-keyword">return</span> html;
        }
      },

      <span class="hljs-comment">/**
       * Saves the contents from a editor out to the textarea or div element that got converted into an editor instance.
       * This method will move the HTML contents from the editor into that textarea or div by getContent
       * so all events etc that method has will get dispatched as well.
       *
       * @method save
       * @param {Object} args Optional content object, this gets passed around through the whole save process.
       * @return {String} HTML string that got set into the textarea/div.
       */</span>
      save: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, elm = self.getElement(), html, form;

        <span class="hljs-keyword">if</span> (!elm || !self.initialized) {
          <span class="hljs-keyword">return</span>;
        }

        args = args || {};
        args.save = <span class="hljs-literal">true</span>;

        args.element = elm;
        html = args.content = self.getContent(args);

        <span class="hljs-keyword">if</span> (!args.no_events) {
          self.fire(<span class="hljs-string">'SaveContent'</span>, args);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1750">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1750">&#182;</a>
              </div>
              <p>Always run this internal event</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (args.format == <span class="hljs-string">'raw'</span>) {
          self.fire(<span class="hljs-string">'RawSaveContent'</span>, args);
        }

        html = args.content;

        <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/TEXTAREA|INPUT/i</span>.test(elm.nodeName)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1751">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1751">&#182;</a>
              </div>
              <p>Update DIV element when not in inline mode</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!self.inline) {
            elm.innerHTML = html;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1752">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1752">&#182;</a>
              </div>
              <p>Update hidden form element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> ((form = DOM.getParent(self.id, <span class="hljs-string">'form'</span>))) {
            each(form.elements, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
              <span class="hljs-keyword">if</span> (elm.name == self.id) {
                elm.value = html;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
            });
          }
        } <span class="hljs-keyword">else</span> {
          elm.value = html;
        }

        args.element = elm = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (args.set_dirty !== <span class="hljs-literal">false</span>) {
          self.setDirty(<span class="hljs-literal">false</span>);
        }

        <span class="hljs-keyword">return</span> html;
      },

      <span class="hljs-comment">/**
       * Sets the specified content to the editor instance, this will cleanup the content before it gets set using
       * the different cleanup rules options.
       *
       * @method setContent
       * @param {String} content Content to set to editor, normally HTML contents but can be other formats as well.
       * @param {Object} args Optional content object, this gets passed around through the whole set process.
       * @return {String} HTML string that got set into the editor.
       * @example
       * // Sets the HTML contents of the activeEditor editor
       * tinymce.activeEditor.setContent('&lt;span&gt;some&lt;/span&gt; html');
       *
       * // Sets the raw contents of the activeEditor editor
       * tinymce.activeEditor.setContent('&lt;span&gt;some&lt;/span&gt; html', {format: 'raw'});
       *
       * // Sets the content of a specific editor (my_editor in this example)
       * tinymce.get('my_editor').setContent(data);
       *
       * // Sets the bbcode contents of the activeEditor editor if the bbcode plugin was added
       * tinymce.activeEditor.setContent('[b]some[/b] html', {format: 'bbcode'});
       */</span>
      setContent: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">content, args</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, body = self.getBody(), forcedRootBlockName, padd;</pre></div></div>
            
        </li>
        
        
        <li id="section-1753">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1753">&#182;</a>
              </div>
              <p>Setup args object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        args = args || {};
        args.format = args.format || <span class="hljs-string">'html'</span>;
        args.set = <span class="hljs-literal">true</span>;
        args.content = content;</pre></div></div>
            
        </li>
        
        
        <li id="section-1754">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1754">&#182;</a>
              </div>
              <p>Do preprocessing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!args.no_events) {
          self.fire(<span class="hljs-string">'BeforeSetContent'</span>, args);
        }

        content = args.content;</pre></div></div>
            
        </li>
        
        
        <li id="section-1755">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1755">&#182;</a>
              </div>
              <p>Padd empty content in Gecko and Safari. Commands will otherwise fail on the content
It will also be impossible to place the caret in the editor unless there is a BR element present</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (content.length === <span class="hljs-number">0</span> || <span class="hljs-regexp">/^\s+$/</span>.test(content)) {
          padd = ie &amp;&amp; ie &lt; <span class="hljs-number">11</span> ? <span class="hljs-string">''</span> : <span class="hljs-string">'&lt;br data-mce-bogus="1"&gt;'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1756">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1756">&#182;</a>
              </div>
              <p>Todo: There is a lot more root elements that need special padding
so separate this and add all of them at some point.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (body.nodeName == <span class="hljs-string">'TABLE'</span>) {
            content = <span class="hljs-string">'&lt;tr&gt;&lt;td&gt;'</span> + padd + <span class="hljs-string">'&lt;/td&gt;&lt;/tr&gt;'</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(UL|OL)$/</span>.test(body.nodeName)) {
            content = <span class="hljs-string">'&lt;li&gt;'</span> + padd + <span class="hljs-string">'&lt;/li&gt;'</span>;
          }

          forcedRootBlockName = self.settings.forced_root_block;</pre></div></div>
            
        </li>
        
        
        <li id="section-1757">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1757">&#182;</a>
              </div>
              <p>Check if forcedRootBlock is configured and that the block is a valid child of the body</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (forcedRootBlockName &amp;&amp; self.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1758">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1758">&#182;</a>
              </div>
              <p>Padd with bogus BR elements on modern browsers and IE 7 and 8 since they dont render empty P tags properly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            content = padd;
            content = self.dom.createHTML(forcedRootBlockName, self.settings.forced_root_block_attrs, content);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!ie &amp;&amp; !content) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1759">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1759">&#182;</a>
              </div>
              <p>We need to add a BR when forced_root_block is disabled on non IE browsers to place the caret</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            content = <span class="hljs-string">'&lt;br data-mce-bogus="1"&gt;'</span>;
          }

          self.dom.setHTML(body, content);

          self.fire(<span class="hljs-string">'SetContent'</span>, args);
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1760">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1760">&#182;</a>
              </div>
              <p>Parse and serialize the html</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (args.format !== <span class="hljs-string">'raw'</span>) {
            content = <span class="hljs-keyword">new</span> Serializer({
              <span class="hljs-attr">validate</span>: self.validate
            }, self.schema).serialize(
              self.parser.parse(content, { <span class="hljs-attr">isRootContent</span>: <span class="hljs-literal">true</span> })
              );
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1761">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1761">&#182;</a>
              </div>
              <p>Set the new cleaned contents to the editor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          args.content = trim(content);
          self.dom.setHTML(body, args.content);</pre></div></div>
            
        </li>
        
        
        <li id="section-1762">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1762">&#182;</a>
              </div>
              <p>Do post processing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!args.no_events) {
            self.fire(<span class="hljs-string">'SetContent'</span>, args);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1763">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1763">&#182;</a>
              </div>
              <p>Dont normalize selection if the focused element isnt the body in
content editable mode since it will steal focus otherwise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-comment">/*if (!self.settings.content_editable || document.activeElement === self.getBody()) {
            self.selection.normalize();
          }*/</span>
        }

        <span class="hljs-keyword">return</span> args.content;
      },

      <span class="hljs-comment">/**
       * Gets the content from the editor instance, this will cleanup the content before it gets returned using
       * the different cleanup rules options.
       *
       * @method getContent
       * @param {Object} args Optional content object, this gets passed around through the whole get process.
       * @return {String} Cleaned content string, normally HTML contents.
       * @example
       * // Get the HTML contents of the currently active editor
       * console.debug(tinymce.activeEditor.getContent());
       *
       * // Get the raw contents of the currently active editor
       * tinymce.activeEditor.getContent({format: 'raw'});
       *
       * // Get content of a specific editor:
       * tinymce.get('content id').getContent()
       */</span>
      getContent: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, content, body = self.getBody();</pre></div></div>
            
        </li>
        
        
        <li id="section-1764">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1764">&#182;</a>
              </div>
              <p>Setup args object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        args = args || {};
        args.format = args.format || <span class="hljs-string">'html'</span>;
        args.get = <span class="hljs-literal">true</span>;
        args.getInner = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1765">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1765">&#182;</a>
              </div>
              <p>Do preprocessing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!args.no_events) {
          self.fire(<span class="hljs-string">'BeforeGetContent'</span>, args);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1766">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1766">&#182;</a>
              </div>
              <p>Get raw contents or by default the cleaned contents</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (args.format == <span class="hljs-string">'raw'</span>) {
          content = Tools.trim(self.serializer.getTrimmedContent());
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args.format == <span class="hljs-string">'text'</span>) {
          content = body.innerText || body.textContent;
        } <span class="hljs-keyword">else</span> {
          content = self.serializer.serialize(body, args);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1767">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1767">&#182;</a>
              </div>
              <p>Trim whitespace in beginning/end of HTML</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (args.format != <span class="hljs-string">'text'</span>) {
          args.content = trim(content);
        } <span class="hljs-keyword">else</span> {
          args.content = content;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1768">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1768">&#182;</a>
              </div>
              <p>Do post processing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!args.no_events) {
          self.fire(<span class="hljs-string">'GetContent'</span>, args);
        }

        <span class="hljs-keyword">return</span> args.content;
      },

      <span class="hljs-comment">/**
       * Inserts content at caret position.
       *
       * @method insertContent
       * @param {String} content Content to insert.
       * @param {Object} args Optional args to pass to insert call.
       */</span>
      insertContent: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">content, args</span>) </span>{
        <span class="hljs-keyword">if</span> (args) {
          content = extend({ <span class="hljs-attr">content</span>: content }, args);
        }

        <span class="hljs-keyword">this</span>.execCommand(<span class="hljs-string">'mceInsertContent'</span>, <span class="hljs-literal">false</span>, content);
      },

      <span class="hljs-comment">/**
       * Returns true/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
       *
       * The dirty state is automatically set to true if you do modifications to the content in other
       * words when new undo levels is created or if you undo/redo to update the contents of the editor. It will also be set
       * to false if you call editor.save().
       *
       * @method isDirty
       * @return {Boolean} True/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
       * @example
       * if (tinymce.activeEditor.isDirty())
       *     alert("You must save your contents.");
       */</span>
      isDirty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.isNotDirty;
      },

      <span class="hljs-comment">/**
       * Explicitly sets the dirty state. This will fire the dirty event if the editor dirty state is changed from false to true
       * by invoking this method.
       *
       * @method setDirty
       * @param {Boolean} state True/false if the editor is considered dirty.
       * @example
       * function ajaxSave() {
       *     var editor = tinymce.get('elm1');
       *
       *     // Save contents using some XHR call
       *     alert(editor.getContent());
       *
       *     editor.setDirty(false); // Force not dirty state
       * }
       */</span>
      setDirty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
        <span class="hljs-keyword">var</span> oldState = !<span class="hljs-keyword">this</span>.isNotDirty;

        <span class="hljs-keyword">this</span>.isNotDirty = !state;

        <span class="hljs-keyword">if</span> (state &amp;&amp; state != oldState) {
          <span class="hljs-keyword">this</span>.fire(<span class="hljs-string">'dirty'</span>);
        }
      },

      <span class="hljs-comment">/**
       * Sets the editor mode. Mode can be for example "design", "code" or "readonly".
       *
       * @method setMode
       * @param {String} mode Mode to set the editor in.
       */</span>
      setMode: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mode</span>) </span>{
        Mode.setMode(<span class="hljs-keyword">this</span>, mode);
      },

      <span class="hljs-comment">/**
       * Returns the editors container element. The container element wrappes in
       * all the elements added to the page for the editor. Such as UI, iframe etc.
       *
       * @method getContainer
       * @return {Element} HTML DOM element for the editor container.
       */</span>
      getContainer: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (!self.container) {
          self.container = DOM.get(self.editorContainer || self.id + <span class="hljs-string">'_parent'</span>);
        }

        <span class="hljs-keyword">return</span> self.container;
      },

      <span class="hljs-comment">/**
       * Returns the editors content area container element. The this element is the one who
       * holds the iframe or the editable element.
       *
       * @method getContentAreaContainer
       * @return {Element} HTML DOM element for the editor area container.
       */</span>
      getContentAreaContainer: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.contentAreaContainer;
      },

      <span class="hljs-comment">/**
       * Returns the target element/textarea that got replaced with a TinyMCE editor instance.
       *
       * @method getElement
       * @return {Element} HTML DOM element for the replaced element.
       */</span>
      getElement: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.targetElm) {
          <span class="hljs-keyword">this</span>.targetElm = DOM.get(<span class="hljs-keyword">this</span>.id);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.targetElm;
      },

      <span class="hljs-comment">/**
       * Returns the iframes window object.
       *
       * @method getWin
       * @return {Window} Iframe DOM window object.
       */</span>
      getWin: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, elm;

        <span class="hljs-keyword">if</span> (!self.contentWindow) {
          elm = self.iframeElement;

          <span class="hljs-keyword">if</span> (elm) {
            self.contentWindow = elm.contentWindow;
          }
        }

        <span class="hljs-keyword">return</span> self.contentWindow;
      },

      <span class="hljs-comment">/**
       * Returns the iframes document object.
       *
       * @method getDoc
       * @return {Document} Iframe DOM document object.
       */</span>
      getDoc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, win;

        <span class="hljs-keyword">if</span> (!self.contentDocument) {
          win = self.getWin();

          <span class="hljs-keyword">if</span> (win) {
            self.contentDocument = win.document;
          }
        }

        <span class="hljs-keyword">return</span> self.contentDocument;
      },

      <span class="hljs-comment">/**
       * Returns the root element of the editable area.
       * For a non-inline iframe-based editor, returns the iframe's body element.
       *
       * @method getBody
       * @return {Element} The root element of the editable area.
       */</span>
      getBody: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> doc = <span class="hljs-keyword">this</span>.getDoc();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bodyElement || (doc ? doc.body : <span class="hljs-literal">null</span>);
      },

      <span class="hljs-comment">/**
       * URL converter function this gets executed each time a user adds an img, a or
       * any other element that has a URL in it. This will be called both by the DOM and HTML
       * manipulation functions.
       *
       * @method convertURL
       * @param {string} url URL to convert.
       * @param {string} name Attribute name src, href etc.
       * @param {string/HTMLElement} elm Tag name or HTML DOM element depending on HTML or DOM insert.
       * @return {string} Converted URL string.
       */</span>
      convertURL: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url, name, elm</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, settings = self.settings;</pre></div></div>
            
        </li>
        
        
        <li id="section-1769">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1769">&#182;</a>
              </div>
              <p>Use callback instead</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (settings.urlconverter_callback) {
          <span class="hljs-keyword">return</span> self.execCallback(<span class="hljs-string">'urlconverter_callback'</span>, url, elm, <span class="hljs-literal">true</span>, name);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1770">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1770">&#182;</a>
              </div>
              <p>Dont convert link href since thats the CSS files that gets loaded into the editor also skip local file URLs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!settings.convert_urls || (elm &amp;&amp; elm.nodeName == <span class="hljs-string">'LINK'</span>) || url.indexOf(<span class="hljs-string">'file:'</span>) === <span class="hljs-number">0</span> || url.length === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> url;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1771">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1771">&#182;</a>
              </div>
              <p>Convert to relative</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (settings.relative_urls) {
          <span class="hljs-keyword">return</span> self.documentBaseURI.toRelative(url);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1772">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1772">&#182;</a>
              </div>
              <p>Convert to absolute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        url = self.documentBaseURI.toAbsolute(url, settings.remove_script_host);

        <span class="hljs-keyword">return</span> url;
      },

      <span class="hljs-comment">/**
       * Adds visual aid for tables, anchors etc so they can be more easily edited inside the editor.
       *
       * @method addVisual
       * @param {Element} elm Optional root element to loop though to find tables etc that needs the visual aid.
       */</span>
      addVisual: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, settings = self.settings, dom = self.dom, cls;

        elm = elm || self.getBody();

        <span class="hljs-keyword">if</span> (self.hasVisual === <span class="hljs-literal">undefined</span>) {
          self.hasVisual = settings.visual;
        }

        each(dom.select(<span class="hljs-string">'table,a'</span>, elm), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
          <span class="hljs-keyword">var</span> value;

          <span class="hljs-keyword">switch</span> (elm.nodeName) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">'TABLE'</span>:
              cls = settings.visual_table_class || <span class="hljs-string">'mce-item-table'</span>;
              value = dom.getAttrib(elm, <span class="hljs-string">'border'</span>);

              <span class="hljs-keyword">if</span> ((!value || value == <span class="hljs-string">'0'</span>) &amp;&amp; self.hasVisual) {
                dom.addClass(elm, cls);
              } <span class="hljs-keyword">else</span> {
                dom.removeClass(elm, cls);
              }

              <span class="hljs-keyword">return</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">'A'</span>:
              <span class="hljs-keyword">if</span> (!dom.getAttrib(elm, <span class="hljs-string">'href'</span>, <span class="hljs-literal">false</span>)) {
                value = dom.getAttrib(elm, <span class="hljs-string">'name'</span>) || elm.id;
                cls = settings.visual_anchor_class || <span class="hljs-string">'mce-item-anchor'</span>;

                <span class="hljs-keyword">if</span> (value &amp;&amp; self.hasVisual) {
                  dom.addClass(elm, cls);
                } <span class="hljs-keyword">else</span> {
                  dom.removeClass(elm, cls);
                }
              }

              <span class="hljs-keyword">return</span>;
          }
        });

        self.fire(<span class="hljs-string">'VisualAid'</span>, { <span class="hljs-attr">element</span>: elm, <span class="hljs-attr">hasVisual</span>: self.hasVisual });
      },

      <span class="hljs-comment">/**
       * Removes the editor from the dom and tinymce collection.
       *
       * @method remove
       */</span>
      remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (!self.removed) {
          self.save();
          self.removed = <span class="hljs-number">1</span>;
          self.unbindAllNativeEvents();</pre></div></div>
            
        </li>
        
        
        <li id="section-1773">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1773">&#182;</a>
              </div>
              <p>Remove any hidden input</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (self.hasHiddenInput) {
            DOM.remove(self.getElement().nextSibling);
          }

          <span class="hljs-keyword">if</span> (!self.inline) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1774">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1774">&#182;</a>
              </div>
              <p>IE 9 has a bug where the selection stops working if you place the
caret inside the editor then remove the iframe</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (ie &amp;&amp; ie &lt; <span class="hljs-number">10</span>) {
              self.getDoc().execCommand(<span class="hljs-string">'SelectAll'</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);
            }

            DOM.setStyle(self.id, <span class="hljs-string">'display'</span>, self.orgDisplay);
            self.getBody().onload = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Prevent #6816</span>
          }

          self.fire(<span class="hljs-string">'remove'</span>);

          self.editorManager.remove(self);
          DOM.remove(self.getContainer());
          self._selectionOverrides.destroy();
          self.editorUpload.destroy();
          self.destroy();
        }
      },

      <span class="hljs-comment">/**
       * Destroys the editor instance by removing all events, element references or other resources
       * that could leak memory. This method will be called automatically when the page is unloaded
       * but you can also call it directly if you know what you are doing.
       *
       * @method destroy
       * @param {Boolean} automatic Optional state if the destroy is an automatic destroy or user called one.
       */</span>
      destroy: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">automatic</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, form;</pre></div></div>
            
        </li>
        
        
        <li id="section-1775">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1775">&#182;</a>
              </div>
              <p>One time is enough</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self.destroyed) {
          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1776">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1776">&#182;</a>
              </div>
              <p>If user manually calls destroy and not remove
Users seems to have logic that calls destroy instead of remove</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!automatic &amp;&amp; !self.removed) {
          self.remove();
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (!automatic) {
          self.editorManager.off(<span class="hljs-string">'beforeunload'</span>, self._beforeUnload);</pre></div></div>
            
        </li>
        
        
        <li id="section-1777">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1777">&#182;</a>
              </div>
              <p>Manual destroy</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (self.theme &amp;&amp; self.theme.destroy) {
            self.theme.destroy();
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1778">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1778">&#182;</a>
              </div>
              <p>Destroy controls, selection and dom</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          self.selection.destroy();
          self.dom.destroy();
        }

        form = self.formElement;
        <span class="hljs-keyword">if</span> (form) {
          <span class="hljs-keyword">if</span> (form._mceOldSubmit) {
            form.submit = form._mceOldSubmit;
            form._mceOldSubmit = <span class="hljs-literal">null</span>;
          }

          DOM.unbind(form, <span class="hljs-string">'submit reset'</span>, self.formEventDelegate);
        }

        self.contentAreaContainer = self.formElement = self.container = self.editorContainer = <span class="hljs-literal">null</span>;
        self.bodyElement = self.contentDocument = self.contentWindow = <span class="hljs-literal">null</span>;
        self.iframeElement = self.targetElm = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (self.selection) {
          self.selection = self.selection.win = self.selection.dom = self.selection.dom.doc = <span class="hljs-literal">null</span>;
        }

        self.destroyed = <span class="hljs-number">1</span>;
      },

      <span class="hljs-comment">/**
       * Uploads all data uri/blob uri images in the editor contents to server.
       *
       * @method uploadImages
       * @param {function} callback Optional callback with images and status for each image.
       * @return {tinymce.util.Promise} Promise instance.
       */</span>
      uploadImages: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.editorUpload.uploadImages(callback);
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-1779">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1779">&#182;</a>
              </div>
              <p>Internal functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      _scanForImages: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.editorUpload.scanForImages();
      }
    };

    extend(Editor.prototype, EditorObservable);

    <span class="hljs-keyword">return</span> Editor;
  }
);

<span class="hljs-comment">/**
 * I18n.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * I18n class that handles translation of TinyMCE UI.
 * Uses po style with csharp style parameters.
 *
 * @class tinymce.util.I18n
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.I18n'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Tools</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> data = {}, code = <span class="hljs-string">"en"</span>;

    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">/**
       * Sets the current language code.
       *
       * @method setCode
       * @param {String} newCode Current language code.
       */</span>
      setCode: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newCode</span>) </span>{
        <span class="hljs-keyword">if</span> (newCode) {
          code = newCode;
          <span class="hljs-keyword">this</span>.rtl = <span class="hljs-keyword">this</span>.data[newCode] ? <span class="hljs-keyword">this</span>.data[newCode]._dir === <span class="hljs-string">'rtl'</span> : <span class="hljs-literal">false</span>;
        }
      },

      <span class="hljs-comment">/**
       * Returns the current language code.
       *
       * @method getCode
       * @return {String} Current language code.
       */</span>
      getCode: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> code;
      },

      <span class="hljs-comment">/**
       * Property gets set to true if a RTL language pack was loaded.
       *
       * @property rtl
       * @type Boolean
       */</span>
      rtl: <span class="hljs-literal">false</span>,

      <span class="hljs-comment">/**
       * Adds translations for a specific language code.
       *
       * @method add
       * @param {String} code Language code like sv_SE.
       * @param {Array} items Name/value array with English en_US to sv_SE.
       */</span>
      add: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">code, items</span>) </span>{
        <span class="hljs-keyword">var</span> langData = data[code];

        <span class="hljs-keyword">if</span> (!langData) {
          data[code] = langData = {};
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> items) {
          langData[name] = items[name];
        }

        <span class="hljs-keyword">this</span>.setCode(code);
      },

      <span class="hljs-comment">/**
       * Translates the specified text.
       *
       * It has a few formats:
       * I18n.translate("Text");
       * I18n.translate(["Text {0}/{1}", 0, 1]);
       * I18n.translate({raw: "Raw string"});
       *
       * @method translate
       * @param {String/Object/Array} text Text to translate.
       * @return {String} String that got translated.
       */</span>
      translate: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
        <span class="hljs-keyword">var</span> langData = data[code] || {};

        <span class="hljs-comment">/**
         * number - string
         * null, undefined and empty string - empty string
         * array - comma-delimited string
         * object - in [object Object]
         * function - in [object Function]
         *
         * @param obj
         * @returns {string}
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toString</span>(<span class="hljs-params">obj</span>) </span>{
          <span class="hljs-keyword">if</span> (Tools.is(obj, <span class="hljs-string">'function'</span>)) {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj);
          }
          <span class="hljs-keyword">return</span> !isEmpty(obj) ? <span class="hljs-string">''</span> + obj : <span class="hljs-string">''</span>;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEmpty</span>(<span class="hljs-params">text</span>) </span>{
          <span class="hljs-keyword">return</span> text === <span class="hljs-string">''</span> || text === <span class="hljs-literal">null</span> || Tools.is(text, <span class="hljs-string">'undefined'</span>);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLangData</span>(<span class="hljs-params">text</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1780">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1780">&#182;</a>
              </div>
              <p>make sure we work on a string and return a string</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          text = toString(text);
          <span class="hljs-keyword">return</span> Tools.hasOwn(langData, text) ? toString(langData[text]) : text;
        }


        <span class="hljs-keyword">if</span> (isEmpty(text)) {
          <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
        }

        <span class="hljs-keyword">if</span> (Tools.is(text, <span class="hljs-string">'object'</span>) &amp;&amp; Tools.hasOwn(text, <span class="hljs-string">'raw'</span>)) {
          <span class="hljs-keyword">return</span> toString(text.raw);
        }

        <span class="hljs-keyword">if</span> (Tools.is(text, <span class="hljs-string">'array'</span>)) {
          <span class="hljs-keyword">var</span> values = text.slice(<span class="hljs-number">1</span>);
          text = getLangData(text[<span class="hljs-number">0</span>]).replace(<span class="hljs-regexp">/\{([0-9]+)\}/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$<span class="hljs-number">1</span>, $<span class="hljs-number">2</span></span>) </span>{
            <span class="hljs-keyword">return</span> Tools.hasOwn(values, $<span class="hljs-number">2</span>) ? toString(values[$<span class="hljs-number">2</span>]) : $<span class="hljs-number">1</span>;
          });
        }

        <span class="hljs-keyword">return</span> getLangData(text).replace(<span class="hljs-regexp">/{context:\w+}$/</span>, <span class="hljs-string">''</span>);
      },

      <span class="hljs-attr">data</span>: data
    };
  }
);
<span class="hljs-comment">/**
 * FocusManager.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class manages the focus/blur state of the editor. This class is needed since some
 * browsers fire false focus/blur states when the selection is moved to a UI dialog or similar.
 *
 * This class will fire two events focus and blur on the editor instances that got affected.
 * It will also handle the restore of selection when the focus is lost and returned.
 *
 * @class tinymce.FocusManager
 */</span>
define(
  <span class="hljs-string">'tinymce.core.FocusManager'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.DOMUtils"</span>,
    <span class="hljs-string">"tinymce.core.util.Delay"</span>,
    <span class="hljs-string">"tinymce.core.Env"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">DOMUtils, Delay, Env</span>) </span>{
    <span class="hljs-keyword">var</span> selectionChangeHandler, documentFocusInHandler, documentMouseUpHandler, DOM = DOMUtils.DOM;

    <span class="hljs-keyword">var</span> isUIElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, elm</span>) </span>{
      <span class="hljs-keyword">var</span> customSelector = editor ? editor.settings.custom_ui_selector : <span class="hljs-string">''</span>;
      <span class="hljs-keyword">var</span> parent = DOM.getParent(elm, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
        <span class="hljs-keyword">return</span> (
          FocusManager.isEditorUIElement(elm) ||
          (customSelector ? editor.dom.is(elm, customSelector) : <span class="hljs-literal">false</span>)
        );
      });
      <span class="hljs-keyword">return</span> parent !== <span class="hljs-literal">null</span>;
    };

    <span class="hljs-keyword">var</span> isInlineEditor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">return</span> editor.inline === <span class="hljs-literal">true</span>;
    };

    <span class="hljs-keyword">var</span> isElementOursideInlineEditor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor, target</span>) </span>{
      <span class="hljs-keyword">return</span> isInlineEditor(editor) === <span class="hljs-literal">false</span> || editor.dom.isChildOf(target, editor.getBody()) === <span class="hljs-literal">false</span>;
    };

    <span class="hljs-comment">/**
     * Constructs a new focus manager instance.
     *
     * @constructor FocusManager
     * @param {tinymce.EditorManager} editorManager Editor manager instance to handle focus for.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FocusManager</span>(<span class="hljs-params">editorManager</span>) </span>{
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getActiveElement</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.activeElement;
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1781">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1781">&#182;</a>
              </div>
              <p>IE sometimes fails to get the activeElement when resizing table
TODO: Investigate this</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.body;
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1782">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1782">&#182;</a>
              </div>
              <p>We cant store a real range on IE 11 since it gets mutated so we need to use a bookmark object
TODO: Move this to a separate range utils class since its its logic is present in Selection as well.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createBookmark</span>(<span class="hljs-params">dom, rng</span>) </span>{
        <span class="hljs-keyword">if</span> (rng &amp;&amp; rng.startContainer) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1783">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1783">&#182;</a>
              </div>
              <p>Verify that the range is within the root of the editor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!dom.isChildOf(rng.startContainer, dom.getRoot()) || !dom.isChildOf(rng.endContainer, dom.getRoot())) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">startContainer</span>: rng.startContainer,
            <span class="hljs-attr">startOffset</span>: rng.startOffset,
            <span class="hljs-attr">endContainer</span>: rng.endContainer,
            <span class="hljs-attr">endOffset</span>: rng.endOffset
          };
        }

        <span class="hljs-keyword">return</span> rng;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bookmarkToRng</span>(<span class="hljs-params">editor, bookmark</span>) </span>{
        <span class="hljs-keyword">var</span> rng;

        <span class="hljs-keyword">if</span> (bookmark.startContainer) {
          rng = editor.getDoc().createRange();
          rng.setStart(bookmark.startContainer, bookmark.startOffset);
          rng.setEnd(bookmark.endContainer, bookmark.endOffset);
        } <span class="hljs-keyword">else</span> {
          rng = bookmark;
        }

        <span class="hljs-keyword">return</span> rng;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerEvents</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> editor = e.editor;

        editor.on(<span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1784">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1784">&#182;</a>
              </div>
              <p>Gecko/WebKit has ghost selections in iframes and IE only has one selection per browser tab</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (editor.inline || Env.ie) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1785">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1785">&#182;</a>
              </div>
              <p>Use the onbeforedeactivate event when available since it works better see #7023</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-string">"onbeforedeactivate"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">document</span> &amp;&amp; Env.ie &lt; <span class="hljs-number">9</span>) {
              editor.dom.bind(editor.getBody(), <span class="hljs-string">'beforedeactivate'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">if</span> (e.target != editor.getBody()) {
                  <span class="hljs-keyword">return</span>;
                }

                <span class="hljs-keyword">try</span> {
                  editor.lastRng = editor.selection.getRng();
                } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1786">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1786">&#182;</a>
              </div>
              <p>IE throws Unexcpected call to method or property access some times so lets ignore it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                }
              });
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1787">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1787">&#182;</a>
              </div>
              <p>On other browsers take snapshot on nodechange in inline mode since they have Ghost selections for iframes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              editor.on(<span class="hljs-string">'nodechange mouseup keyup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> node = getActiveElement();</pre></div></div>
            
        </li>
        
        
        <li id="section-1788">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1788">&#182;</a>
              </div>
              <p>Only act on manual nodechanges</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (e.type == <span class="hljs-string">'nodechange'</span> &amp;&amp; e.selectionChange) {
                  <span class="hljs-keyword">return</span>;
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-1789">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1789">&#182;</a>
              </div>
              <p>IE 11 reports active element as iframe not body of iframe</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (node &amp;&amp; node.id == editor.id + <span class="hljs-string">'_ifr'</span>) {
                  node = editor.getBody();
                }

                <span class="hljs-keyword">if</span> (editor.dom.isChildOf(node, editor.getBody())) {
                  editor.lastRng = editor.selection.getRng();
                }
              });
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1790">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1790">&#182;</a>
              </div>
              <p>Handles the issue with WebKit not retaining selection within inline document
If the user releases the mouse out side the body since a mouse up event wont occur on the body</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (Env.webkit &amp;&amp; !selectionChangeHandler) {
              selectionChangeHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> activeEditor = editorManager.activeEditor;

                <span class="hljs-keyword">if</span> (activeEditor &amp;&amp; activeEditor.selection) {
                  <span class="hljs-keyword">var</span> rng = activeEditor.selection.getRng();</pre></div></div>
            
        </li>
        
        
        <li id="section-1791">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1791">&#182;</a>
              </div>
              <p>Store when its non collapsed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">if</span> (rng &amp;&amp; !rng.collapsed) {
                    editor.lastRng = rng;
                  }
                }
              };

              DOM.bind(<span class="hljs-built_in">document</span>, <span class="hljs-string">'selectionchange'</span>, selectionChangeHandler);
            }
          }
        });

        editor.on(<span class="hljs-string">'setcontent'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          editor.lastRng = <span class="hljs-literal">null</span>;
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-1792">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1792">&#182;</a>
              </div>
              <p>Remove last selection bookmark on mousedown see #6305</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        editor.on(<span class="hljs-string">'mousedown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          editor.selection.lastFocusBookmark = <span class="hljs-literal">null</span>;
        });

        editor.on(<span class="hljs-string">'focusin'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> focusedEditor = editorManager.focusedEditor, lastRng;

          <span class="hljs-keyword">if</span> (editor.selection.lastFocusBookmark) {
            lastRng = bookmarkToRng(editor, editor.selection.lastFocusBookmark);
            editor.selection.lastFocusBookmark = <span class="hljs-literal">null</span>;
            editor.selection.setRng(lastRng);
          }

          <span class="hljs-keyword">if</span> (focusedEditor != editor) {
            <span class="hljs-keyword">if</span> (focusedEditor) {
              focusedEditor.fire(<span class="hljs-string">'blur'</span>, { <span class="hljs-attr">focusedEditor</span>: editor });
            }

            editorManager.setActive(editor);
            editorManager.focusedEditor = editor;
            editor.fire(<span class="hljs-string">'focus'</span>, { <span class="hljs-attr">blurredEditor</span>: focusedEditor });
            editor.focus(<span class="hljs-literal">true</span>);
          }

          editor.lastRng = <span class="hljs-literal">null</span>;
        });

        editor.on(<span class="hljs-string">'focusout'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          Delay.setEditorTimeout(editor, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> focusedEditor = editorManager.focusedEditor;</pre></div></div>
            
        </li>
        
        
        <li id="section-1793">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1793">&#182;</a>
              </div>
              <p>Still the same editor the blur was outside any editor UI</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!isUIElement(editor, getActiveElement()) &amp;&amp; focusedEditor == editor) {
              editor.fire(<span class="hljs-string">'blur'</span>, { <span class="hljs-attr">focusedEditor</span>: <span class="hljs-literal">null</span> });
              editorManager.focusedEditor = <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1794">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1794">&#182;</a>
              </div>
              <p>Make sure selection is valid could be invalid if the editor is blured and removed before the timeout occurs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (editor.selection) {
                editor.selection.lastFocusBookmark = <span class="hljs-literal">null</span>;
              }
            }
          });
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-1795">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1795">&#182;</a>
              </div>
              <p>Check if focus is moved to an element outside the active editor by checking if the target node
isnt within the body of the activeEditor nor a UI element such as a dialog child control</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!documentFocusInHandler) {
          documentFocusInHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">var</span> activeEditor = editorManager.activeEditor, target;

            target = e.target;

            <span class="hljs-keyword">if</span> (activeEditor &amp;&amp; target.ownerDocument === <span class="hljs-built_in">document</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1796">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1796">&#182;</a>
              </div>
              <p>Check to make sure we have a valid selection dont update the bookmark if its
a focusin to the body of the editor see #7025</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (activeEditor.selection &amp;&amp; target !== activeEditor.getBody() &amp;&amp; isElementOursideInlineEditor(editor, target)) {
                activeEditor.selection.lastFocusBookmark = createBookmark(activeEditor.dom, activeEditor.lastRng);
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-1797">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1797">&#182;</a>
              </div>
              <p>Fire a blur event if the element isnt a UI element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (target !== <span class="hljs-built_in">document</span>.body &amp;&amp; !isUIElement(activeEditor, target) &amp;&amp; editorManager.focusedEditor === activeEditor) {
                activeEditor.fire(<span class="hljs-string">'blur'</span>, { <span class="hljs-attr">focusedEditor</span>: <span class="hljs-literal">null</span> });
                editorManager.focusedEditor = <span class="hljs-literal">null</span>;
              }
            }
          };

          DOM.bind(<span class="hljs-built_in">document</span>, <span class="hljs-string">'focusin'</span>, documentFocusInHandler);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1798">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1798">&#182;</a>
              </div>
              <p>Handle edge case when user starts the selection inside the editor and releases
the mouse outside the editor producing a new selection. This weird workaround is needed since
Gecko doesnt have the selectionchange event we need to do this. Fixes: #6843</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (editor.inline &amp;&amp; !documentMouseUpHandler) {
          documentMouseUpHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">var</span> activeEditor = editorManager.activeEditor, dom = activeEditor.dom;

            <span class="hljs-keyword">if</span> (activeEditor.inline &amp;&amp; dom &amp;&amp; !dom.isChildOf(e.target, activeEditor.getBody())) {
              <span class="hljs-keyword">var</span> rng = activeEditor.selection.getRng();

              <span class="hljs-keyword">if</span> (!rng.collapsed) {
                activeEditor.lastRng = rng;
              }
            }
          };

          DOM.bind(<span class="hljs-built_in">document</span>, <span class="hljs-string">'mouseup'</span>, documentMouseUpHandler);
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unregisterDocumentEvents</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (editorManager.focusedEditor == e.editor) {
          editorManager.focusedEditor = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">if</span> (!editorManager.activeEditor) {
          DOM.unbind(<span class="hljs-built_in">document</span>, <span class="hljs-string">'selectionchange'</span>, selectionChangeHandler);
          DOM.unbind(<span class="hljs-built_in">document</span>, <span class="hljs-string">'focusin'</span>, documentFocusInHandler);
          DOM.unbind(<span class="hljs-built_in">document</span>, <span class="hljs-string">'mouseup'</span>, documentMouseUpHandler);
          selectionChangeHandler = documentFocusInHandler = documentMouseUpHandler = <span class="hljs-literal">null</span>;
        }
      }

      editorManager.on(<span class="hljs-string">'AddEditor'</span>, registerEvents);
      editorManager.on(<span class="hljs-string">'RemoveEditor'</span>, unregisterDocumentEvents);
    }

    <span class="hljs-comment">/**
     * Returns true if the specified element is part of the UI for example an button or text input.
     *
     * @method isEditorUIElement
     * @param  {Element} elm Element to check if it's part of the UI or not.
     * @return {Boolean} True/false state if the element is part of the UI or not.
     */</span>
    FocusManager.isEditorUIElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1799">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1799">&#182;</a>
              </div>
              <p>Needs to be converted to string since svg can have focus: #6776</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> elm.className.toString().indexOf(<span class="hljs-string">'mce-'</span>) !== <span class="hljs-number">-1</span>;
    };

    FocusManager._isUIElement = isUIElement;

    <span class="hljs-keyword">return</span> FocusManager;
  }
);

<span class="hljs-comment">/**
 * LegacyInput.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Converts legacy input to modern HTML.
 *
 * @class tinymce.LegacyInput
 * @private
 */</span>
define(
  <span class="hljs-string">'tinymce.core.LegacyInput'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Tools</span>) </span>{
    <span class="hljs-keyword">var</span> each = Tools.each, explode = Tools.explode;

    <span class="hljs-keyword">var</span> register = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">EditorManager</span>) </span>{
      EditorManager.on(<span class="hljs-string">'AddEditor'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> editor = e.editor;

        editor.on(<span class="hljs-string">'preInit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> filters, fontSizes, dom, settings = editor.settings;

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceWithSpan</span>(<span class="hljs-params">node, styles</span>) </span>{
            each(styles, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, name</span>) </span>{
              <span class="hljs-keyword">if</span> (value) {
                dom.setStyle(node, name, value);
              }
            });

            dom.rename(node, <span class="hljs-string">'span'</span>);
          }

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convert</span>(<span class="hljs-params">e</span>) </span>{
            dom = editor.dom;

            <span class="hljs-keyword">if</span> (settings.convert_fonts_to_spans) {
              each(dom.select(<span class="hljs-string">'font,u,strike'</span>, e.node), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
                filters[node.nodeName.toLowerCase()](dom, node);
              });
            }
          }

          <span class="hljs-keyword">if</span> (settings.inline_styles) {
            fontSizes = explode(settings.font_size_legacy_values);

            filters = {
              <span class="hljs-attr">font</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dom, node</span>) </span>{
                replaceWithSpan(node, {
                  <span class="hljs-attr">backgroundColor</span>: node.style.backgroundColor,
                  <span class="hljs-attr">color</span>: node.color,
                  <span class="hljs-attr">fontFamily</span>: node.face,
                  <span class="hljs-attr">fontSize</span>: fontSizes[<span class="hljs-built_in">parseInt</span>(node.size, <span class="hljs-number">10</span>) - <span class="hljs-number">1</span>]
                });
              },

              <span class="hljs-attr">u</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dom, node</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1800">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1800">&#182;</a>
              </div>
              <p>HTML5 allows U element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (editor.settings.schema === <span class="hljs-string">"html4"</span>) {
                  replaceWithSpan(node, {
                    <span class="hljs-attr">textDecoration</span>: <span class="hljs-string">'underline'</span>
                  });
                }
              },

              <span class="hljs-attr">strike</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dom, node</span>) </span>{
                replaceWithSpan(node, {
                  <span class="hljs-attr">textDecoration</span>: <span class="hljs-string">'line-through'</span>
                });
              }
            };

            editor.on(<span class="hljs-string">'PreProcess SetContent'</span>, convert);
          }
        });
      });
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">register</span>: register
    };
  }
);
<span class="hljs-comment">/**
 * EditorManager.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class used as a factory for manager for tinymce.Editor instances.
 *
 * @example
 * tinymce.EditorManager.init({});
 *
 * @class tinymce.EditorManager
 * @mixes tinymce.util.Observable
 * @static
 */</span>
define(
  <span class="hljs-string">'tinymce.core.EditorManager'</span>,
  [
    <span class="hljs-string">'tinymce.core.AddOnManager'</span>,
    <span class="hljs-string">'tinymce.core.dom.DomQuery'</span>,
    <span class="hljs-string">'tinymce.core.dom.DOMUtils'</span>,
    <span class="hljs-string">'tinymce.core.Editor'</span>,
    <span class="hljs-string">'tinymce.core.Env'</span>,
    <span class="hljs-string">'tinymce.core.ErrorReporter'</span>,
    <span class="hljs-string">'tinymce.core.FocusManager'</span>,
    <span class="hljs-string">'tinymce.core.LegacyInput'</span>,
    <span class="hljs-string">'tinymce.core.util.I18n'</span>,
    <span class="hljs-string">'tinymce.core.util.Observable'</span>,
    <span class="hljs-string">'tinymce.core.util.Promise'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>,
    <span class="hljs-string">'tinymce.core.util.URI'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">AddOnManager, DomQuery, DOMUtils, Editor, Env, ErrorReporter, FocusManager, LegacyInput, I18n, Observable, Promise, Tools, URI</span>) </span>{
    <span class="hljs-keyword">var</span> DOM = DOMUtils.DOM;
    <span class="hljs-keyword">var</span> explode = Tools.explode, each = Tools.each, extend = Tools.extend;
    <span class="hljs-keyword">var</span> instanceCounter = <span class="hljs-number">0</span>, beforeUnloadDelegate, EditorManager, boundGlobalEvents = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">globalEventDelegate</span>(<span class="hljs-params">e</span>) </span>{
      each(EditorManager.editors, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
        <span class="hljs-keyword">if</span> (e.type === <span class="hljs-string">'scroll'</span>) {
          editor.fire(<span class="hljs-string">'ScrollWindow'</span>, e);
        } <span class="hljs-keyword">else</span> {
          editor.fire(<span class="hljs-string">'ResizeWindow'</span>, e);
        }
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleGlobalEvents</span>(<span class="hljs-params">editors, state</span>) </span>{
      <span class="hljs-keyword">if</span> (state !== boundGlobalEvents) {
        <span class="hljs-keyword">if</span> (state) {
          DomQuery(<span class="hljs-built_in">window</span>).on(<span class="hljs-string">'resize scroll'</span>, globalEventDelegate);
        } <span class="hljs-keyword">else</span> {
          DomQuery(<span class="hljs-built_in">window</span>).off(<span class="hljs-string">'resize scroll'</span>, globalEventDelegate);
        }

        boundGlobalEvents = state;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeEditorFromList</span>(<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> editors = EditorManager.editors, removedFromList;

      <span class="hljs-keyword">delete</span> editors[editor.id];

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; editors.length; i++) {
        <span class="hljs-keyword">if</span> (editors[i] == editor) {
          editors.splice(i, <span class="hljs-number">1</span>);
          removedFromList = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">break</span>;
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1801">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1801">&#182;</a>
              </div>
              <p>Select another editor since the active one was removed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (EditorManager.activeEditor == editor) {
        EditorManager.activeEditor = editors[<span class="hljs-number">0</span>];
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1802">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1802">&#182;</a>
              </div>
              <p>Clear focusedEditor if necessary, so that we dont try to blur the destroyed editor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (EditorManager.focusedEditor == editor) {
        EditorManager.focusedEditor = <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">return</span> removedFromList;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">purgeDestroyedEditor</span>(<span class="hljs-params">editor</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1803">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1803">&#182;</a>
              </div>
              <p>User has manually destroyed the editor lets clean up the mess</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (editor &amp;&amp; editor.initialized &amp;&amp; !(editor.getContainer() || editor.getBody()).parentNode) {
        removeEditorFromList(editor);
        editor.unbindAllNativeEvents();
        editor.destroy(<span class="hljs-literal">true</span>);
        editor.removed = <span class="hljs-literal">true</span>;
        editor = <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">return</span> editor;
    }

    EditorManager = {
      <span class="hljs-comment">/**
       * Dom query instance.
       *
       * @property $
       * @type tinymce.dom.DomQuery
       */</span>
      $: DomQuery,

      <span class="hljs-comment">/**
       * Major version of TinyMCE build.
       *
       * @property majorVersion
       * @type String
       */</span>
      majorVersion: <span class="hljs-string">'4'</span>,

      <span class="hljs-comment">/**
       * Minor version of TinyMCE build.
       *
       * @property minorVersion
       * @type String
       */</span>
      minorVersion: <span class="hljs-string">'6.1'</span>,

      <span class="hljs-comment">/**
       * Release date of TinyMCE build.
       *
       * @property releaseDate
       * @type String
       */</span>
      releaseDate: <span class="hljs-string">'2017-05-10'</span>,

      <span class="hljs-comment">/**
       * Collection of editor instances.
       *
       * @property editors
       * @type Object
       * @example
       * for (edId in tinymce.editors)
       *     tinymce.editors[edId].save();
       */</span>
      editors: [],

      <span class="hljs-comment">/**
       * Collection of language pack data.
       *
       * @property i18n
       * @type Object
       */</span>
      i18n: I18n,

      <span class="hljs-comment">/**
       * Currently active editor instance.
       *
       * @property activeEditor
       * @type tinymce.Editor
       * @example
       * tinyMCE.activeEditor.selection.getContent();
       * tinymce.EditorManager.activeEditor.selection.getContent();
       */</span>
      activeEditor: <span class="hljs-literal">null</span>,

      <span class="hljs-attr">setup</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, baseURL, documentBaseURL, suffix = <span class="hljs-string">""</span>, preInit, src;</pre></div></div>
            
        </li>
        
        
        <li id="section-1804">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1804">&#182;</a>
              </div>
              <p>Get base URL for the current document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        documentBaseURL = URI.getDocumentBaseUrl(<span class="hljs-built_in">document</span>.location);</pre></div></div>
            
        </li>
        
        
        <li id="section-1805">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1805">&#182;</a>
              </div>
              <p>Check if the URL is a document based format like: <a href="http://site/dir/file">http://site/dir/file</a> and file:///
leave other formats like applewebdata:// intact</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^[^:]+:\/\/\/?[^\/]+\//</span>.test(documentBaseURL)) {
          documentBaseURL = documentBaseURL.replace(<span class="hljs-regexp">/[\?#].*$/</span>, <span class="hljs-string">''</span>).replace(<span class="hljs-regexp">/[\/\\][^\/]+$/</span>, <span class="hljs-string">''</span>);

          <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/[\/\\]$/</span>.test(documentBaseURL)) {
            documentBaseURL += <span class="hljs-string">'/'</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1806">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1806">&#182;</a>
              </div>
              <p>If tinymce is defined and has a base use that or use the old tinyMCEPreInit</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        preInit = <span class="hljs-built_in">window</span>.tinymce || <span class="hljs-built_in">window</span>.tinyMCEPreInit;
        <span class="hljs-keyword">if</span> (preInit) {
          baseURL = preInit.base || preInit.baseURL;
          suffix = preInit.suffix;
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1807">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1807">&#182;</a>
              </div>
              <p>Get base where the tinymce script is located</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> scripts = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'script'</span>);
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; scripts.length; i++) {
            src = scripts[i].src;</pre></div></div>
            
        </li>
        
        
        <li id="section-1808">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1808">&#182;</a>
              </div>
              <p>Script types supported:
tinymce.js tinymce.min.js tinymce.dev.js
tinymce.jquery.js tinymce.jquery.min.js tinymce.jquery.dev.js
tinymce.full.js tinymce.full.min.js tinymce.full.dev.js</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> srcScript = src.substring(src.lastIndexOf(<span class="hljs-string">'/'</span>));
            <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/</span>.test(src)) {
              <span class="hljs-keyword">if</span> (srcScript.indexOf(<span class="hljs-string">'.min'</span>) != <span class="hljs-number">-1</span>) {
                suffix = <span class="hljs-string">'.min'</span>;
              }

              baseURL = src.substring(<span class="hljs-number">0</span>, src.lastIndexOf(<span class="hljs-string">'/'</span>));
              <span class="hljs-keyword">break</span>;
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1809">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1809">&#182;</a>
              </div>
              <p>We didnt find any baseURL by looking at the script elements
Try to use the document.currentScript as a fallback</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!baseURL &amp;&amp; <span class="hljs-built_in">document</span>.currentScript) {
            src = <span class="hljs-built_in">document</span>.currentScript.src;

            <span class="hljs-keyword">if</span> (src.indexOf(<span class="hljs-string">'.min'</span>) != <span class="hljs-number">-1</span>) {
              suffix = <span class="hljs-string">'.min'</span>;
            }

            baseURL = src.substring(<span class="hljs-number">0</span>, src.lastIndexOf(<span class="hljs-string">'/'</span>));
          }
        }

        <span class="hljs-comment">/**
         * Base URL where the root directory if TinyMCE is located.
         *
         * @property baseURL
         * @type String
         */</span>
        self.baseURL = <span class="hljs-keyword">new</span> URI(documentBaseURL).toAbsolute(baseURL);

        <span class="hljs-comment">/**
         * Document base URL where the current document is located.
         *
         * @property documentBaseURL
         * @type String
         */</span>
        self.documentBaseURL = documentBaseURL;

        <span class="hljs-comment">/**
         * Absolute baseURI for the installation path of TinyMCE.
         *
         * @property baseURI
         * @type tinymce.util.URI
         */</span>
        self.baseURI = <span class="hljs-keyword">new</span> URI(self.baseURL);

        <span class="hljs-comment">/**
         * Current suffix to add to each plugin/theme that gets loaded for example ".min".
         *
         * @property suffix
         * @type String
         */</span>
        self.suffix = suffix;

        self.focusManager = <span class="hljs-keyword">new</span> FocusManager(self);
      },

      <span class="hljs-comment">/**
       * Overrides the default settings for editor instances.
       *
       * @method overrideDefaults
       * @param {Object} defaultSettings Defaults settings object.
       */</span>
      overrideDefaults: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">defaultSettings</span>) </span>{
        <span class="hljs-keyword">var</span> baseUrl, suffix;

        baseUrl = defaultSettings.base_url;
        <span class="hljs-keyword">if</span> (baseUrl) {
          <span class="hljs-keyword">this</span>.baseURL = <span class="hljs-keyword">new</span> URI(<span class="hljs-keyword">this</span>.documentBaseURL).toAbsolute(baseUrl.replace(<span class="hljs-regexp">/\/+$/</span>, <span class="hljs-string">''</span>));
          <span class="hljs-keyword">this</span>.baseURI = <span class="hljs-keyword">new</span> URI(<span class="hljs-keyword">this</span>.baseURL);
        }

        suffix = defaultSettings.suffix;
        <span class="hljs-keyword">if</span> (defaultSettings.suffix) {
          <span class="hljs-keyword">this</span>.suffix = suffix;
        }

        <span class="hljs-keyword">this</span>.defaultSettings = defaultSettings;

        <span class="hljs-keyword">var</span> pluginBaseUrls = defaultSettings.plugin_base_urls;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> pluginBaseUrls) {
          AddOnManager.PluginManager.urls[name] = pluginBaseUrls[name];
        }
      },

      <span class="hljs-comment">/**
       * Initializes a set of editors. This method will create editors based on various settings.
       *
       * @method init
       * @param {Object} settings Settings object to be passed to each editor instance.
       * @return {tinymce.util.Promise} Promise that gets resolved with an array of editors when all editor instances are initialized.
       * @example
       * // Initializes a editor using the longer method
       * tinymce.EditorManager.init({
       *    some_settings : 'some value'
       * });
       *
       * // Initializes a editor instance using the shorter version and with a promise
       * tinymce.init({
       *    some_settings : 'some value'
       * }).then(function(editors) {
       *    ...
       * });
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, result, invalidInlineTargets;

        invalidInlineTargets = Tools.makeMap(
          <span class="hljs-string">'area base basefont br col frame hr img input isindex link meta param embed source wbr track '</span> +
          <span class="hljs-string">'colgroup option tbody tfoot thead tr script noscript style textarea video audio iframe object menu'</span>,
          <span class="hljs-string">' '</span>
        );

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isInvalidInlineTarget</span>(<span class="hljs-params">settings, elm</span>) </span>{
          <span class="hljs-keyword">return</span> settings.inline &amp;&amp; elm.tagName.toLowerCase() <span class="hljs-keyword">in</span> invalidInlineTargets;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createId</span>(<span class="hljs-params">elm</span>) </span>{
          <span class="hljs-keyword">var</span> id = elm.id;</pre></div></div>
            
        </li>
        
        
        <li id="section-1810">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1810">&#182;</a>
              </div>
              <p>Use element id, or unique name or generate a unique id</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!id) {
            id = elm.name;

            <span class="hljs-keyword">if</span> (id &amp;&amp; !DOM.get(id)) {
              id = elm.name;
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1811">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1811">&#182;</a>
              </div>
              <p>Generate unique name</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              id = DOM.uniqueId();
            }

            elm.setAttribute(<span class="hljs-string">'id'</span>, id);
          }

          <span class="hljs-keyword">return</span> id;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execCallback</span>(<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">var</span> callback = settings[name];

          <span class="hljs-keyword">if</span> (!callback) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">return</span> callback.apply(self, <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>));
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasClass</span>(<span class="hljs-params">elm, className</span>) </span>{
          <span class="hljs-keyword">return</span> className.constructor === <span class="hljs-built_in">RegExp</span> ? className.test(elm.className) : DOM.hasClass(elm, className);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findTargets</span>(<span class="hljs-params">settings</span>) </span>{
          <span class="hljs-keyword">var</span> l, targets = [];

          <span class="hljs-keyword">if</span> (Env.ie &amp;&amp; Env.ie &lt; <span class="hljs-number">11</span>) {
            ErrorReporter.initError(
              <span class="hljs-string">'TinyMCE does not support the browser you are using. For a list of supported'</span> +
              <span class="hljs-string">' browsers please see: https://www.tinymce.com/docs/get-started/system-requirements/'</span>
            );
            <span class="hljs-keyword">return</span> [];
          }

          <span class="hljs-keyword">if</span> (settings.types) {
            each(settings.types, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
              targets = targets.concat(DOM.select(type.selector));
            });

            <span class="hljs-keyword">return</span> targets;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (settings.selector) {
            <span class="hljs-keyword">return</span> DOM.select(settings.selector);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (settings.target) {
            <span class="hljs-keyword">return</span> [settings.target];
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1812">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1812">&#182;</a>
              </div>
              <p>Fallback to old setting</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">switch</span> (settings.mode) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">"exact"</span>:
              l = settings.elements || <span class="hljs-string">''</span>;

              <span class="hljs-keyword">if</span> (l.length &gt; <span class="hljs-number">0</span>) {
                each(explode(l), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
                  <span class="hljs-keyword">var</span> elm;

                  <span class="hljs-keyword">if</span> ((elm = DOM.get(id))) {
                    targets.push(elm);
                  } <span class="hljs-keyword">else</span> {
                    each(<span class="hljs-built_in">document</span>.forms, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
                      each(f.elements, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
                        <span class="hljs-keyword">if</span> (e.name === id) {
                          id = <span class="hljs-string">'mce_editor_'</span> + instanceCounter++;
                          DOM.setAttrib(e, <span class="hljs-string">'id'</span>, id);
                          targets.push(e);
                        }
                      });
                    });
                  }
                });
              }
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">"textareas"</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">"specific_textareas"</span>:
              each(DOM.select(<span class="hljs-string">'textarea'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
                <span class="hljs-keyword">if</span> (settings.editor_deselector &amp;&amp; hasClass(elm, settings.editor_deselector)) {
                  <span class="hljs-keyword">return</span>;
                }

                <span class="hljs-keyword">if</span> (!settings.editor_selector || hasClass(elm, settings.editor_selector)) {
                  targets.push(elm);
                }
              });
              <span class="hljs-keyword">break</span>;
          }

          <span class="hljs-keyword">return</span> targets;
        }

        <span class="hljs-keyword">var</span> provideResults = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editors</span>) </span>{
          result = editors;
        };

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initEditors</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> initCount = <span class="hljs-number">0</span>, editors = [], targets;

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createEditor</span>(<span class="hljs-params">id, settings, targetElm</span>) </span>{
            <span class="hljs-keyword">var</span> editor = <span class="hljs-keyword">new</span> Editor(id, settings, self);

            editors.push(editor);

            editor.on(<span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">if</span> (++initCount === targets.length) {
                provideResults(editors);
              }
            });

            editor.targetElm = editor.targetElm || targetElm;
            editor.render();
          }

          DOM.unbind(<span class="hljs-built_in">window</span>, <span class="hljs-string">'ready'</span>, initEditors);
          execCallback(<span class="hljs-string">'onpageload'</span>);

          targets = DomQuery.unique(findTargets(settings));</pre></div></div>
            
        </li>
        
        
        <li id="section-1813">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1813">&#182;</a>
              </div>
              <p>TODO: Deprecate this one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (settings.types) {
            each(settings.types, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
              Tools.each(targets, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
                <span class="hljs-keyword">if</span> (DOM.is(elm, type.selector)) {
                  createEditor(createId(elm), extend({}, settings, type), elm);
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }

                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              });
            });

            <span class="hljs-keyword">return</span>;
          }

          Tools.each(targets, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
            purgeDestroyedEditor(self.get(elm.id));
          });

          targets = Tools.grep(targets, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
            <span class="hljs-keyword">return</span> !self.get(elm.id);
          });

          <span class="hljs-keyword">if</span> (targets.length === <span class="hljs-number">0</span>) {
            provideResults([]);
          } <span class="hljs-keyword">else</span> {
            each(targets, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
              <span class="hljs-keyword">if</span> (isInvalidInlineTarget(settings, elm)) {
                ErrorReporter.initError(<span class="hljs-string">'Could not initialize inline editor on invalid inline target element'</span>, elm);
              } <span class="hljs-keyword">else</span> {
                createEditor(createId(elm), settings, elm);
              }
            });
          }
        }

        self.settings = settings;
        DOM.bind(<span class="hljs-built_in">window</span>, <span class="hljs-string">'ready'</span>, initEditors);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
          <span class="hljs-keyword">if</span> (result) {
            resolve(result);
          } <span class="hljs-keyword">else</span> {
            provideResults = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editors</span>) </span>{
              resolve(editors);
            };
          }
        });
      },

      <span class="hljs-comment">/**
       * Returns a editor instance by id.
       *
       * @method get
       * @param {String/Number} id Editor instance id or index to return.
       * @return {tinymce.Editor} Editor instance to return.
       * @example
       * // Adds an onclick event to an editor by id (shorter version)
       * tinymce.get('mytextbox').on('click', function(e) {
       *    ed.windowManager.alert('Hello world!');
       * });
       *
       * // Adds an onclick event to an editor by id (longer version)
       * tinymce.EditorManager.get('mytextbox').on('click', function(e) {
       *    ed.windowManager.alert('Hello world!');
       * });
       */</span>
      get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">arguments</span>.length) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.editors;
        }

        <span class="hljs-keyword">return</span> id <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.editors ? <span class="hljs-keyword">this</span>.editors[id] : <span class="hljs-literal">null</span>;
      },

      <span class="hljs-comment">/**
       * Adds an editor instance to the editor collection. This will also set it as the active editor.
       *
       * @method add
       * @param {tinymce.Editor} editor Editor instance to add to the collection.
       * @return {tinymce.Editor} The same instance that got passed in.
       */</span>
      add: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, editors = self.editors;</pre></div></div>
            
        </li>
        
        
        <li id="section-1814">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1814">&#182;</a>
              </div>
              <p>Add named and index editor instance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        editors[editor.id] = editor;
        editors.push(editor);

        toggleGlobalEvents(editors, <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1815">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1815">&#182;</a>
              </div>
              <p>Doesnt call setActive method since we dont want
to fire a bunch of activate/deactivate calls while initializing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self.activeEditor = editor;

        self.fire(<span class="hljs-string">'AddEditor'</span>, { <span class="hljs-attr">editor</span>: editor });

        <span class="hljs-keyword">if</span> (!beforeUnloadDelegate) {
          beforeUnloadDelegate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            self.fire(<span class="hljs-string">'BeforeUnload'</span>);
          };

          DOM.bind(<span class="hljs-built_in">window</span>, <span class="hljs-string">'beforeunload'</span>, beforeUnloadDelegate);
        }

        <span class="hljs-keyword">return</span> editor;
      },

      <span class="hljs-comment">/**
       * Creates an editor instance and adds it to the EditorManager collection.
       *
       * @method createEditor
       * @param {String} id Instance id to use for editor.
       * @param {Object} settings Editor instance settings.
       * @return {tinymce.Editor} Editor instance that got created.
       */</span>
      createEditor: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, settings</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.add(<span class="hljs-keyword">new</span> Editor(id, settings, <span class="hljs-keyword">this</span>));
      },

      <span class="hljs-comment">/**
       * Removes a editor or editors form page.
       *
       * @example
       * // Remove all editors bound to divs
       * tinymce.remove('div');
       *
       * // Remove all editors bound to textareas
       * tinymce.remove('textarea');
       *
       * // Remove all editors
       * tinymce.remove();
       *
       * // Remove specific instance by id
       * tinymce.remove('#id');
       *
       * @method remove
       * @param {tinymce.Editor/String/Object} [selector] CSS selector or editor instance to remove.
       * @return {tinymce.Editor} The editor that got passed in will be return if it was found otherwise null.
       */</span>
      remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, i, editors = self.editors, editor;</pre></div></div>
            
        </li>
        
        
        <li id="section-1816">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1816">&#182;</a>
              </div>
              <p>Remove all editors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!selector) {
          <span class="hljs-keyword">for</span> (i = editors.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            self.remove(editors[i]);
          }

          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1817">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1817">&#182;</a>
              </div>
              <p>Remove editors by selector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> selector == <span class="hljs-string">"string"</span>) {
          selector = selector.selector || selector;

          each(DOM.select(selector), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
            editor = editors[elm.id];

            <span class="hljs-keyword">if</span> (editor) {
              self.remove(editor);
            }
          });

          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1818">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1818">&#182;</a>
              </div>
              <p>Remove specific editor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        editor = selector;</pre></div></div>
            
        </li>
        
        
        <li id="section-1819">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1819">&#182;</a>
              </div>
              <p>Not in the collection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!editors[editor.id]) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">if</span> (removeEditorFromList(editor)) {
          self.fire(<span class="hljs-string">'RemoveEditor'</span>, { <span class="hljs-attr">editor</span>: editor });
        }

        <span class="hljs-keyword">if</span> (!editors.length) {
          DOM.unbind(<span class="hljs-built_in">window</span>, <span class="hljs-string">'beforeunload'</span>, beforeUnloadDelegate);
        }

        editor.remove();

        toggleGlobalEvents(editors, editors.length &gt; <span class="hljs-number">0</span>);

        <span class="hljs-keyword">return</span> editor;
      },

      <span class="hljs-comment">/**
       * Executes a specific command on the currently active editor.
       *
       * @method execCommand
       * @param {String} cmd Command to perform for example Bold.
       * @param {Boolean} ui Optional boolean state if a UI should be presented for the command or not.
       * @param {String} value Optional value parameter like for example an URL to a link.
       * @return {Boolean} true/false if the command was executed or not.
       */</span>
      execCommand: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cmd, ui, value</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, editor = self.get(value);</pre></div></div>
            
        </li>
        
        
        <li id="section-1820">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1820">&#182;</a>
              </div>
              <p>Manager commands</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">switch</span> (cmd) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">"mceAddEditor"</span>:
            <span class="hljs-keyword">if</span> (!self.get(value)) {
              <span class="hljs-keyword">new</span> Editor(value, self.settings, self).render();
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">"mceRemoveEditor"</span>:
            <span class="hljs-keyword">if</span> (editor) {
              editor.remove();
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'mceToggleEditor'</span>:
            <span class="hljs-keyword">if</span> (!editor) {
              self.execCommand(<span class="hljs-string">'mceAddEditor'</span>, <span class="hljs-number">0</span>, value);
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">if</span> (editor.isHidden()) {
              editor.show();
            } <span class="hljs-keyword">else</span> {
              editor.hide();
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1821">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1821">&#182;</a>
              </div>
              <p>Run command on active editor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (self.activeEditor) {
          <span class="hljs-keyword">return</span> self.activeEditor.execCommand(cmd, ui, value);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      },

      <span class="hljs-comment">/**
       * Calls the save method on all editor instances in the collection. This can be useful when a form is to be submitted.
       *
       * @method triggerSave
       * @example
       * // Saves all contents
       * tinyMCE.triggerSave();
       */</span>
      triggerSave: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        each(<span class="hljs-keyword">this</span>.editors, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
          editor.save();
        });
      },

      <span class="hljs-comment">/**
       * Adds a language pack, this gets called by the loaded language files like en.js.
       *
       * @method addI18n
       * @param {String} code Optional language code.
       * @param {Object} items Name/value object with translations.
       */</span>
      addI18n: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">code, items</span>) </span>{
        I18n.add(code, items);
      },

      <span class="hljs-comment">/**
       * Translates the specified string using the language pack items.
       *
       * @method translate
       * @param {String/Array/Object} text String to translate
       * @return {String} Translated string.
       */</span>
      translate: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
        <span class="hljs-keyword">return</span> I18n.translate(text);
      },

      <span class="hljs-comment">/**
       * Sets the active editor instance and fires the deactivate/activate events.
       *
       * @method setActive
       * @param {tinymce.Editor} editor Editor instance to set as the active instance.
       */</span>
      setActive: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editor</span>) </span>{
        <span class="hljs-keyword">var</span> activeEditor = <span class="hljs-keyword">this</span>.activeEditor;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.activeEditor != editor) {
          <span class="hljs-keyword">if</span> (activeEditor) {
            activeEditor.fire(<span class="hljs-string">'deactivate'</span>, { <span class="hljs-attr">relatedTarget</span>: editor });
          }

          editor.fire(<span class="hljs-string">'activate'</span>, { <span class="hljs-attr">relatedTarget</span>: activeEditor });
        }

        <span class="hljs-keyword">this</span>.activeEditor = editor;
      }
    };

    extend(EditorManager, Observable);

    EditorManager.setup();
    LegacyInput.register(EditorManager);

    <span class="hljs-keyword">return</span> EditorManager;
  }
);

<span class="hljs-comment">/**
 * XHR.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class enables you to send XMLHTTPRequests cross browser.
 * @class tinymce.util.XHR
 * @mixes tinymce.util.Observable
 * @static
 * @example
 * // Sends a low level Ajax request
 * tinymce.util.XHR.send({
 *    url: 'someurl',
 *    success: function(text) {
 *       console.debug(text);
 *    }
 * });
 *
 * // Add custom header to XHR request
 * tinymce.util.XHR.on('beforeSend', function(e) {
 *     e.xhr.setRequestHeader('X-Requested-With', 'Something');
 * });
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.XHR'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Observable"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Observable, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> XHR = {
      <span class="hljs-comment">/**
       * Sends a XMLHTTPRequest.
       * Consult the Wiki for details on what settings this method takes.
       *
       * @method send
       * @param {Object} settings Object will target URL, callbacks and other info needed to make the request.
       */</span>
      send: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> xhr, count = <span class="hljs-number">0</span>;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ready</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (!settings.async || xhr.readyState == <span class="hljs-number">4</span> || count++ &gt; <span class="hljs-number">10000</span>) {
            <span class="hljs-keyword">if</span> (settings.success &amp;&amp; count &lt; <span class="hljs-number">10000</span> &amp;&amp; xhr.status == <span class="hljs-number">200</span>) {
              settings.success.call(settings.success_scope, <span class="hljs-string">''</span> + xhr.responseText, xhr, settings);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (settings.error) {
              settings.error.call(settings.error_scope, count &gt; <span class="hljs-number">10000</span> ? <span class="hljs-string">'TIMED_OUT'</span> : <span class="hljs-string">'GENERAL'</span>, xhr, settings);
            }

            xhr = <span class="hljs-literal">null</span>;
          } <span class="hljs-keyword">else</span> {
            setTimeout(ready, <span class="hljs-number">10</span>);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1822">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1822">&#182;</a>
              </div>
              <p>Default settings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        settings.scope = settings.scope || <span class="hljs-keyword">this</span>;
        settings.success_scope = settings.success_scope || settings.scope;
        settings.error_scope = settings.error_scope || settings.scope;
        settings.async = settings.async === <span class="hljs-literal">false</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;
        settings.data = settings.data || <span class="hljs-string">''</span>;

        XHR.fire(<span class="hljs-string">'beforeInitialize'</span>, { <span class="hljs-attr">settings</span>: settings });

        xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();

        <span class="hljs-keyword">if</span> (xhr) {
          <span class="hljs-keyword">if</span> (xhr.overrideMimeType) {
            xhr.overrideMimeType(settings.content_type);
          }

          xhr.open(settings.type || (settings.data ? <span class="hljs-string">'POST'</span> : <span class="hljs-string">'GET'</span>), settings.url, settings.async);

          <span class="hljs-keyword">if</span> (settings.crossDomain) {
            xhr.withCredentials = <span class="hljs-literal">true</span>;
          }

          <span class="hljs-keyword">if</span> (settings.content_type) {
            xhr.setRequestHeader(<span class="hljs-string">'Content-Type'</span>, settings.content_type);
          }

          <span class="hljs-keyword">if</span> (settings.requestheaders) {
            Tools.each(settings.requestheaders, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">header</span>) </span>{
              xhr.setRequestHeader(header.key, header.value);
            });
          }

          xhr.setRequestHeader(<span class="hljs-string">'X-Requested-With'</span>, <span class="hljs-string">'XMLHttpRequest'</span>);

          xhr = XHR.fire(<span class="hljs-string">'beforeSend'</span>, { <span class="hljs-attr">xhr</span>: xhr, <span class="hljs-attr">settings</span>: settings }).xhr;
          xhr.send(settings.data);</pre></div></div>
            
        </li>
        
        
        <li id="section-1823">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1823">&#182;</a>
              </div>
              <p>Syncronous request</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!settings.async) {
            <span class="hljs-keyword">return</span> ready();
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1824">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1824">&#182;</a>
              </div>
              <p>Wait for response, onReadyStateChange can not be used since it leaks memory in IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          setTimeout(ready, <span class="hljs-number">10</span>);
        }
      }
    };

    Tools.extend(XHR, Observable);

    <span class="hljs-keyword">return</span> XHR;
  }
);

<span class="hljs-comment">/**
 * JSON.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * JSON parser and serializer class.
 *
 * @class tinymce.util.JSON
 * @static
 * @example
 * // JSON parse a string into an object
 * var obj = tinymce.util.JSON.parse(somestring);
 *
 * // JSON serialize a object into an string
 * var str = tinymce.util.JSON.serialize(obj);
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.JSON'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serialize</span>(<span class="hljs-params">o, quote</span>) </span>{
      <span class="hljs-keyword">var</span> i, v, t, name;

      quote = quote || <span class="hljs-string">'"'</span>;

      <span class="hljs-keyword">if</span> (o === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'null'</span>;
      }

      t = <span class="hljs-keyword">typeof</span> o;

      <span class="hljs-keyword">if</span> (t == <span class="hljs-string">'string'</span>) {
        v = <span class="hljs-string">'\bb\tt\nn\ff\rr\""\'\'\\\\'</span>;

        <span class="hljs-comment">/*eslint no-control-regex:0 */</span>
        <span class="hljs-keyword">return</span> quote + o.replace(<span class="hljs-regexp">/([\u0080-\uFFFF\x00-\x1f\"\'\\])/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1825">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1825">&#182;</a>
              </div>
              <p>Make sure single quotes never get encoded inside double quotes for JSON compatibility</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (quote === <span class="hljs-string">'"'</span> &amp;&amp; a === <span class="hljs-string">"'"</span>) {
            <span class="hljs-keyword">return</span> a;
          }

          i = v.indexOf(b);

          <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'\\'</span> + v.charAt(i + <span class="hljs-number">1</span>);
          }

          a = b.charCodeAt().toString(<span class="hljs-number">16</span>);

          <span class="hljs-keyword">return</span> <span class="hljs-string">'\\u'</span> + <span class="hljs-string">'0000'</span>.substring(a.length) + a;
        }) + quote;
      }

      <span class="hljs-keyword">if</span> (t == <span class="hljs-string">'object'</span>) {
        <span class="hljs-keyword">if</span> (o.hasOwnProperty &amp;&amp; <span class="hljs-built_in">Object</span>.prototype.toString.call(o) === <span class="hljs-string">'[object Array]'</span>) {
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, v = <span class="hljs-string">'['</span>; i &lt; o.length; i++) {
            v += (i &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">','</span> : <span class="hljs-string">''</span>) + serialize(o[i], quote);
          }

          <span class="hljs-keyword">return</span> v + <span class="hljs-string">']'</span>;
        }

        v = <span class="hljs-string">'{'</span>;

        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> o) {
          <span class="hljs-keyword">if</span> (o.hasOwnProperty(name)) {
            v += <span class="hljs-keyword">typeof</span> o[name] != <span class="hljs-string">'function'</span> ? (v.length &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">','</span> + quote : quote) + name +
              quote + <span class="hljs-string">':'</span> + serialize(o[name], quote) : <span class="hljs-string">''</span>;
          }
        }

        <span class="hljs-keyword">return</span> v + <span class="hljs-string">'}'</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span> + o;
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">/**
       * Serializes the specified object as a JSON string.
       *
       * @method serialize
       * @param {Object} obj Object to serialize as a JSON string.
       * @param {String} quote Optional quote string defaults to ".
       * @return {string} JSON string serialized from input.
       */</span>
      serialize: serialize,

      <span class="hljs-comment">/**
       * Unserializes/parses the specified JSON string into a object.
       *
       * @method parse
       * @param {string} s JSON String to parse into a JavaScript object.
       * @return {Object} Object from input JSON string or undefined if it failed.
       */</span>
      parse: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
        <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1826">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1826">&#182;</a>
              </div>
              <p>Trick uglify JS</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>[<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">101</span>) + <span class="hljs-string">'val'</span>](<span class="hljs-string">'('</span> + text + <span class="hljs-string">')'</span>);
        } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1827">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1827">&#182;</a>
              </div>
              <p>Ignore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }
      }

      <span class="hljs-comment">/**#@-*/</span>
    };
  }
);

<span class="hljs-comment">/**
 * JSONRequest.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class enables you to use JSON-RPC to call backend methods.
 *
 * @class tinymce.util.JSONRequest
 * @example
 * var json = new tinymce.util.JSONRequest({
 *     url: 'somebackend.php'
 * });
 *
 * // Send RPC call 1
 * json.send({
 *     method: 'someMethod1',
 *     params: ['a', 'b'],
 *     success: function(result) {
 *         console.dir(result);
 *     }
 * });
 *
 * // Send RPC call 2
 * json.send({
 *     method: 'someMethod2',
 *     params: ['a', 'b'],
 *     success: function(result) {
 *         console.dir(result);
 *     }
 * });
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.JSONRequest'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.JSON"</span>,
    <span class="hljs-string">"tinymce.core.util.XHR"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">JSON, XHR, Tools</span>) </span>{
    <span class="hljs-keyword">var</span> extend = Tools.extend;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">JSONRequest</span>(<span class="hljs-params">settings</span>) </span>{
      <span class="hljs-keyword">this</span>.settings = extend({}, settings);
      <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">/**
     * Simple helper function to send a JSON-RPC request without the need to initialize an object.
     * Consult the Wiki API documentation for more details on what you can pass to this function.
     *
     * @method sendRPC
     * @static
     * @param {Object} o Call object where there are three field id, method and params this object should also contain callbacks etc.
     */</span>
    JSONRequest.sendRPC = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JSONRequest().send(o);
    };

    JSONRequest.prototype = {
      <span class="hljs-comment">/**
       * Sends a JSON-RPC call. Consult the Wiki API documentation for more details on what you can pass to this function.
       *
       * @method send
       * @param {Object} args Call object where there are three field id, method and params this object should also contain callbacks etc.
       */</span>
      send: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>{
        <span class="hljs-keyword">var</span> ecb = args.error, scb = args.success;

        args = extend(<span class="hljs-keyword">this</span>.settings, args);

        args.success = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c, x</span>) </span>{
          c = <span class="hljs-built_in">JSON</span>.parse(c);

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> c == <span class="hljs-string">'undefined'</span>) {
            c = {
              <span class="hljs-attr">error</span>: <span class="hljs-string">'JSON Parse error.'</span>
            };
          }

          <span class="hljs-keyword">if</span> (c.error) {
            ecb.call(args.error_scope || args.scope, c.error, x);
          } <span class="hljs-keyword">else</span> {
            scb.call(args.success_scope || args.scope, c.result);
          }
        };

        args.error = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ty, x</span>) </span>{
          <span class="hljs-keyword">if</span> (ecb) {
            ecb.call(args.error_scope || args.scope, ty, x);
          }
        };

        args.data = <span class="hljs-built_in">JSON</span>.serialize({
          <span class="hljs-attr">id</span>: args.id || <span class="hljs-string">'c'</span> + (<span class="hljs-keyword">this</span>.count++),
          <span class="hljs-attr">method</span>: args.method,
          <span class="hljs-attr">params</span>: args.params
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-1828">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1828">&#182;</a>
              </div>
              <p>JSON content type for Ruby on rails. Bug: #1883287</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        args.content_type = <span class="hljs-string">'application/json'</span>;

        XHR.send(args);
      }
    };

    <span class="hljs-keyword">return</span> JSONRequest;
  }
);
<span class="hljs-comment">/**
 * JSONP.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.util.JSONP'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.DOMUtils"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">DOMUtils</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">callbacks</span>: {},
      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,

      <span class="hljs-attr">send</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, dom = DOMUtils.DOM, count = settings.count !== <span class="hljs-literal">undefined</span> ? settings.count : self.count;
        <span class="hljs-keyword">var</span> id = <span class="hljs-string">'tinymce_jsonp_'</span> + count;

        self.callbacks[count] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">json</span>) </span>{
          dom.remove(id);
          <span class="hljs-keyword">delete</span> self.callbacks[count];

          settings.callback(json);
        };

        dom.add(dom.doc.body, <span class="hljs-string">'script'</span>, {
          <span class="hljs-attr">id</span>: id,
          <span class="hljs-attr">src</span>: settings.url,
          <span class="hljs-attr">type</span>: <span class="hljs-string">'text/javascript'</span>
        });

        self.count++;
      }
    };
  }
);
<span class="hljs-comment">/**
 * LocalStorage.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class will simulate LocalStorage on IE 7 and return the native version on modern browsers.
 * Storage is done using userData on IE 7 and a special serialization format. The format is designed
 * to be as small as possible by making sure that the keys and values doesn't need to be encoded. This
 * makes it possible to store for example HTML data.
 *
 * Storage format for userData:
 * &lt;base 32 key length&gt;,&lt;key string&gt;,&lt;base 32 value length&gt;,&lt;value&gt;,...
 *
 * For example this data key1=value1,key2=value2 would be:
 * 4,key1,6,value1,4,key2,6,value2
 *
 * @class tinymce.util.LocalStorage
 * @static
 * @version 4.0
 * @example
 * tinymce.util.LocalStorage.setItem('key', 'value');
 * var value = tinymce.util.LocalStorage.getItem('key');
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.LocalStorage'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> LocalStorage, storageElm, items, keys, userDataKey, hasOldIEDataSupport;</pre></div></div>
            
        </li>
        
        
        <li id="section-1829">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1829">&#182;</a>
              </div>
              <p>Check for native support</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.localStorage) {
        <span class="hljs-keyword">return</span> localStorage;
      }
    } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1830">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1830">&#182;</a>
              </div>
              <p>Ignore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    }

    userDataKey = <span class="hljs-string">"tinymce"</span>;
    storageElm = <span class="hljs-built_in">document</span>.documentElement;
    hasOldIEDataSupport = !!storageElm.addBehavior;

    <span class="hljs-keyword">if</span> (hasOldIEDataSupport) {
      storageElm.addBehavior(<span class="hljs-string">'#default#userData'</span>);
    }

    <span class="hljs-comment">/**
     * Gets the keys names and updates LocalStorage.length property. Since IE7 doesn't have any getters/setters.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateKeys</span>(<span class="hljs-params"></span>) </span>{
      keys = [];

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> items) {
        keys.push(key);
      }

      LocalStorage.length = keys.length;
    }

    <span class="hljs-comment">/**
     * Loads the userData string and parses it into the items structure.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> key, data, value, pos = <span class="hljs-number">0</span>;

      items = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-1831">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1831">&#182;</a>
              </div>
              <p>localStorage can be disabled on WebKit/Gecko so make a dummy storage</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!hasOldIEDataSupport) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params">end</span>) </span>{
        <span class="hljs-keyword">var</span> value, nextPos;

        nextPos = end !== <span class="hljs-literal">undefined</span> ? pos + end : data.indexOf(<span class="hljs-string">','</span>, pos);
        <span class="hljs-keyword">if</span> (nextPos === <span class="hljs-number">-1</span> || nextPos &gt; data.length) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        value = data.substring(pos, nextPos);
        pos = nextPos + <span class="hljs-number">1</span>;

        <span class="hljs-keyword">return</span> value;
      }

      storageElm.load(userDataKey);
      data = storageElm.getAttribute(userDataKey) || <span class="hljs-string">''</span>;

      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">var</span> offset = next();
        <span class="hljs-keyword">if</span> (offset === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">break</span>;
        }

        key = next(<span class="hljs-built_in">parseInt</span>(offset, <span class="hljs-number">32</span>) || <span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (key !== <span class="hljs-literal">null</span>) {
          offset = next();
          <span class="hljs-keyword">if</span> (offset === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">break</span>;
          }

          value = next(<span class="hljs-built_in">parseInt</span>(offset, <span class="hljs-number">32</span>) || <span class="hljs-number">0</span>);

          <span class="hljs-keyword">if</span> (key) {
            items[key] = value;
          }
        }
      } <span class="hljs-keyword">while</span> (key !== <span class="hljs-literal">null</span>);

      updateKeys();
    }

    <span class="hljs-comment">/**
     * Saves the items structure into a the userData format.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> value, data = <span class="hljs-string">''</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1832">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1832">&#182;</a>
              </div>
              <p>localStorage can be disabled on WebKit/Gecko so make a dummy storage</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!hasOldIEDataSupport) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> items) {
        value = items[key];
        data += (data ? <span class="hljs-string">','</span> : <span class="hljs-string">''</span>) + key.length.toString(<span class="hljs-number">32</span>) + <span class="hljs-string">','</span> + key + <span class="hljs-string">','</span> + value.length.toString(<span class="hljs-number">32</span>) + <span class="hljs-string">','</span> + value;
      }

      storageElm.setAttribute(userDataKey, data);

      <span class="hljs-keyword">try</span> {
        storageElm.save(userDataKey);
      } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1833">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1833">&#182;</a>
              </div>
              <p>Ignore disk full</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      }

      updateKeys();
    }

    LocalStorage = {
      <span class="hljs-comment">/**
       * Length of the number of items in storage.
       *
       * @property length
       * @type Number
       * @return {Number} Number of items in storage.
       */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1834">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1834">&#182;</a>
              </div>
              <p>length:0,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-comment">/**
       * Returns the key name by index.
       *
       * @method key
       * @param {Number} index Index of key to return.
       * @return {String} Key value or null if it wasn't found.
       */</span>
      key: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>{
        <span class="hljs-keyword">return</span> keys[index];
      },

      <span class="hljs-comment">/**
       * Returns the value if the specified key or null if it wasn't found.
       *
       * @method getItem
       * @param {String} key Key of item to retrieve.
       * @return {String} Value of the specified item or null if it wasn't found.
       */</span>
      getItem: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
        <span class="hljs-keyword">return</span> key <span class="hljs-keyword">in</span> items ? items[key] : <span class="hljs-literal">null</span>;
      },

      <span class="hljs-comment">/**
       * Sets the value of the specified item by it's key.
       *
       * @method setItem
       * @param {String} key Key of the item to set.
       * @param {String} value Value of the item to set.
       */</span>
      setItem: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) </span>{
        items[key] = <span class="hljs-string">""</span> + value;
        save();
      },

      <span class="hljs-comment">/**
       * Removes the specified item by key.
       *
       * @method removeItem
       * @param {String} key Key of item to remove.
       */</span>
      removeItem: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
        <span class="hljs-keyword">delete</span> items[key];
        save();
      },

      <span class="hljs-comment">/**
       * Removes all items.
       *
       * @method clear
       */</span>
      clear: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        items = {};
        save();
      }
    };

    load();

    <span class="hljs-keyword">return</span> LocalStorage;
  }
);

<span class="hljs-comment">/**
 * Compat.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * TinyMCE core class.
 *
 * @static
 * @class tinymce
 * @borrow-members tinymce.EditorManager
 * @borrow-members tinymce.util.Tools
 */</span>
define(
  <span class="hljs-string">'tinymce.core.api.Compat'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.DOMUtils"</span>,
    <span class="hljs-string">"tinymce.core.dom.EventUtils"</span>,
    <span class="hljs-string">"tinymce.core.dom.ScriptLoader"</span>,
    <span class="hljs-string">"tinymce.core.AddOnManager"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.Env"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">DOMUtils, EventUtils, ScriptLoader, AddOnManager, Tools, Env</span>) </span>{
    <span class="hljs-keyword">var</span> register = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tinymce</span>) </span>{
      <span class="hljs-comment">/**
       * @property {tinymce.dom.DOMUtils} DOM Global DOM instance.
       * @property {tinymce.dom.ScriptLoader} ScriptLoader Global ScriptLoader instance.
       * @property {tinymce.AddOnManager} PluginManager Global PluginManager instance.
       * @property {tinymce.AddOnManager} ThemeManager Global ThemeManager instance.
       */</span>
      tinymce.DOM = DOMUtils.DOM;
      tinymce.ScriptLoader = ScriptLoader.ScriptLoader;
      tinymce.PluginManager = AddOnManager.PluginManager;
      tinymce.ThemeManager = AddOnManager.ThemeManager;

      tinymce.dom = tinymce.dom || {};
      tinymce.dom.Event = EventUtils.Event;

      Tools.each(
        <span class="hljs-string">'trim isArray is toArray makeMap each map grep inArray extend create walk createNS resolve explode _addCacheSuffix'</span>.split(<span class="hljs-string">' '</span>),
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
          tinymce[key] = Tools[key];
        }
      );

      Tools.each(<span class="hljs-string">'isOpera isWebKit isIE isGecko isMac'</span>.split(<span class="hljs-string">' '</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        tinymce[name] = Env[name.substr(<span class="hljs-number">2</span>).toLowerCase()];
      });
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">register</span>: register
    };
  }
);</pre></div></div>
            
        </li>
        
        
        <li id="section-1835">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1835">&#182;</a>
              </div>
              <p>Describe the different namespaces</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-comment">/**
 * Root level namespace this contains classes directly related to the TinyMCE editor.
 *
 * @namespace tinymce
 */</span>

<span class="hljs-comment">/**
 * Contains classes for handling the browsers DOM.
 *
 * @namespace tinymce.dom
 */</span>

<span class="hljs-comment">/**
 * Contains html parser and serializer logic.
 *
 * @namespace tinymce.html
 */</span>

<span class="hljs-comment">/**
 * Contains the different UI types such as buttons, listboxes etc.
 *
 * @namespace tinymce.ui
 */</span>

<span class="hljs-comment">/**
 * Contains various utility classes such as json parser, cookies etc.
 *
 * @namespace tinymce.util
 */</span>

<span class="hljs-comment">/**
 * Contains modules to handle data binding.
 *
 * @namespace tinymce.data
 */</span>

<span class="hljs-comment">/**
 * Color.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class lets you parse/serialize colors and convert rgb/hsb.
 *
 * @class tinymce.util.Color
 * @example
 * var white = new tinymce.util.Color({r: 255, g: 255, b: 255});
 * var red = new tinymce.util.Color('#FF0000');
 *
 * console.log(white.toHex(), red.toHsv());
 */</span>
define(
  <span class="hljs-string">'tinymce.core.util.Color'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> min = <span class="hljs-built_in">Math</span>.min, max = <span class="hljs-built_in">Math</span>.max, round = <span class="hljs-built_in">Math</span>.round;

    <span class="hljs-comment">/**
     * Constructs a new color instance.
     *
     * @constructor
     * @method Color
     * @param {String} value Optional initial value to parse.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Color</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, r = <span class="hljs-number">0</span>, g = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rgb2hsv</span>(<span class="hljs-params">r, g, b</span>) </span>{
        <span class="hljs-keyword">var</span> h, s, v, d, minRGB, maxRGB;

        h = <span class="hljs-number">0</span>;
        s = <span class="hljs-number">0</span>;
        v = <span class="hljs-number">0</span>;
        r = r / <span class="hljs-number">255</span>;
        g = g / <span class="hljs-number">255</span>;
        b = b / <span class="hljs-number">255</span>;

        minRGB = min(r, min(g, b));
        maxRGB = max(r, max(g, b));

        <span class="hljs-keyword">if</span> (minRGB == maxRGB) {
          v = minRGB;

          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">h</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">s</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">v</span>: v * <span class="hljs-number">100</span>
          };
        }

        <span class="hljs-comment">/*eslint no-nested-ternary:0 */</span>
        d = (r == minRGB) ? g - b : ((b == minRGB) ? r - g : b - r);
        h = (r == minRGB) ? <span class="hljs-number">3</span> : ((b == minRGB) ? <span class="hljs-number">1</span> : <span class="hljs-number">5</span>);
        h = <span class="hljs-number">60</span> * (h - d / (maxRGB - minRGB));
        s = (maxRGB - minRGB) / maxRGB;
        v = maxRGB;

        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">h</span>: round(h),
          <span class="hljs-attr">s</span>: round(s * <span class="hljs-number">100</span>),
          <span class="hljs-attr">v</span>: round(v * <span class="hljs-number">100</span>)
        };
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hsvToRgb</span>(<span class="hljs-params">hue, saturation, brightness</span>) </span>{
        <span class="hljs-keyword">var</span> side, chroma, x, match;

        hue = (<span class="hljs-built_in">parseInt</span>(hue, <span class="hljs-number">10</span>) || <span class="hljs-number">0</span>) % <span class="hljs-number">360</span>;
        saturation = <span class="hljs-built_in">parseInt</span>(saturation, <span class="hljs-number">10</span>) / <span class="hljs-number">100</span>;
        brightness = <span class="hljs-built_in">parseInt</span>(brightness, <span class="hljs-number">10</span>) / <span class="hljs-number">100</span>;
        saturation = max(<span class="hljs-number">0</span>, min(saturation, <span class="hljs-number">1</span>));
        brightness = max(<span class="hljs-number">0</span>, min(brightness, <span class="hljs-number">1</span>));

        <span class="hljs-keyword">if</span> (saturation === <span class="hljs-number">0</span>) {
          r = g = b = round(<span class="hljs-number">255</span> * brightness);
          <span class="hljs-keyword">return</span>;
        }

        side = hue / <span class="hljs-number">60</span>;
        chroma = brightness * saturation;
        x = chroma * (<span class="hljs-number">1</span> - <span class="hljs-built_in">Math</span>.abs(side % <span class="hljs-number">2</span> - <span class="hljs-number">1</span>));
        match = brightness - chroma;

        <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">Math</span>.floor(side)) {
          <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            r = chroma;
            g = x;
            b = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            r = x;
            g = chroma;
            b = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            r = <span class="hljs-number">0</span>;
            g = chroma;
            b = x;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
            r = <span class="hljs-number">0</span>;
            g = x;
            b = chroma;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
            r = x;
            g = <span class="hljs-number">0</span>;
            b = chroma;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
            r = chroma;
            g = <span class="hljs-number">0</span>;
            b = x;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">default</span>:
            r = g = b = <span class="hljs-number">0</span>;
        }

        r = round(<span class="hljs-number">255</span> * (r + match));
        g = round(<span class="hljs-number">255</span> * (g + match));
        b = round(<span class="hljs-number">255</span> * (b + match));
      }

      <span class="hljs-comment">/**
       * Returns the hex string of the current color. For example: #ff00ff
       *
       * @method toHex
       * @return {String} Hex string of current color.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toHex</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hex</span>(<span class="hljs-params">val</span>) </span>{
          val = <span class="hljs-built_in">parseInt</span>(val, <span class="hljs-number">10</span>).toString(<span class="hljs-number">16</span>);

          <span class="hljs-keyword">return</span> val.length &gt; <span class="hljs-number">1</span> ? val : <span class="hljs-string">'0'</span> + val;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-string">'#'</span> + hex(r) + hex(g) + hex(b);
      }

      <span class="hljs-comment">/**
       * Returns the r, g, b values of the color. Each channel has a range from 0-255.
       *
       * @method toRgb
       * @return {Object} Object with r, g, b fields.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toRgb</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">r</span>: r,
          <span class="hljs-attr">g</span>: g,
          <span class="hljs-attr">b</span>: b
        };
      }

      <span class="hljs-comment">/**
       * Returns the h, s, v values of the color. Ranges: h=0-360, s=0-100, v=0-100.
       *
       * @method toHsv
       * @return {Object} Object with h, s, v fields.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toHsv</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> rgb2hsv(r, g, b);
      }

      <span class="hljs-comment">/**
       * Parses the specified value and populates the color instance.
       *
       * Supported format examples:
       *  * rbg(255,0,0)
       *  * #ff0000
       *  * #fff
       *  * {r: 255, g: 0, b: 0}
       *  * {h: 360, s: 100, v: 100}
       *
       * @method parse
       * @param {Object/String} value Color value to parse.
       * @return {tinymce.util.Color} Current color instance.
       */</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">var</span> matches;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'object'</span>) {
          <span class="hljs-keyword">if</span> (<span class="hljs-string">"r"</span> <span class="hljs-keyword">in</span> value) {
            r = value.r;
            g = value.g;
            b = value.b;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"v"</span> <span class="hljs-keyword">in</span> value) {
            hsvToRgb(value.h, value.s, value.v);
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> ((matches = <span class="hljs-regexp">/rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)[^\)]*\)/gi</span>.exec(value))) {
            r = <span class="hljs-built_in">parseInt</span>(matches[<span class="hljs-number">1</span>], <span class="hljs-number">10</span>);
            g = <span class="hljs-built_in">parseInt</span>(matches[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>);
            b = <span class="hljs-built_in">parseInt</span>(matches[<span class="hljs-number">3</span>], <span class="hljs-number">10</span>);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((matches = <span class="hljs-regexp">/#([0-F]{2})([0-F]{2})([0-F]{2})/gi</span>.exec(value))) {
            r = <span class="hljs-built_in">parseInt</span>(matches[<span class="hljs-number">1</span>], <span class="hljs-number">16</span>);
            g = <span class="hljs-built_in">parseInt</span>(matches[<span class="hljs-number">2</span>], <span class="hljs-number">16</span>);
            b = <span class="hljs-built_in">parseInt</span>(matches[<span class="hljs-number">3</span>], <span class="hljs-number">16</span>);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((matches = <span class="hljs-regexp">/#([0-F])([0-F])([0-F])/gi</span>.exec(value))) {
            r = <span class="hljs-built_in">parseInt</span>(matches[<span class="hljs-number">1</span>] + matches[<span class="hljs-number">1</span>], <span class="hljs-number">16</span>);
            g = <span class="hljs-built_in">parseInt</span>(matches[<span class="hljs-number">2</span>] + matches[<span class="hljs-number">2</span>], <span class="hljs-number">16</span>);
            b = <span class="hljs-built_in">parseInt</span>(matches[<span class="hljs-number">3</span>] + matches[<span class="hljs-number">3</span>], <span class="hljs-number">16</span>);
          }
        }

        r = r &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : (r &gt; <span class="hljs-number">255</span> ? <span class="hljs-number">255</span> : r);
        g = g &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : (g &gt; <span class="hljs-number">255</span> ? <span class="hljs-number">255</span> : g);
        b = b &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : (b &gt; <span class="hljs-number">255</span> ? <span class="hljs-number">255</span> : b);

        <span class="hljs-keyword">return</span> self;
      }

      <span class="hljs-keyword">if</span> (value) {
        parse(value);
      }

      self.toRgb = toRgb;
      self.toHsv = toHsv;
      self.toHex = toHex;
      self.parse = parse;
    }

    <span class="hljs-keyword">return</span> Color;
  }
);

<span class="hljs-comment">/**
 * Layout.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Base layout manager class.
 *
 * @class tinymce.ui.Layout
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Layout'</span>,
  [
    <span class="hljs-string">"tinymce.core.util.Class"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Class, Tools</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Class.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">firstControlClass</span>: <span class="hljs-string">'first'</span>,
        <span class="hljs-attr">lastControlClass</span>: <span class="hljs-string">'last'</span>
      },

      <span class="hljs-comment">/**
       * Constructs a layout instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">this</span>.settings = Tools.extend({}, <span class="hljs-keyword">this</span>.Defaults, settings);
      },

      <span class="hljs-comment">/**
       * This method gets invoked before the layout renders the controls.
       *
       * @method preRender
       * @param {tinymce.ui.Container} container Container instance to preRender.
       */</span>
      preRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">container</span>) </span>{
        container.bodyClasses.add(<span class="hljs-keyword">this</span>.settings.containerClass);
      },

      <span class="hljs-comment">/**
       * Applies layout classes to the container.
       *
       * @private
       */</span>
      applyClasses: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, settings = self.settings, firstClass, lastClass, firstItem, lastItem;

        firstClass = settings.firstControlClass;
        lastClass = settings.lastControlClass;

        items.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          item.classes.remove(firstClass).remove(lastClass).add(settings.controlClass);

          <span class="hljs-keyword">if</span> (item.visible()) {
            <span class="hljs-keyword">if</span> (!firstItem) {
              firstItem = item;
            }

            lastItem = item;
          }
        });

        <span class="hljs-keyword">if</span> (firstItem) {
          firstItem.classes.add(firstClass);
        }

        <span class="hljs-keyword">if</span> (lastItem) {
          lastItem.classes.add(lastClass);
        }
      },

      <span class="hljs-comment">/**
       * Renders the specified container and any layout specific HTML.
       *
       * @method renderHtml
       * @param {tinymce.ui.Container} container Container to render HTML for.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">container</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, html = <span class="hljs-string">''</span>;

        self.applyClasses(container.items());

        container.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          html += item.renderHtml();
        });

        <span class="hljs-keyword">return</span> html;
      },

      <span class="hljs-comment">/**
       * Recalculates the positions of the controls in the specified container.
       *
       * @method recalc
       * @param {tinymce.ui.Container} container Container instance to recalc.
       */</span>
      recalc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      },

      <span class="hljs-comment">/**
       * This method gets invoked after the layout renders the controls.
       *
       * @method postRender
       * @param {tinymce.ui.Container} container Container instance to postRender.
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      },

      <span class="hljs-attr">isNative</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    });
  }
);
<span class="hljs-comment">/**
 * AbsoluteLayout.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * LayoutManager for absolute positioning. This layout manager is more of
 * a base class for other layouts but can be created and used directly.
 *
 * @-x-less AbsoluteLayout.less
 * @class tinymce.ui.AbsoluteLayout
 * @extends tinymce.ui.Layout
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.AbsoluteLayout'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Layout"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Layout</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Layout.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">containerClass</span>: <span class="hljs-string">'abs-layout'</span>,
        <span class="hljs-attr">controlClass</span>: <span class="hljs-string">'abs-layout-item'</span>
      },

      <span class="hljs-comment">/**
       * Recalculates the positions of the controls in the specified container.
       *
       * @method recalc
       * @param {tinymce.ui.Container} container Container instance to recalc.
       */</span>
      recalc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">container</span>) </span>{
        container.items().filter(<span class="hljs-string">':visible'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
          <span class="hljs-keyword">var</span> settings = ctrl.settings;

          ctrl.layoutRect({
            <span class="hljs-attr">x</span>: settings.x,
            <span class="hljs-attr">y</span>: settings.y,
            <span class="hljs-attr">w</span>: settings.w,
            <span class="hljs-attr">h</span>: settings.h
          });

          <span class="hljs-keyword">if</span> (ctrl.recalc) {
            ctrl.recalc();
          }
        });
      },

      <span class="hljs-comment">/**
       * Renders the specified container and any layout specific HTML.
       *
       * @method renderHtml
       * @param {tinymce.ui.Container} container Container to render HTML for.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">container</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div id="'</span> + container._id + <span class="hljs-string">'-absend" class="'</span> + container.classPrefix + <span class="hljs-string">'abs-end"&gt;&lt;/div&gt;'</span> + <span class="hljs-keyword">this</span>._super(container);
      }
    });
  }
);
<span class="hljs-comment">/**
 * Button.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class is used to create buttons. You can create them directly or through the Factory.
 *
 * @example
 * // Create and render a button to the body element
 * tinymce.ui.Factory.create({
 *     type: 'button',
 *     text: 'My button'
 * }).renderTo(document.body);
 *
 * @-x-less Button.less
 * @class tinymce.ui.Button
 * @extends tinymce.ui.Widget
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Button'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">classes</span>: <span class="hljs-string">"widget btn"</span>,
        <span class="hljs-attr">role</span>: <span class="hljs-string">"button"</span>
      },

      <span class="hljs-comment">/**
       * Constructs a new button instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {String} size Size of the button small|medium|large.
       * @setting {String} image Image to use for icon.
       * @setting {String} icon Icon to use for button.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, size;

        self._super(settings);
        settings = self.settings;

        size = self.settings.size;

        self.on(<span class="hljs-string">'click mousedown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          e.preventDefault();
        });

        self.on(<span class="hljs-string">'touchstart'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.fire(<span class="hljs-string">'click'</span>, e);
          e.preventDefault();
        });

        <span class="hljs-keyword">if</span> (settings.subtype) {
          self.classes.add(settings.subtype);
        }

        <span class="hljs-keyword">if</span> (size) {
          self.classes.add(<span class="hljs-string">'btn-'</span> + size);
        }

        <span class="hljs-keyword">if</span> (settings.icon) {
          self.icon(settings.icon);
        }
      },

      <span class="hljs-comment">/**
       * Sets/gets the current button icon.
       *
       * @method icon
       * @param {String} [icon] New icon identifier.
       * @return {String|tinymce.ui.MenuButton} Current icon or current MenuButton instance.
       */</span>
      icon: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">icon</span>) </span>{
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">arguments</span>.length) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.get(<span class="hljs-string">'icon'</span>);
        }

        <span class="hljs-keyword">this</span>.state.set(<span class="hljs-string">'icon'</span>, icon);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Repaints the button for example after it's been resizes by a layout engine.
       *
       * @method repaint
       */</span>
      repaint: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> btnElm = <span class="hljs-keyword">this</span>.getEl().firstChild,
          btnStyle;

        <span class="hljs-keyword">if</span> (btnElm) {
          btnStyle = btnElm.style;
          btnStyle.width = btnStyle.height = <span class="hljs-string">"100%"</span>;
        }

        <span class="hljs-keyword">this</span>._super();
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, id = self._id, prefix = self.classPrefix;
        <span class="hljs-keyword">var</span> icon = self.state.get(<span class="hljs-string">'icon'</span>), image, text = self.state.get(<span class="hljs-string">'text'</span>), textHtml = <span class="hljs-string">''</span>;

        image = self.settings.image;
        <span class="hljs-keyword">if</span> (image) {
          icon = <span class="hljs-string">'none'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1836">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1836">&#182;</a>
              </div>
              <p>Support for [high dpi, low dpi] image sources</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> image != <span class="hljs-string">"string"</span>) {
            image = <span class="hljs-built_in">window</span>.getSelection ? image[<span class="hljs-number">0</span>] : image[<span class="hljs-number">1</span>];
          }

          image = <span class="hljs-string">' style="background-image: url(\''</span> + image + <span class="hljs-string">'\')"'</span>;
        } <span class="hljs-keyword">else</span> {
          image = <span class="hljs-string">''</span>;
        }

        <span class="hljs-keyword">if</span> (text) {
          self.classes.add(<span class="hljs-string">'btn-has-text'</span>);
          textHtml = <span class="hljs-string">'&lt;span class="'</span> + prefix + <span class="hljs-string">'txt"&gt;'</span> + self.encode(text) + <span class="hljs-string">'&lt;/span&gt;'</span>;
        }

        icon = icon ? prefix + <span class="hljs-string">'ico '</span> + prefix + <span class="hljs-string">'i-'</span> + icon : <span class="hljs-string">''</span>;

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'" tabindex="-1"&gt;'</span> +
          <span class="hljs-string">'&lt;button role="presentation" type="button" tabindex="-1"&gt;'</span> +
          (icon ? <span class="hljs-string">'&lt;i class="'</span> + icon + <span class="hljs-string">'"'</span> + image + <span class="hljs-string">'&gt;&lt;/i&gt;'</span> : <span class="hljs-string">''</span>) +
          textHtml +
          <span class="hljs-string">'&lt;/button&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, $ = self.$, textCls = self.classPrefix + <span class="hljs-string">'txt'</span>;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setButtonText</span>(<span class="hljs-params">text</span>) </span>{
          <span class="hljs-keyword">var</span> $span = $(<span class="hljs-string">'span.'</span> + textCls, self.getEl());

          <span class="hljs-keyword">if</span> (text) {
            <span class="hljs-keyword">if</span> (!$span[<span class="hljs-number">0</span>]) {
              $(<span class="hljs-string">'button:first'</span>, self.getEl()).append(<span class="hljs-string">'&lt;span class="'</span> + textCls + <span class="hljs-string">'"&gt;&lt;/span&gt;'</span>);
              $span = $(<span class="hljs-string">'span.'</span> + textCls, self.getEl());
            }

            $span.html(self.encode(text));
          } <span class="hljs-keyword">else</span> {
            $span.remove();
          }

          self.classes.toggle(<span class="hljs-string">'btn-has-text'</span>, !!text);
        }

        self.state.on(<span class="hljs-string">'change:text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          setButtonText(e.value);
        });

        self.state.on(<span class="hljs-string">'change:icon'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> icon = e.value, prefix = self.classPrefix;

          self.settings.icon = icon;
          icon = icon ? prefix + <span class="hljs-string">'ico '</span> + prefix + <span class="hljs-string">'i-'</span> + self.settings.icon : <span class="hljs-string">''</span>;

          <span class="hljs-keyword">var</span> btnElm = self.getEl().firstChild, iconElm = btnElm.getElementsByTagName(<span class="hljs-string">'i'</span>)[<span class="hljs-number">0</span>];

          <span class="hljs-keyword">if</span> (icon) {
            <span class="hljs-keyword">if</span> (!iconElm || iconElm != btnElm.firstChild) {
              iconElm = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'i'</span>);
              btnElm.insertBefore(iconElm, btnElm.firstChild);
            }

            iconElm.className = icon;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (iconElm) {
            btnElm.removeChild(iconElm);
          }

          setButtonText(self.state.get(<span class="hljs-string">'text'</span>));
        });

        <span class="hljs-keyword">return</span> self._super();
      }
    });
  }
);

<span class="hljs-comment">/**
 * ButtonGroup.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This control enables you to put multiple buttons into a group. This is
 * useful when you want to combine similar toolbar buttons into a group.
 *
 * @example
 * // Create and render a buttongroup with two buttons to the body element
 * tinymce.ui.Factory.create({
 *     type: 'buttongroup',
 *     items: [
 *         {text: 'Button A'},
 *         {text: 'Button B'}
 *     ]
 * }).renderTo(document.body);
 *
 * @-x-less ButtonGroup.less
 * @class tinymce.ui.ButtonGroup
 * @extends tinymce.ui.Container
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.ButtonGroup'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Container"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Container</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Container.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">defaultType</span>: <span class="hljs-string">'button'</span>,
        <span class="hljs-attr">role</span>: <span class="hljs-string">'group'</span>
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, layout = self._layout;

        self.classes.add(<span class="hljs-string">'btn-group'</span>);
        self.preRender();
        layout.preRender(self);

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'"&gt;'</span> +
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'-body"&gt;'</span> +
          (self.settings.html || <span class="hljs-string">''</span>) + layout.renderHtml(self) +
          <span class="hljs-string">'&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      }
    });
  }
);
<span class="hljs-comment">/**
 * Checkbox.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This control creates a custom checkbox.
 *
 * @example
 * // Create and render a checkbox to the body element
 * tinymce.ui.Factory.create({
 *     type: 'checkbox',
 *     checked: true,
 *     text: 'My checkbox'
 * }).renderTo(document.body);
 *
 * @-x-less Checkbox.less
 * @class tinymce.ui.Checkbox
 * @extends tinymce.ui.Widget
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Checkbox'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">classes</span>: <span class="hljs-string">"checkbox"</span>,
        <span class="hljs-attr">role</span>: <span class="hljs-string">"checkbox"</span>,
        <span class="hljs-attr">checked</span>: <span class="hljs-literal">false</span>
      },

      <span class="hljs-comment">/**
       * Constructs a new Checkbox instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {Boolean} checked True if the checkbox should be checked by default.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super(settings);

        self.on(<span class="hljs-string">'click mousedown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          e.preventDefault();
        });

        self.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          e.preventDefault();

          <span class="hljs-keyword">if</span> (!self.disabled()) {
            self.checked(!self.checked());
          }
        });

        self.checked(self.settings.checked);
      },

      <span class="hljs-comment">/**
       * Getter/setter function for the checked state.
       *
       * @method checked
       * @param {Boolean} [state] State to be set.
       * @return {Boolean|tinymce.ui.Checkbox} True/false or checkbox if it's a set operation.
       */</span>
      checked: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">arguments</span>.length) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.get(<span class="hljs-string">'checked'</span>);
        }

        <span class="hljs-keyword">this</span>.state.set(<span class="hljs-string">'checked'</span>, state);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Getter/setter function for the value state.
       *
       * @method value
       * @param {Boolean} [state] State to be set.
       * @return {Boolean|tinymce.ui.Checkbox} True/false or checkbox if it's a set operation.
       */</span>
      value: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">arguments</span>.length) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.checked();
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.checked(state);
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, id = self._id, prefix = self.classPrefix;

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'" unselectable="on" aria-labelledby="'</span> + id + <span class="hljs-string">'-al" tabindex="-1"&gt;'</span> +
          <span class="hljs-string">'&lt;i class="'</span> + prefix + <span class="hljs-string">'ico '</span> + prefix + <span class="hljs-string">'i-checkbox"&gt;&lt;/i&gt;'</span> +
          <span class="hljs-string">'&lt;span id="'</span> + id + <span class="hljs-string">'-al" class="'</span> + prefix + <span class="hljs-string">'label"&gt;'</span> + self.encode(self.state.get(<span class="hljs-string">'text'</span>)) + <span class="hljs-string">'&lt;/span&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checked</span>(<span class="hljs-params">state</span>) </span>{
          self.classes.toggle(<span class="hljs-string">"checked"</span>, state);
          self.aria(<span class="hljs-string">'checked'</span>, state);
        }

        self.state.on(<span class="hljs-string">'change:text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.getEl(<span class="hljs-string">'al'</span>).firstChild.data = self.translate(e.value);
        });

        self.state.on(<span class="hljs-string">'change:checked change:value'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.fire(<span class="hljs-string">'change'</span>);
          checked(e.value);
        });

        self.state.on(<span class="hljs-string">'change:icon'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> icon = e.value, prefix = self.classPrefix;

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> icon == <span class="hljs-string">'undefined'</span>) {
            <span class="hljs-keyword">return</span> self.settings.icon;
          }

          self.settings.icon = icon;
          icon = icon ? prefix + <span class="hljs-string">'ico '</span> + prefix + <span class="hljs-string">'i-'</span> + self.settings.icon : <span class="hljs-string">''</span>;

          <span class="hljs-keyword">var</span> btnElm = self.getEl().firstChild, iconElm = btnElm.getElementsByTagName(<span class="hljs-string">'i'</span>)[<span class="hljs-number">0</span>];

          <span class="hljs-keyword">if</span> (icon) {
            <span class="hljs-keyword">if</span> (!iconElm || iconElm != btnElm.firstChild) {
              iconElm = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'i'</span>);
              btnElm.insertBefore(iconElm, btnElm.firstChild);
            }

            iconElm.className = icon;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (iconElm) {
            btnElm.removeChild(iconElm);
          }
        });

        <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'checked'</span>)) {
          checked(<span class="hljs-literal">true</span>);
        }

        <span class="hljs-keyword">return</span> self._super();
      }
    });
  }
);
<span class="hljs-comment">/**
 * ComboBox.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class creates a combobox control. Select box that you select a value from or
 * type a value into.
 *
 * @-x-less ComboBox.less
 * @class tinymce.ui.ComboBox
 * @extends tinymce.ui.Widget
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.ComboBox'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>,
    <span class="hljs-string">"tinymce.core.ui.Factory"</span>,
    <span class="hljs-string">"tinymce.core.ui.DomUtils"</span>,
    <span class="hljs-string">"tinymce.core.dom.DomQuery"</span>,
    <span class="hljs-string">"tinymce.core.util.VK"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget, Factory, DomUtils, $, VK, Tools</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-comment">/**
       * Constructs a new control instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {String} placeholder Placeholder text to display.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super(settings);
        settings = self.settings;

        self.classes.add(<span class="hljs-string">'combobox'</span>);
        self.subinput = <span class="hljs-literal">true</span>;
        self.ariaTarget = <span class="hljs-string">'inp'</span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Figure out a better way</span>

        settings.menu = settings.menu || settings.values;

        <span class="hljs-keyword">if</span> (settings.menu) {
          settings.icon = <span class="hljs-string">'caret'</span>;
        }

        self.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> elm = e.target, root = self.getEl();

          <span class="hljs-keyword">if</span> (!$.contains(root, elm) &amp;&amp; elm != root) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">while</span> (elm &amp;&amp; elm != root) {
            <span class="hljs-keyword">if</span> (elm.id &amp;&amp; elm.id.indexOf(<span class="hljs-string">'-open'</span>) != <span class="hljs-number">-1</span>) {
              self.fire(<span class="hljs-string">'action'</span>);

              <span class="hljs-keyword">if</span> (settings.menu) {
                self.showMenu();

                <span class="hljs-keyword">if</span> (e.aria) {
                  self.menu.items()[<span class="hljs-number">0</span>].focus();
                }
              }
            }

            elm = elm.parentNode;
          }
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-1837">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1837">&#182;</a>
              </div>
              <p>TODO: Rework this</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> rootControl;

          <span class="hljs-keyword">if</span> (e.keyCode == <span class="hljs-number">13</span> &amp;&amp; e.target.nodeName === <span class="hljs-string">'INPUT'</span>) {
            e.preventDefault();</pre></div></div>
            
        </li>
        
        
        <li id="section-1838">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1838">&#182;</a>
              </div>
              <p>Find root control that we can do toJSON on</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            self.parents().reverse().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
              <span class="hljs-keyword">if</span> (ctrl.toJSON) {
                rootControl = ctrl;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-1839">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1839">&#182;</a>
              </div>
              <p>Fire event on current text box with the serialized data of the whole form</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            self.fire(<span class="hljs-string">'submit'</span>, { <span class="hljs-attr">data</span>: rootControl.toJSON() });
          }
        });

        self.on(<span class="hljs-string">'keyup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (e.target.nodeName == <span class="hljs-string">"INPUT"</span>) {
            <span class="hljs-keyword">var</span> oldValue = self.state.get(<span class="hljs-string">'value'</span>);
            <span class="hljs-keyword">var</span> newValue = e.target.value;

            <span class="hljs-keyword">if</span> (newValue !== oldValue) {
              self.state.set(<span class="hljs-string">'value'</span>, newValue);
              self.fire(<span class="hljs-string">'autocomplete'</span>, e);
            }
          }
        });

        self.on(<span class="hljs-string">'mouseover'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> tooltip = self.tooltip().moveTo(<span class="hljs-number">-0xFFFF</span>);

          <span class="hljs-keyword">if</span> (self.statusLevel() &amp;&amp; e.target.className.indexOf(self.classPrefix + <span class="hljs-string">'status'</span>) !== <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">var</span> statusMessage = self.statusMessage() || <span class="hljs-string">'Ok'</span>;
            <span class="hljs-keyword">var</span> rel = tooltip.text(statusMessage).show().testMoveRel(e.target, [<span class="hljs-string">'bc-tc'</span>, <span class="hljs-string">'bc-tl'</span>, <span class="hljs-string">'bc-tr'</span>]);

            tooltip.classes.toggle(<span class="hljs-string">'tooltip-n'</span>, rel == <span class="hljs-string">'bc-tc'</span>);
            tooltip.classes.toggle(<span class="hljs-string">'tooltip-nw'</span>, rel == <span class="hljs-string">'bc-tl'</span>);
            tooltip.classes.toggle(<span class="hljs-string">'tooltip-ne'</span>, rel == <span class="hljs-string">'bc-tr'</span>);

            tooltip.moveRel(e.target, rel);
          }
        });
      },

      <span class="hljs-attr">statusLevel</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">this</span>.state.set(<span class="hljs-string">'statusLevel'</span>, value);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.get(<span class="hljs-string">'statusLevel'</span>);
      },

      <span class="hljs-attr">statusMessage</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">this</span>.state.set(<span class="hljs-string">'statusMessage'</span>, value);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.get(<span class="hljs-string">'statusMessage'</span>);
      },

      <span class="hljs-attr">showMenu</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, settings = self.settings, menu;

        <span class="hljs-keyword">if</span> (!self.menu) {
          menu = settings.menu || [];</pre></div></div>
            
        </li>
        
        
        <li id="section-1840">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1840">&#182;</a>
              </div>
              <p>Is menu array then auto constuct menu control</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (menu.length) {
            menu = {
              <span class="hljs-attr">type</span>: <span class="hljs-string">'menu'</span>,
              <span class="hljs-attr">items</span>: menu
            };
          } <span class="hljs-keyword">else</span> {
            menu.type = menu.type || <span class="hljs-string">'menu'</span>;
          }

          self.menu = Factory.create(menu).parent(self).renderTo(self.getContainerElm());
          self.fire(<span class="hljs-string">'createmenu'</span>);
          self.menu.reflow();
          self.menu.on(<span class="hljs-string">'cancel'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">if</span> (e.control === self.menu) {
              self.focus();
            }
          });

          self.menu.on(<span class="hljs-string">'show hide'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            e.control.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
              ctrl.active(ctrl.value() == self.value());
            });
          }).fire(<span class="hljs-string">'show'</span>);

          self.menu.on(<span class="hljs-string">'select'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            self.value(e.control.value());
          });

          self.on(<span class="hljs-string">'focusin'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">if</span> (e.target.tagName.toUpperCase() == <span class="hljs-string">'INPUT'</span>) {
              self.menu.hide();
            }
          });

          self.aria(<span class="hljs-string">'expanded'</span>, <span class="hljs-literal">true</span>);
        }

        self.menu.show();
        self.menu.layoutRect({ <span class="hljs-attr">w</span>: self.layoutRect().w });
        self.menu.moveRel(self.getEl(), self.isRtl() ? [<span class="hljs-string">'br-tr'</span>, <span class="hljs-string">'tr-br'</span>] : [<span class="hljs-string">'bl-tl'</span>, <span class="hljs-string">'tl-bl'</span>]);
      },

      <span class="hljs-comment">/**
       * Focuses the input area of the control.
       *
       * @method focus
       */</span>
      focus: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.getEl(<span class="hljs-string">'inp'</span>).focus();
      },

      <span class="hljs-comment">/**
       * Repaints the control after a layout operation.
       *
       * @method repaint
       */</span>
      repaint: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, elm = self.getEl(), openElm = self.getEl(<span class="hljs-string">'open'</span>), rect = self.layoutRect();
        <span class="hljs-keyword">var</span> width, lineHeight, innerPadding = <span class="hljs-number">0</span>, inputElm = elm.firstChild;

        <span class="hljs-keyword">if</span> (self.statusLevel() &amp;&amp; self.statusLevel() !== <span class="hljs-string">'none'</span>) {
          innerPadding = (
            <span class="hljs-built_in">parseInt</span>(DomUtils.getRuntimeStyle(inputElm, <span class="hljs-string">'padding-right'</span>), <span class="hljs-number">10</span>) -
            <span class="hljs-built_in">parseInt</span>(DomUtils.getRuntimeStyle(inputElm, <span class="hljs-string">'padding-left'</span>), <span class="hljs-number">10</span>)
          );
        }

        <span class="hljs-keyword">if</span> (openElm) {
          width = rect.w - DomUtils.getSize(openElm).width - <span class="hljs-number">10</span>;
        } <span class="hljs-keyword">else</span> {
          width = rect.w - <span class="hljs-number">10</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1841">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1841">&#182;</a>
              </div>
              <p>Detect old IE 7+8 add lineHeight to align caret vertically in the middle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> doc = <span class="hljs-built_in">document</span>;
        <span class="hljs-keyword">if</span> (doc.all &amp;&amp; (!doc.documentMode || doc.documentMode &lt;= <span class="hljs-number">8</span>)) {
          lineHeight = (self.layoutRect().h - <span class="hljs-number">2</span>) + <span class="hljs-string">'px'</span>;
        }

        $(inputElm).css({
          <span class="hljs-attr">width</span>: width - innerPadding,
          <span class="hljs-attr">lineHeight</span>: lineHeight
        });

        self._super();

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Post render method. Called after the control has been rendered to the target.
       *
       * @method postRender
       * @return {tinymce.ui.ComboBox} Current combobox instance.
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        $(<span class="hljs-keyword">this</span>.getEl(<span class="hljs-string">'inp'</span>)).on(<span class="hljs-string">'change'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.state.set(<span class="hljs-string">'value'</span>, e.target.value);
          self.fire(<span class="hljs-string">'change'</span>, e);
        });

        <span class="hljs-keyword">return</span> self._super();
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, id = self._id, settings = self.settings, prefix = self.classPrefix;
        <span class="hljs-keyword">var</span> value = self.state.get(<span class="hljs-string">'value'</span>) || <span class="hljs-string">''</span>;
        <span class="hljs-keyword">var</span> icon, text, openBtnHtml = <span class="hljs-string">''</span>, extraAttrs = <span class="hljs-string">''</span>, statusHtml = <span class="hljs-string">''</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-string">"spellcheck"</span> <span class="hljs-keyword">in</span> settings) {
          extraAttrs += <span class="hljs-string">' spellcheck="'</span> + settings.spellcheck + <span class="hljs-string">'"'</span>;
        }

        <span class="hljs-keyword">if</span> (settings.maxLength) {
          extraAttrs += <span class="hljs-string">' maxlength="'</span> + settings.maxLength + <span class="hljs-string">'"'</span>;
        }

        <span class="hljs-keyword">if</span> (settings.size) {
          extraAttrs += <span class="hljs-string">' size="'</span> + settings.size + <span class="hljs-string">'"'</span>;
        }

        <span class="hljs-keyword">if</span> (settings.subtype) {
          extraAttrs += <span class="hljs-string">' type="'</span> + settings.subtype + <span class="hljs-string">'"'</span>;
        }

        statusHtml = <span class="hljs-string">'&lt;i id="'</span> + id + <span class="hljs-string">'-status" class="mce-status mce-ico" style="display: none"&gt;&lt;/i&gt;'</span>;

        <span class="hljs-keyword">if</span> (self.disabled()) {
          extraAttrs += <span class="hljs-string">' disabled="disabled"'</span>;
        }

        icon = settings.icon;
        <span class="hljs-keyword">if</span> (icon &amp;&amp; icon != <span class="hljs-string">'caret'</span>) {
          icon = prefix + <span class="hljs-string">'ico '</span> + prefix + <span class="hljs-string">'i-'</span> + settings.icon;
        }

        text = self.state.get(<span class="hljs-string">'text'</span>);

        <span class="hljs-keyword">if</span> (icon || text) {
          openBtnHtml = (
            <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'-open" class="'</span> + prefix + <span class="hljs-string">'btn '</span> + prefix + <span class="hljs-string">'open" tabIndex="-1" role="button"&gt;'</span> +
            <span class="hljs-string">'&lt;button id="'</span> + id + <span class="hljs-string">'-action" type="button" hidefocus="1" tabindex="-1"&gt;'</span> +
            (icon != <span class="hljs-string">'caret'</span> ? <span class="hljs-string">'&lt;i class="'</span> + icon + <span class="hljs-string">'"&gt;&lt;/i&gt;'</span> : <span class="hljs-string">'&lt;i class="'</span> + prefix + <span class="hljs-string">'caret"&gt;&lt;/i&gt;'</span>) +
            (text ? (icon ? <span class="hljs-string">' '</span> : <span class="hljs-string">''</span>) + text : <span class="hljs-string">''</span>) +
            <span class="hljs-string">'&lt;/button&gt;'</span> +
            <span class="hljs-string">'&lt;/div&gt;'</span>
          );

          self.classes.add(<span class="hljs-string">'has-open'</span>);
        }

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'"&gt;'</span> +
          <span class="hljs-string">'&lt;input id="'</span> + id + <span class="hljs-string">'-inp" class="'</span> + prefix + <span class="hljs-string">'textbox" value="'</span> +
          self.encode(value, <span class="hljs-literal">false</span>) + <span class="hljs-string">'" hidefocus="1"'</span> + extraAttrs + <span class="hljs-string">' placeholder="'</span> +
          self.encode(settings.placeholder) + <span class="hljs-string">'" /&gt;'</span> +
          statusHtml +
          openBtnHtml +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length) {
          <span class="hljs-keyword">this</span>.state.set(<span class="hljs-string">'value'</span>, value);
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1842">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1842">&#182;</a>
              </div>
              <p>Make sure the real state is in sync</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.get(<span class="hljs-string">'rendered'</span>)) {
          <span class="hljs-keyword">this</span>.state.set(<span class="hljs-string">'value'</span>, <span class="hljs-keyword">this</span>.getEl(<span class="hljs-string">'inp'</span>).value);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.get(<span class="hljs-string">'value'</span>);
      },

      <span class="hljs-attr">showAutoComplete</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items, term</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (items.length === <span class="hljs-number">0</span>) {
          self.hideMenu();
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> insert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, title</span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            self.fire(<span class="hljs-string">'selectitem'</span>, {
              <span class="hljs-attr">title</span>: title,
              <span class="hljs-attr">value</span>: value
            });
          };
        };

        <span class="hljs-keyword">if</span> (self.menu) {
          self.menu.items().remove();
        } <span class="hljs-keyword">else</span> {
          self.menu = Factory.create({
            <span class="hljs-attr">type</span>: <span class="hljs-string">'menu'</span>,
            <span class="hljs-attr">classes</span>: <span class="hljs-string">'combobox-menu'</span>,
            <span class="hljs-attr">layout</span>: <span class="hljs-string">'flow'</span>
          }).parent(self).renderTo();
        }

        Tools.each(items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          self.menu.add({
            <span class="hljs-attr">text</span>: item.title,
            <span class="hljs-attr">url</span>: item.previewUrl,
            <span class="hljs-attr">match</span>: term,
            <span class="hljs-attr">classes</span>: <span class="hljs-string">'menu-item-ellipsis'</span>,
            <span class="hljs-attr">onclick</span>: insert(item.value, item.title)
          });
        });

        self.menu.renderNew();
        self.hideMenu();

        self.menu.on(<span class="hljs-string">'cancel'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (e.control.parent() === self.menu) {
            e.stopPropagation();
            self.focus();
            self.hideMenu();
          }
        });

        self.menu.on(<span class="hljs-string">'select'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          self.focus();
        });

        <span class="hljs-keyword">var</span> maxW = self.layoutRect().w;
        self.menu.layoutRect({ <span class="hljs-attr">w</span>: maxW, <span class="hljs-attr">minW</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">maxW</span>: maxW });
        self.menu.reflow();
        self.menu.show();
        self.menu.moveRel(self.getEl(), self.isRtl() ? [<span class="hljs-string">'br-tr'</span>, <span class="hljs-string">'tr-br'</span>] : [<span class="hljs-string">'bl-tl'</span>, <span class="hljs-string">'tl-bl'</span>]);
      },

      <span class="hljs-attr">hideMenu</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.menu) {
          <span class="hljs-keyword">this</span>.menu.hide();
        }
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.state.on(<span class="hljs-string">'change:value'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (self.getEl(<span class="hljs-string">'inp'</span>).value != e.value) {
            self.getEl(<span class="hljs-string">'inp'</span>).value = e.value;
          }
        });

        self.state.on(<span class="hljs-string">'change:disabled'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.getEl(<span class="hljs-string">'inp'</span>).disabled = e.value;
        });

        self.state.on(<span class="hljs-string">'change:statusLevel'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> statusIconElm = self.getEl(<span class="hljs-string">'status'</span>);
          <span class="hljs-keyword">var</span> prefix = self.classPrefix, value = e.value;

          DomUtils.css(statusIconElm, <span class="hljs-string">'display'</span>, value === <span class="hljs-string">'none'</span> ? <span class="hljs-string">'none'</span> : <span class="hljs-string">''</span>);
          DomUtils.toggleClass(statusIconElm, prefix + <span class="hljs-string">'i-checkmark'</span>, value === <span class="hljs-string">'ok'</span>);
          DomUtils.toggleClass(statusIconElm, prefix + <span class="hljs-string">'i-warning'</span>, value === <span class="hljs-string">'warn'</span>);
          DomUtils.toggleClass(statusIconElm, prefix + <span class="hljs-string">'i-error'</span>, value === <span class="hljs-string">'error'</span>);
          self.classes.toggle(<span class="hljs-string">'has-status'</span>, value !== <span class="hljs-string">'none'</span>);
          self.repaint();
        });

        DomUtils.on(self.getEl(<span class="hljs-string">'status'</span>), <span class="hljs-string">'mouseleave'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          self.tooltip().hide();
        });

        self.on(<span class="hljs-string">'cancel'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (self.menu &amp;&amp; self.menu.visible()) {
            e.stopPropagation();
            self.hideMenu();
          }
        });

        <span class="hljs-keyword">var</span> focusIdx = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">idx, menu</span>) </span>{
          <span class="hljs-keyword">if</span> (menu &amp;&amp; menu.items().length &gt; <span class="hljs-number">0</span>) {
            menu.items().eq(idx)[<span class="hljs-number">0</span>].focus();
          }
        };

        self.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> keyCode = e.keyCode;

          <span class="hljs-keyword">if</span> (e.target.nodeName === <span class="hljs-string">'INPUT'</span>) {
            <span class="hljs-keyword">if</span> (keyCode === VK.DOWN) {
              e.preventDefault();
              self.fire(<span class="hljs-string">'autocomplete'</span>);
              focusIdx(<span class="hljs-number">0</span>, self.menu);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keyCode === VK.UP) {
              e.preventDefault();
              focusIdx(<span class="hljs-number">-1</span>, self.menu);
            }
          }
        });

        <span class="hljs-keyword">return</span> self._super();
      },

      <span class="hljs-attr">remove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        $(<span class="hljs-keyword">this</span>.getEl(<span class="hljs-string">'inp'</span>)).off();

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.menu) {
          <span class="hljs-keyword">this</span>.menu.remove();
        }

        <span class="hljs-keyword">this</span>._super();
      }
    });
  }
);
<span class="hljs-comment">/**
 * ColorBox.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This widget lets you enter colors and browse for colors by pressing the color button. It also displays
 * a preview of the current color.
 *
 * @-x-less ColorBox.less
 * @class tinymce.ui.ColorBox
 * @extends tinymce.ui.ComboBox
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.ColorBox'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.ComboBox"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ComboBox</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> ComboBox.extend({
      <span class="hljs-comment">/**
       * Constructs a new control instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        settings.spellcheck = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (settings.onaction) {
          settings.icon = <span class="hljs-string">'none'</span>;
        }

        self._super(settings);

        self.classes.add(<span class="hljs-string">'colorbox'</span>);
        self.on(<span class="hljs-string">'change keyup postrender'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          self.repaintColor(self.value());
        });
      },

      <span class="hljs-attr">repaintColor</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">var</span> openElm = <span class="hljs-keyword">this</span>.getEl(<span class="hljs-string">'open'</span>);
        <span class="hljs-keyword">var</span> elm = openElm ? openElm.getElementsByTagName(<span class="hljs-string">'i'</span>)[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (elm) {
          <span class="hljs-keyword">try</span> {
            elm.style.background = value;
          } <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1843">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1843">&#182;</a>
              </div>
              <p>Ignore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          }
        }
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.state.on(<span class="hljs-string">'change:value'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'rendered'</span>)) {
            self.repaintColor(e.value);
          }
        });

        <span class="hljs-keyword">return</span> self._super();
      }
    });
  }
);
<span class="hljs-comment">/**
 * PanelButton.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a new panel button.
 *
 * @class tinymce.ui.PanelButton
 * @extends tinymce.ui.Button
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.PanelButton'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Button"</span>,
    <span class="hljs-string">"tinymce.core.ui.FloatPanel"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Button, FloatPanel</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Button.extend({
      <span class="hljs-comment">/**
       * Shows the panel for the button.
       *
       * @method showPanel
       */</span>
      showPanel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, settings = self.settings;

        self.active(<span class="hljs-literal">true</span>);

        <span class="hljs-keyword">if</span> (!self.panel) {
          <span class="hljs-keyword">var</span> panelSettings = settings.panel;</pre></div></div>
            
        </li>
        
        
        <li id="section-1844">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1844">&#182;</a>
              </div>
              <p>Wrap panel in grid layout if type if specified
This makes it possible to add forms or other containers directly in the panel option</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (panelSettings.type) {
            panelSettings = {
              <span class="hljs-attr">layout</span>: <span class="hljs-string">'grid'</span>,
              <span class="hljs-attr">items</span>: panelSettings
            };
          }

          panelSettings.role = panelSettings.role || <span class="hljs-string">'dialog'</span>;
          panelSettings.popover = <span class="hljs-literal">true</span>;
          panelSettings.autohide = <span class="hljs-literal">true</span>;
          panelSettings.ariaRoot = <span class="hljs-literal">true</span>;

          self.panel = <span class="hljs-keyword">new</span> FloatPanel(panelSettings).on(<span class="hljs-string">'hide'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            self.active(<span class="hljs-literal">false</span>);
          }).on(<span class="hljs-string">'cancel'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            e.stopPropagation();
            self.focus();
            self.hidePanel();
          }).parent(self).renderTo(self.getContainerElm());

          self.panel.fire(<span class="hljs-string">'show'</span>);
          self.panel.reflow();
        } <span class="hljs-keyword">else</span> {
          self.panel.show();
        }

        self.panel.moveRel(self.getEl(), settings.popoverAlign || (self.isRtl() ? [<span class="hljs-string">'bc-tr'</span>, <span class="hljs-string">'bc-tc'</span>] : [<span class="hljs-string">'bc-tl'</span>, <span class="hljs-string">'bc-tc'</span>]));
      },

      <span class="hljs-comment">/**
       * Hides the panel for the button.
       *
       * @method hidePanel
       */</span>
      hidePanel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (self.panel) {
          self.panel.hide();
        }
      },

      <span class="hljs-comment">/**
       * Called after the control has been rendered.
       *
       * @method postRender
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.aria(<span class="hljs-string">'haspopup'</span>, <span class="hljs-literal">true</span>);

        self.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (e.control === self) {
            <span class="hljs-keyword">if</span> (self.panel &amp;&amp; self.panel.visible()) {
              self.hidePanel();
            } <span class="hljs-keyword">else</span> {
              self.showPanel();
              self.panel.focus(!!e.aria);
            }
          }
        });

        <span class="hljs-keyword">return</span> self._super();
      },

      <span class="hljs-attr">remove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.panel) {
          <span class="hljs-keyword">this</span>.panel.remove();
          <span class="hljs-keyword">this</span>.panel = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._super();
      }
    });
  }
);
<span class="hljs-comment">/**
 * ColorButton.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class creates a color button control. This is a split button in which the main
 * button has a visual representation of the currently selected color. When clicked
 * the caret button displays a color picker, allowing the user to select a new color.
 *
 * @-x-less ColorButton.less
 * @class tinymce.ui.ColorButton
 * @extends tinymce.ui.PanelButton
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.ColorButton'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.PanelButton"</span>,
    <span class="hljs-string">"tinymce.core.dom.DOMUtils"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">PanelButton, DomUtils</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> DOM = DomUtils.DOM;

    <span class="hljs-keyword">return</span> PanelButton.extend({
      <span class="hljs-comment">/**
       * Constructs a new ColorButton instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">this</span>._super(settings);
        <span class="hljs-keyword">this</span>.classes.add(<span class="hljs-string">'colorbutton'</span>);
      },

      <span class="hljs-comment">/**
       * Getter/setter for the current color.
       *
       * @method color
       * @param {String} [color] Color to set.
       * @return {String|tinymce.ui.ColorButton} Current color or current instance.
       */</span>
      color: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">color</span>) </span>{
        <span class="hljs-keyword">if</span> (color) {
          <span class="hljs-keyword">this</span>._color = color;
          <span class="hljs-keyword">this</span>.getEl(<span class="hljs-string">'preview'</span>).style.backgroundColor = color;
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._color;
      },

      <span class="hljs-comment">/**
       * Resets the current color.
       *
       * @method resetColor
       * @return {tinymce.ui.ColorButton} Current instance.
       */</span>
      resetColor: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._color = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">this</span>.getEl(<span class="hljs-string">'preview'</span>).style.backgroundColor = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, id = self._id, prefix = self.classPrefix, text = self.state.get(<span class="hljs-string">'text'</span>);
        <span class="hljs-keyword">var</span> icon = self.settings.icon ? prefix + <span class="hljs-string">'ico '</span> + prefix + <span class="hljs-string">'i-'</span> + self.settings.icon : <span class="hljs-string">''</span>;
        <span class="hljs-keyword">var</span> image = self.settings.image ? <span class="hljs-string">' style="background-image: url(\''</span> + self.settings.image + <span class="hljs-string">'\')"'</span> : <span class="hljs-string">''</span>,
          textHtml = <span class="hljs-string">''</span>;

        <span class="hljs-keyword">if</span> (text) {
          self.classes.add(<span class="hljs-string">'btn-has-text'</span>);
          textHtml = <span class="hljs-string">'&lt;span class="'</span> + prefix + <span class="hljs-string">'txt"&gt;'</span> + self.encode(text) + <span class="hljs-string">'&lt;/span&gt;'</span>;
        }

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'" role="button" tabindex="-1" aria-haspopup="true"&gt;'</span> +
          <span class="hljs-string">'&lt;button role="presentation" hidefocus="1" type="button" tabindex="-1"&gt;'</span> +
          (icon ? <span class="hljs-string">'&lt;i class="'</span> + icon + <span class="hljs-string">'"'</span> + image + <span class="hljs-string">'&gt;&lt;/i&gt;'</span> : <span class="hljs-string">''</span>) +
          <span class="hljs-string">'&lt;span id="'</span> + id + <span class="hljs-string">'-preview" class="'</span> + prefix + <span class="hljs-string">'preview"&gt;&lt;/span&gt;'</span> +
          textHtml +
          <span class="hljs-string">'&lt;/button&gt;'</span> +
          <span class="hljs-string">'&lt;button type="button" class="'</span> + prefix + <span class="hljs-string">'open" hidefocus="1" tabindex="-1"&gt;'</span> +
          <span class="hljs-string">' &lt;i class="'</span> + prefix + <span class="hljs-string">'caret"&gt;&lt;/i&gt;'</span> +
          <span class="hljs-string">'&lt;/button&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-comment">/**
       * Called after the control has been rendered.
       *
       * @method postRender
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, onClickHandler = self.settings.onclick;

        self.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (e.aria &amp;&amp; e.aria.key == <span class="hljs-string">'down'</span>) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (e.control == self &amp;&amp; !DOM.getParent(e.target, <span class="hljs-string">'.'</span> + self.classPrefix + <span class="hljs-string">'open'</span>)) {
            e.stopImmediatePropagation();
            onClickHandler.call(self, e);
          }
        });

        <span class="hljs-keyword">delete</span> self.settings.onclick;

        <span class="hljs-keyword">return</span> self._super();
      }
    });
  }
);

<span class="hljs-comment">/**
 * ColorPicker.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Color picker widget lets you select colors.
 *
 * @-x-less ColorPicker.less
 * @class tinymce.ui.ColorPicker
 * @extends tinymce.ui.Widget
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.ColorPicker'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>,
    <span class="hljs-string">"tinymce.core.ui.DragHelper"</span>,
    <span class="hljs-string">"tinymce.core.ui.DomUtils"</span>,
    <span class="hljs-string">"tinymce.core.util.Color"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget, DragHelper, DomUtils, Color</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">classes</span>: <span class="hljs-string">"widget colorpicker"</span>
      },

      <span class="hljs-comment">/**
       * Constructs a new colorpicker instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {String} color Initial color value.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">this</span>._super(settings);
      },

      <span class="hljs-attr">postRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, color = self.color(), hsv, hueRootElm, huePointElm, svRootElm, svPointElm;

        hueRootElm = self.getEl(<span class="hljs-string">'h'</span>);
        huePointElm = self.getEl(<span class="hljs-string">'hp'</span>);
        svRootElm = self.getEl(<span class="hljs-string">'sv'</span>);
        svPointElm = self.getEl(<span class="hljs-string">'svp'</span>);

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPos</span>(<span class="hljs-params">elm, event</span>) </span>{
          <span class="hljs-keyword">var</span> pos = DomUtils.getPos(elm), x, y;

          x = event.pageX - pos.x;
          y = event.pageY - pos.y;

          x = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.min(x / elm.clientWidth, <span class="hljs-number">1</span>));
          y = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.min(y / elm.clientHeight, <span class="hljs-number">1</span>));

          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">x</span>: x,
            <span class="hljs-attr">y</span>: y
          };
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateColor</span>(<span class="hljs-params">hsv, hueUpdate</span>) </span>{
          <span class="hljs-keyword">var</span> hue = (<span class="hljs-number">360</span> - hsv.h) / <span class="hljs-number">360</span>;

          DomUtils.css(huePointElm, {
            <span class="hljs-attr">top</span>: (hue * <span class="hljs-number">100</span>) + <span class="hljs-string">'%'</span>
          });

          <span class="hljs-keyword">if</span> (!hueUpdate) {
            DomUtils.css(svPointElm, {
              <span class="hljs-attr">left</span>: hsv.s + <span class="hljs-string">'%'</span>,
              <span class="hljs-attr">top</span>: (<span class="hljs-number">100</span> - hsv.v) + <span class="hljs-string">'%'</span>
            });
          }

          svRootElm.style.background = <span class="hljs-keyword">new</span> Color({ <span class="hljs-attr">s</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">v</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">h</span>: hsv.h }).toHex();
          self.color().parse({ <span class="hljs-attr">s</span>: hsv.s, <span class="hljs-attr">v</span>: hsv.v, <span class="hljs-attr">h</span>: hsv.h });
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateSaturationAndValue</span>(<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> pos;

          pos = getPos(svRootElm, e);
          hsv.s = pos.x * <span class="hljs-number">100</span>;
          hsv.v = (<span class="hljs-number">1</span> - pos.y) * <span class="hljs-number">100</span>;

          updateColor(hsv);
          self.fire(<span class="hljs-string">'change'</span>);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHue</span>(<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> pos;

          pos = getPos(hueRootElm, e);
          hsv = color.toHsv();
          hsv.h = (<span class="hljs-number">1</span> - pos.y) * <span class="hljs-number">360</span>;
          updateColor(hsv, <span class="hljs-literal">true</span>);
          self.fire(<span class="hljs-string">'change'</span>);
        }

        self._repaint = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          hsv = color.toHsv();
          updateColor(hsv);
        };

        self._super();

        self._svdraghelper = <span class="hljs-keyword">new</span> DragHelper(self._id + <span class="hljs-string">'-sv'</span>, {
          <span class="hljs-attr">start</span>: updateSaturationAndValue,
          <span class="hljs-attr">drag</span>: updateSaturationAndValue
        });

        self._hdraghelper = <span class="hljs-keyword">new</span> DragHelper(self._id + <span class="hljs-string">'-h'</span>, {
          <span class="hljs-attr">start</span>: updateHue,
          <span class="hljs-attr">drag</span>: updateHue
        });

        self._repaint();
      },

      <span class="hljs-attr">rgb</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.color().toRgb();
      },

      <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length) {
          self.color().parse(value);

          <span class="hljs-keyword">if</span> (self._rendered) {
            self._repaint();
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> self.color().toHex();
        }
      },

      <span class="hljs-attr">color</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._color) {
          <span class="hljs-keyword">this</span>._color = <span class="hljs-keyword">new</span> Color();
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._color;
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, id = self._id, prefix = self.classPrefix, hueHtml;
        <span class="hljs-keyword">var</span> stops = <span class="hljs-string">'#ff0000,#ff0080,#ff00ff,#8000ff,#0000ff,#0080ff,#00ffff,#00ff80,#00ff00,#80ff00,#ffff00,#ff8000,#ff0000'</span>;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOldIeFallbackHtml</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> i, l, html = <span class="hljs-string">''</span>, gradientPrefix, stopsList;

          gradientPrefix = <span class="hljs-string">'filter:progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr='</span>;
          stopsList = stops.split(<span class="hljs-string">','</span>);
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = stopsList.length - <span class="hljs-number">1</span>; i &lt; l; i++) {
            html += (
              <span class="hljs-string">'&lt;div class="'</span> + prefix + <span class="hljs-string">'colorpicker-h-chunk" style="'</span> +
              <span class="hljs-string">'height:'</span> + (<span class="hljs-number">100</span> / l) + <span class="hljs-string">'%;'</span> +
              gradientPrefix + stopsList[i] + <span class="hljs-string">',endColorstr='</span> + stopsList[i + <span class="hljs-number">1</span>] + <span class="hljs-string">');'</span> +
              <span class="hljs-string">'-ms-'</span> + gradientPrefix + stopsList[i] + <span class="hljs-string">',endColorstr='</span> + stopsList[i + <span class="hljs-number">1</span>] + <span class="hljs-string">')'</span> +
              <span class="hljs-string">'"&gt;&lt;/div&gt;'</span>
            );
          }

          <span class="hljs-keyword">return</span> html;
        }

        <span class="hljs-keyword">var</span> gradientCssText = (
          <span class="hljs-string">'background: -ms-linear-gradient(top,'</span> + stops + <span class="hljs-string">');'</span> +
          <span class="hljs-string">'background: linear-gradient(to bottom,'</span> + stops + <span class="hljs-string">');'</span>
        );

        hueHtml = (
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'-h" class="'</span> + prefix + <span class="hljs-string">'colorpicker-h" style="'</span> + gradientCssText + <span class="hljs-string">'"&gt;'</span> +
          getOldIeFallbackHtml() +
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'-hp" class="'</span> + prefix + <span class="hljs-string">'colorpicker-h-marker"&gt;&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'"&gt;'</span> +
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'-sv" class="'</span> + prefix + <span class="hljs-string">'colorpicker-sv"&gt;'</span> +
          <span class="hljs-string">'&lt;div class="'</span> + prefix + <span class="hljs-string">'colorpicker-overlay1"&gt;'</span> +
          <span class="hljs-string">'&lt;div class="'</span> + prefix + <span class="hljs-string">'colorpicker-overlay2"&gt;'</span> +
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'-svp" class="'</span> + prefix + <span class="hljs-string">'colorpicker-selector1"&gt;'</span> +
          <span class="hljs-string">'&lt;div class="'</span> + prefix + <span class="hljs-string">'colorpicker-selector2"&gt;&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span> +
          hueHtml +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      }
    });
  }
);
<span class="hljs-comment">/**
 * Path.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a new path control.
 *
 * @-x-less Path.less
 * @class tinymce.ui.Path
 * @extends tinymce.ui.Widget
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Path'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-comment">/**
       * Constructs a instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {String} delimiter Delimiter to display between row in path.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (!settings.delimiter) {
          settings.delimiter = <span class="hljs-string">'\u00BB'</span>;
        }

        self._super(settings);
        self.classes.add(<span class="hljs-string">'path'</span>);
        self.canFocus = <span class="hljs-literal">true</span>;

        self.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> index, target = e.target;

          <span class="hljs-keyword">if</span> ((index = target.getAttribute(<span class="hljs-string">'data-index'</span>))) {
            self.fire(<span class="hljs-string">'select'</span>, { <span class="hljs-attr">value</span>: self.row()[index], <span class="hljs-attr">index</span>: index });
          }
        });

        self.row(self.settings.row);
      },

      <span class="hljs-comment">/**
       * Focuses the current control.
       *
       * @method focus
       * @return {tinymce.ui.Control} Current control instance.
       */</span>
      focus: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.getEl().firstChild.focus();

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Sets/gets the data to be used for the path.
       *
       * @method row
       * @param {Array} row Array with row name is rendered to path.
       */</span>
      row: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">row</span>) </span>{
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">arguments</span>.length) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.get(<span class="hljs-string">'row'</span>);
        }

        <span class="hljs-keyword">this</span>.state.set(<span class="hljs-string">'row'</span>, row);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'"&gt;'</span> +
          self._getDataPathHtml(self.state.get(<span class="hljs-string">'row'</span>)) +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.state.on(<span class="hljs-string">'change:row'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.innerHtml(self._getDataPathHtml(e.value));
        });

        <span class="hljs-keyword">return</span> self._super();
      },

      <span class="hljs-attr">_getDataPathHtml</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, parts = data || [], i, l, html = <span class="hljs-string">''</span>, prefix = self.classPrefix;

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = parts.length; i &lt; l; i++) {
          html += (
            (i &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">'&lt;div class="'</span> + prefix + <span class="hljs-string">'divider" aria-hidden="true"&gt; '</span> + self.settings.delimiter + <span class="hljs-string">' &lt;/div&gt;'</span> : <span class="hljs-string">''</span>) +
            <span class="hljs-string">'&lt;div role="button" class="'</span> + prefix + <span class="hljs-string">'path-item'</span> + (i == l - <span class="hljs-number">1</span> ? <span class="hljs-string">' '</span> + prefix + <span class="hljs-string">'last'</span> : <span class="hljs-string">''</span>) + <span class="hljs-string">'" data-index="'</span> +
            i + <span class="hljs-string">'" tabindex="-1" id="'</span> + self._id + <span class="hljs-string">'-'</span> + i + <span class="hljs-string">'" aria-level="'</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">'"&gt;'</span> + parts[i].name + <span class="hljs-string">'&lt;/div&gt;'</span>
          );
        }

        <span class="hljs-keyword">if</span> (!html) {
          html = <span class="hljs-string">'&lt;div class="'</span> + prefix + <span class="hljs-string">'path-item"&gt;\u00a0&lt;/div&gt;'</span>;
        }

        <span class="hljs-keyword">return</span> html;
      }
    });
  }
);

<span class="hljs-comment">/**
 * ElementPath.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This control creates an path for the current selections parent elements in TinyMCE.
 *
 * @class tinymce.ui.ElementPath
 * @extends tinymce.ui.Path
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.ElementPath'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Path"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Path</span>) </span>{
    <span class="hljs-keyword">return</span> Path.extend({
      <span class="hljs-comment">/**
       * Post render method. Called after the control has been rendered to the target.
       *
       * @method postRender
       * @return {tinymce.ui.ElementPath} Current combobox instance.
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, editor = self.settings.editor;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isHidden</span>(<span class="hljs-params">elm</span>) </span>{
          <span class="hljs-keyword">if</span> (elm.nodeType === <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (elm.nodeName == <span class="hljs-string">"BR"</span> || !!elm.getAttribute(<span class="hljs-string">'data-mce-bogus'</span>)) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">if</span> (elm.getAttribute(<span class="hljs-string">'data-mce-type'</span>) === <span class="hljs-string">'bookmark'</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">if</span> (editor.settings.elementpath !== <span class="hljs-literal">false</span>) {
          self.on(<span class="hljs-string">'select'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            editor.focus();
            editor.selection.select(<span class="hljs-keyword">this</span>.row()[e.index].element);
            editor.nodeChanged();
          });

          editor.on(<span class="hljs-string">'nodeChange'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">var</span> outParents = [], parents = e.parents, i = parents.length;

            <span class="hljs-keyword">while</span> (i--) {
              <span class="hljs-keyword">if</span> (parents[i].nodeType == <span class="hljs-number">1</span> &amp;&amp; !isHidden(parents[i])) {
                <span class="hljs-keyword">var</span> args = editor.fire(<span class="hljs-string">'ResolveName'</span>, {
                  <span class="hljs-attr">name</span>: parents[i].nodeName.toLowerCase(),
                  <span class="hljs-attr">target</span>: parents[i]
                });

                <span class="hljs-keyword">if</span> (!args.isDefaultPrevented()) {
                  outParents.push({ <span class="hljs-attr">name</span>: args.name, <span class="hljs-attr">element</span>: parents[i] });
                }

                <span class="hljs-keyword">if</span> (args.isPropagationStopped()) {
                  <span class="hljs-keyword">break</span>;
                }
              }
            }

            self.row(outParents);
          });
        }

        <span class="hljs-keyword">return</span> self._super();
      }
    });
  }
);
<span class="hljs-comment">/**
 * FormItem.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class is a container created by the form element with
 * a label and control item.
 *
 * @class tinymce.ui.FormItem
 * @extends tinymce.ui.Container
 * @setting {String} label Label to display for the form item.
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.FormItem'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Container"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Container</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Container.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">layout</span>: <span class="hljs-string">'flex'</span>,
        <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>,
        <span class="hljs-attr">defaults</span>: {
          <span class="hljs-attr">flex</span>: <span class="hljs-number">1</span>
        }
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, layout = self._layout, prefix = self.classPrefix;

        self.classes.add(<span class="hljs-string">'formitem'</span>);
        layout.preRender(self);

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'" hidefocus="1" tabindex="-1"&gt;'</span> +
          (self.settings.title ? (<span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'-title" class="'</span> + prefix + <span class="hljs-string">'title"&gt;'</span> +
            self.settings.title + <span class="hljs-string">'&lt;/div&gt;'</span>) : <span class="hljs-string">''</span>) +
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'-body" class="'</span> + self.bodyClasses + <span class="hljs-string">'"&gt;'</span> +
          (self.settings.html || <span class="hljs-string">''</span>) + layout.renderHtml(self) +
          <span class="hljs-string">'&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      }
    });
  }
);
<span class="hljs-comment">/**
 * Form.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class creates a form container. A form container has the ability
 * to automatically wrap items in tinymce.ui.FormItem instances.
 *
 * Each FormItem instance is a container for the label and the item.
 *
 * @example
 * tinymce.ui.Factory.create({
 *     type: 'form',
 *     items: [
 *         {type: 'textbox', label: 'My text box'}
 *     ]
 * }).renderTo(document.body);
 *
 * @class tinymce.ui.Form
 * @extends tinymce.ui.Container
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Form'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Container"</span>,
    <span class="hljs-string">"tinymce.core.ui.FormItem"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Container, FormItem, Tools</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Container.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">containerCls</span>: <span class="hljs-string">'form'</span>,
        <span class="hljs-attr">layout</span>: <span class="hljs-string">'flex'</span>,
        <span class="hljs-attr">direction</span>: <span class="hljs-string">'column'</span>,
        <span class="hljs-attr">align</span>: <span class="hljs-string">'stretch'</span>,
        <span class="hljs-attr">flex</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">padding</span>: <span class="hljs-number">20</span>,
        <span class="hljs-attr">labelGap</span>: <span class="hljs-number">30</span>,
        <span class="hljs-attr">spacing</span>: <span class="hljs-number">10</span>,
        <span class="hljs-attr">callbacks</span>: {
          <span class="hljs-attr">submit</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>.submit();
          }
        }
      },

      <span class="hljs-comment">/**
       * This method gets invoked before the control is rendered.
       *
       * @method preRender
       */</span>
      preRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, items = self.items();

        <span class="hljs-keyword">if</span> (!self.settings.formItemDefaults) {
          self.settings.formItemDefaults = {
            <span class="hljs-attr">layout</span>: <span class="hljs-string">'flex'</span>,
            <span class="hljs-attr">autoResize</span>: <span class="hljs-string">"overflow"</span>,
            <span class="hljs-attr">defaults</span>: { <span class="hljs-attr">flex</span>: <span class="hljs-number">1</span> }
          };
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1845">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1845">&#182;</a>
              </div>
              <p>Wrap any labeled items in FormItems</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        items.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
          <span class="hljs-keyword">var</span> formItem, label = ctrl.settings.label;

          <span class="hljs-keyword">if</span> (label) {
            formItem = <span class="hljs-keyword">new</span> FormItem(Tools.extend({
              <span class="hljs-attr">items</span>: {
                <span class="hljs-attr">type</span>: <span class="hljs-string">'label'</span>,
                <span class="hljs-attr">id</span>: ctrl._id + <span class="hljs-string">'-l'</span>,
                <span class="hljs-attr">text</span>: label,
                <span class="hljs-attr">flex</span>: <span class="hljs-number">0</span>,
                <span class="hljs-attr">forId</span>: ctrl._id,
                <span class="hljs-attr">disabled</span>: ctrl.disabled()
              }
            }, self.settings.formItemDefaults));

            formItem.type = <span class="hljs-string">'formitem'</span>;
            ctrl.aria(<span class="hljs-string">'labelledby'</span>, ctrl._id + <span class="hljs-string">'-l'</span>);

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctrl.settings.flex == <span class="hljs-string">"undefined"</span>) {
              ctrl.settings.flex = <span class="hljs-number">1</span>;
            }

            self.replace(ctrl, formItem);
            formItem.add(ctrl);
          }
        });
      },

      <span class="hljs-comment">/**
       * Fires a submit event with the serialized form.
       *
       * @method submit
       * @return {Object} Event arguments object.
       */</span>
      submit: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.fire(<span class="hljs-string">'submit'</span>, { <span class="hljs-attr">data</span>: <span class="hljs-keyword">this</span>.toJSON() });
      },

      <span class="hljs-comment">/**
       * Post render method. Called after the control has been rendered to the target.
       *
       * @method postRender
       * @return {tinymce.ui.ComboBox} Current combobox instance.
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super();
        self.fromJSON(self.settings.data);
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super();

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recalcLabels</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> maxLabelWidth = <span class="hljs-number">0</span>, labels = [], i, labelGap, items;

          <span class="hljs-keyword">if</span> (self.settings.labelGapCalc === <span class="hljs-literal">false</span>) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (self.settings.labelGapCalc == <span class="hljs-string">"children"</span>) {
            items = self.find(<span class="hljs-string">'formitem'</span>);
          } <span class="hljs-keyword">else</span> {
            items = self.items();
          }

          items.filter(<span class="hljs-string">'formitem'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
            <span class="hljs-keyword">var</span> labelCtrl = item.items()[<span class="hljs-number">0</span>], labelWidth = labelCtrl.getEl().clientWidth;

            maxLabelWidth = labelWidth &gt; maxLabelWidth ? labelWidth : maxLabelWidth;
            labels.push(labelCtrl);
          });

          labelGap = self.settings.labelGap || <span class="hljs-number">0</span>;

          i = labels.length;
          <span class="hljs-keyword">while</span> (i--) {
            labels[i].settings.minWidth = maxLabelWidth + labelGap;
          }
        }

        self.on(<span class="hljs-string">'show'</span>, recalcLabels);
        recalcLabels();
      }
    });
  }
);
<span class="hljs-comment">/**
 * FieldSet.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class creates fieldset containers.
 *
 * @-x-less FieldSet.less
 * @class tinymce.ui.FieldSet
 * @extends tinymce.ui.Form
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.FieldSet'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Form"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Form</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Form.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">containerCls</span>: <span class="hljs-string">'fieldset'</span>,
        <span class="hljs-attr">layout</span>: <span class="hljs-string">'flex'</span>,
        <span class="hljs-attr">direction</span>: <span class="hljs-string">'column'</span>,
        <span class="hljs-attr">align</span>: <span class="hljs-string">'stretch'</span>,
        <span class="hljs-attr">flex</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">padding</span>: <span class="hljs-string">"25 15 5 15"</span>,
        <span class="hljs-attr">labelGap</span>: <span class="hljs-number">30</span>,
        <span class="hljs-attr">spacing</span>: <span class="hljs-number">10</span>,
        <span class="hljs-attr">border</span>: <span class="hljs-number">1</span>
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, layout = self._layout, prefix = self.classPrefix;

        self.preRender();
        layout.preRender(self);

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;fieldset id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'" hidefocus="1" tabindex="-1"&gt;'</span> +
          (self.settings.title ? (<span class="hljs-string">'&lt;legend id="'</span> + self._id + <span class="hljs-string">'-title" class="'</span> + prefix + <span class="hljs-string">'fieldset-title"&gt;'</span> +
            self.settings.title + <span class="hljs-string">'&lt;/legend&gt;'</span>) : <span class="hljs-string">''</span>) +
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'-body" class="'</span> + self.bodyClasses + <span class="hljs-string">'"&gt;'</span> +
          (self.settings.html || <span class="hljs-string">''</span>) + layout.renderHtml(self) +
          <span class="hljs-string">'&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/fieldset&gt;'</span>
        );
      }
    });
  }
);
<span class="hljs-comment">/**
 * LinkTargets.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This module is enables you to get anything that you can link to in a element.
 *
 * @private
 * @class tinymce.content.LinkTargets
 */</span>
define(
  <span class="hljs-string">'tinymce.core.content.LinkTargets'</span>,
  [
    <span class="hljs-string">'tinymce.core.dom.DOMUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.NodeType'</span>,
    <span class="hljs-string">'tinymce.core.util.Arr'</span>,
    <span class="hljs-string">'tinymce.core.util.Fun'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>,
    <span class="hljs-string">'tinymce.core.util.Uuid'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">DOMUtils, NodeType, Arr, Fun, Tools, Uuid</span>) </span>{
    <span class="hljs-keyword">var</span> trim = Tools.trim;

    <span class="hljs-keyword">var</span> create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, title, url, level, attach</span>) </span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">type</span>: type,
        <span class="hljs-attr">title</span>: title,
        <span class="hljs-attr">url</span>: url,
        <span class="hljs-attr">level</span>: level,
        <span class="hljs-attr">attach</span>: attach
      };
    };

    <span class="hljs-keyword">var</span> isChildOfContentEditableTrue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">while</span> ((node = node.parentNode)) {
        <span class="hljs-keyword">var</span> value = node.contentEditable;
        <span class="hljs-keyword">if</span> (value &amp;&amp; value !== <span class="hljs-string">'inherit'</span>) {
          <span class="hljs-keyword">return</span> NodeType.isContentEditableTrue(node);
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">var</span> select = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector, root</span>) </span>{
      <span class="hljs-keyword">return</span> DOMUtils.DOM.select(selector, root);
    };

    <span class="hljs-keyword">var</span> getElementText = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> elm.innerText || elm.textContent;
    };

    <span class="hljs-keyword">var</span> getOrGenerateId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> elm.id ? elm.id : Uuid.uuid(<span class="hljs-string">'h'</span>);
    };

    <span class="hljs-keyword">var</span> isAnchor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> elm &amp;&amp; elm.nodeName === <span class="hljs-string">'A'</span> &amp;&amp; (elm.id || elm.name);
    };

    <span class="hljs-keyword">var</span> isValidAnchor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> isAnchor(elm) &amp;&amp; isEditable(elm);
    };

    <span class="hljs-keyword">var</span> isHeader = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> elm &amp;&amp; <span class="hljs-regexp">/^(H[1-6])$/</span>.test(elm.nodeName);
    };

    <span class="hljs-keyword">var</span> isEditable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> isChildOfContentEditableTrue(elm) &amp;&amp; !NodeType.isContentEditableFalse(elm);
    };

    <span class="hljs-keyword">var</span> isValidHeader = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> isHeader(elm) &amp;&amp; isEditable(elm);
    };

    <span class="hljs-keyword">var</span> getLevel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">return</span> isHeader(elm) ? <span class="hljs-built_in">parseInt</span>(elm.nodeName.substr(<span class="hljs-number">1</span>), <span class="hljs-number">10</span>) : <span class="hljs-number">0</span>;
    };

    <span class="hljs-keyword">var</span> headerTarget = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">var</span> headerId = getOrGenerateId(elm);

      <span class="hljs-keyword">var</span> attach = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        elm.id = headerId;
      };

      <span class="hljs-keyword">return</span> create(<span class="hljs-string">'header'</span>, getElementText(elm), <span class="hljs-string">'#'</span> + headerId, getLevel(elm), attach);
    };

    <span class="hljs-keyword">var</span> anchorTarget = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">var</span> anchorId = elm.id || elm.name;
      <span class="hljs-keyword">var</span> anchorText = getElementText(elm);

      <span class="hljs-keyword">return</span> create(<span class="hljs-string">'anchor'</span>, anchorText ? anchorText : <span class="hljs-string">'#'</span> + anchorId, <span class="hljs-string">'#'</span> + anchorId, <span class="hljs-number">0</span>, Fun.noop);
    };

    <span class="hljs-keyword">var</span> getHeaderTargets = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elms</span>) </span>{
      <span class="hljs-keyword">return</span> Arr.map(Arr.filter(elms, isValidHeader), headerTarget);
    };

    <span class="hljs-keyword">var</span> getAnchorTargets = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elms</span>) </span>{
      <span class="hljs-keyword">return</span> Arr.map(Arr.filter(elms, isValidAnchor), anchorTarget);
    };

    <span class="hljs-keyword">var</span> getTargetElements = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">var</span> elms = select(<span class="hljs-string">'h1,h2,h3,h4,h5,h6,a:not([href])'</span>, elm);
      <span class="hljs-keyword">return</span> elms;
    };

    <span class="hljs-keyword">var</span> hasTitle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>{
      <span class="hljs-keyword">return</span> trim(target.title).length &gt; <span class="hljs-number">0</span>;
    };

    <span class="hljs-keyword">var</span> find = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm</span>) </span>{
      <span class="hljs-keyword">var</span> elms = getTargetElements(elm);
      <span class="hljs-keyword">return</span> Arr.filter(getHeaderTargets(elms).concat(getAnchorTargets(elms)), hasTitle);
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">find</span>: find
    };
  }
);

<span class="hljs-comment">/**
 * FilePicker.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class creates a file picker control.
 *
 * @class tinymce.ui.FilePicker
 * @extends tinymce.ui.ComboBox
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.FilePicker'</span>,
  [
    <span class="hljs-string">'global!window'</span>,
    <span class="hljs-string">'tinymce.core.content.LinkTargets'</span>,
    <span class="hljs-string">'tinymce.core.EditorManager'</span>,
    <span class="hljs-string">'tinymce.core.ui.ComboBox'</span>,
    <span class="hljs-string">'tinymce.core.util.Arr'</span>,
    <span class="hljs-string">'tinymce.core.util.Fun'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">window, LinkTargets, EditorManager, ComboBox, Arr, Fun, Tools</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> getActiveEditor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.tinymce ? <span class="hljs-built_in">window</span>.tinymce.activeEditor : EditorManager.activeEditor;
    };

    <span class="hljs-keyword">var</span> history = {};
    <span class="hljs-keyword">var</span> HISTORY_LENGTH = <span class="hljs-number">5</span>;

    <span class="hljs-keyword">var</span> toMenuItem = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">title</span>: target.title,
        <span class="hljs-attr">value</span>: {
          <span class="hljs-attr">title</span>: { <span class="hljs-attr">raw</span>: target.title },
          <span class="hljs-attr">url</span>: target.url,
          <span class="hljs-attr">attach</span>: target.attach
        }
      };
    };

    <span class="hljs-keyword">var</span> toMenuItems = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">targets</span>) </span>{
      <span class="hljs-keyword">return</span> Tools.map(targets, toMenuItem);
    };

    <span class="hljs-keyword">var</span> staticMenuItem = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">title, url</span>) </span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">title</span>: title,
        <span class="hljs-attr">value</span>: {
          <span class="hljs-attr">title</span>: title,
          <span class="hljs-attr">url</span>: url,
          <span class="hljs-attr">attach</span>: Fun.noop
        }
      };
    };

    <span class="hljs-keyword">var</span> isUniqueUrl = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url, targets</span>) </span>{
      <span class="hljs-keyword">var</span> foundTarget = Arr.find(targets, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>{
        <span class="hljs-keyword">return</span> target.url === url;
      });

      <span class="hljs-keyword">return</span> !foundTarget;
    };

    <span class="hljs-keyword">var</span> getSetting = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editorSettings, name, defaultValue</span>) </span>{
      <span class="hljs-keyword">var</span> value = name <span class="hljs-keyword">in</span> editorSettings ? editorSettings[name] : defaultValue;
      <span class="hljs-keyword">return</span> value === <span class="hljs-literal">false</span> ? <span class="hljs-literal">null</span> : value;
    };

    <span class="hljs-keyword">var</span> createMenuItems = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">term, targets, fileType, editorSettings</span>) </span>{
      <span class="hljs-keyword">var</span> separator = { <span class="hljs-attr">title</span>: <span class="hljs-string">'-'</span> };

      <span class="hljs-keyword">var</span> fromHistoryMenuItems = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">history</span>) </span>{
        <span class="hljs-keyword">var</span> uniqueHistory = Arr.filter(history[fileType], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
          <span class="hljs-keyword">return</span> isUniqueUrl(url, targets);
        });

        <span class="hljs-keyword">return</span> Tools.map(uniqueHistory, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">title</span>: url,
            <span class="hljs-attr">value</span>: {
              <span class="hljs-attr">title</span>: url,
              <span class="hljs-attr">url</span>: url,
              <span class="hljs-attr">attach</span>: Fun.noop
            }
          };
        });
      };

      <span class="hljs-keyword">var</span> fromMenuItems = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
        <span class="hljs-keyword">var</span> filteredTargets = Arr.filter(targets, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>{
          <span class="hljs-keyword">return</span> target.type == type;
        });

        <span class="hljs-keyword">return</span> toMenuItems(filteredTargets);
      };

      <span class="hljs-keyword">var</span> anchorMenuItems = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> anchorMenuItems = fromMenuItems(<span class="hljs-string">'anchor'</span>);
        <span class="hljs-keyword">var</span> topAnchor = getSetting(editorSettings, <span class="hljs-string">'anchor_top'</span>, <span class="hljs-string">'#top'</span>);
        <span class="hljs-keyword">var</span> bottomAchor = getSetting(editorSettings, <span class="hljs-string">'anchor_bottom'</span>, <span class="hljs-string">'#bottom'</span>);

        <span class="hljs-keyword">if</span> (topAnchor !== <span class="hljs-literal">null</span>) {
          anchorMenuItems.unshift(staticMenuItem(<span class="hljs-string">'&lt;top&gt;'</span>, topAnchor));
        }

        <span class="hljs-keyword">if</span> (bottomAchor !== <span class="hljs-literal">null</span>) {
          anchorMenuItems.push(staticMenuItem(<span class="hljs-string">'&lt;bottom&gt;'</span>, bottomAchor));
        }

        <span class="hljs-keyword">return</span> anchorMenuItems;
      };

      <span class="hljs-keyword">var</span> join = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>{
        <span class="hljs-keyword">return</span> Arr.reduce(items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
          <span class="hljs-keyword">var</span> bothEmpty = a.length === <span class="hljs-number">0</span> || b.length === <span class="hljs-number">0</span>;
          <span class="hljs-keyword">return</span> bothEmpty ? a.concat(b) : a.concat(separator, b);
        }, []);
      };

      <span class="hljs-keyword">if</span> (editorSettings.typeahead_urls === <span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">return</span> [];
      }

      <span class="hljs-keyword">return</span> fileType === <span class="hljs-string">'file'</span> ? join([
        filterByQuery(term, fromHistoryMenuItems(history)),
        filterByQuery(term, fromMenuItems(<span class="hljs-string">'header'</span>)),
        filterByQuery(term, anchorMenuItems())
      ]) : filterByQuery(term, fromHistoryMenuItems(history));
    };

    <span class="hljs-keyword">var</span> addToHistory = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url, fileType</span>) </span>{
      <span class="hljs-keyword">var</span> items = history[fileType];

      <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^https?/</span>.test(url)) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (items) {
        <span class="hljs-keyword">if</span> (Arr.indexOf(items, url) === <span class="hljs-number">-1</span>) {
          history[fileType] = items.slice(<span class="hljs-number">0</span>, HISTORY_LENGTH).concat(url);
        }
      } <span class="hljs-keyword">else</span> {
        history[fileType] = [url];
      }
    };

    <span class="hljs-keyword">var</span> filterByQuery = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">term, menuItems</span>) </span>{
      <span class="hljs-keyword">var</span> lowerCaseTerm = term.toLowerCase();
      <span class="hljs-keyword">var</span> result = Tools.grep(menuItems, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
        <span class="hljs-keyword">return</span> item.title.toLowerCase().indexOf(lowerCaseTerm) !== <span class="hljs-number">-1</span>;
      });

      <span class="hljs-keyword">return</span> result.length === <span class="hljs-number">1</span> &amp;&amp; result[<span class="hljs-number">0</span>].title === term ? [] : result;
    };

    <span class="hljs-keyword">var</span> getTitle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">linkDetails</span>) </span>{
      <span class="hljs-keyword">var</span> title = linkDetails.title;
      <span class="hljs-keyword">return</span> title.raw ? title.raw : title;
    };

    <span class="hljs-keyword">var</span> setupAutoCompleteHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl, editorSettings, bodyElm, fileType</span>) </span>{
      <span class="hljs-keyword">var</span> autocomplete = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">term</span>) </span>{
        <span class="hljs-keyword">var</span> linkTargets = LinkTargets.find(bodyElm);
        <span class="hljs-keyword">var</span> menuItems = createMenuItems(term, linkTargets, fileType, editorSettings);
        ctrl.showAutoComplete(menuItems, term);
      };

      ctrl.on(<span class="hljs-string">'autocomplete'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        autocomplete(ctrl.value());
      });

      ctrl.on(<span class="hljs-string">'selectitem'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> linkDetails = e.value;

        ctrl.value(linkDetails.url);
        <span class="hljs-keyword">var</span> title = getTitle(linkDetails);

        <span class="hljs-keyword">if</span> (fileType === <span class="hljs-string">'image'</span>) {
          ctrl.fire(<span class="hljs-string">'change'</span>, { <span class="hljs-attr">meta</span>: { <span class="hljs-attr">alt</span>: title, <span class="hljs-attr">attach</span>: linkDetails.attach } });
        } <span class="hljs-keyword">else</span> {
          ctrl.fire(<span class="hljs-string">'change'</span>, { <span class="hljs-attr">meta</span>: { <span class="hljs-attr">text</span>: title, <span class="hljs-attr">attach</span>: linkDetails.attach } });
        }

        ctrl.focus();
      });

      ctrl.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (ctrl.value().length === <span class="hljs-number">0</span> &amp;&amp; e.target.nodeName === <span class="hljs-string">'INPUT'</span>) {
          autocomplete(<span class="hljs-string">''</span>);
        }
      });

      ctrl.on(<span class="hljs-string">'PostRender'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        ctrl.getRoot().on(<span class="hljs-string">'submit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (!e.isDefaultPrevented()) {
            addToHistory(ctrl.value(), fileType);
          }
        });
      });
    };

    <span class="hljs-keyword">var</span> statusToUiState = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
      <span class="hljs-keyword">var</span> status = result.status, message = result.message;

      <span class="hljs-keyword">if</span> (status === <span class="hljs-string">'valid'</span>) {
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">status</span>: <span class="hljs-string">'ok'</span>, <span class="hljs-attr">message</span>: message };
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status === <span class="hljs-string">'unknown'</span>) {
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">status</span>: <span class="hljs-string">'warn'</span>, <span class="hljs-attr">message</span>: message };
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status === <span class="hljs-string">'invalid'</span>) {
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">status</span>: <span class="hljs-string">'warn'</span>, <span class="hljs-attr">message</span>: message };
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">status</span>: <span class="hljs-string">'none'</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">''</span> };
      }
    };

    <span class="hljs-keyword">var</span> setupLinkValidatorHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl, editorSettings, fileType</span>) </span>{
      <span class="hljs-keyword">var</span> validatorHandler = editorSettings.filepicker_validator_handler;
      <span class="hljs-keyword">if</span> (validatorHandler) {
        <span class="hljs-keyword">var</span> validateUrl = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
          <span class="hljs-keyword">if</span> (url.length === <span class="hljs-number">0</span>) {
            ctrl.statusLevel(<span class="hljs-string">'none'</span>);
            <span class="hljs-keyword">return</span>;
          }

          validatorHandler({
            <span class="hljs-attr">url</span>: url,
            <span class="hljs-attr">type</span>: fileType
          }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
            <span class="hljs-keyword">var</span> uiState = statusToUiState(result);

            ctrl.statusMessage(uiState.message);
            ctrl.statusLevel(uiState.status);
          });
        };

        ctrl.state.on(<span class="hljs-string">'change:value'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          validateUrl(e.value);
        });
      }
    };

    <span class="hljs-keyword">return</span> ComboBox.extend({
      <span class="hljs-comment">/**
       * Constructs a new control instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, editor = getActiveEditor(), editorSettings = editor.settings;
        <span class="hljs-keyword">var</span> actionCallback, fileBrowserCallback, fileBrowserCallbackTypes;
        <span class="hljs-keyword">var</span> fileType = settings.filetype;

        settings.spellcheck = <span class="hljs-literal">false</span>;

        fileBrowserCallbackTypes = editorSettings.file_picker_types || editorSettings.file_browser_callback_types;
        <span class="hljs-keyword">if</span> (fileBrowserCallbackTypes) {
          fileBrowserCallbackTypes = Tools.makeMap(fileBrowserCallbackTypes, /[, ]/);
        }

        <span class="hljs-keyword">if</span> (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[fileType]) {
          fileBrowserCallback = editorSettings.file_picker_callback;
          <span class="hljs-keyword">if</span> (fileBrowserCallback &amp;&amp; (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[fileType])) {
            actionCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">var</span> meta = self.fire(<span class="hljs-string">'beforecall'</span>).meta;

              meta = Tools.extend({ <span class="hljs-attr">filetype</span>: fileType }, meta);</pre></div></div>
            
        </li>
        
        
        <li id="section-1846">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1846">&#182;</a>
              </div>
              <p>file_picker_callback(callback, currentValue, metaData)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              fileBrowserCallback.call(
                editor,
                <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, meta</span>) </span>{
                  self.value(value).fire(<span class="hljs-string">'change'</span>, { <span class="hljs-attr">meta</span>: meta });
                },
                self.value(),
                meta
              );
            };
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1847">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1847">&#182;</a>
              </div>
              <p>Legacy callback: file_picker_callback(id, currentValue, filetype, window)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            fileBrowserCallback = editorSettings.file_browser_callback;
            <span class="hljs-keyword">if</span> (fileBrowserCallback &amp;&amp; (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[fileType])) {
              actionCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                fileBrowserCallback(
                  self.getEl(<span class="hljs-string">'inp'</span>).id,
                  self.value(),
                  fileType,
                  <span class="hljs-built_in">window</span>
                );
              };
            }
          }
        }

        <span class="hljs-keyword">if</span> (actionCallback) {
          settings.icon = <span class="hljs-string">'browse'</span>;
          settings.onaction = actionCallback;
        }

        self._super(settings);

        setupAutoCompleteHandler(self, editorSettings, editor.getBody(), fileType);
        setupLinkValidatorHandler(self, editorSettings, fileType);
      }
    });
  }
);
<span class="hljs-comment">/**
 * FitLayout.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This layout manager will resize the control to be the size of it's parent container.
 * In other words width: 100% and height: 100%.
 *
 * @-x-less FitLayout.less
 * @class tinymce.ui.FitLayout
 * @extends tinymce.ui.AbsoluteLayout
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.FitLayout'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.AbsoluteLayout"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">AbsoluteLayout</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> AbsoluteLayout.extend({
      <span class="hljs-comment">/**
       * Recalculates the positions of the controls in the specified container.
       *
       * @method recalc
       * @param {tinymce.ui.Container} container Container instance to recalc.
       */</span>
      recalc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">container</span>) </span>{
        <span class="hljs-keyword">var</span> contLayoutRect = container.layoutRect(), paddingBox = container.paddingBox;

        container.items().filter(<span class="hljs-string">':visible'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
          ctrl.layoutRect({
            <span class="hljs-attr">x</span>: paddingBox.left,
            <span class="hljs-attr">y</span>: paddingBox.top,
            <span class="hljs-attr">w</span>: contLayoutRect.innerW - paddingBox.right - paddingBox.left,
            <span class="hljs-attr">h</span>: contLayoutRect.innerH - paddingBox.top - paddingBox.bottom
          });

          <span class="hljs-keyword">if</span> (ctrl.recalc) {
            ctrl.recalc();
          }
        });
      }
    });
  }
);
<span class="hljs-comment">/**
 * FlexLayout.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This layout manager works similar to the CSS flex box.
 *
 * @setting {String} direction row|row-reverse|column|column-reverse
 * @setting {Number} flex A positive-number to flex by.
 * @setting {String} align start|end|center|stretch
 * @setting {String} pack start|end|justify
 *
 * @class tinymce.ui.FlexLayout
 * @extends tinymce.ui.AbsoluteLayout
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.FlexLayout'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.AbsoluteLayout"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">AbsoluteLayout</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> AbsoluteLayout.extend({
      <span class="hljs-comment">/**
       * Recalculates the positions of the controls in the specified container.
       *
       * @method recalc
       * @param {tinymce.ui.Container} container Container instance to recalc.
       */</span>
      recalc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">container</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1848">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1848">&#182;</a>
              </div>
              <p>A ton of variables, needs to be in the same scope for performance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> i, l, items, contLayoutRect, contPaddingBox, contSettings, align, pack, spacing, totalFlex, availableSpace, direction;
        <span class="hljs-keyword">var</span> ctrl, ctrlLayoutRect, ctrlSettings, flex, maxSizeItems = [], size, maxSize, ratio, rect, pos, maxAlignEndPos;
        <span class="hljs-keyword">var</span> sizeName, minSizeName, posName, maxSizeName, beforeName, innerSizeName, deltaSizeName, contentSizeName;
        <span class="hljs-keyword">var</span> alignAxisName, alignInnerSizeName, alignSizeName, alignMinSizeName, alignBeforeName, alignAfterName;
        <span class="hljs-keyword">var</span> alignDeltaSizeName, alignContentSizeName;
        <span class="hljs-keyword">var</span> max = <span class="hljs-built_in">Math</span>.max, min = <span class="hljs-built_in">Math</span>.min;</pre></div></div>
            
        </li>
        
        
        <li id="section-1849">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1849">&#182;</a>
              </div>
              <p>Get container items, properties and settings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        items = container.items().filter(<span class="hljs-string">':visible'</span>);
        contLayoutRect = container.layoutRect();
        contPaddingBox = container.paddingBox;
        contSettings = container.settings;
        direction = container.isRtl() ? (contSettings.direction || <span class="hljs-string">'row-reversed'</span>) : contSettings.direction;
        align = contSettings.align;
        pack = container.isRtl() ? (contSettings.pack || <span class="hljs-string">'end'</span>) : contSettings.pack;
        spacing = contSettings.spacing || <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (direction == <span class="hljs-string">"row-reversed"</span> || direction == <span class="hljs-string">"column-reverse"</span>) {
          items = items.set(items.toArray().reverse());
          direction = direction.split(<span class="hljs-string">'-'</span>)[<span class="hljs-number">0</span>];
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1850">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1850">&#182;</a>
              </div>
              <p>Setup axis variable name for row/column direction since the calculations is the same</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (direction == <span class="hljs-string">"column"</span>) {
          posName = <span class="hljs-string">"y"</span>;
          sizeName = <span class="hljs-string">"h"</span>;
          minSizeName = <span class="hljs-string">"minH"</span>;
          maxSizeName = <span class="hljs-string">"maxH"</span>;
          innerSizeName = <span class="hljs-string">"innerH"</span>;
          beforeName = <span class="hljs-string">'top'</span>;
          deltaSizeName = <span class="hljs-string">"deltaH"</span>;
          contentSizeName = <span class="hljs-string">"contentH"</span>;

          alignBeforeName = <span class="hljs-string">"left"</span>;
          alignSizeName = <span class="hljs-string">"w"</span>;
          alignAxisName = <span class="hljs-string">"x"</span>;
          alignInnerSizeName = <span class="hljs-string">"innerW"</span>;
          alignMinSizeName = <span class="hljs-string">"minW"</span>;
          alignAfterName = <span class="hljs-string">"right"</span>;
          alignDeltaSizeName = <span class="hljs-string">"deltaW"</span>;
          alignContentSizeName = <span class="hljs-string">"contentW"</span>;
        } <span class="hljs-keyword">else</span> {
          posName = <span class="hljs-string">"x"</span>;
          sizeName = <span class="hljs-string">"w"</span>;
          minSizeName = <span class="hljs-string">"minW"</span>;
          maxSizeName = <span class="hljs-string">"maxW"</span>;
          innerSizeName = <span class="hljs-string">"innerW"</span>;
          beforeName = <span class="hljs-string">'left'</span>;
          deltaSizeName = <span class="hljs-string">"deltaW"</span>;
          contentSizeName = <span class="hljs-string">"contentW"</span>;

          alignBeforeName = <span class="hljs-string">"top"</span>;
          alignSizeName = <span class="hljs-string">"h"</span>;
          alignAxisName = <span class="hljs-string">"y"</span>;
          alignInnerSizeName = <span class="hljs-string">"innerH"</span>;
          alignMinSizeName = <span class="hljs-string">"minH"</span>;
          alignAfterName = <span class="hljs-string">"bottom"</span>;
          alignDeltaSizeName = <span class="hljs-string">"deltaH"</span>;
          alignContentSizeName = <span class="hljs-string">"contentH"</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1851">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1851">&#182;</a>
              </div>
              <p>Figure out total flex, availableSpace and collect any max size elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        availableSpace = contLayoutRect[innerSizeName] - contPaddingBox[beforeName] - contPaddingBox[beforeName];
        maxAlignEndPos = totalFlex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = items.length; i &lt; l; i++) {
          ctrl = items[i];
          ctrlLayoutRect = ctrl.layoutRect();
          ctrlSettings = ctrl.settings;
          flex = ctrlSettings.flex;
          availableSpace -= (i &lt; l - <span class="hljs-number">1</span> ? spacing : <span class="hljs-number">0</span>);

          <span class="hljs-keyword">if</span> (flex &gt; <span class="hljs-number">0</span>) {
            totalFlex += flex;</pre></div></div>
            
        </li>
        
        
        <li id="section-1852">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1852">&#182;</a>
              </div>
              <p>Flexed item has a max size then we need to check if we will hit that size</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (ctrlLayoutRect[maxSizeName]) {
              maxSizeItems.push(ctrl);
            }

            ctrlLayoutRect.flex = flex;
          }

          availableSpace -= ctrlLayoutRect[minSizeName];</pre></div></div>
            
        </li>
        
        
        <li id="section-1853">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1853">&#182;</a>
              </div>
              <p>Calculate the align end position to be used to check for overflow/underflow</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          size = contPaddingBox[alignBeforeName] + ctrlLayoutRect[alignMinSizeName] + contPaddingBox[alignAfterName];
          <span class="hljs-keyword">if</span> (size &gt; maxAlignEndPos) {
            maxAlignEndPos = size;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1854">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1854">&#182;</a>
              </div>
              <p>Calculate minW/minH</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        rect = {};
        <span class="hljs-keyword">if</span> (availableSpace &lt; <span class="hljs-number">0</span>) {
          rect[minSizeName] = contLayoutRect[minSizeName] - availableSpace + contLayoutRect[deltaSizeName];
        } <span class="hljs-keyword">else</span> {
          rect[minSizeName] = contLayoutRect[innerSizeName] - availableSpace + contLayoutRect[deltaSizeName];
        }

        rect[alignMinSizeName] = maxAlignEndPos + contLayoutRect[alignDeltaSizeName];

        rect[contentSizeName] = contLayoutRect[innerSizeName] - availableSpace;
        rect[alignContentSizeName] = maxAlignEndPos;
        rect.minW = min(rect.minW, contLayoutRect.maxW);
        rect.minH = min(rect.minH, contLayoutRect.maxH);
        rect.minW = max(rect.minW, contLayoutRect.startMinWidth);
        rect.minH = max(rect.minH, contLayoutRect.startMinHeight);</pre></div></div>
            
        </li>
        
        
        <li id="section-1855">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1855">&#182;</a>
              </div>
              <p>Resize container container if minSize was changed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (contLayoutRect.autoResize &amp;&amp; (rect.minW != contLayoutRect.minW || rect.minH != contLayoutRect.minH)) {
          rect.w = rect.minW;
          rect.h = rect.minH;

          container.layoutRect(rect);
          <span class="hljs-keyword">this</span>.recalc(container);</pre></div></div>
            
        </li>
        
        
        <li id="section-1856">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1856">&#182;</a>
              </div>
              <p>Forced recalc for example if items are hidden/shown</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (container._lastRect === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> parentCtrl = container.parent();
            <span class="hljs-keyword">if</span> (parentCtrl) {
              parentCtrl._lastRect = <span class="hljs-literal">null</span>;
              parentCtrl.recalc();
            }
          }

          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1857">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1857">&#182;</a>
              </div>
              <p>Handle max size elements, check if they will become to wide with current options</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        ratio = availableSpace / totalFlex;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = maxSizeItems.length; i &lt; l; i++) {
          ctrl = maxSizeItems[i];
          ctrlLayoutRect = ctrl.layoutRect();
          maxSize = ctrlLayoutRect[maxSizeName];
          size = ctrlLayoutRect[minSizeName] + ctrlLayoutRect.flex * ratio;

          <span class="hljs-keyword">if</span> (size &gt; maxSize) {
            availableSpace -= (ctrlLayoutRect[maxSizeName] - ctrlLayoutRect[minSizeName]);
            totalFlex -= ctrlLayoutRect.flex;
            ctrlLayoutRect.flex = <span class="hljs-number">0</span>;
            ctrlLayoutRect.maxFlexSize = maxSize;
          } <span class="hljs-keyword">else</span> {
            ctrlLayoutRect.maxFlexSize = <span class="hljs-number">0</span>;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1858">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1858">&#182;</a>
              </div>
              <p>Setup new ratio, target layout rect, start position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        ratio = availableSpace / totalFlex;
        pos = contPaddingBox[beforeName];
        rect = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-1859">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1859">&#182;</a>
              </div>
              <p>Handle pack setting moves the start position to end, center</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (totalFlex === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">if</span> (pack == <span class="hljs-string">"end"</span>) {
            pos = availableSpace + contPaddingBox[beforeName];
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pack == <span class="hljs-string">"center"</span>) {
            pos = <span class="hljs-built_in">Math</span>.round(
              (contLayoutRect[innerSizeName] / <span class="hljs-number">2</span>) - ((contLayoutRect[innerSizeName] - availableSpace) / <span class="hljs-number">2</span>)
            ) + contPaddingBox[beforeName];

            <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">0</span>) {
              pos = contPaddingBox[beforeName];
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pack == <span class="hljs-string">"justify"</span>) {
            pos = contPaddingBox[beforeName];
            spacing = <span class="hljs-built_in">Math</span>.floor(availableSpace / (items.length - <span class="hljs-number">1</span>));
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1860">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1860">&#182;</a>
              </div>
              <p>Default aligning (start) the other ones needs to be calculated while doing the layout</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        rect[alignAxisName] = contPaddingBox[alignBeforeName];</pre></div></div>
            
        </li>
        
        
        <li id="section-1861">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1861">&#182;</a>
              </div>
              <p>Start laying out controls</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = items.length; i &lt; l; i++) {
          ctrl = items[i];
          ctrlLayoutRect = ctrl.layoutRect();
          size = ctrlLayoutRect.maxFlexSize || ctrlLayoutRect[minSizeName];</pre></div></div>
            
        </li>
        
        
        <li id="section-1862">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1862">&#182;</a>
              </div>
              <p>Align the control on the other axis</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (align === <span class="hljs-string">"center"</span>) {
            rect[alignAxisName] = <span class="hljs-built_in">Math</span>.round((contLayoutRect[alignInnerSizeName] / <span class="hljs-number">2</span>) - (ctrlLayoutRect[alignSizeName] / <span class="hljs-number">2</span>));
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (align === <span class="hljs-string">"stretch"</span>) {
            rect[alignSizeName] = max(
              ctrlLayoutRect[alignMinSizeName] || <span class="hljs-number">0</span>,
              contLayoutRect[alignInnerSizeName] - contPaddingBox[alignBeforeName] - contPaddingBox[alignAfterName]
            );
            rect[alignAxisName] = contPaddingBox[alignBeforeName];
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (align === <span class="hljs-string">"end"</span>) {
            rect[alignAxisName] = contLayoutRect[alignInnerSizeName] - ctrlLayoutRect[alignSizeName] - contPaddingBox.top;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1863">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1863">&#182;</a>
              </div>
              <p>Calculate new size based on flex</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (ctrlLayoutRect.flex &gt; <span class="hljs-number">0</span>) {
            size += ctrlLayoutRect.flex * ratio;
          }

          rect[sizeName] = size;
          rect[posName] = pos;
          ctrl.layoutRect(rect);</pre></div></div>
            
        </li>
        
        
        <li id="section-1864">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1864">&#182;</a>
              </div>
              <p>Recalculate containers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (ctrl.recalc) {
            ctrl.recalc();
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1865">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1865">&#182;</a>
              </div>
              <p>Move x/y position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          pos += size + spacing;
        }
      }
    });
  }
);
<span class="hljs-comment">/**
 * FlowLayout.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This layout manager will place the controls by using the browsers native layout.
 *
 * @-x-less FlowLayout.less
 * @class tinymce.ui.FlowLayout
 * @extends tinymce.ui.Layout
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.FlowLayout'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Layout"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Layout</span>) </span>{
    <span class="hljs-keyword">return</span> Layout.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">containerClass</span>: <span class="hljs-string">'flow-layout'</span>,
        <span class="hljs-attr">controlClass</span>: <span class="hljs-string">'flow-layout-item'</span>,
        <span class="hljs-attr">endClass</span>: <span class="hljs-string">'break'</span>
      },

      <span class="hljs-comment">/**
       * Recalculates the positions of the controls in the specified container.
       *
       * @method recalc
       * @param {tinymce.ui.Container} container Container instance to recalc.
       */</span>
      recalc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">container</span>) </span>{
        container.items().filter(<span class="hljs-string">':visible'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
          <span class="hljs-keyword">if</span> (ctrl.recalc) {
            ctrl.recalc();
          }
        });
      },

      <span class="hljs-attr">isNative</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    });
  }
);
<span class="hljs-comment">/**
 * FontInfo.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Internal class for computing font size for elements.
 *
 * @private
 * @class tinymce.fmt.FontInfo
 */</span>
define(
  <span class="hljs-string">'tinymce.core.fmt.FontInfo'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.DOMUtils"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">DOMUtils</span>) </span>{
    <span class="hljs-keyword">var</span> getSpecifiedFontProp = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">propName, rootElm, elm</span>) </span>{
      <span class="hljs-keyword">while</span> (elm !== rootElm) {
        <span class="hljs-keyword">if</span> (elm.style[propName]) {
          <span class="hljs-keyword">return</span> elm.style[propName];
        }

        elm = elm.parentNode;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    };

    <span class="hljs-keyword">var</span> toPt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fontSize</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/[0-9.]+px$/</span>.test(fontSize)) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">parseInt</span>(fontSize, <span class="hljs-number">10</span>) * <span class="hljs-number">72</span> / <span class="hljs-number">96</span>) + <span class="hljs-string">'pt'</span>;
      }

      <span class="hljs-keyword">return</span> fontSize;
    };

    <span class="hljs-keyword">var</span> normalizeFontFamily = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fontFamily</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1866">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1866">&#182;</a>
              </div>
              <p>Font name, Font -&gt; Font name,Font</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> fontFamily.replace(<span class="hljs-regexp">/[\'\"]/g</span>, <span class="hljs-string">''</span>).replace(<span class="hljs-regexp">/,\s+/g</span>, <span class="hljs-string">','</span>);
    };

    <span class="hljs-keyword">var</span> getComputedFontProp = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">propName, elm</span>) </span>{
      <span class="hljs-keyword">return</span> DOMUtils.DOM.getStyle(elm, propName, <span class="hljs-literal">true</span>);
    };

    <span class="hljs-keyword">var</span> getFontSize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootElm, elm</span>) </span>{
      <span class="hljs-keyword">var</span> specifiedFontSize = getSpecifiedFontProp(<span class="hljs-string">'fontSize'</span>, rootElm, elm);
      <span class="hljs-keyword">return</span> specifiedFontSize !== <span class="hljs-string">''</span> ? specifiedFontSize : getComputedFontProp(<span class="hljs-string">'fontSize'</span>, elm);
    };

    <span class="hljs-keyword">var</span> getFontFamily = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rootElm, elm</span>) </span>{
      <span class="hljs-keyword">var</span> specifiedFontSize = getSpecifiedFontProp(<span class="hljs-string">'fontFamily'</span>, rootElm, elm);
      <span class="hljs-keyword">var</span> fontValue = specifiedFontSize !== <span class="hljs-string">''</span> ? specifiedFontSize : getComputedFontProp(<span class="hljs-string">'fontFamily'</span>, elm);

      <span class="hljs-keyword">return</span> fontValue !== <span class="hljs-literal">undefined</span> ? normalizeFontFamily(fontValue) : <span class="hljs-string">''</span>;
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">getFontSize</span>: getFontSize,
      <span class="hljs-attr">getFontFamily</span>: getFontFamily,
      <span class="hljs-attr">toPt</span>: toPt
    };
  }
);

<span class="hljs-comment">/**
 * FormatControls.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Internal class containing all TinyMCE specific control types such as
 * format listboxes, fontlist boxes, toolbar buttons etc.
 *
 * @class tinymce.ui.FormatControls
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.FormatControls'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Control"</span>,
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>,
    <span class="hljs-string">"tinymce.core.ui.FloatPanel"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.util.Arr"</span>,
    <span class="hljs-string">"tinymce.core.dom.DOMUtils"</span>,
    <span class="hljs-string">"tinymce.core.EditorManager"</span>,
    <span class="hljs-string">"tinymce.core.Env"</span>,
    <span class="hljs-string">"tinymce.core.fmt.FontInfo"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Control, Widget, FloatPanel, Tools, Arr, DOMUtils, EditorManager, Env, FontInfo</span>) </span>{
    <span class="hljs-keyword">var</span> each = Tools.each;

    <span class="hljs-keyword">var</span> flatten = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ar</span>) </span>{
      <span class="hljs-keyword">return</span> Arr.reduce(ar, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result, item</span>) </span>{
        <span class="hljs-keyword">return</span> result.concat(item);
      }, []);
    };

    EditorManager.on(<span class="hljs-string">'AddEditor'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
      <span class="hljs-keyword">var</span> editor = e.editor;

      setupRtlMode(editor);
      registerControls(editor);
      setupContainer(editor);
    });

    Control.translate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
      <span class="hljs-keyword">return</span> EditorManager.translate(text);
    };

    Widget.tooltips = !Env.iOS;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setupContainer</span>(<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">if</span> (editor.settings.ui_container) {
        Env.container = DOMUtils.DOM.select(editor.settings.ui_container)[<span class="hljs-number">0</span>];
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setupRtlMode</span>(<span class="hljs-params">editor</span>) </span>{
      editor.on(<span class="hljs-string">'ScriptsLoaded'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (editor.rtl) {
          Control.rtl = <span class="hljs-literal">true</span>;
        }
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerControls</span>(<span class="hljs-params">editor</span>) </span>{
      <span class="hljs-keyword">var</span> formatMenu;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createListBoxChangeHandler</span>(<span class="hljs-params">items, formatName</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

          editor.on(<span class="hljs-string">'nodeChange'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">var</span> formatter = editor.formatter;
            <span class="hljs-keyword">var</span> value = <span class="hljs-literal">null</span>;

            each(e.parents, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
              each(items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
                <span class="hljs-keyword">if</span> (formatName) {
                  <span class="hljs-keyword">if</span> (formatter.matchNode(node, formatName, { <span class="hljs-attr">value</span>: item.value })) {
                    value = item.value;
                  }
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">if</span> (formatter.matchNode(node, item.value)) {
                    value = item.value;
                  }
                }

                <span class="hljs-keyword">if</span> (value) {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
              });

              <span class="hljs-keyword">if</span> (value) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
            });

            self.value(value);
          });
        };
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFontNameListBoxChangeHandler</span>(<span class="hljs-params">items</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

          <span class="hljs-keyword">var</span> getFirstFont = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fontFamily</span>) </span>{
            <span class="hljs-keyword">return</span> fontFamily ? fontFamily.split(<span class="hljs-string">','</span>)[<span class="hljs-number">0</span>] : <span class="hljs-string">''</span>;
          };

          editor.on(<span class="hljs-string">'nodeChange'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">var</span> fontFamily, value = <span class="hljs-literal">null</span>;

            fontFamily = FontInfo.getFontFamily(editor.getBody(), e.element);

            each(items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
              <span class="hljs-keyword">if</span> (item.value.toLowerCase() === fontFamily.toLowerCase()) {
                value = item.value;
              }
            });

            each(items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
              <span class="hljs-keyword">if</span> (!value &amp;&amp; getFirstFont(item.value).toLowerCase() === getFirstFont(fontFamily).toLowerCase()) {
                value = item.value;
              }
            });

            self.value(value);

            <span class="hljs-keyword">if</span> (!value &amp;&amp; fontFamily) {
              self.text(getFirstFont(fontFamily));
            }
          });
        };
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFontSizeListBoxChangeHandler</span>(<span class="hljs-params">items</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

          editor.on(<span class="hljs-string">'nodeChange'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">var</span> px, pt, value = <span class="hljs-literal">null</span>;

            px = FontInfo.getFontSize(editor.getBody(), e.element);
            pt = FontInfo.toPt(px);

            each(items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
              <span class="hljs-keyword">if</span> (item.value === px) {
                value = px;
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.value === pt) {
                value = pt;
              }
            });

            self.value(value);

            <span class="hljs-keyword">if</span> (!value) {
              self.text(pt);
            }
          });
        };
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFormats</span>(<span class="hljs-params">formats</span>) </span>{
        formats = formats.replace(<span class="hljs-regexp">/;$/</span>, <span class="hljs-string">''</span>).split(<span class="hljs-string">';'</span>);

        <span class="hljs-keyword">var</span> i = formats.length;
        <span class="hljs-keyword">while</span> (i--) {
          formats[i] = formats[i].split(<span class="hljs-string">'='</span>);
        }

        <span class="hljs-keyword">return</span> formats;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFormatMenu</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>, newFormats = [];

        <span class="hljs-keyword">var</span> defaultStyleFormats = [
          {
            <span class="hljs-attr">title</span>: <span class="hljs-string">'Headings'</span>, <span class="hljs-attr">items</span>: [
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Heading 1'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'h1'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Heading 2'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'h2'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Heading 3'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'h3'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Heading 4'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'h4'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Heading 5'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'h5'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Heading 6'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'h6'</span> }
            ]
          },

          {
            <span class="hljs-attr">title</span>: <span class="hljs-string">'Inline'</span>, <span class="hljs-attr">items</span>: [
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Bold'</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">'bold'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'bold'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Italic'</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">'italic'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'italic'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Underline'</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">'underline'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'underline'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Strikethrough'</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">'strikethrough'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'strikethrough'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Superscript'</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">'superscript'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'superscript'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Subscript'</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">'subscript'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'subscript'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Code'</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">'code'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'code'</span> }
            ]
          },

          {
            <span class="hljs-attr">title</span>: <span class="hljs-string">'Blocks'</span>, <span class="hljs-attr">items</span>: [
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Paragraph'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'p'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Blockquote'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'blockquote'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Div'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'div'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Pre'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'pre'</span> }
            ]
          },

          {
            <span class="hljs-attr">title</span>: <span class="hljs-string">'Alignment'</span>, <span class="hljs-attr">items</span>: [
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Left'</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">'alignleft'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'alignleft'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Center'</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">'aligncenter'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'aligncenter'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Right'</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">'alignright'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'alignright'</span> },
              { <span class="hljs-attr">title</span>: <span class="hljs-string">'Justify'</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">'alignjustify'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'alignjustify'</span> }
            ]
          }
        ];

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMenu</span>(<span class="hljs-params">formats</span>) </span>{
          <span class="hljs-keyword">var</span> menu = [];

          <span class="hljs-keyword">if</span> (!formats) {
            <span class="hljs-keyword">return</span>;
          }

          each(formats, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">format</span>) </span>{
            <span class="hljs-keyword">var</span> menuItem = {
              <span class="hljs-attr">text</span>: format.title,
              <span class="hljs-attr">icon</span>: format.icon
            };

            <span class="hljs-keyword">if</span> (format.items) {
              menuItem.menu = createMenu(format.items);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> formatName = format.format || <span class="hljs-string">"custom"</span> + count++;

              <span class="hljs-keyword">if</span> (!format.format) {
                format.name = formatName;
                newFormats.push(format);
              }

              menuItem.format = formatName;
              menuItem.cmd = format.cmd;
            }

            menu.push(menuItem);
          });

          <span class="hljs-keyword">return</span> menu;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStylesMenu</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> menu;

          <span class="hljs-keyword">if</span> (editor.settings.style_formats_merge) {
            <span class="hljs-keyword">if</span> (editor.settings.style_formats) {
              menu = createMenu(defaultStyleFormats.concat(editor.settings.style_formats));
            } <span class="hljs-keyword">else</span> {
              menu = createMenu(defaultStyleFormats);
            }
          } <span class="hljs-keyword">else</span> {
            menu = createMenu(editor.settings.style_formats || defaultStyleFormats);
          }

          <span class="hljs-keyword">return</span> menu;
        }

        editor.on(<span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          each(newFormats, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">format</span>) </span>{
            editor.formatter.register(format.name, format);
          });
        });

        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">type</span>: <span class="hljs-string">'menu'</span>,
          <span class="hljs-attr">items</span>: createStylesMenu(),
          <span class="hljs-attr">onPostRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            editor.fire(<span class="hljs-string">'renderFormatsMenu'</span>, { <span class="hljs-attr">control</span>: e.control });
          },
          <span class="hljs-attr">itemDefaults</span>: {
            <span class="hljs-attr">preview</span>: <span class="hljs-literal">true</span>,

            <span class="hljs-attr">textStyle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.settings.format) {
                <span class="hljs-keyword">return</span> editor.formatter.getCssText(<span class="hljs-keyword">this</span>.settings.format);
              }
            },

            <span class="hljs-attr">onPostRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

              self.parent().on(<span class="hljs-string">'show'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> formatName, command;

                formatName = self.settings.format;
                <span class="hljs-keyword">if</span> (formatName) {
                  self.disabled(!editor.formatter.canApply(formatName));
                  self.active(editor.formatter.match(formatName));
                }

                command = self.settings.cmd;
                <span class="hljs-keyword">if</span> (command) {
                  self.active(editor.queryCommandState(command));
                }
              });
            },

            <span class="hljs-attr">onclick</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.settings.format) {
                toggleFormat(<span class="hljs-keyword">this</span>.settings.format);
              }

              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.settings.cmd) {
                editor.execCommand(<span class="hljs-keyword">this</span>.settings.cmd);
              }
            }
          }
        };
      }

      formatMenu = createFormatMenu();

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initOnPostRender</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1867">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1867">&#182;</a>
              </div>
              <p>TODO: Fix this</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (editor.formatter) {
            editor.formatter.formatChanged(name, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
              self.active(state);
            });
          } <span class="hljs-keyword">else</span> {
            editor.on(<span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              editor.formatter.formatChanged(name, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
                self.active(state);
              });
            });
          }
        };
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-1868">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1868">&#182;</a>
              </div>
              <p>Simple format controls <control/format>:<UI text></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      each({
        <span class="hljs-attr">bold</span>: <span class="hljs-string">'Bold'</span>,
        <span class="hljs-attr">italic</span>: <span class="hljs-string">'Italic'</span>,
        <span class="hljs-attr">underline</span>: <span class="hljs-string">'Underline'</span>,
        <span class="hljs-attr">strikethrough</span>: <span class="hljs-string">'Strikethrough'</span>,
        <span class="hljs-attr">subscript</span>: <span class="hljs-string">'Subscript'</span>,
        <span class="hljs-attr">superscript</span>: <span class="hljs-string">'Superscript'</span>
      }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, name</span>) </span>{
        editor.addButton(name, {
          <span class="hljs-attr">tooltip</span>: text,
          <span class="hljs-attr">onPostRender</span>: initOnPostRender(name),
          <span class="hljs-attr">onclick</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            toggleFormat(name);
          }
        });
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-1869">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1869">&#182;</a>
              </div>
              <p>Simple command controls <control>:[<UI text>,<Command>]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      each({
        <span class="hljs-attr">outdent</span>: [<span class="hljs-string">'Decrease indent'</span>, <span class="hljs-string">'Outdent'</span>],
        <span class="hljs-attr">indent</span>: [<span class="hljs-string">'Increase indent'</span>, <span class="hljs-string">'Indent'</span>],
        <span class="hljs-attr">cut</span>: [<span class="hljs-string">'Cut'</span>, <span class="hljs-string">'Cut'</span>],
        <span class="hljs-attr">copy</span>: [<span class="hljs-string">'Copy'</span>, <span class="hljs-string">'Copy'</span>],
        <span class="hljs-attr">paste</span>: [<span class="hljs-string">'Paste'</span>, <span class="hljs-string">'Paste'</span>],
        <span class="hljs-attr">help</span>: [<span class="hljs-string">'Help'</span>, <span class="hljs-string">'mceHelp'</span>],
        <span class="hljs-attr">selectall</span>: [<span class="hljs-string">'Select all'</span>, <span class="hljs-string">'SelectAll'</span>],
        <span class="hljs-attr">removeformat</span>: [<span class="hljs-string">'Clear formatting'</span>, <span class="hljs-string">'RemoveFormat'</span>],
        <span class="hljs-attr">visualaid</span>: [<span class="hljs-string">'Visual aids'</span>, <span class="hljs-string">'mceToggleVisualAid'</span>],
        <span class="hljs-attr">newdocument</span>: [<span class="hljs-string">'New document'</span>, <span class="hljs-string">'mceNewDocument'</span>]
      }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, name</span>) </span>{
        editor.addButton(name, {
          <span class="hljs-attr">tooltip</span>: item[<span class="hljs-number">0</span>],
          <span class="hljs-attr">cmd</span>: item[<span class="hljs-number">1</span>]
        });
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-1870">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1870">&#182;</a>
              </div>
              <p>Simple command controls with format state</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      each({
        <span class="hljs-attr">blockquote</span>: [<span class="hljs-string">'Blockquote'</span>, <span class="hljs-string">'mceBlockQuote'</span>],
        <span class="hljs-attr">subscript</span>: [<span class="hljs-string">'Subscript'</span>, <span class="hljs-string">'Subscript'</span>],
        <span class="hljs-attr">superscript</span>: [<span class="hljs-string">'Superscript'</span>, <span class="hljs-string">'Superscript'</span>],
        <span class="hljs-attr">alignleft</span>: [<span class="hljs-string">'Align left'</span>, <span class="hljs-string">'JustifyLeft'</span>],
        <span class="hljs-attr">aligncenter</span>: [<span class="hljs-string">'Align center'</span>, <span class="hljs-string">'JustifyCenter'</span>],
        <span class="hljs-attr">alignright</span>: [<span class="hljs-string">'Align right'</span>, <span class="hljs-string">'JustifyRight'</span>],
        <span class="hljs-attr">alignjustify</span>: [<span class="hljs-string">'Justify'</span>, <span class="hljs-string">'JustifyFull'</span>],
        <span class="hljs-attr">alignnone</span>: [<span class="hljs-string">'No alignment'</span>, <span class="hljs-string">'JustifyNone'</span>]
      }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, name</span>) </span>{
        editor.addButton(name, {
          <span class="hljs-attr">tooltip</span>: item[<span class="hljs-number">0</span>],
          <span class="hljs-attr">cmd</span>: item[<span class="hljs-number">1</span>],
          <span class="hljs-attr">onPostRender</span>: initOnPostRender(name)
        });
      });

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleUndoRedoState</span>(<span class="hljs-params">type</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkState</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> typeFn = type == <span class="hljs-string">'redo'</span> ? <span class="hljs-string">'hasRedo'</span> : <span class="hljs-string">'hasUndo'</span>;
            <span class="hljs-keyword">return</span> editor.undoManager ? editor.undoManager[typeFn]() : <span class="hljs-literal">false</span>;
          }

          self.disabled(!checkState());
          editor.on(<span class="hljs-string">'Undo Redo AddUndo TypingUndo ClearUndos SwitchMode'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            self.disabled(editor.readonly || !checkState());
          });
        };
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleVisualAidState</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        editor.on(<span class="hljs-string">'VisualAid'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.active(e.hasVisual);
        });

        self.active(editor.hasVisual);
      }

      <span class="hljs-keyword">var</span> trimMenuItems = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">menuItems</span>) </span>{
        <span class="hljs-keyword">var</span> outputMenuItems = menuItems;

        <span class="hljs-keyword">if</span> (outputMenuItems.length &gt; <span class="hljs-number">0</span> &amp;&amp; outputMenuItems[<span class="hljs-number">0</span>].text === <span class="hljs-string">'-'</span>) {
          outputMenuItems = outputMenuItems.slice(<span class="hljs-number">1</span>);
        }

        <span class="hljs-keyword">if</span> (outputMenuItems.length &gt; <span class="hljs-number">0</span> &amp;&amp; outputMenuItems[outputMenuItems.length - <span class="hljs-number">1</span>].text === <span class="hljs-string">'-'</span>) {
          outputMenuItems = outputMenuItems.slice(<span class="hljs-number">0</span>, outputMenuItems.length - <span class="hljs-number">1</span>);
        }

        <span class="hljs-keyword">return</span> outputMenuItems;
      };

      <span class="hljs-keyword">var</span> createCustomMenuItems = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">names</span>) </span>{
        <span class="hljs-keyword">var</span> items, nameList;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> names === <span class="hljs-string">'string'</span>) {
          nameList = names.split(<span class="hljs-string">' '</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Tools.isArray(names)) {
          <span class="hljs-keyword">return</span> flatten(Tools.map(names, createCustomMenuItems));
        }

        items = Tools.grep(nameList, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">return</span> name === <span class="hljs-string">'|'</span> || name <span class="hljs-keyword">in</span> editor.menuItems;
        });

        <span class="hljs-keyword">return</span> Tools.map(items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          <span class="hljs-keyword">return</span> name === <span class="hljs-string">'|'</span> ? { <span class="hljs-attr">text</span>: <span class="hljs-string">'-'</span> } : editor.menuItems[name];
        });
      };

      <span class="hljs-keyword">var</span> createContextMenuItems = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>{
        <span class="hljs-keyword">var</span> outputMenuItems = [{ <span class="hljs-attr">text</span>: <span class="hljs-string">'-'</span> }];
        <span class="hljs-keyword">var</span> menuItems = Tools.grep(editor.menuItems, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">menuItem</span>) </span>{
          <span class="hljs-keyword">return</span> menuItem.context === context;
        });

        Tools.each(menuItems, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">menuItem</span>) </span>{
          <span class="hljs-keyword">if</span> (menuItem.separator == <span class="hljs-string">'before'</span>) {
            outputMenuItems.push({ <span class="hljs-attr">text</span>: <span class="hljs-string">'|'</span> });
          }

          <span class="hljs-keyword">if</span> (menuItem.prependToContext) {
            outputMenuItems.unshift(menuItem);
          } <span class="hljs-keyword">else</span> {
            outputMenuItems.push(menuItem);
          }

          <span class="hljs-keyword">if</span> (menuItem.separator == <span class="hljs-string">'after'</span>) {
            outputMenuItems.push({ <span class="hljs-attr">text</span>: <span class="hljs-string">'|'</span> });
          }
        });

        <span class="hljs-keyword">return</span> outputMenuItems;
      };

      <span class="hljs-keyword">var</span> createInsertMenu = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">editorSettings</span>) </span>{
        <span class="hljs-keyword">if</span> (editorSettings.insert_button_items) {
          <span class="hljs-keyword">return</span> trimMenuItems(createCustomMenuItems(editorSettings.insert_button_items));
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> trimMenuItems(createContextMenuItems(<span class="hljs-string">'insert'</span>));
        }
      };

      editor.addButton(<span class="hljs-string">'undo'</span>, {
        <span class="hljs-attr">tooltip</span>: <span class="hljs-string">'Undo'</span>,
        <span class="hljs-attr">onPostRender</span>: toggleUndoRedoState(<span class="hljs-string">'undo'</span>),
        <span class="hljs-attr">cmd</span>: <span class="hljs-string">'undo'</span>
      });

      editor.addButton(<span class="hljs-string">'redo'</span>, {
        <span class="hljs-attr">tooltip</span>: <span class="hljs-string">'Redo'</span>,
        <span class="hljs-attr">onPostRender</span>: toggleUndoRedoState(<span class="hljs-string">'redo'</span>),
        <span class="hljs-attr">cmd</span>: <span class="hljs-string">'redo'</span>
      });

      editor.addMenuItem(<span class="hljs-string">'newdocument'</span>, {
        <span class="hljs-attr">text</span>: <span class="hljs-string">'New document'</span>,
        <span class="hljs-attr">icon</span>: <span class="hljs-string">'newdocument'</span>,
        <span class="hljs-attr">cmd</span>: <span class="hljs-string">'mceNewDocument'</span>
      });

      editor.addMenuItem(<span class="hljs-string">'undo'</span>, {
        <span class="hljs-attr">text</span>: <span class="hljs-string">'Undo'</span>,
        <span class="hljs-attr">icon</span>: <span class="hljs-string">'undo'</span>,
        <span class="hljs-attr">shortcut</span>: <span class="hljs-string">'Meta+Z'</span>,
        <span class="hljs-attr">onPostRender</span>: toggleUndoRedoState(<span class="hljs-string">'undo'</span>),
        <span class="hljs-attr">cmd</span>: <span class="hljs-string">'undo'</span>
      });

      editor.addMenuItem(<span class="hljs-string">'redo'</span>, {
        <span class="hljs-attr">text</span>: <span class="hljs-string">'Redo'</span>,
        <span class="hljs-attr">icon</span>: <span class="hljs-string">'redo'</span>,
        <span class="hljs-attr">shortcut</span>: <span class="hljs-string">'Meta+Y'</span>,
        <span class="hljs-attr">onPostRender</span>: toggleUndoRedoState(<span class="hljs-string">'redo'</span>),
        <span class="hljs-attr">cmd</span>: <span class="hljs-string">'redo'</span>
      });

      editor.addMenuItem(<span class="hljs-string">'visualaid'</span>, {
        <span class="hljs-attr">text</span>: <span class="hljs-string">'Visual aids'</span>,
        <span class="hljs-attr">selectable</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">onPostRender</span>: toggleVisualAidState,
        <span class="hljs-attr">cmd</span>: <span class="hljs-string">'mceToggleVisualAid'</span>
      });

      editor.addButton(<span class="hljs-string">'remove'</span>, {
        <span class="hljs-attr">tooltip</span>: <span class="hljs-string">'Remove'</span>,
        <span class="hljs-attr">icon</span>: <span class="hljs-string">'remove'</span>,
        <span class="hljs-attr">cmd</span>: <span class="hljs-string">'Delete'</span>
      });

      editor.addButton(<span class="hljs-string">'insert'</span>, {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'menubutton'</span>,
        <span class="hljs-attr">icon</span>: <span class="hljs-string">'insert'</span>,
        <span class="hljs-attr">menu</span>: [],
        <span class="hljs-attr">oncreatemenu</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">this</span>.menu.add(createInsertMenu(editor.settings));
          <span class="hljs-keyword">this</span>.menu.renderNew();
        }
      });

      each({
        <span class="hljs-attr">cut</span>: [<span class="hljs-string">'Cut'</span>, <span class="hljs-string">'Cut'</span>, <span class="hljs-string">'Meta+X'</span>],
        <span class="hljs-attr">copy</span>: [<span class="hljs-string">'Copy'</span>, <span class="hljs-string">'Copy'</span>, <span class="hljs-string">'Meta+C'</span>],
        <span class="hljs-attr">paste</span>: [<span class="hljs-string">'Paste'</span>, <span class="hljs-string">'Paste'</span>, <span class="hljs-string">'Meta+V'</span>],
        <span class="hljs-attr">selectall</span>: [<span class="hljs-string">'Select all'</span>, <span class="hljs-string">'SelectAll'</span>, <span class="hljs-string">'Meta+A'</span>],
        <span class="hljs-attr">bold</span>: [<span class="hljs-string">'Bold'</span>, <span class="hljs-string">'Bold'</span>, <span class="hljs-string">'Meta+B'</span>],
        <span class="hljs-attr">italic</span>: [<span class="hljs-string">'Italic'</span>, <span class="hljs-string">'Italic'</span>, <span class="hljs-string">'Meta+I'</span>],
        <span class="hljs-attr">underline</span>: [<span class="hljs-string">'Underline'</span>, <span class="hljs-string">'Underline'</span>, <span class="hljs-string">'Meta+U'</span>],
        <span class="hljs-attr">strikethrough</span>: [<span class="hljs-string">'Strikethrough'</span>, <span class="hljs-string">'Strikethrough'</span>],
        <span class="hljs-attr">subscript</span>: [<span class="hljs-string">'Subscript'</span>, <span class="hljs-string">'Subscript'</span>],
        <span class="hljs-attr">superscript</span>: [<span class="hljs-string">'Superscript'</span>, <span class="hljs-string">'Superscript'</span>],
        <span class="hljs-attr">removeformat</span>: [<span class="hljs-string">'Clear formatting'</span>, <span class="hljs-string">'RemoveFormat'</span>]
      }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, name</span>) </span>{
        editor.addMenuItem(name, {
          <span class="hljs-attr">text</span>: item[<span class="hljs-number">0</span>],
          <span class="hljs-attr">icon</span>: name,
          <span class="hljs-attr">shortcut</span>: item[<span class="hljs-number">2</span>],
          <span class="hljs-attr">cmd</span>: item[<span class="hljs-number">1</span>]
        });
      });

      editor.on(<span class="hljs-string">'mousedown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        FloatPanel.hideAll();
      });

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleFormat</span>(<span class="hljs-params">fmt</span>) </span>{
        <span class="hljs-keyword">if</span> (fmt.control) {
          fmt = fmt.control.value();
        }

        <span class="hljs-keyword">if</span> (fmt) {
          editor.execCommand(<span class="hljs-string">'mceToggleFormat'</span>, <span class="hljs-literal">false</span>, fmt);
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hideMenuObjects</span>(<span class="hljs-params">menu</span>) </span>{
        <span class="hljs-keyword">var</span> count = menu.length;

        Tools.each(menu, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          <span class="hljs-keyword">if</span> (item.menu) {
            item.hidden = hideMenuObjects(item.menu) === <span class="hljs-number">0</span>;
          }

          <span class="hljs-keyword">var</span> formatName = item.format;
          <span class="hljs-keyword">if</span> (formatName) {
            item.hidden = !editor.formatter.canApply(formatName);
          }

          <span class="hljs-keyword">if</span> (item.hidden) {
            count--;
          }
        });

        <span class="hljs-keyword">return</span> count;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hideFormatMenuItems</span>(<span class="hljs-params">menu</span>) </span>{
        <span class="hljs-keyword">var</span> count = menu.items().length;

        menu.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          <span class="hljs-keyword">if</span> (item.menu) {
            item.visible(hideFormatMenuItems(item.menu) &gt; <span class="hljs-number">0</span>);
          }

          <span class="hljs-keyword">if</span> (!item.menu &amp;&amp; item.settings.menu) {
            item.visible(hideMenuObjects(item.settings.menu) &gt; <span class="hljs-number">0</span>);
          }

          <span class="hljs-keyword">var</span> formatName = item.settings.format;
          <span class="hljs-keyword">if</span> (formatName) {
            item.visible(editor.formatter.canApply(formatName));
          }

          <span class="hljs-keyword">if</span> (!item.visible()) {
            count--;
          }
        });

        <span class="hljs-keyword">return</span> count;
      }

      editor.addButton(<span class="hljs-string">'styleselect'</span>, {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'menubutton'</span>,
        <span class="hljs-attr">text</span>: <span class="hljs-string">'Formats'</span>,
        <span class="hljs-attr">menu</span>: formatMenu,
        <span class="hljs-attr">onShowMenu</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (editor.settings.style_formats_autohide) {
            hideFormatMenuItems(<span class="hljs-keyword">this</span>.menu);
          }
        }
      });

      editor.addButton(<span class="hljs-string">'formatselect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> items = [], blocks = createFormats(editor.settings.block_formats ||
          <span class="hljs-string">'Paragraph=p;'</span> +
          <span class="hljs-string">'Heading 1=h1;'</span> +
          <span class="hljs-string">'Heading 2=h2;'</span> +
          <span class="hljs-string">'Heading 3=h3;'</span> +
          <span class="hljs-string">'Heading 4=h4;'</span> +
          <span class="hljs-string">'Heading 5=h5;'</span> +
          <span class="hljs-string">'Heading 6=h6;'</span> +
          <span class="hljs-string">'Preformatted=pre'</span>
        );

        each(blocks, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">block</span>) </span>{
          items.push({
            <span class="hljs-attr">text</span>: block[<span class="hljs-number">0</span>],
            <span class="hljs-attr">value</span>: block[<span class="hljs-number">1</span>],
            <span class="hljs-attr">textStyle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">return</span> editor.formatter.getCssText(block[<span class="hljs-number">1</span>]);
            }
          });
        });

        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">type</span>: <span class="hljs-string">'listbox'</span>,
          <span class="hljs-attr">text</span>: blocks[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],
          <span class="hljs-attr">values</span>: items,
          <span class="hljs-attr">fixedWidth</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">onselect</span>: toggleFormat,
          <span class="hljs-attr">onPostRender</span>: createListBoxChangeHandler(items)
        };
      });

      editor.addButton(<span class="hljs-string">'fontselect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> defaultFontsFormats =
          <span class="hljs-string">'Andale Mono=andale mono,monospace;'</span> +
          <span class="hljs-string">'Arial=arial,helvetica,sans-serif;'</span> +
          <span class="hljs-string">'Arial Black=arial black,sans-serif;'</span> +
          <span class="hljs-string">'Book Antiqua=book antiqua,palatino,serif;'</span> +
          <span class="hljs-string">'Comic Sans MS=comic sans ms,sans-serif;'</span> +
          <span class="hljs-string">'Courier New=courier new,courier,monospace;'</span> +
          <span class="hljs-string">'Georgia=georgia,palatino,serif;'</span> +
          <span class="hljs-string">'Helvetica=helvetica,arial,sans-serif;'</span> +
          <span class="hljs-string">'Impact=impact,sans-serif;'</span> +
          <span class="hljs-string">'Symbol=symbol;'</span> +
          <span class="hljs-string">'Tahoma=tahoma,arial,helvetica,sans-serif;'</span> +
          <span class="hljs-string">'Terminal=terminal,monaco,monospace;'</span> +
          <span class="hljs-string">'Times New Roman=times new roman,times,serif;'</span> +
          <span class="hljs-string">'Trebuchet MS=trebuchet ms,geneva,sans-serif;'</span> +
          <span class="hljs-string">'Verdana=verdana,geneva,sans-serif;'</span> +
          <span class="hljs-string">'Webdings=webdings;'</span> +
          <span class="hljs-string">'Wingdings=wingdings,zapf dingbats'</span>;

        <span class="hljs-keyword">var</span> items = [], fonts = createFormats(editor.settings.font_formats || defaultFontsFormats);

        each(fonts, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">font</span>) </span>{
          items.push({
            <span class="hljs-attr">text</span>: { <span class="hljs-attr">raw</span>: font[<span class="hljs-number">0</span>] },
            <span class="hljs-attr">value</span>: font[<span class="hljs-number">1</span>],
            <span class="hljs-attr">textStyle</span>: font[<span class="hljs-number">1</span>].indexOf(<span class="hljs-string">'dings'</span>) == <span class="hljs-number">-1</span> ? <span class="hljs-string">'font-family:'</span> + font[<span class="hljs-number">1</span>] : <span class="hljs-string">''</span>
          });
        });

        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">type</span>: <span class="hljs-string">'listbox'</span>,
          <span class="hljs-attr">text</span>: <span class="hljs-string">'Font Family'</span>,
          <span class="hljs-attr">tooltip</span>: <span class="hljs-string">'Font Family'</span>,
          <span class="hljs-attr">values</span>: items,
          <span class="hljs-attr">fixedWidth</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">onPostRender</span>: createFontNameListBoxChangeHandler(items),
          <span class="hljs-attr">onselect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">if</span> (e.control.settings.value) {
              editor.execCommand(<span class="hljs-string">'FontName'</span>, <span class="hljs-literal">false</span>, e.control.settings.value);
            }
          }
        };
      });

      editor.addButton(<span class="hljs-string">'fontsizeselect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> items = [], defaultFontsizeFormats = <span class="hljs-string">'8pt 10pt 12pt 14pt 18pt 24pt 36pt'</span>;
        <span class="hljs-keyword">var</span> fontsizeFormats = editor.settings.fontsize_formats || defaultFontsizeFormats;

        each(fontsizeFormats.split(<span class="hljs-string">' '</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          <span class="hljs-keyword">var</span> text = item, value = item;</pre></div></div>
            
        </li>
        
        
        <li id="section-1871">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1871">&#182;</a>
              </div>
              <p>Allow text=value font sizes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> values = item.split(<span class="hljs-string">'='</span>);
          <span class="hljs-keyword">if</span> (values.length &gt; <span class="hljs-number">1</span>) {
            text = values[<span class="hljs-number">0</span>];
            value = values[<span class="hljs-number">1</span>];
          }
          items.push({ <span class="hljs-attr">text</span>: text, <span class="hljs-attr">value</span>: value });
        });

        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">type</span>: <span class="hljs-string">'listbox'</span>,
          <span class="hljs-attr">text</span>: <span class="hljs-string">'Font Sizes'</span>,
          <span class="hljs-attr">tooltip</span>: <span class="hljs-string">'Font Sizes'</span>,
          <span class="hljs-attr">values</span>: items,
          <span class="hljs-attr">fixedWidth</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">onPostRender</span>: createFontSizeListBoxChangeHandler(items),
          <span class="hljs-attr">onclick</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">if</span> (e.control.settings.value) {
              editor.execCommand(<span class="hljs-string">'FontSize'</span>, <span class="hljs-literal">false</span>, e.control.settings.value);
            }
          }
        };
      });

      editor.addMenuItem(<span class="hljs-string">'formats'</span>, {
        <span class="hljs-attr">text</span>: <span class="hljs-string">'Formats'</span>,
        <span class="hljs-attr">menu</span>: formatMenu
      });
    }

    <span class="hljs-keyword">return</span> {};
  }
);

<span class="hljs-comment">/**
 * GridLayout.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This layout manager places controls in a grid.
 *
 * @setting {Number} spacing Spacing between controls.
 * @setting {Number} spacingH Horizontal spacing between controls.
 * @setting {Number} spacingV Vertical spacing between controls.
 * @setting {Number} columns Number of columns to use.
 * @setting {String/Array} alignH start|end|center|stretch or array of values for each column.
 * @setting {String/Array} alignV start|end|center|stretch or array of values for each column.
 * @setting {String} pack start|end
 *
 * @class tinymce.ui.GridLayout
 * @extends tinymce.ui.AbsoluteLayout
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.GridLayout'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.AbsoluteLayout"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">AbsoluteLayout</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> AbsoluteLayout.extend({
      <span class="hljs-comment">/**
       * Recalculates the positions of the controls in the specified container.
       *
       * @method recalc
       * @param {tinymce.ui.Container} container Container instance to recalc.
       */</span>
      recalc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">container</span>) </span>{
        <span class="hljs-keyword">var</span> settings, rows, cols, items, contLayoutRect, width, height, rect,
          ctrlLayoutRect, ctrl, x, y, posX, posY, ctrlSettings, contPaddingBox, align, spacingH, spacingV, alignH, alignV, maxX, maxY,
          colWidths = [], rowHeights = [], ctrlMinWidth, ctrlMinHeight, availableWidth, availableHeight, reverseRows, idx;</pre></div></div>
            
        </li>
        
        
        <li id="section-1872">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1872">&#182;</a>
              </div>
              <p>Get layout settings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        settings = container.settings;
        items = container.items().filter(<span class="hljs-string">':visible'</span>);
        contLayoutRect = container.layoutRect();
        cols = settings.columns || <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">Math</span>.sqrt(items.length));
        rows = <span class="hljs-built_in">Math</span>.ceil(items.length / cols);
        spacingH = settings.spacingH || settings.spacing || <span class="hljs-number">0</span>;
        spacingV = settings.spacingV || settings.spacing || <span class="hljs-number">0</span>;
        alignH = settings.alignH || settings.align;
        alignV = settings.alignV || settings.align;
        contPaddingBox = container.paddingBox;
        reverseRows = <span class="hljs-string">'reverseRows'</span> <span class="hljs-keyword">in</span> settings ? settings.reverseRows : container.isRtl();

        <span class="hljs-keyword">if</span> (alignH &amp;&amp; <span class="hljs-keyword">typeof</span> alignH == <span class="hljs-string">"string"</span>) {
          alignH = [alignH];
        }

        <span class="hljs-keyword">if</span> (alignV &amp;&amp; <span class="hljs-keyword">typeof</span> alignV == <span class="hljs-string">"string"</span>) {
          alignV = [alignV];
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1873">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1873">&#182;</a>
              </div>
              <p>Zero padd columnWidths</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; cols; x++) {
          colWidths.push(<span class="hljs-number">0</span>);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1874">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1874">&#182;</a>
              </div>
              <p>Zero padd rowHeights</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; rows; y++) {
          rowHeights.push(<span class="hljs-number">0</span>);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1875">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1875">&#182;</a>
              </div>
              <p>Calculate columnWidths and rowHeights</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; rows; y++) {
          <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; cols; x++) {
            ctrl = items[y * cols + x];</pre></div></div>
            
        </li>
        
        
        <li id="section-1876">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1876">&#182;</a>
              </div>
              <p>Out of bounds</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!ctrl) {
              <span class="hljs-keyword">break</span>;
            }

            ctrlLayoutRect = ctrl.layoutRect();
            ctrlMinWidth = ctrlLayoutRect.minW;
            ctrlMinHeight = ctrlLayoutRect.minH;

            colWidths[x] = ctrlMinWidth &gt; colWidths[x] ? ctrlMinWidth : colWidths[x];
            rowHeights[y] = ctrlMinHeight &gt; rowHeights[y] ? ctrlMinHeight : rowHeights[y];
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1877">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1877">&#182;</a>
              </div>
              <p>Calculate maxX</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        availableWidth = contLayoutRect.innerW - contPaddingBox.left - contPaddingBox.right;
        <span class="hljs-keyword">for</span> (maxX = <span class="hljs-number">0</span>, x = <span class="hljs-number">0</span>; x &lt; cols; x++) {
          maxX += colWidths[x] + (x &gt; <span class="hljs-number">0</span> ? spacingH : <span class="hljs-number">0</span>);
          availableWidth -= (x &gt; <span class="hljs-number">0</span> ? spacingH : <span class="hljs-number">0</span>) + colWidths[x];
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1878">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1878">&#182;</a>
              </div>
              <p>Calculate maxY</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        availableHeight = contLayoutRect.innerH - contPaddingBox.top - contPaddingBox.bottom;
        <span class="hljs-keyword">for</span> (maxY = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>; y &lt; rows; y++) {
          maxY += rowHeights[y] + (y &gt; <span class="hljs-number">0</span> ? spacingV : <span class="hljs-number">0</span>);
          availableHeight -= (y &gt; <span class="hljs-number">0</span> ? spacingV : <span class="hljs-number">0</span>) + rowHeights[y];
        }

        maxX += contPaddingBox.left + contPaddingBox.right;
        maxY += contPaddingBox.top + contPaddingBox.bottom;</pre></div></div>
            
        </li>
        
        
        <li id="section-1879">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1879">&#182;</a>
              </div>
              <p>Calculate minW/minH</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        rect = {};
        rect.minW = maxX + (contLayoutRect.w - contLayoutRect.innerW);
        rect.minH = maxY + (contLayoutRect.h - contLayoutRect.innerH);

        rect.contentW = rect.minW - contLayoutRect.deltaW;
        rect.contentH = rect.minH - contLayoutRect.deltaH;
        rect.minW = <span class="hljs-built_in">Math</span>.min(rect.minW, contLayoutRect.maxW);
        rect.minH = <span class="hljs-built_in">Math</span>.min(rect.minH, contLayoutRect.maxH);
        rect.minW = <span class="hljs-built_in">Math</span>.max(rect.minW, contLayoutRect.startMinWidth);
        rect.minH = <span class="hljs-built_in">Math</span>.max(rect.minH, contLayoutRect.startMinHeight);</pre></div></div>
            
        </li>
        
        
        <li id="section-1880">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1880">&#182;</a>
              </div>
              <p>Resize container container if minSize was changed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (contLayoutRect.autoResize &amp;&amp; (rect.minW != contLayoutRect.minW || rect.minH != contLayoutRect.minH)) {
          rect.w = rect.minW;
          rect.h = rect.minH;

          container.layoutRect(rect);
          <span class="hljs-keyword">this</span>.recalc(container);</pre></div></div>
            
        </li>
        
        
        <li id="section-1881">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1881">&#182;</a>
              </div>
              <p>Forced recalc for example if items are hidden/shown</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (container._lastRect === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> parentCtrl = container.parent();
            <span class="hljs-keyword">if</span> (parentCtrl) {
              parentCtrl._lastRect = <span class="hljs-literal">null</span>;
              parentCtrl.recalc();
            }
          }

          <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1882">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1882">&#182;</a>
              </div>
              <p>Update contentW/contentH so absEnd moves correctly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (contLayoutRect.autoResize) {
          rect = container.layoutRect(rect);
          rect.contentW = rect.minW - contLayoutRect.deltaW;
          rect.contentH = rect.minH - contLayoutRect.deltaH;
        }

        <span class="hljs-keyword">var</span> flexV;

        <span class="hljs-keyword">if</span> (settings.packV == <span class="hljs-string">'start'</span>) {
          flexV = <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> {
          flexV = availableHeight &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">Math</span>.floor(availableHeight / rows) : <span class="hljs-number">0</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1883">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1883">&#182;</a>
              </div>
              <p>Calculate totalFlex</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> totalFlex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> flexWidths = settings.flexWidths;
        <span class="hljs-keyword">if</span> (flexWidths) {
          <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; flexWidths.length; x++) {
            totalFlex += flexWidths[x];
          }
        } <span class="hljs-keyword">else</span> {
          totalFlex = cols;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1884">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1884">&#182;</a>
              </div>
              <p>Calculate new column widths based on flex values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> ratio = availableWidth / totalFlex;
        <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; cols; x++) {
          colWidths[x] += flexWidths ? flexWidths[x] * ratio : ratio;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1885">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1885">&#182;</a>
              </div>
              <p>Move/resize controls</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        posY = contPaddingBox.top;
        <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; rows; y++) {
          posX = contPaddingBox.left;
          height = rowHeights[y] + flexV;

          <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; cols; x++) {
            <span class="hljs-keyword">if</span> (reverseRows) {
              idx = y * cols + cols - <span class="hljs-number">1</span> - x;
            } <span class="hljs-keyword">else</span> {
              idx = y * cols + x;
            }

            ctrl = items[idx];</pre></div></div>
            
        </li>
        
        
        <li id="section-1886">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1886">&#182;</a>
              </div>
              <p>No more controls to render then break</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!ctrl) {
              <span class="hljs-keyword">break</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1887">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1887">&#182;</a>
              </div>
              <p>Get control settings and calculate x, y</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            ctrlSettings = ctrl.settings;
            ctrlLayoutRect = ctrl.layoutRect();
            width = <span class="hljs-built_in">Math</span>.max(colWidths[x], ctrlLayoutRect.startMinWidth);
            ctrlLayoutRect.x = posX;
            ctrlLayoutRect.y = posY;</pre></div></div>
            
        </li>
        
        
        <li id="section-1888">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1888">&#182;</a>
              </div>
              <p>Align control horizontal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            align = ctrlSettings.alignH || (alignH ? (alignH[x] || alignH[<span class="hljs-number">0</span>]) : <span class="hljs-literal">null</span>);
            <span class="hljs-keyword">if</span> (align == <span class="hljs-string">"center"</span>) {
              ctrlLayoutRect.x = posX + (width / <span class="hljs-number">2</span>) - (ctrlLayoutRect.w / <span class="hljs-number">2</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (align == <span class="hljs-string">"right"</span>) {
              ctrlLayoutRect.x = posX + width - ctrlLayoutRect.w;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (align == <span class="hljs-string">"stretch"</span>) {
              ctrlLayoutRect.w = width;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1889">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1889">&#182;</a>
              </div>
              <p>Align control vertical</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            align = ctrlSettings.alignV || (alignV ? (alignV[x] || alignV[<span class="hljs-number">0</span>]) : <span class="hljs-literal">null</span>);
            <span class="hljs-keyword">if</span> (align == <span class="hljs-string">"center"</span>) {
              ctrlLayoutRect.y = posY + (height / <span class="hljs-number">2</span>) - (ctrlLayoutRect.h / <span class="hljs-number">2</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (align == <span class="hljs-string">"bottom"</span>) {
              ctrlLayoutRect.y = posY + height - ctrlLayoutRect.h;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (align == <span class="hljs-string">"stretch"</span>) {
              ctrlLayoutRect.h = height;
            }

            ctrl.layoutRect(ctrlLayoutRect);

            posX += width + spacingH;

            <span class="hljs-keyword">if</span> (ctrl.recalc) {
              ctrl.recalc();
            }
          }

          posY += height + spacingV;
        }
      }
    });
  }
);

<span class="hljs-comment">/**
 * Iframe.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/*jshint scripturl:true */</span>

<span class="hljs-comment">/**
 * This class creates an iframe.
 *
 * @setting {String} url Url to open in the iframe.
 *
 * @-x-less Iframe.less
 * @class tinymce.ui.Iframe
 * @extends tinymce.ui.Widget
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Iframe'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>,
    <span class="hljs-string">"tinymce.core.util.Delay"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget, Delay</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.classes.add(<span class="hljs-string">'iframe'</span>);
        self.canFocus = <span class="hljs-literal">false</span>;

        <span class="hljs-comment">/*eslint no-script-url:0 */</span>
        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;iframe id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'" tabindex="-1" src="'</span> +
          (self.settings.url || <span class="hljs-string">"javascript:''"</span>) + <span class="hljs-string">'" frameborder="0"&gt;&lt;/iframe&gt;'</span>
        );
      },

      <span class="hljs-comment">/**
       * Setter for the iframe source.
       *
       * @method src
       * @param {String} src Source URL for iframe.
       */</span>
      src: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">src</span>) </span>{
        <span class="hljs-keyword">this</span>.getEl().src = src;
      },

      <span class="hljs-comment">/**
       * Inner HTML for the iframe.
       *
       * @method html
       * @param {String} html HTML string to set as HTML inside the iframe.
       * @param {function} callback Optional callback to execute when the iframe body is filled with contents.
       * @return {tinymce.ui.Iframe} Current iframe control.
       */</span>
      html: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">html, callback</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, body = <span class="hljs-keyword">this</span>.getEl().contentWindow.document.body;</pre></div></div>
            
        </li>
        
        
        <li id="section-1890">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1890">&#182;</a>
              </div>
              <p>Wait for iframe to initialize IE 10 takes time</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!body) {
          Delay.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            self.html(html);
          });
        } <span class="hljs-keyword">else</span> {
          body.innerHTML = html;

          <span class="hljs-keyword">if</span> (callback) {
            callback();
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      }
    });
  }
);

<span class="hljs-comment">/**
 * InfoBox.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * ....
 *
 * @-x-less InfoBox.less
 * @class tinymce.ui.InfoBox
 * @extends tinymce.ui.Widget
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.InfoBox'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-comment">/**
       * Constructs a instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {Boolean} multiline Multiline label.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super(settings);
        self.classes.add(<span class="hljs-string">'widget'</span>).add(<span class="hljs-string">'infobox'</span>);
        self.canFocus = <span class="hljs-literal">false</span>;
      },

      <span class="hljs-attr">severity</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">level</span>) </span>{
        <span class="hljs-keyword">this</span>.classes.remove(<span class="hljs-string">'error'</span>);
        <span class="hljs-keyword">this</span>.classes.remove(<span class="hljs-string">'warning'</span>);
        <span class="hljs-keyword">this</span>.classes.remove(<span class="hljs-string">'success'</span>);
        <span class="hljs-keyword">this</span>.classes.add(level);
      },

      <span class="hljs-attr">help</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
        <span class="hljs-keyword">this</span>.state.set(<span class="hljs-string">'help'</span>, state);
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, prefix = self.classPrefix;

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'"&gt;'</span> +
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'-body"&gt;'</span> +
          self.encode(self.state.get(<span class="hljs-string">'text'</span>)) +
          <span class="hljs-string">'&lt;button role="button" tabindex="-1"&gt;'</span> +
          <span class="hljs-string">'&lt;i class="'</span> + prefix + <span class="hljs-string">'ico '</span> + prefix + <span class="hljs-string">'i-help"&gt;&lt;/i&gt;'</span> +
          <span class="hljs-string">'&lt;/button&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.state.on(<span class="hljs-string">'change:text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.getEl(<span class="hljs-string">'body'</span>).firstChild.data = self.encode(e.value);

          <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'rendered'</span>)) {
            self.updateLayoutRect();
          }
        });

        self.state.on(<span class="hljs-string">'change:help'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.classes.toggle(<span class="hljs-string">'has-help'</span>, e.value);

          <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'rendered'</span>)) {
            self.updateLayoutRect();
          }
        });

        <span class="hljs-keyword">return</span> self._super();
      }
    });
  }
);

<span class="hljs-comment">/**
 * Label.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class creates a label element. A label is a simple text control
 * that can be bound to other controls.
 *
 * @-x-less Label.less
 * @class tinymce.ui.Label
 * @extends tinymce.ui.Widget
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Label'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>,
    <span class="hljs-string">"tinymce.core.ui.DomUtils"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget, DomUtils</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-comment">/**
       * Constructs a instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {Boolean} multiline Multiline label.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super(settings);
        self.classes.add(<span class="hljs-string">'widget'</span>).add(<span class="hljs-string">'label'</span>);
        self.canFocus = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (settings.multiline) {
          self.classes.add(<span class="hljs-string">'autoscroll'</span>);
        }

        <span class="hljs-keyword">if</span> (settings.strong) {
          self.classes.add(<span class="hljs-string">'strong'</span>);
        }
      },

      <span class="hljs-comment">/**
       * Initializes the current controls layout rect.
       * This will be executed by the layout managers to determine the
       * default minWidth/minHeight etc.
       *
       * @method initLayoutRect
       * @return {Object} Layout rect instance.
       */</span>
      initLayoutRect: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, layoutRect = self._super();

        <span class="hljs-keyword">if</span> (self.settings.multiline) {
          <span class="hljs-keyword">var</span> size = DomUtils.getSize(self.getEl());</pre></div></div>
            
        </li>
        
        
        <li id="section-1891">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1891">&#182;</a>
              </div>
              <p>Check if the text fits within maxW if not then try word wrapping it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (size.width &gt; layoutRect.maxW) {
            layoutRect.minW = layoutRect.maxW;
            self.classes.add(<span class="hljs-string">'multiline'</span>);
          }

          self.getEl().style.width = layoutRect.minW + <span class="hljs-string">'px'</span>;
          layoutRect.startMinH = layoutRect.h = layoutRect.minH = <span class="hljs-built_in">Math</span>.min(layoutRect.maxH, DomUtils.getSize(self.getEl()).height);
        }

        <span class="hljs-keyword">return</span> layoutRect;
      },

      <span class="hljs-comment">/**
       * Repaints the control after a layout operation.
       *
       * @method repaint
       */</span>
      repaint: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (!self.settings.multiline) {
          self.getEl().style.lineHeight = self.layoutRect().h + <span class="hljs-string">'px'</span>;
        }

        <span class="hljs-keyword">return</span> self._super();
      },

      <span class="hljs-attr">severity</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">level</span>) </span>{
        <span class="hljs-keyword">this</span>.classes.remove(<span class="hljs-string">'error'</span>);
        <span class="hljs-keyword">this</span>.classes.remove(<span class="hljs-string">'warning'</span>);
        <span class="hljs-keyword">this</span>.classes.remove(<span class="hljs-string">'success'</span>);
        <span class="hljs-keyword">this</span>.classes.add(level);
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, targetCtrl, forName, forId = self.settings.forId;
        <span class="hljs-keyword">var</span> text = self.settings.html ? self.settings.html : self.encode(self.state.get(<span class="hljs-string">'text'</span>));

        <span class="hljs-keyword">if</span> (!forId &amp;&amp; (forName = self.settings.forName)) {
          targetCtrl = self.getRoot().find(<span class="hljs-string">'#'</span> + forName)[<span class="hljs-number">0</span>];

          <span class="hljs-keyword">if</span> (targetCtrl) {
            forId = targetCtrl._id;
          }
        }

        <span class="hljs-keyword">if</span> (forId) {
          <span class="hljs-keyword">return</span> (
            <span class="hljs-string">'&lt;label id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'"'</span> + (forId ? <span class="hljs-string">' for="'</span> + forId + <span class="hljs-string">'"'</span> : <span class="hljs-string">''</span>) + <span class="hljs-string">'&gt;'</span> +
            text +
            <span class="hljs-string">'&lt;/label&gt;'</span>
          );
        }

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;span id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'"&gt;'</span> +
          text +
          <span class="hljs-string">'&lt;/span&gt;'</span>
        );
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.state.on(<span class="hljs-string">'change:text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.innerHtml(self.encode(e.value));

          <span class="hljs-keyword">if</span> (self.state.get(<span class="hljs-string">'rendered'</span>)) {
            self.updateLayoutRect();
          }
        });

        <span class="hljs-keyword">return</span> self._super();
      }
    });
  }
);

<span class="hljs-comment">/**
 * Toolbar.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a new toolbar.
 *
 * @class tinymce.ui.Toolbar
 * @extends tinymce.ui.Container
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Toolbar'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Container"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Container</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Container.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">role</span>: <span class="hljs-string">'toolbar'</span>,
        <span class="hljs-attr">layout</span>: <span class="hljs-string">'flow'</span>
      },

      <span class="hljs-comment">/**
       * Constructs a instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super(settings);
        self.classes.add(<span class="hljs-string">'toolbar'</span>);
      },

      <span class="hljs-comment">/**
       * Called after the control has been rendered.
       *
       * @method postRender
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
          ctrl.classes.add(<span class="hljs-string">'toolbar-item'</span>);
        });

        <span class="hljs-keyword">return</span> self._super();
      }
    });
  }
);
<span class="hljs-comment">/**
 * MenuBar.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a new menubar.
 *
 * @-x-less MenuBar.less
 * @class tinymce.ui.MenuBar
 * @extends tinymce.ui.Container
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.MenuBar'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Toolbar"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Toolbar</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Toolbar.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">role</span>: <span class="hljs-string">'menubar'</span>,
        <span class="hljs-attr">containerCls</span>: <span class="hljs-string">'menubar'</span>,
        <span class="hljs-attr">ariaRoot</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">defaults</span>: {
          <span class="hljs-attr">type</span>: <span class="hljs-string">'menubutton'</span>
        }
      }
    });
  }
);
<span class="hljs-comment">/**
 * MenuButton.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a new menu button.
 *
 * @-x-less MenuButton.less
 * @class tinymce.ui.MenuButton
 * @extends tinymce.ui.Button
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.MenuButton'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Button"</span>,
    <span class="hljs-string">"tinymce.core.ui.Factory"</span>,
    <span class="hljs-string">"tinymce.core.ui.MenuBar"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Button, Factory, MenuBar</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1892">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1892">&#182;</a>
              </div>
              <p>TODO: Maybe add as some global function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isChildOf</span>(<span class="hljs-params">node, parent</span>) </span>{
      <span class="hljs-keyword">while</span> (node) {
        <span class="hljs-keyword">if</span> (parent === node) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        node = node.parentNode;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> MenuButton = Button.extend({
      <span class="hljs-comment">/**
       * Constructs a instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._renderOpen = <span class="hljs-literal">true</span>;

        self._super(settings);
        settings = self.settings;

        self.classes.add(<span class="hljs-string">'menubtn'</span>);

        <span class="hljs-keyword">if</span> (settings.fixedWidth) {
          self.classes.add(<span class="hljs-string">'fixed-width'</span>);
        }

        self.aria(<span class="hljs-string">'haspopup'</span>, <span class="hljs-literal">true</span>);

        self.state.set(<span class="hljs-string">'menu'</span>, settings.menu || self.render());
      },

      <span class="hljs-comment">/**
       * Shows the menu for the button.
       *
       * @method showMenu
       */</span>
      showMenu: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">toggle</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, menu;

        <span class="hljs-keyword">if</span> (self.menu &amp;&amp; self.menu.visible() &amp;&amp; toggle !== <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">return</span> self.hideMenu();
        }

        <span class="hljs-keyword">if</span> (!self.menu) {
          menu = self.state.get(<span class="hljs-string">'menu'</span>) || [];</pre></div></div>
            
        </li>
        
        
        <li id="section-1893">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1893">&#182;</a>
              </div>
              <p>Is menu array then auto constuct menu control</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (menu.length) {
            menu = {
              <span class="hljs-attr">type</span>: <span class="hljs-string">'menu'</span>,
              <span class="hljs-attr">items</span>: menu
            };
          } <span class="hljs-keyword">else</span> {
            menu.type = menu.type || <span class="hljs-string">'menu'</span>;
          }

          <span class="hljs-keyword">if</span> (!menu.renderTo) {
            self.menu = Factory.create(menu).parent(self).renderTo();
          } <span class="hljs-keyword">else</span> {
            self.menu = menu.parent(self).show().renderTo();
          }

          self.fire(<span class="hljs-string">'createmenu'</span>);
          self.menu.reflow();
          self.menu.on(<span class="hljs-string">'cancel'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">if</span> (e.control.parent() === self.menu) {
              e.stopPropagation();
              self.focus();
              self.hideMenu();
            }
          });</pre></div></div>
            
        </li>
        
        
        <li id="section-1894">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1894">&#182;</a>
              </div>
              <p>Move focus to button when a menu item is selected/clicked</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          self.menu.on(<span class="hljs-string">'select'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            self.focus();
          });

          self.menu.on(<span class="hljs-string">'show hide'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">if</span> (e.control == self.menu) {
              self.activeMenu(e.type == <span class="hljs-string">'show'</span>);
            }

            self.aria(<span class="hljs-string">'expanded'</span>, e.type == <span class="hljs-string">'show'</span>);
          }).fire(<span class="hljs-string">'show'</span>);
        }

        self.menu.show();
        self.menu.layoutRect({ <span class="hljs-attr">w</span>: self.layoutRect().w });
        self.menu.moveRel(self.getEl(), self.isRtl() ? [<span class="hljs-string">'br-tr'</span>, <span class="hljs-string">'tr-br'</span>] : [<span class="hljs-string">'bl-tl'</span>, <span class="hljs-string">'tl-bl'</span>]);
        self.fire(<span class="hljs-string">'showmenu'</span>);
      },

      <span class="hljs-comment">/**
       * Hides the menu for the button.
       *
       * @method hideMenu
       */</span>
      hideMenu: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (self.menu) {
          self.menu.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
            <span class="hljs-keyword">if</span> (item.hideMenu) {
              item.hideMenu();
            }
          });

          self.menu.hide();
        }
      },

      <span class="hljs-comment">/**
       * Sets the active menu state.
       *
       * @private
       */</span>
      activeMenu: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
        <span class="hljs-keyword">this</span>.classes.toggle(<span class="hljs-string">'active'</span>, state);
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, id = self._id, prefix = self.classPrefix;
        <span class="hljs-keyword">var</span> icon = self.settings.icon, image, text = self.state.get(<span class="hljs-string">'text'</span>),
          textHtml = <span class="hljs-string">''</span>;

        image = self.settings.image;
        <span class="hljs-keyword">if</span> (image) {
          icon = <span class="hljs-string">'none'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1895">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1895">&#182;</a>
              </div>
              <p>Support for [high dpi, low dpi] image sources</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> image != <span class="hljs-string">"string"</span>) {
            image = <span class="hljs-built_in">window</span>.getSelection ? image[<span class="hljs-number">0</span>] : image[<span class="hljs-number">1</span>];
          }

          image = <span class="hljs-string">' style="background-image: url(\''</span> + image + <span class="hljs-string">'\')"'</span>;
        } <span class="hljs-keyword">else</span> {
          image = <span class="hljs-string">''</span>;
        }

        <span class="hljs-keyword">if</span> (text) {
          self.classes.add(<span class="hljs-string">'btn-has-text'</span>);
          textHtml = <span class="hljs-string">'&lt;span class="'</span> + prefix + <span class="hljs-string">'txt"&gt;'</span> + self.encode(text) + <span class="hljs-string">'&lt;/span&gt;'</span>;
        }

        icon = self.settings.icon ? prefix + <span class="hljs-string">'ico '</span> + prefix + <span class="hljs-string">'i-'</span> + icon : <span class="hljs-string">''</span>;

        self.aria(<span class="hljs-string">'role'</span>, self.parent() <span class="hljs-keyword">instanceof</span> MenuBar ? <span class="hljs-string">'menuitem'</span> : <span class="hljs-string">'button'</span>);

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'" tabindex="-1" aria-labelledby="'</span> + id + <span class="hljs-string">'"&gt;'</span> +
          <span class="hljs-string">'&lt;button id="'</span> + id + <span class="hljs-string">'-open" role="presentation" type="button" tabindex="-1"&gt;'</span> +
          (icon ? <span class="hljs-string">'&lt;i class="'</span> + icon + <span class="hljs-string">'"'</span> + image + <span class="hljs-string">'&gt;&lt;/i&gt;'</span> : <span class="hljs-string">''</span>) +
          textHtml +
          <span class="hljs-string">' &lt;i class="'</span> + prefix + <span class="hljs-string">'caret"&gt;&lt;/i&gt;'</span> +
          <span class="hljs-string">'&lt;/button&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-comment">/**
       * Gets invoked after the control has been rendered.
       *
       * @method postRender
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (e.control === self &amp;&amp; isChildOf(e.target, self.getEl())) {
            self.focus();
            self.showMenu(!e.aria);

            <span class="hljs-keyword">if</span> (e.aria) {
              self.menu.items().filter(<span class="hljs-string">':visible'</span>)[<span class="hljs-number">0</span>].focus();
            }
          }
        });

        self.on(<span class="hljs-string">'mouseenter'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> overCtrl = e.control, parent = self.parent(), hasVisibleSiblingMenu;

          <span class="hljs-keyword">if</span> (overCtrl &amp;&amp; parent &amp;&amp; overCtrl <span class="hljs-keyword">instanceof</span> MenuButton &amp;&amp; overCtrl.parent() == parent) {
            parent.items().filter(<span class="hljs-string">'MenuButton'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
              <span class="hljs-keyword">if</span> (ctrl.hideMenu &amp;&amp; ctrl != overCtrl) {
                <span class="hljs-keyword">if</span> (ctrl.menu &amp;&amp; ctrl.menu.visible()) {
                  hasVisibleSiblingMenu = <span class="hljs-literal">true</span>;
                }

                ctrl.hideMenu();
              }
            });

            <span class="hljs-keyword">if</span> (hasVisibleSiblingMenu) {
              overCtrl.focus(); <span class="hljs-comment">// Fix for: #5887</span>
              overCtrl.showMenu();
            }
          }
        });

        <span class="hljs-keyword">return</span> self._super();
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.state.on(<span class="hljs-string">'change:menu'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (self.menu) {
            self.menu.remove();
          }

          self.menu = <span class="hljs-literal">null</span>;
        });

        <span class="hljs-keyword">return</span> self._super();
      },

      <span class="hljs-comment">/**
       * Removes the control and it's menus.
       *
       * @method remove
       */</span>
      remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._super();

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.menu) {
          <span class="hljs-keyword">this</span>.menu.remove();
        }
      }
    });

    <span class="hljs-keyword">return</span> MenuButton;
  }
);

<span class="hljs-comment">/**
 * MenuItem.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a new menu item.
 *
 * @-x-less MenuItem.less
 * @class tinymce.ui.MenuItem
 * @extends tinymce.ui.Control
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.MenuItem'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>,
    <span class="hljs-string">"tinymce.core.ui.Factory"</span>,
    <span class="hljs-string">"tinymce.core.Env"</span>,
    <span class="hljs-string">"tinymce.core.util.Delay"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget, Factory, Env, Delay</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">border</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">role</span>: <span class="hljs-string">'menuitem'</span>
      },

      <span class="hljs-comment">/**
       * Constructs a instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {Boolean} selectable Selectable menu.
       * @setting {Array} menu Submenu array with items.
       * @setting {String} shortcut Shortcut to display for menu item. Example: Ctrl+X
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, text;

        self._super(settings);

        settings = self.settings;

        self.classes.add(<span class="hljs-string">'menu-item'</span>);

        <span class="hljs-keyword">if</span> (settings.menu) {
          self.classes.add(<span class="hljs-string">'menu-item-expand'</span>);
        }

        <span class="hljs-keyword">if</span> (settings.preview) {
          self.classes.add(<span class="hljs-string">'menu-item-preview'</span>);
        }

        text = self.state.get(<span class="hljs-string">'text'</span>);
        <span class="hljs-keyword">if</span> (text === <span class="hljs-string">'-'</span> || text === <span class="hljs-string">'|'</span>) {
          self.classes.add(<span class="hljs-string">'menu-item-sep'</span>);
          self.aria(<span class="hljs-string">'role'</span>, <span class="hljs-string">'separator'</span>);
          self.state.set(<span class="hljs-string">'text'</span>, <span class="hljs-string">'-'</span>);
        }

        <span class="hljs-keyword">if</span> (settings.selectable) {
          self.aria(<span class="hljs-string">'role'</span>, <span class="hljs-string">'menuitemcheckbox'</span>);
          self.classes.add(<span class="hljs-string">'menu-item-checkbox'</span>);
          settings.icon = <span class="hljs-string">'selected'</span>;
        }

        <span class="hljs-keyword">if</span> (!settings.preview &amp;&amp; !settings.selectable) {
          self.classes.add(<span class="hljs-string">'menu-item-normal'</span>);
        }

        self.on(<span class="hljs-string">'mousedown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          e.preventDefault();
        });

        <span class="hljs-keyword">if</span> (settings.menu &amp;&amp; !settings.ariaHideMenu) {
          self.aria(<span class="hljs-string">'haspopup'</span>, <span class="hljs-literal">true</span>);
        }
      },

      <span class="hljs-comment">/**
       * Returns true/false if the menuitem has sub menu.
       *
       * @method hasMenus
       * @return {Boolean} True/false state if it has submenu.
       */</span>
      hasMenus: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> !!<span class="hljs-keyword">this</span>.settings.menu;
      },

      <span class="hljs-comment">/**
       * Shows the menu for the menu item.
       *
       * @method showMenu
       */</span>
      showMenu: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, settings = self.settings, menu, parent = self.parent();

        parent.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
          <span class="hljs-keyword">if</span> (ctrl !== self) {
            ctrl.hideMenu();
          }
        });

        <span class="hljs-keyword">if</span> (settings.menu) {
          menu = self.menu;

          <span class="hljs-keyword">if</span> (!menu) {
            menu = settings.menu;</pre></div></div>
            
        </li>
        
        
        <li id="section-1896">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1896">&#182;</a>
              </div>
              <p>Is menu array then auto constuct menu control</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (menu.length) {
              menu = {
                <span class="hljs-attr">type</span>: <span class="hljs-string">'menu'</span>,
                <span class="hljs-attr">items</span>: menu
              };
            } <span class="hljs-keyword">else</span> {
              menu.type = menu.type || <span class="hljs-string">'menu'</span>;
            }

            <span class="hljs-keyword">if</span> (parent.settings.itemDefaults) {
              menu.itemDefaults = parent.settings.itemDefaults;
            }

            menu = self.menu = Factory.create(menu).parent(self).renderTo();
            menu.reflow();
            menu.on(<span class="hljs-string">'cancel'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
              e.stopPropagation();
              self.focus();
              menu.hide();
            });
            menu.on(<span class="hljs-string">'show hide'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
              <span class="hljs-keyword">if</span> (e.control.items) {
                e.control.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
                  ctrl.active(ctrl.settings.selected);
                });
              }
            }).fire(<span class="hljs-string">'show'</span>);

            menu.on(<span class="hljs-string">'hide'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
              <span class="hljs-keyword">if</span> (e.control === menu) {
                self.classes.remove(<span class="hljs-string">'selected'</span>);
              }
            });

            menu.submenu = <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            menu.show();
          }

          menu._parentMenu = parent;

          menu.classes.add(<span class="hljs-string">'menu-sub'</span>);

          <span class="hljs-keyword">var</span> rel = menu.testMoveRel(
            self.getEl(),
            self.isRtl() ? [<span class="hljs-string">'tl-tr'</span>, <span class="hljs-string">'bl-br'</span>, <span class="hljs-string">'tr-tl'</span>, <span class="hljs-string">'br-bl'</span>] : [<span class="hljs-string">'tr-tl'</span>, <span class="hljs-string">'br-bl'</span>, <span class="hljs-string">'tl-tr'</span>, <span class="hljs-string">'bl-br'</span>]
          );

          menu.moveRel(self.getEl(), rel);
          menu.rel = rel;

          rel = <span class="hljs-string">'menu-sub-'</span> + rel;
          menu.classes.remove(menu._lastRel).add(rel);
          menu._lastRel = rel;

          self.classes.add(<span class="hljs-string">'selected'</span>);
          self.aria(<span class="hljs-string">'expanded'</span>, <span class="hljs-literal">true</span>);
        }
      },

      <span class="hljs-comment">/**
       * Hides the menu for the menu item.
       *
       * @method hideMenu
       */</span>
      hideMenu: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (self.menu) {
          self.menu.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
            <span class="hljs-keyword">if</span> (item.hideMenu) {
              item.hideMenu();
            }
          });

          self.menu.hide();
          self.aria(<span class="hljs-string">'expanded'</span>, <span class="hljs-literal">false</span>);
        }

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, id = self._id, settings = self.settings, prefix = self.classPrefix, text = self.state.get(<span class="hljs-string">'text'</span>);
        <span class="hljs-keyword">var</span> icon = self.settings.icon, image = <span class="hljs-string">''</span>, shortcut = settings.shortcut;
        <span class="hljs-keyword">var</span> url = self.encode(settings.url), iconHtml = <span class="hljs-string">''</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1897">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1897">&#182;</a>
              </div>
              <p>Converts shortcut format to Mac/PC variants</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertShortcut</span>(<span class="hljs-params">shortcut</span>) </span>{
          <span class="hljs-keyword">var</span> i, value, replace = {};

          <span class="hljs-keyword">if</span> (Env.mac) {
            replace = {
              <span class="hljs-attr">alt</span>: <span class="hljs-string">'&amp;#x2325;'</span>,
              <span class="hljs-attr">ctrl</span>: <span class="hljs-string">'&amp;#x2318;'</span>,
              <span class="hljs-attr">shift</span>: <span class="hljs-string">'&amp;#x21E7;'</span>,
              <span class="hljs-attr">meta</span>: <span class="hljs-string">'&amp;#x2318;'</span>
            };
          } <span class="hljs-keyword">else</span> {
            replace = {
              <span class="hljs-attr">meta</span>: <span class="hljs-string">'Ctrl'</span>
            };
          }

          shortcut = shortcut.split(<span class="hljs-string">'+'</span>);

          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; shortcut.length; i++) {
            value = replace[shortcut[i].toLowerCase()];

            <span class="hljs-keyword">if</span> (value) {
              shortcut[i] = value;
            }
          }

          <span class="hljs-keyword">return</span> shortcut.join(<span class="hljs-string">'+'</span>);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">escapeRegExp</span>(<span class="hljs-params">str</span>) </span>{
          <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/[.*+?^${}()|[\]\\]/g</span>, <span class="hljs-string">"\\$&amp;"</span>);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markMatches</span>(<span class="hljs-params">text</span>) </span>{
          <span class="hljs-keyword">var</span> match = settings.match || <span class="hljs-string">''</span>;

          <span class="hljs-keyword">return</span> match ? text.replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(escapeRegExp(match), <span class="hljs-string">'gi'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">'!mce~match['</span> + match + <span class="hljs-string">']mce~match!'</span>;
          }) : text;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boldMatches</span>(<span class="hljs-params">text</span>) </span>{
          <span class="hljs-keyword">return</span> text.
            replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(escapeRegExp(<span class="hljs-string">'!mce~match['</span>), <span class="hljs-string">'g'</span>), <span class="hljs-string">'&lt;b&gt;'</span>).
            replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(escapeRegExp(<span class="hljs-string">']mce~match!'</span>), <span class="hljs-string">'g'</span>), <span class="hljs-string">'&lt;/b&gt;'</span>);
        }

        <span class="hljs-keyword">if</span> (icon) {
          self.parent().classes.add(<span class="hljs-string">'menu-has-icons'</span>);
        }

        <span class="hljs-keyword">if</span> (settings.image) {
          image = <span class="hljs-string">' style="background-image: url(\''</span> + settings.image + <span class="hljs-string">'\')"'</span>;
        }

        <span class="hljs-keyword">if</span> (shortcut) {
          shortcut = convertShortcut(shortcut);
        }

        icon = prefix + <span class="hljs-string">'ico '</span> + prefix + <span class="hljs-string">'i-'</span> + (self.settings.icon || <span class="hljs-string">'none'</span>);
        iconHtml = (text !== <span class="hljs-string">'-'</span> ? <span class="hljs-string">'&lt;i class="'</span> + icon + <span class="hljs-string">'"'</span> + image + <span class="hljs-string">'&gt;&lt;/i&gt;\u00a0'</span> : <span class="hljs-string">''</span>);

        text = boldMatches(self.encode(markMatches(text)));
        url = boldMatches(self.encode(markMatches(url)));

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'" tabindex="-1"&gt;'</span> +
          iconHtml +
          (text !== <span class="hljs-string">'-'</span> ? <span class="hljs-string">'&lt;span id="'</span> + id + <span class="hljs-string">'-text" class="'</span> + prefix + <span class="hljs-string">'text"&gt;'</span> + text + <span class="hljs-string">'&lt;/span&gt;'</span> : <span class="hljs-string">''</span>) +
          (shortcut ? <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'-shortcut" class="'</span> + prefix + <span class="hljs-string">'menu-shortcut"&gt;'</span> + shortcut + <span class="hljs-string">'&lt;/div&gt;'</span> : <span class="hljs-string">''</span>) +
          (settings.menu ? <span class="hljs-string">'&lt;div class="'</span> + prefix + <span class="hljs-string">'caret"&gt;&lt;/div&gt;'</span> : <span class="hljs-string">''</span>) +
          (url ? <span class="hljs-string">'&lt;div class="'</span> + prefix + <span class="hljs-string">'menu-item-link"&gt;'</span> + url + <span class="hljs-string">'&lt;/div&gt;'</span> : <span class="hljs-string">''</span>) +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-comment">/**
       * Gets invoked after the control has been rendered.
       *
       * @method postRender
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, settings = self.settings;

        <span class="hljs-keyword">var</span> textStyle = settings.textStyle;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> textStyle == <span class="hljs-string">"function"</span>) {
          textStyle = textStyle.call(<span class="hljs-keyword">this</span>);
        }

        <span class="hljs-keyword">if</span> (textStyle) {
          <span class="hljs-keyword">var</span> textElm = self.getEl(<span class="hljs-string">'text'</span>);
          <span class="hljs-keyword">if</span> (textElm) {
            textElm.setAttribute(<span class="hljs-string">'style'</span>, textStyle);
          }
        }

        self.on(<span class="hljs-string">'mouseenter click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (e.control === self) {
            <span class="hljs-keyword">if</span> (!settings.menu &amp;&amp; e.type === <span class="hljs-string">'click'</span>) {
              self.fire(<span class="hljs-string">'select'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-1898">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1898">&#182;</a>
              </div>
              <p>Edge will crash if you stress it see #2660</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              Delay.requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                self.parent().hideAll();
              });
            } <span class="hljs-keyword">else</span> {
              self.showMenu();

              <span class="hljs-keyword">if</span> (e.aria) {
                self.menu.focus(<span class="hljs-literal">true</span>);
              }
            }
          }
        });

        self._super();

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-attr">hover</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.parent().items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
          ctrl.classes.remove(<span class="hljs-string">'selected'</span>);
        });

        self.classes.toggle(<span class="hljs-string">'selected'</span>, <span class="hljs-literal">true</span>);

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-attr">active</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> state != <span class="hljs-string">"undefined"</span>) {
          <span class="hljs-keyword">this</span>.aria(<span class="hljs-string">'checked'</span>, state);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._super(state);
      },

      <span class="hljs-comment">/**
       * Removes the control and it's menus.
       *
       * @method remove
       */</span>
      remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._super();

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.menu) {
          <span class="hljs-keyword">this</span>.menu.remove();
        }
      }
    });
  }
);

<span class="hljs-comment">/**
 * Throbber.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This class enables you to display a Throbber for any element.
 *
 * @-x-less Throbber.less
 * @class tinymce.ui.Throbber
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Throbber'</span>,
  [
    <span class="hljs-string">"tinymce.core.dom.DomQuery"</span>,
    <span class="hljs-string">"tinymce.core.ui.Control"</span>,
    <span class="hljs-string">"tinymce.core.util.Delay"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$, Control, Delay</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-comment">/**
     * Constructs a new throbber.
     *
     * @constructor
     * @param {Element} elm DOM Html element to display throbber in.
     * @param {Boolean} inline Optional true/false state if the throbber should be appended to end of element for infinite scroll.
     */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elm, inline</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, state, classPrefix = Control.classPrefix, timer;

      <span class="hljs-comment">/**
       * Shows the throbber.
       *
       * @method show
       * @param {Number} [time] Time to wait before showing.
       * @param {function} [callback] Optional callback to execute when the throbber is shown.
       * @return {tinymce.ui.Throbber} Current throbber instance.
       */</span>
      self.show = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">time, callback</span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (state) {
            $(elm).append(
              <span class="hljs-string">'&lt;div class="'</span> + classPrefix + <span class="hljs-string">'throbber'</span> + (inline ? <span class="hljs-string">' '</span> + classPrefix + <span class="hljs-string">'throbber-inline'</span> : <span class="hljs-string">''</span>) + <span class="hljs-string">'"&gt;&lt;/div&gt;'</span>
            );

            <span class="hljs-keyword">if</span> (callback) {
              callback();
            }
          }
        }

        self.hide();

        state = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">if</span> (time) {
          timer = Delay.setTimeout(render, time);
        } <span class="hljs-keyword">else</span> {
          render();
        }

        <span class="hljs-keyword">return</span> self;
      };

      <span class="hljs-comment">/**
       * Hides the throbber.
       *
       * @method hide
       * @return {tinymce.ui.Throbber} Current throbber instance.
       */</span>
      self.hide = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> child = elm.lastChild;

        Delay.clearTimeout(timer);

        <span class="hljs-keyword">if</span> (child &amp;&amp; child.className.indexOf(<span class="hljs-string">'throbber'</span>) != <span class="hljs-number">-1</span>) {
          child.parentNode.removeChild(child);
        }

        state = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">return</span> self;
      };
    };
  }
);

<span class="hljs-comment">/**
 * Menu.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a new menu.
 *
 * @-x-less Menu.less
 * @class tinymce.ui.Menu
 * @extends tinymce.ui.FloatPanel
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Menu'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.FloatPanel"</span>,
    <span class="hljs-string">"tinymce.core.ui.MenuItem"</span>,
    <span class="hljs-string">"tinymce.core.ui.Throbber"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">FloatPanel, MenuItem, Throbber, Tools</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> FloatPanel.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">defaultType</span>: <span class="hljs-string">'menuitem'</span>,
        <span class="hljs-attr">border</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">layout</span>: <span class="hljs-string">'stack'</span>,
        <span class="hljs-attr">role</span>: <span class="hljs-string">'application'</span>,
        <span class="hljs-attr">bodyRole</span>: <span class="hljs-string">'menu'</span>,
        <span class="hljs-attr">ariaRoot</span>: <span class="hljs-literal">true</span>
      },

      <span class="hljs-comment">/**
       * Constructs a instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        settings.autohide = <span class="hljs-literal">true</span>;
        settings.constrainToViewport = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> settings.items === <span class="hljs-string">'function'</span>) {
          settings.itemsFactory = settings.items;
          settings.items = [];
        }

        <span class="hljs-keyword">if</span> (settings.itemDefaults) {
          <span class="hljs-keyword">var</span> items = settings.items, i = items.length;

          <span class="hljs-keyword">while</span> (i--) {
            items[i] = Tools.extend({}, settings.itemDefaults, items[i]);
          }
        }

        self._super(settings);
        self.classes.add(<span class="hljs-string">'menu'</span>);
      },

      <span class="hljs-comment">/**
       * Repaints the control after a layout operation.
       *
       * @method repaint
       */</span>
      repaint: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.classes.toggle(<span class="hljs-string">'menu-align'</span>, <span class="hljs-literal">true</span>);

        <span class="hljs-keyword">this</span>._super();

        <span class="hljs-keyword">this</span>.getEl().style.height = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">this</span>.getEl(<span class="hljs-string">'body'</span>).style.height = <span class="hljs-string">''</span>;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-comment">/**
       * Hides/closes the menu.
       *
       * @method cancel
       */</span>
      cancel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.hideAll();
        self.fire(<span class="hljs-string">'select'</span>);
      },

      <span class="hljs-comment">/**
       * Loads new items from the factory items function.
       *
       * @method load
       */</span>
      load: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, time, factory;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hideThrobber</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (self.throbber) {
            self.throbber.hide();
            self.throbber = <span class="hljs-literal">null</span>;
          }
        }

        factory = self.settings.itemsFactory;
        <span class="hljs-keyword">if</span> (!factory) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (!self.throbber) {
          self.throbber = <span class="hljs-keyword">new</span> Throbber(self.getEl(<span class="hljs-string">'body'</span>), <span class="hljs-literal">true</span>);

          <span class="hljs-keyword">if</span> (self.items().length === <span class="hljs-number">0</span>) {
            self.throbber.show();
            self.fire(<span class="hljs-string">'loading'</span>);
          } <span class="hljs-keyword">else</span> {
            self.throbber.show(<span class="hljs-number">100</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              self.items().remove();
              self.fire(<span class="hljs-string">'loading'</span>);
            });
          }

          self.on(<span class="hljs-string">'hide close'</span>, hideThrobber);
        }

        self.requestTime = time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();

        self.settings.itemsFactory(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>{
          <span class="hljs-keyword">if</span> (items.length === <span class="hljs-number">0</span>) {
            self.hide();
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (self.requestTime !== time) {
            <span class="hljs-keyword">return</span>;
          }

          self.getEl().style.width = <span class="hljs-string">''</span>;
          self.getEl(<span class="hljs-string">'body'</span>).style.width = <span class="hljs-string">''</span>;

          hideThrobber();
          self.items().remove();
          self.getEl(<span class="hljs-string">'body'</span>).innerHTML = <span class="hljs-string">''</span>;

          self.add(items);
          self.renderNew();
          self.fire(<span class="hljs-string">'loaded'</span>);
        });
      },

      <span class="hljs-comment">/**
       * Hide menu and all sub menus.
       *
       * @method hideAll
       */</span>
      hideAll: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">this</span>.find(<span class="hljs-string">'menuitem'</span>).exec(<span class="hljs-string">'hideMenu'</span>);

        <span class="hljs-keyword">return</span> self._super();
      },

      <span class="hljs-comment">/**
       * Invoked before the menu is rendered.
       *
       * @method preRender
       */</span>
      preRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
          <span class="hljs-keyword">var</span> settings = ctrl.settings;

          <span class="hljs-keyword">if</span> (settings.icon || settings.image || settings.selectable) {
            self._hasIcons = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        });

        <span class="hljs-keyword">if</span> (self.settings.itemsFactory) {
          self.on(<span class="hljs-string">'postrender'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (self.settings.itemsFactory) {
              self.load();
            }
          });
        }

        <span class="hljs-keyword">return</span> self._super();
      }
    });
  }
);

<span class="hljs-comment">/**
 * ListBox.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a new list box control.
 *
 * @-x-less ListBox.less
 * @class tinymce.ui.ListBox
 * @extends tinymce.ui.MenuButton
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.ListBox'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.MenuButton"</span>,
    <span class="hljs-string">"tinymce.core.ui.Menu"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">MenuButton, Menu</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> MenuButton.extend({
      <span class="hljs-comment">/**
       * Constructs a instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {Array} values Array with values to add to list box.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, values, selected, selectedText, lastItemCtrl;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSelected</span>(<span class="hljs-params">menuValues</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-1899">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1899">&#182;</a>
              </div>
              <p>Try to find a selected value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; menuValues.length; i++) {
            selected = menuValues[i].selected || settings.value === menuValues[i].value;

            <span class="hljs-keyword">if</span> (selected) {
              selectedText = selectedText || menuValues[i].text;
              self.state.set(<span class="hljs-string">'value'</span>, menuValues[i].value);
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-1900">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1900">&#182;</a>
              </div>
              <p>If the value has a submenu, try to find the selected values in that menu</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (menuValues[i].menu) {
              <span class="hljs-keyword">if</span> (setSelected(menuValues[i].menu)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              }
            }
          }
        }

        self._super(settings);
        settings = self.settings;

        self._values = values = settings.values;
        <span class="hljs-keyword">if</span> (values) {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> settings.value != <span class="hljs-string">"undefined"</span>) {
            setSelected(values);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-1901">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1901">&#182;</a>
              </div>
              <p>Default with first item</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!selected &amp;&amp; values.length &gt; <span class="hljs-number">0</span>) {
            selectedText = values[<span class="hljs-number">0</span>].text;
            self.state.set(<span class="hljs-string">'value'</span>, values[<span class="hljs-number">0</span>].value);
          }

          self.state.set(<span class="hljs-string">'menu'</span>, values);
        }

        self.state.set(<span class="hljs-string">'text'</span>, settings.text || selectedText);

        self.classes.add(<span class="hljs-string">'listbox'</span>);

        self.on(<span class="hljs-string">'select'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> ctrl = e.control;

          <span class="hljs-keyword">if</span> (lastItemCtrl) {
            e.lastControl = lastItemCtrl;
          }

          <span class="hljs-keyword">if</span> (settings.multiple) {
            ctrl.active(!ctrl.active());
          } <span class="hljs-keyword">else</span> {
            self.value(e.control.value());
          }

          lastItemCtrl = ctrl;
        });
      },

      <span class="hljs-comment">/**
       * Getter/setter function for the control value.
       *
       * @method value
       * @param {String} [value] Value to be set.
       * @return {Boolean/tinymce.ui.ListBox} Value or self if it's a set operation.
       */</span>
      bindStates: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">activateMenuItemsByValue</span>(<span class="hljs-params">menu, value</span>) </span>{
          <span class="hljs-keyword">if</span> (menu <span class="hljs-keyword">instanceof</span> Menu) {
            menu.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
              <span class="hljs-keyword">if</span> (!ctrl.hasMenus()) {
                ctrl.active(ctrl.value() === value);
              }
            });
          }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSelectedItem</span>(<span class="hljs-params">menuValues, value</span>) </span>{
          <span class="hljs-keyword">var</span> selectedItem;

          <span class="hljs-keyword">if</span> (!menuValues) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; menuValues.length; i++) {
            <span class="hljs-keyword">if</span> (menuValues[i].value === value) {
              <span class="hljs-keyword">return</span> menuValues[i];
            }

            <span class="hljs-keyword">if</span> (menuValues[i].menu) {
              selectedItem = getSelectedItem(menuValues[i].menu, value);
              <span class="hljs-keyword">if</span> (selectedItem) {
                <span class="hljs-keyword">return</span> selectedItem;
              }
            }
          }
        }

        self.on(<span class="hljs-string">'show'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          activateMenuItemsByValue(e.control, self.value());
        });

        self.state.on(<span class="hljs-string">'change:value'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> selectedItem = getSelectedItem(self.state.get(<span class="hljs-string">'menu'</span>), e.value);

          <span class="hljs-keyword">if</span> (selectedItem) {
            self.text(selectedItem.text);
          } <span class="hljs-keyword">else</span> {
            self.text(self.settings.text);
          }
        });

        <span class="hljs-keyword">return</span> self._super();
      }
    });
  }
);

<span class="hljs-comment">/**
 * Radio.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a new radio button.
 *
 * @-x-less Radio.less
 * @class tinymce.ui.Radio
 * @extends tinymce.ui.Checkbox
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Radio'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Checkbox"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Checkbox</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Checkbox.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">classes</span>: <span class="hljs-string">"radio"</span>,
        <span class="hljs-attr">role</span>: <span class="hljs-string">"radio"</span>
      }
    });
  }
);
<span class="hljs-comment">/**
 * ResizeHandle.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Renders a resize handle that fires ResizeStart, Resize and ResizeEnd events.
 *
 * @-x-less ResizeHandle.less
 * @class tinymce.ui.ResizeHandle
 * @extends tinymce.ui.Widget
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.ResizeHandle'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>,
    <span class="hljs-string">"tinymce.core.ui.DragHelper"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget, DragHelper</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, prefix = self.classPrefix;

        self.classes.add(<span class="hljs-string">'resizehandle'</span>);

        <span class="hljs-keyword">if</span> (self.settings.direction == <span class="hljs-string">"both"</span>) {
          self.classes.add(<span class="hljs-string">'resizehandle-both'</span>);
        }

        self.canFocus = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'"&gt;'</span> +
          <span class="hljs-string">'&lt;i class="'</span> + prefix + <span class="hljs-string">'ico '</span> + prefix + <span class="hljs-string">'i-resize"&gt;&lt;/i&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-comment">/**
       * Called after the control has been rendered.
       *
       * @method postRender
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super();

        self.resizeDragHelper = <span class="hljs-keyword">new</span> DragHelper(<span class="hljs-keyword">this</span>._id, {
          <span class="hljs-attr">start</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            self.fire(<span class="hljs-string">'ResizeStart'</span>);
          },

          <span class="hljs-attr">drag</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">if</span> (self.settings.direction != <span class="hljs-string">"both"</span>) {
              e.deltaX = <span class="hljs-number">0</span>;
            }

            self.fire(<span class="hljs-string">'Resize'</span>, e);
          },

          <span class="hljs-attr">stop</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            self.fire(<span class="hljs-string">'ResizeEnd'</span>);
          }
        });
      },

      <span class="hljs-attr">remove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.resizeDragHelper) {
          <span class="hljs-keyword">this</span>.resizeDragHelper.destroy();
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._super();
      }
    });
  }
);

<span class="hljs-comment">/**
 * SelectBox.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a new select box control.
 *
 * @-x-less SelectBox.less
 * @class tinymce.ui.SelectBox
 * @extends tinymce.ui.Widget
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.SelectBox'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createOptions</span>(<span class="hljs-params">options</span>) </span>{
      <span class="hljs-keyword">var</span> strOptions = <span class="hljs-string">''</span>;
      <span class="hljs-keyword">if</span> (options) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; options.length; i++) {
          strOptions += <span class="hljs-string">'&lt;option value="'</span> + options[i] + <span class="hljs-string">'"&gt;'</span> + options[i] + <span class="hljs-string">'&lt;/option&gt;'</span>;
        }
      }
      <span class="hljs-keyword">return</span> strOptions;
    }

    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">classes</span>: <span class="hljs-string">"selectbox"</span>,
        <span class="hljs-attr">role</span>: <span class="hljs-string">"selectbox"</span>,
        <span class="hljs-attr">options</span>: []
      },
      <span class="hljs-comment">/**
       * Constructs a instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {Array} options Array with options to add to the select box.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super(settings);

        <span class="hljs-keyword">if</span> (self.settings.size) {
          self.size = self.settings.size;
        }

        <span class="hljs-keyword">if</span> (self.settings.options) {
          self._options = self.settings.options;
        }

        self.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> rootControl;

          <span class="hljs-keyword">if</span> (e.keyCode == <span class="hljs-number">13</span>) {
            e.preventDefault();</pre></div></div>
            
        </li>
        
        
        <li id="section-1902">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1902">&#182;</a>
              </div>
              <p>Find root control that we can do toJSON on</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            self.parents().reverse().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
              <span class="hljs-keyword">if</span> (ctrl.toJSON) {
                rootControl = ctrl;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
              }
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-1903">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1903">&#182;</a>
              </div>
              <p>Fire event on current text box with the serialized data of the whole form</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            self.fire(<span class="hljs-string">'submit'</span>, { <span class="hljs-attr">data</span>: rootControl.toJSON() });
          }
        });
      },

      <span class="hljs-comment">/**
       * Getter/setter function for the options state.
       *
       * @method options
       * @param {Array} [state] State to be set.
       * @return {Array|tinymce.ui.SelectBox} Array of string options.
       */</span>
      options: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">arguments</span>.length) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.get(<span class="hljs-string">'options'</span>);
        }

        <span class="hljs-keyword">this</span>.state.set(<span class="hljs-string">'options'</span>, state);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      },

      <span class="hljs-attr">renderHtml</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, options, size = <span class="hljs-string">''</span>;

        options = createOptions(self._options);

        <span class="hljs-keyword">if</span> (self.size) {
          size = <span class="hljs-string">' size = "'</span> + self.size + <span class="hljs-string">'"'</span>;
        }

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;select id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'"'</span> + size + <span class="hljs-string">'&gt;'</span> +
          options +
          <span class="hljs-string">'&lt;/select&gt;'</span>
        );
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.state.on(<span class="hljs-string">'change:options'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.getEl().innerHTML = createOptions(e.value);
        });

        <span class="hljs-keyword">return</span> self._super();
      }
    });
  }
);

<span class="hljs-comment">/**
 * Slider.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Slider control.
 *
 * @-x-less Slider.less
 * @class tinymce.ui.Slider
 * @extends tinymce.ui.Widget
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Slider'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>,
    <span class="hljs-string">"tinymce.core.ui.DragHelper"</span>,
    <span class="hljs-string">"tinymce.core.ui.DomUtils"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget, DragHelper, DomUtils</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constrain</span>(<span class="hljs-params">value, minVal, maxVal</span>) </span>{
      <span class="hljs-keyword">if</span> (value &lt; minVal) {
        value = minVal;
      }

      <span class="hljs-keyword">if</span> (value &gt; maxVal) {
        value = maxVal;
      }

      <span class="hljs-keyword">return</span> value;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setAriaProp</span>(<span class="hljs-params">el, name, value</span>) </span>{
      el.setAttribute(<span class="hljs-string">'aria-'</span> + name, value);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateSliderHandle</span>(<span class="hljs-params">ctrl, value</span>) </span>{
      <span class="hljs-keyword">var</span> maxHandlePos, shortSizeName, sizeName, stylePosName, styleValue, handleEl;

      <span class="hljs-keyword">if</span> (ctrl.settings.orientation == <span class="hljs-string">"v"</span>) {
        stylePosName = <span class="hljs-string">"top"</span>;
        sizeName = <span class="hljs-string">"height"</span>;
        shortSizeName = <span class="hljs-string">"h"</span>;
      } <span class="hljs-keyword">else</span> {
        stylePosName = <span class="hljs-string">"left"</span>;
        sizeName = <span class="hljs-string">"width"</span>;
        shortSizeName = <span class="hljs-string">"w"</span>;
      }

      handleEl = ctrl.getEl(<span class="hljs-string">'handle'</span>);
      maxHandlePos = (ctrl.layoutRect()[shortSizeName] || <span class="hljs-number">100</span>) - DomUtils.getSize(handleEl)[sizeName];

      styleValue = (maxHandlePos * ((value - ctrl._minValue) / (ctrl._maxValue - ctrl._minValue))) + <span class="hljs-string">'px'</span>;
      handleEl.style[stylePosName] = styleValue;
      handleEl.style.height = ctrl.layoutRect().h + <span class="hljs-string">'px'</span>;

      setAriaProp(handleEl, <span class="hljs-string">'valuenow'</span>, value);
      setAriaProp(handleEl, <span class="hljs-string">'valuetext'</span>, <span class="hljs-string">''</span> + ctrl.settings.previewFilter(value));
      setAriaProp(handleEl, <span class="hljs-string">'valuemin'</span>, ctrl._minValue);
      setAriaProp(handleEl, <span class="hljs-string">'valuemax'</span>, ctrl._maxValue);
    }

    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        <span class="hljs-keyword">if</span> (!settings.previewFilter) {
          settings.previewFilter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round(value * <span class="hljs-number">100</span>) / <span class="hljs-number">100.0</span>;
          };
        }

        self._super(settings);
        self.classes.add(<span class="hljs-string">'slider'</span>);

        <span class="hljs-keyword">if</span> (settings.orientation == <span class="hljs-string">"v"</span>) {
          self.classes.add(<span class="hljs-string">'vertical'</span>);
        }

        self._minValue = settings.minValue || <span class="hljs-number">0</span>;
        self._maxValue = settings.maxValue || <span class="hljs-number">100</span>;
        self._initValue = self.state.get(<span class="hljs-string">'value'</span>);
      },

      <span class="hljs-attr">renderHtml</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, id = self._id, prefix = self.classPrefix;

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'"&gt;'</span> +
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'-handle" class="'</span> + prefix + <span class="hljs-string">'slider-handle" role="slider" tabindex="-1"&gt;&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-attr">reset</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.value(<span class="hljs-keyword">this</span>._initValue).repaint();
      },

      <span class="hljs-attr">postRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, minValue, maxValue, screenCordName,
          stylePosName, sizeName, shortSizeName;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toFraction</span>(<span class="hljs-params">min, max, val</span>) </span>{
          <span class="hljs-keyword">return</span> (val + min) / (max - min);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromFraction</span>(<span class="hljs-params">min, max, val</span>) </span>{
          <span class="hljs-keyword">return</span> (val * (max - min)) - min;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleKeyboard</span>(<span class="hljs-params">minValue, maxValue</span>) </span>{
          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alter</span>(<span class="hljs-params">delta</span>) </span>{
            <span class="hljs-keyword">var</span> value;

            value = self.value();
            value = fromFraction(minValue, maxValue, toFraction(minValue, maxValue, value) + (delta * <span class="hljs-number">0.05</span>));
            value = constrain(value, minValue, maxValue);

            self.value(value);

            self.fire(<span class="hljs-string">'dragstart'</span>, { <span class="hljs-attr">value</span>: value });
            self.fire(<span class="hljs-string">'drag'</span>, { <span class="hljs-attr">value</span>: value });
            self.fire(<span class="hljs-string">'dragend'</span>, { <span class="hljs-attr">value</span>: value });
          }

          self.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">switch</span> (e.keyCode) {
              <span class="hljs-keyword">case</span> <span class="hljs-number">37</span>:
              <span class="hljs-keyword">case</span> <span class="hljs-number">38</span>:
                alter(<span class="hljs-number">-1</span>);
                <span class="hljs-keyword">break</span>;

              <span class="hljs-keyword">case</span> <span class="hljs-number">39</span>:
              <span class="hljs-keyword">case</span> <span class="hljs-number">40</span>:
                alter(<span class="hljs-number">1</span>);
                <span class="hljs-keyword">break</span>;
            }
          });
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleDrag</span>(<span class="hljs-params">minValue, maxValue, handleEl</span>) </span>{
          <span class="hljs-keyword">var</span> startPos, startHandlePos, maxHandlePos, handlePos, value;

          self._dragHelper = <span class="hljs-keyword">new</span> DragHelper(self._id, {
            <span class="hljs-attr">handle</span>: self._id + <span class="hljs-string">"-handle"</span>,

            <span class="hljs-attr">start</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
              startPos = e[screenCordName];
              startHandlePos = <span class="hljs-built_in">parseInt</span>(self.getEl(<span class="hljs-string">'handle'</span>).style[stylePosName], <span class="hljs-number">10</span>);
              maxHandlePos = (self.layoutRect()[shortSizeName] || <span class="hljs-number">100</span>) - DomUtils.getSize(handleEl)[sizeName];
              self.fire(<span class="hljs-string">'dragstart'</span>, { <span class="hljs-attr">value</span>: value });
            },

            <span class="hljs-attr">drag</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
              <span class="hljs-keyword">var</span> delta = e[screenCordName] - startPos;

              handlePos = constrain(startHandlePos + delta, <span class="hljs-number">0</span>, maxHandlePos);
              handleEl.style[stylePosName] = handlePos + <span class="hljs-string">'px'</span>;

              value = minValue + (handlePos / maxHandlePos) * (maxValue - minValue);
              self.value(value);

              self.tooltip().text(<span class="hljs-string">''</span> + self.settings.previewFilter(value)).show().moveRel(handleEl, <span class="hljs-string">'bc tc'</span>);

              self.fire(<span class="hljs-string">'drag'</span>, { <span class="hljs-attr">value</span>: value });
            },

            <span class="hljs-attr">stop</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              self.tooltip().hide();
              self.fire(<span class="hljs-string">'dragend'</span>, { <span class="hljs-attr">value</span>: value });
            }
          });
        }

        minValue = self._minValue;
        maxValue = self._maxValue;

        <span class="hljs-keyword">if</span> (self.settings.orientation == <span class="hljs-string">"v"</span>) {
          screenCordName = <span class="hljs-string">"screenY"</span>;
          stylePosName = <span class="hljs-string">"top"</span>;
          sizeName = <span class="hljs-string">"height"</span>;
          shortSizeName = <span class="hljs-string">"h"</span>;
        } <span class="hljs-keyword">else</span> {
          screenCordName = <span class="hljs-string">"screenX"</span>;
          stylePosName = <span class="hljs-string">"left"</span>;
          sizeName = <span class="hljs-string">"width"</span>;
          shortSizeName = <span class="hljs-string">"w"</span>;
        }

        self._super();

        handleKeyboard(minValue, maxValue, self.getEl(<span class="hljs-string">'handle'</span>));
        handleDrag(minValue, maxValue, self.getEl(<span class="hljs-string">'handle'</span>));
      },

      <span class="hljs-attr">repaint</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._super();
        updateSliderHandle(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.value());
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.state.on(<span class="hljs-string">'change:value'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          updateSliderHandle(self, e.value);
        });

        <span class="hljs-keyword">return</span> self._super();
      }
    });
  }
);
<span class="hljs-comment">/**
 * Spacer.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a spacer. This control is used in flex layouts for example.
 *
 * @-x-less Spacer.less
 * @class tinymce.ui.Spacer
 * @extends tinymce.ui.Widget
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.Spacer'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.classes.add(<span class="hljs-string">'spacer'</span>);
        self.canFocus = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'"&gt;&lt;/div&gt;'</span>;
      }
    });
  }
);
<span class="hljs-comment">/**
 * SplitButton.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a split button.
 *
 * @-x-less SplitButton.less
 * @class tinymce.ui.SplitButton
 * @extends tinymce.ui.Button
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.SplitButton'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.MenuButton"</span>,
    <span class="hljs-string">"tinymce.core.ui.DomUtils"</span>,
    <span class="hljs-string">"tinymce.core.dom.DomQuery"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">MenuButton, DomUtils, $</span>) </span>{
    <span class="hljs-keyword">return</span> MenuButton.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">classes</span>: <span class="hljs-string">"widget btn splitbtn"</span>,
        <span class="hljs-attr">role</span>: <span class="hljs-string">"button"</span>
      },

      <span class="hljs-comment">/**
       * Repaints the control after a layout operation.
       *
       * @method repaint
       */</span>
      repaint: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, elm = self.getEl(), rect = self.layoutRect(), mainButtonElm, menuButtonElm;

        self._super();

        mainButtonElm = elm.firstChild;
        menuButtonElm = elm.lastChild;

        $(mainButtonElm).css({
          <span class="hljs-attr">width</span>: rect.w - DomUtils.getSize(menuButtonElm).width,
          <span class="hljs-attr">height</span>: rect.h - <span class="hljs-number">2</span>
        });

        $(menuButtonElm).css({
          <span class="hljs-attr">height</span>: rect.h - <span class="hljs-number">2</span>
        });

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Sets the active menu state.
       *
       * @private
       */</span>
      activeMenu: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        $(self.getEl().lastChild).toggleClass(self.classPrefix + <span class="hljs-string">'active'</span>, state);
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, id = self._id, prefix = self.classPrefix, image;
        <span class="hljs-keyword">var</span> icon = self.state.get(<span class="hljs-string">'icon'</span>), text = self.state.get(<span class="hljs-string">'text'</span>),
          textHtml = <span class="hljs-string">''</span>;

        image = self.settings.image;
        <span class="hljs-keyword">if</span> (image) {
          icon = <span class="hljs-string">'none'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-1904">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1904">&#182;</a>
              </div>
              <p>Support for [high dpi, low dpi] image sources</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> image != <span class="hljs-string">"string"</span>) {
            image = <span class="hljs-built_in">window</span>.getSelection ? image[<span class="hljs-number">0</span>] : image[<span class="hljs-number">1</span>];
          }

          image = <span class="hljs-string">' style="background-image: url(\''</span> + image + <span class="hljs-string">'\')"'</span>;
        } <span class="hljs-keyword">else</span> {
          image = <span class="hljs-string">''</span>;
        }

        icon = self.settings.icon ? prefix + <span class="hljs-string">'ico '</span> + prefix + <span class="hljs-string">'i-'</span> + icon : <span class="hljs-string">''</span>;

        <span class="hljs-keyword">if</span> (text) {
          self.classes.add(<span class="hljs-string">'btn-has-text'</span>);
          textHtml = <span class="hljs-string">'&lt;span class="'</span> + prefix + <span class="hljs-string">'txt"&gt;'</span> + self.encode(text) + <span class="hljs-string">'&lt;/span&gt;'</span>;
        }

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'" role="button" tabindex="-1"&gt;'</span> +
          <span class="hljs-string">'&lt;button type="button" hidefocus="1" tabindex="-1"&gt;'</span> +
          (icon ? <span class="hljs-string">'&lt;i class="'</span> + icon + <span class="hljs-string">'"'</span> + image + <span class="hljs-string">'&gt;&lt;/i&gt;'</span> : <span class="hljs-string">''</span>) +
          textHtml +
          <span class="hljs-string">'&lt;/button&gt;'</span> +
          <span class="hljs-string">'&lt;button type="button" class="'</span> + prefix + <span class="hljs-string">'open" hidefocus="1" tabindex="-1"&gt;'</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-1905">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1905">&#182;</a>
              </div>
              <p>(icon ? <i class="' + icon + '"></i> : ) +</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          (self._menuBtnText ? (icon ? <span class="hljs-string">'\u00a0'</span> : <span class="hljs-string">''</span>) + self._menuBtnText : <span class="hljs-string">''</span>) +
          <span class="hljs-string">' &lt;i class="'</span> + prefix + <span class="hljs-string">'caret"&gt;&lt;/i&gt;'</span> +
          <span class="hljs-string">'&lt;/button&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-comment">/**
       * Called after the control has been rendered.
       *
       * @method postRender
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, onClickHandler = self.settings.onclick;

        self.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> node = e.target;

          <span class="hljs-keyword">if</span> (e.control == <span class="hljs-keyword">this</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1906">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1906">&#182;</a>
              </div>
              <p>Find clicks that is on the main button</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">while</span> (node) {
              <span class="hljs-keyword">if</span> ((e.aria &amp;&amp; e.aria.key != <span class="hljs-string">'down'</span>) || (node.nodeName == <span class="hljs-string">'BUTTON'</span> &amp;&amp; node.className.indexOf(<span class="hljs-string">'open'</span>) == <span class="hljs-number">-1</span>)) {
                e.stopImmediatePropagation();

                <span class="hljs-keyword">if</span> (onClickHandler) {
                  onClickHandler.call(<span class="hljs-keyword">this</span>, e);
                }

                <span class="hljs-keyword">return</span>;
              }

              node = node.parentNode;
            }
          }
        });

        <span class="hljs-keyword">delete</span> self.settings.onclick;

        <span class="hljs-keyword">return</span> self._super();
      }
    });
  }
);
<span class="hljs-comment">/**
 * StackLayout.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This layout uses the browsers layout when the items are blocks.
 *
 * @-x-less StackLayout.less
 * @class tinymce.ui.StackLayout
 * @extends tinymce.ui.FlowLayout
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.StackLayout'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.FlowLayout"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">FlowLayout</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> FlowLayout.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">containerClass</span>: <span class="hljs-string">'stack-layout'</span>,
        <span class="hljs-attr">controlClass</span>: <span class="hljs-string">'stack-layout-item'</span>,
        <span class="hljs-attr">endClass</span>: <span class="hljs-string">'break'</span>
      },

      <span class="hljs-attr">isNative</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    });
  }
);
<span class="hljs-comment">/**
 * TabPanel.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a tab panel control.
 *
 * @-x-less TabPanel.less
 * @class tinymce.ui.TabPanel
 * @extends tinymce.ui.Panel
 *
 * @setting {Number} activeTab Active tab index.
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.TabPanel'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Panel"</span>,
    <span class="hljs-string">"tinymce.core.dom.DomQuery"</span>,
    <span class="hljs-string">"tinymce.core.ui.DomUtils"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Panel, $, DomUtils</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">return</span> Panel.extend({
      <span class="hljs-attr">Defaults</span>: {
        <span class="hljs-attr">layout</span>: <span class="hljs-string">'absolute'</span>,
        <span class="hljs-attr">defaults</span>: {
          <span class="hljs-attr">type</span>: <span class="hljs-string">'panel'</span>
        }
      },

      <span class="hljs-comment">/**
       * Activates the specified tab by index.
       *
       * @method activateTab
       * @param {Number} idx Index of the tab to activate.
       */</span>
      activateTab: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">idx</span>) </span>{
        <span class="hljs-keyword">var</span> activeTabElm;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.activeTabId) {
          activeTabElm = <span class="hljs-keyword">this</span>.getEl(<span class="hljs-keyword">this</span>.activeTabId);
          $(activeTabElm).removeClass(<span class="hljs-keyword">this</span>.classPrefix + <span class="hljs-string">'active'</span>);
          activeTabElm.setAttribute(<span class="hljs-string">'aria-selected'</span>, <span class="hljs-string">"false"</span>);
        }

        <span class="hljs-keyword">this</span>.activeTabId = <span class="hljs-string">'t'</span> + idx;

        activeTabElm = <span class="hljs-keyword">this</span>.getEl(<span class="hljs-string">'t'</span> + idx);
        activeTabElm.setAttribute(<span class="hljs-string">'aria-selected'</span>, <span class="hljs-string">"true"</span>);
        $(activeTabElm).addClass(<span class="hljs-keyword">this</span>.classPrefix + <span class="hljs-string">'active'</span>);

        <span class="hljs-keyword">this</span>.items()[idx].show().fire(<span class="hljs-string">'showtab'</span>);
        <span class="hljs-keyword">this</span>.reflow();

        <span class="hljs-keyword">this</span>.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, i</span>) </span>{
          <span class="hljs-keyword">if</span> (idx != i) {
            item.hide();
          }
        });
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, layout = self._layout, tabsHtml = <span class="hljs-string">''</span>, prefix = self.classPrefix;

        self.preRender();
        layout.preRender(self);

        self.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl, i</span>) </span>{
          <span class="hljs-keyword">var</span> id = self._id + <span class="hljs-string">'-t'</span> + i;

          ctrl.aria(<span class="hljs-string">'role'</span>, <span class="hljs-string">'tabpanel'</span>);
          ctrl.aria(<span class="hljs-string">'labelledby'</span>, id);

          tabsHtml += (
            <span class="hljs-string">'&lt;div id="'</span> + id + <span class="hljs-string">'" class="'</span> + prefix + <span class="hljs-string">'tab" '</span> +
            <span class="hljs-string">'unselectable="on" role="tab" aria-controls="'</span> + ctrl._id + <span class="hljs-string">'" aria-selected="false" tabIndex="-1"&gt;'</span> +
            self.encode(ctrl.settings.title) +
            <span class="hljs-string">'&lt;/div&gt;'</span>
          );
        });

        <span class="hljs-keyword">return</span> (
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'" class="'</span> + self.classes + <span class="hljs-string">'" hidefocus="1" tabindex="-1"&gt;'</span> +
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'-head" class="'</span> + prefix + <span class="hljs-string">'tabs" role="tablist"&gt;'</span> +
          tabsHtml +
          <span class="hljs-string">'&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;div id="'</span> + self._id + <span class="hljs-string">'-body" class="'</span> + self.bodyClasses + <span class="hljs-string">'"&gt;'</span> +
          layout.renderHtml(self) +
          <span class="hljs-string">'&lt;/div&gt;'</span> +
          <span class="hljs-string">'&lt;/div&gt;'</span>
        );
      },

      <span class="hljs-comment">/**
       * Called after the control has been rendered.
       *
       * @method postRender
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super();

        self.settings.activeTab = self.settings.activeTab || <span class="hljs-number">0</span>;
        self.activateTab(self.settings.activeTab);

        <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">var</span> targetParent = e.target.parentNode;

          <span class="hljs-keyword">if</span> (targetParent &amp;&amp; targetParent.id == self._id + <span class="hljs-string">'-head'</span>) {
            <span class="hljs-keyword">var</span> i = targetParent.childNodes.length;

            <span class="hljs-keyword">while</span> (i--) {
              <span class="hljs-keyword">if</span> (targetParent.childNodes[i] == e.target) {
                self.activateTab(i);
              }
            }
          }
        });
      },

      <span class="hljs-comment">/**
       * Initializes the current controls layout rect.
       * This will be executed by the layout managers to determine the
       * default minWidth/minHeight etc.
       *
       * @method initLayoutRect
       * @return {Object} Layout rect instance.
       */</span>
      initLayoutRect: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, rect, minW, minH;

        minW = DomUtils.getSize(self.getEl(<span class="hljs-string">'head'</span>)).width;
        minW = minW &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : minW;
        minH = <span class="hljs-number">0</span>;

        self.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          minW = <span class="hljs-built_in">Math</span>.max(minW, item.layoutRect().minW);
          minH = <span class="hljs-built_in">Math</span>.max(minH, item.layoutRect().minH);
        });

        self.items().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
          ctrl.settings.x = <span class="hljs-number">0</span>;
          ctrl.settings.y = <span class="hljs-number">0</span>;
          ctrl.settings.w = minW;
          ctrl.settings.h = minH;

          ctrl.layoutRect({
            <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">w</span>: minW,
            <span class="hljs-attr">h</span>: minH
          });
        });

        <span class="hljs-keyword">var</span> headH = DomUtils.getSize(self.getEl(<span class="hljs-string">'head'</span>)).height;

        self.settings.minWidth = minW;
        self.settings.minHeight = minH + headH;

        rect = self._super();
        rect.deltaH += headH;
        rect.innerH = rect.h - rect.deltaH;

        <span class="hljs-keyword">return</span> rect;
      }
    });
  }
);

<span class="hljs-comment">/**
 * TextBox.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * Creates a new textbox.
 *
 * @-x-less TextBox.less
 * @class tinymce.ui.TextBox
 * @extends tinymce.ui.Widget
 */</span>
define(
  <span class="hljs-string">'tinymce.core.ui.TextBox'</span>,
  [
    <span class="hljs-string">"tinymce.core.ui.Widget"</span>,
    <span class="hljs-string">"tinymce.core.util.Tools"</span>,
    <span class="hljs-string">"tinymce.core.ui.DomUtils"</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Widget, Tools, DomUtils</span>) </span>{
    <span class="hljs-keyword">return</span> Widget.extend({
      <span class="hljs-comment">/**
       * Constructs a instance with the specified settings.
       *
       * @constructor
       * @param {Object} settings Name/value object with settings.
       * @setting {Boolean} multiline True if the textbox is a multiline control.
       * @setting {Number} maxLength Max length for the textbox.
       * @setting {Number} size Size of the textbox in characters.
       */</span>
      init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">settings</span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self._super(settings);

        self.classes.add(<span class="hljs-string">'textbox'</span>);

        <span class="hljs-keyword">if</span> (settings.multiline) {
          self.classes.add(<span class="hljs-string">'multiline'</span>);
        } <span class="hljs-keyword">else</span> {
          self.on(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">var</span> rootControl;

            <span class="hljs-keyword">if</span> (e.keyCode == <span class="hljs-number">13</span>) {
              e.preventDefault();</pre></div></div>
            
        </li>
        
        
        <li id="section-1907">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1907">&#182;</a>
              </div>
              <p>Find root control that we can do toJSON on</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              self.parents().reverse().each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctrl</span>) </span>{
                <span class="hljs-keyword">if</span> (ctrl.toJSON) {
                  rootControl = ctrl;
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
              });</pre></div></div>
            
        </li>
        
        
        <li id="section-1908">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1908">&#182;</a>
              </div>
              <p>Fire event on current text box with the serialized data of the whole form</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              self.fire(<span class="hljs-string">'submit'</span>, { <span class="hljs-attr">data</span>: rootControl.toJSON() });
            }
          });

          self.on(<span class="hljs-string">'keyup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
            self.state.set(<span class="hljs-string">'value'</span>, e.target.value);
          });
        }
      },

      <span class="hljs-comment">/**
       * Repaints the control after a layout operation.
       *
       * @method repaint
       */</span>
      repaint: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, style, rect, borderBox, borderW, borderH = <span class="hljs-number">0</span>, lastRepaintRect;

        style = self.getEl().style;
        rect = self._layoutRect;
        lastRepaintRect = self._lastRepaintRect || {};</pre></div></div>
            
        </li>
        
        
        <li id="section-1909">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1909">&#182;</a>
              </div>
              <p>Detect old IE 7+8 add lineHeight to align caret vertically in the middle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> doc = <span class="hljs-built_in">document</span>;
        <span class="hljs-keyword">if</span> (!self.settings.multiline &amp;&amp; doc.all &amp;&amp; (!doc.documentMode || doc.documentMode &lt;= <span class="hljs-number">8</span>)) {
          style.lineHeight = (rect.h - borderH) + <span class="hljs-string">'px'</span>;
        }

        borderBox = self.borderBox;
        borderW = borderBox.left + borderBox.right + <span class="hljs-number">8</span>;
        borderH = borderBox.top + borderBox.bottom + (self.settings.multiline ? <span class="hljs-number">8</span> : <span class="hljs-number">0</span>);

        <span class="hljs-keyword">if</span> (rect.x !== lastRepaintRect.x) {
          style.left = rect.x + <span class="hljs-string">'px'</span>;
          lastRepaintRect.x = rect.x;
        }

        <span class="hljs-keyword">if</span> (rect.y !== lastRepaintRect.y) {
          style.top = rect.y + <span class="hljs-string">'px'</span>;
          lastRepaintRect.y = rect.y;
        }

        <span class="hljs-keyword">if</span> (rect.w !== lastRepaintRect.w) {
          style.width = (rect.w - borderW) + <span class="hljs-string">'px'</span>;
          lastRepaintRect.w = rect.w;
        }

        <span class="hljs-keyword">if</span> (rect.h !== lastRepaintRect.h) {
          style.height = (rect.h - borderH) + <span class="hljs-string">'px'</span>;
          lastRepaintRect.h = rect.h;
        }

        self._lastRepaintRect = lastRepaintRect;
        self.fire(<span class="hljs-string">'repaint'</span>, {}, <span class="hljs-literal">false</span>);

        <span class="hljs-keyword">return</span> self;
      },

      <span class="hljs-comment">/**
       * Renders the control as a HTML string.
       *
       * @method renderHtml
       * @return {String} HTML representing the control.
       */</span>
      renderHtml: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, settings = self.settings, attrs, elm;

        attrs = {
          <span class="hljs-attr">id</span>: self._id,
          <span class="hljs-attr">hidefocus</span>: <span class="hljs-string">'1'</span>
        };

        Tools.each([
          <span class="hljs-string">'rows'</span>, <span class="hljs-string">'spellcheck'</span>, <span class="hljs-string">'maxLength'</span>, <span class="hljs-string">'size'</span>, <span class="hljs-string">'readonly'</span>, <span class="hljs-string">'min'</span>,
          <span class="hljs-string">'max'</span>, <span class="hljs-string">'step'</span>, <span class="hljs-string">'list'</span>, <span class="hljs-string">'pattern'</span>, <span class="hljs-string">'placeholder'</span>, <span class="hljs-string">'required'</span>, <span class="hljs-string">'multiple'</span>
        ], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          attrs[name] = settings[name];
        });

        <span class="hljs-keyword">if</span> (self.disabled()) {
          attrs.disabled = <span class="hljs-string">'disabled'</span>;
        }

        <span class="hljs-keyword">if</span> (settings.subtype) {
          attrs.type = settings.subtype;
        }

        elm = DomUtils.create(settings.multiline ? <span class="hljs-string">'textarea'</span> : <span class="hljs-string">'input'</span>, attrs);
        elm.value = self.state.get(<span class="hljs-string">'value'</span>);
        elm.className = self.classes;

        <span class="hljs-keyword">return</span> elm.outerHTML;
      },

      <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length) {
          <span class="hljs-keyword">this</span>.state.set(<span class="hljs-string">'value'</span>, value);
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1910">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1910">&#182;</a>
              </div>
              <p>Make sure the real state is in sync</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.get(<span class="hljs-string">'rendered'</span>)) {
          <span class="hljs-keyword">this</span>.state.set(<span class="hljs-string">'value'</span>, <span class="hljs-keyword">this</span>.getEl().value);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.get(<span class="hljs-string">'value'</span>);
      },

      <span class="hljs-comment">/**
       * Called after the control has been rendered.
       *
       * @method postRender
       */</span>
      postRender: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.getEl().value = self.state.get(<span class="hljs-string">'value'</span>);
        self._super();

        self.$el.on(<span class="hljs-string">'change'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.state.set(<span class="hljs-string">'value'</span>, e.target.value);
          self.fire(<span class="hljs-string">'change'</span>, e);
        });
      },

      <span class="hljs-attr">bindStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

        self.state.on(<span class="hljs-string">'change:value'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          <span class="hljs-keyword">if</span> (self.getEl().value != e.value) {
            self.getEl().value = e.value;
          }
        });

        self.state.on(<span class="hljs-string">'change:disabled'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
          self.getEl().disabled = e.value;
        });

        <span class="hljs-keyword">return</span> self._super();
      },

      <span class="hljs-attr">remove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.$el.off();
        <span class="hljs-keyword">this</span>._super();
      }
    });
  }
);

<span class="hljs-comment">/**
 * Api.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.ui.Api'</span>,
  [
    <span class="hljs-string">'tinymce.core.ui.Selector'</span>,
    <span class="hljs-string">'tinymce.core.ui.Collection'</span>,
    <span class="hljs-string">'tinymce.core.ui.ReflowQueue'</span>,
    <span class="hljs-string">'tinymce.core.ui.Control'</span>,
    <span class="hljs-string">'tinymce.core.ui.Factory'</span>,
    <span class="hljs-string">'tinymce.core.ui.KeyboardNavigation'</span>,
    <span class="hljs-string">'tinymce.core.ui.Container'</span>,
    <span class="hljs-string">'tinymce.core.ui.DragHelper'</span>,
    <span class="hljs-string">'tinymce.core.ui.Scrollable'</span>,
    <span class="hljs-string">'tinymce.core.ui.Panel'</span>,
    <span class="hljs-string">'tinymce.core.ui.Movable'</span>,
    <span class="hljs-string">'tinymce.core.ui.Resizable'</span>,
    <span class="hljs-string">'tinymce.core.ui.FloatPanel'</span>,
    <span class="hljs-string">'tinymce.core.ui.Window'</span>,
    <span class="hljs-string">'tinymce.core.ui.MessageBox'</span>,
    <span class="hljs-string">'tinymce.core.ui.Tooltip'</span>,
    <span class="hljs-string">'tinymce.core.ui.Widget'</span>,
    <span class="hljs-string">'tinymce.core.ui.Progress'</span>,
    <span class="hljs-string">'tinymce.core.ui.Notification'</span>,
    <span class="hljs-string">'tinymce.core.ui.Layout'</span>,
    <span class="hljs-string">'tinymce.core.ui.AbsoluteLayout'</span>,
    <span class="hljs-string">'tinymce.core.ui.Button'</span>,
    <span class="hljs-string">'tinymce.core.ui.ButtonGroup'</span>,
    <span class="hljs-string">'tinymce.core.ui.Checkbox'</span>,
    <span class="hljs-string">'tinymce.core.ui.ComboBox'</span>,
    <span class="hljs-string">'tinymce.core.ui.ColorBox'</span>,
    <span class="hljs-string">'tinymce.core.ui.PanelButton'</span>,
    <span class="hljs-string">'tinymce.core.ui.ColorButton'</span>,
    <span class="hljs-string">'tinymce.core.ui.ColorPicker'</span>,
    <span class="hljs-string">'tinymce.core.ui.Path'</span>,
    <span class="hljs-string">'tinymce.core.ui.ElementPath'</span>,
    <span class="hljs-string">'tinymce.core.ui.FormItem'</span>,
    <span class="hljs-string">'tinymce.core.ui.Form'</span>,
    <span class="hljs-string">'tinymce.core.ui.FieldSet'</span>,
    <span class="hljs-string">'tinymce.core.ui.FilePicker'</span>,
    <span class="hljs-string">'tinymce.core.ui.FitLayout'</span>,
    <span class="hljs-string">'tinymce.core.ui.FlexLayout'</span>,
    <span class="hljs-string">'tinymce.core.ui.FlowLayout'</span>,
    <span class="hljs-string">'tinymce.core.ui.FormatControls'</span>,
    <span class="hljs-string">'tinymce.core.ui.GridLayout'</span>,
    <span class="hljs-string">'tinymce.core.ui.Iframe'</span>,
    <span class="hljs-string">'tinymce.core.ui.InfoBox'</span>,
    <span class="hljs-string">'tinymce.core.ui.Label'</span>,
    <span class="hljs-string">'tinymce.core.ui.Toolbar'</span>,
    <span class="hljs-string">'tinymce.core.ui.MenuBar'</span>,
    <span class="hljs-string">'tinymce.core.ui.MenuButton'</span>,
    <span class="hljs-string">'tinymce.core.ui.MenuItem'</span>,
    <span class="hljs-string">'tinymce.core.ui.Throbber'</span>,
    <span class="hljs-string">'tinymce.core.ui.Menu'</span>,
    <span class="hljs-string">'tinymce.core.ui.ListBox'</span>,
    <span class="hljs-string">'tinymce.core.ui.Radio'</span>,
    <span class="hljs-string">'tinymce.core.ui.ResizeHandle'</span>,
    <span class="hljs-string">'tinymce.core.ui.SelectBox'</span>,
    <span class="hljs-string">'tinymce.core.ui.Slider'</span>,
    <span class="hljs-string">'tinymce.core.ui.Spacer'</span>,
    <span class="hljs-string">'tinymce.core.ui.SplitButton'</span>,
    <span class="hljs-string">'tinymce.core.ui.StackLayout'</span>,
    <span class="hljs-string">'tinymce.core.ui.TabPanel'</span>,
    <span class="hljs-string">'tinymce.core.ui.TextBox'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">
    Selector, Collection, ReflowQueue, Control, Factory, KeyboardNavigation, Container, DragHelper, Scrollable, Panel, Movable,
    Resizable, FloatPanel, Window, MessageBox, Tooltip, Widget, Progress, Notification, Layout, AbsoluteLayout, Button,
    ButtonGroup, Checkbox, ComboBox, ColorBox, PanelButton, ColorButton, ColorPicker, Path, ElementPath, FormItem, Form,
    FieldSet, FilePicker, FitLayout, FlexLayout, FlowLayout, FormatControls, GridLayout, Iframe, InfoBox, Label, Toolbar,
    MenuBar, MenuButton, MenuItem, Throbber, Menu, ListBox, Radio, ResizeHandle, SelectBox, Slider, Spacer, SplitButton,
    StackLayout, TabPanel, TextBox
  </span>) </span>{
<span class="hljs-meta">    "use strict"</span>;

    <span class="hljs-keyword">var</span> registerToFactory = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, ref</span>) </span>{
      Factory.add(id.split(<span class="hljs-string">'.'</span>).pop(), ref);
    };

    <span class="hljs-keyword">var</span> expose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, id, ref</span>) </span>{
      <span class="hljs-keyword">var</span> i, fragments;

      fragments = id.split(<span class="hljs-regexp">/[.\/]/</span>);
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; fragments.length - <span class="hljs-number">1</span>; ++i) {
        <span class="hljs-keyword">if</span> (target[fragments[i]] === <span class="hljs-literal">undefined</span>) {
          target[fragments[i]] = {};
        }

        target = target[fragments[i]];
      }

      target[fragments[fragments.length - <span class="hljs-number">1</span>]] = ref;

      registerToFactory(id, ref);
    };

    <span class="hljs-keyword">var</span> appendTo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>{
      expose(target, <span class="hljs-string">'ui.Selector'</span>, Selector);
      expose(target, <span class="hljs-string">'ui.Collection'</span>, Collection);
      expose(target, <span class="hljs-string">'ui.ReflowQueue'</span>, ReflowQueue);
      expose(target, <span class="hljs-string">'ui.Control'</span>, Control);
      expose(target, <span class="hljs-string">'ui.Factory'</span>, Factory);
      expose(target, <span class="hljs-string">'ui.KeyboardNavigation'</span>, KeyboardNavigation);
      expose(target, <span class="hljs-string">'ui.Container'</span>, Container);
      expose(target, <span class="hljs-string">'ui.DragHelper'</span>, DragHelper);
      expose(target, <span class="hljs-string">'ui.Scrollable'</span>, Scrollable);
      expose(target, <span class="hljs-string">'ui.Panel'</span>, Panel);
      expose(target, <span class="hljs-string">'ui.Movable'</span>, Movable);
      expose(target, <span class="hljs-string">'ui.Resizable'</span>, Resizable);
      expose(target, <span class="hljs-string">'ui.FloatPanel'</span>, FloatPanel);
      expose(target, <span class="hljs-string">'ui.Window'</span>, Window);
      expose(target, <span class="hljs-string">'ui.MessageBox'</span>, MessageBox);
      expose(target, <span class="hljs-string">'ui.Tooltip'</span>, Tooltip);
      expose(target, <span class="hljs-string">'ui.Widget'</span>, Widget);
      expose(target, <span class="hljs-string">'ui.Progress'</span>, Progress);
      expose(target, <span class="hljs-string">'ui.Notification'</span>, Notification);
      expose(target, <span class="hljs-string">'ui.Layout'</span>, Layout);
      expose(target, <span class="hljs-string">'ui.AbsoluteLayout'</span>, AbsoluteLayout);
      expose(target, <span class="hljs-string">'ui.Button'</span>, Button);
      expose(target, <span class="hljs-string">'ui.ButtonGroup'</span>, ButtonGroup);
      expose(target, <span class="hljs-string">'ui.Checkbox'</span>, Checkbox);
      expose(target, <span class="hljs-string">'ui.ComboBox'</span>, ComboBox);
      expose(target, <span class="hljs-string">'ui.ColorBox'</span>, ColorBox);
      expose(target, <span class="hljs-string">'ui.PanelButton'</span>, PanelButton);
      expose(target, <span class="hljs-string">'ui.ColorButton'</span>, ColorButton);
      expose(target, <span class="hljs-string">'ui.ColorPicker'</span>, ColorPicker);
      expose(target, <span class="hljs-string">'ui.Path'</span>, Path);
      expose(target, <span class="hljs-string">'ui.ElementPath'</span>, ElementPath);
      expose(target, <span class="hljs-string">'ui.FormItem'</span>, FormItem);
      expose(target, <span class="hljs-string">'ui.Form'</span>, Form);
      expose(target, <span class="hljs-string">'ui.FieldSet'</span>, FieldSet);
      expose(target, <span class="hljs-string">'ui.FilePicker'</span>, FilePicker);
      expose(target, <span class="hljs-string">'ui.FitLayout'</span>, FitLayout);
      expose(target, <span class="hljs-string">'ui.FlexLayout'</span>, FlexLayout);
      expose(target, <span class="hljs-string">'ui.FlowLayout'</span>, FlowLayout);
      expose(target, <span class="hljs-string">'ui.FormatControls'</span>, FormatControls);
      expose(target, <span class="hljs-string">'ui.GridLayout'</span>, GridLayout);
      expose(target, <span class="hljs-string">'ui.Iframe'</span>, Iframe);
      expose(target, <span class="hljs-string">'ui.InfoBox'</span>, InfoBox);
      expose(target, <span class="hljs-string">'ui.Label'</span>, Label);
      expose(target, <span class="hljs-string">'ui.Toolbar'</span>, Toolbar);
      expose(target, <span class="hljs-string">'ui.MenuBar'</span>, MenuBar);
      expose(target, <span class="hljs-string">'ui.MenuButton'</span>, MenuButton);
      expose(target, <span class="hljs-string">'ui.MenuItem'</span>, MenuItem);
      expose(target, <span class="hljs-string">'ui.Throbber'</span>, Throbber);
      expose(target, <span class="hljs-string">'ui.Menu'</span>, Menu);
      expose(target, <span class="hljs-string">'ui.ListBox'</span>, ListBox);
      expose(target, <span class="hljs-string">'ui.Radio'</span>, Radio);
      expose(target, <span class="hljs-string">'ui.ResizeHandle'</span>, ResizeHandle);
      expose(target, <span class="hljs-string">'ui.SelectBox'</span>, SelectBox);
      expose(target, <span class="hljs-string">'ui.Slider'</span>, Slider);
      expose(target, <span class="hljs-string">'ui.Spacer'</span>, Spacer);
      expose(target, <span class="hljs-string">'ui.SplitButton'</span>, SplitButton);
      expose(target, <span class="hljs-string">'ui.StackLayout'</span>, StackLayout);
      expose(target, <span class="hljs-string">'ui.TabPanel'</span>, TabPanel);
      expose(target, <span class="hljs-string">'ui.TextBox'</span>, TextBox);
      expose(target, <span class="hljs-string">'ui.Api'</span>, Api);
    };

    <span class="hljs-keyword">var</span> Api = {
      <span class="hljs-attr">appendTo</span>: appendTo
    };

    <span class="hljs-keyword">return</span> Api;
  }
);
<span class="hljs-comment">/**
 * Tinymce.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.api.Tinymce'</span>,
  [
    <span class="hljs-string">'tinymce.core.geom.Rect'</span>,
    <span class="hljs-string">'tinymce.core.util.Promise'</span>,
    <span class="hljs-string">'tinymce.core.util.Delay'</span>,
    <span class="hljs-string">'tinymce.core.Env'</span>,
    <span class="hljs-string">'tinymce.core.dom.EventUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.Sizzle'</span>,
    <span class="hljs-string">'tinymce.core.util.Tools'</span>,
    <span class="hljs-string">'tinymce.core.dom.DomQuery'</span>,
    <span class="hljs-string">'tinymce.core.html.Styles'</span>,
    <span class="hljs-string">'tinymce.core.dom.TreeWalker'</span>,
    <span class="hljs-string">'tinymce.core.html.Entities'</span>,
    <span class="hljs-string">'tinymce.core.dom.DOMUtils'</span>,
    <span class="hljs-string">'tinymce.core.dom.ScriptLoader'</span>,
    <span class="hljs-string">'tinymce.core.AddOnManager'</span>,
    <span class="hljs-string">'tinymce.core.dom.RangeUtils'</span>,
    <span class="hljs-string">'tinymce.core.html.Node'</span>,
    <span class="hljs-string">'tinymce.core.html.Schema'</span>,
    <span class="hljs-string">'tinymce.core.html.SaxParser'</span>,
    <span class="hljs-string">'tinymce.core.html.DomParser'</span>,
    <span class="hljs-string">'tinymce.core.html.Writer'</span>,
    <span class="hljs-string">'tinymce.core.html.Serializer'</span>,
    <span class="hljs-string">'tinymce.core.dom.Serializer'</span>,
    <span class="hljs-string">'tinymce.core.util.VK'</span>,
    <span class="hljs-string">'tinymce.core.dom.ControlSelection'</span>,
    <span class="hljs-string">'tinymce.core.dom.BookmarkManager'</span>,
    <span class="hljs-string">'tinymce.core.dom.Selection'</span>,
    <span class="hljs-string">'tinymce.core.Formatter'</span>,
    <span class="hljs-string">'tinymce.core.UndoManager'</span>,
    <span class="hljs-string">'tinymce.core.EditorCommands'</span>,
    <span class="hljs-string">'tinymce.core.util.URI'</span>,
    <span class="hljs-string">'tinymce.core.util.Class'</span>,
    <span class="hljs-string">'tinymce.core.util.EventDispatcher'</span>,
    <span class="hljs-string">'tinymce.core.util.Observable'</span>,
    <span class="hljs-string">'tinymce.core.WindowManager'</span>,
    <span class="hljs-string">'tinymce.core.NotificationManager'</span>,
    <span class="hljs-string">'tinymce.core.EditorObservable'</span>,
    <span class="hljs-string">'tinymce.core.Shortcuts'</span>,
    <span class="hljs-string">'tinymce.core.Editor'</span>,
    <span class="hljs-string">'tinymce.core.util.I18n'</span>,
    <span class="hljs-string">'tinymce.core.FocusManager'</span>,
    <span class="hljs-string">'tinymce.core.EditorManager'</span>,
    <span class="hljs-string">'tinymce.core.util.XHR'</span>,
    <span class="hljs-string">'tinymce.core.util.JSON'</span>,
    <span class="hljs-string">'tinymce.core.util.JSONRequest'</span>,
    <span class="hljs-string">'tinymce.core.util.JSONP'</span>,
    <span class="hljs-string">'tinymce.core.util.LocalStorage'</span>,
    <span class="hljs-string">'tinymce.core.api.Compat'</span>,
    <span class="hljs-string">'tinymce.core.util.Color'</span>,
    <span class="hljs-string">'tinymce.core.ui.Api'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">
    Rect, Promise, Delay, Env, EventUtils, Sizzle, Tools, DomQuery, Styles, TreeWalker, Entities, DOMUtils, ScriptLoader, AddOnManager,
    RangeUtils, Node, Schema, SaxParser, DomParser, Writer, HtmlSerializer, DomSerializer, VK, ControlSelection, BookmarkManager, Selection,
    Formatter, UndoManager, EditorCommands, URI, Class, EventDispatcher, Observable, WindowManager,
    NotificationManager, EditorObservable, Shortcuts, Editor, I18n, FocusManager, EditorManager,
    XHR, JSON, JSONRequest, JSONP, LocalStorage, Compat, Color, Api
  </span>) </span>{
    <span class="hljs-keyword">var</span> tinymce = EditorManager;

    <span class="hljs-keyword">var</span> expose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, id, ref</span>) </span>{
      <span class="hljs-keyword">var</span> i, fragments;

      fragments = id.split(<span class="hljs-regexp">/[.\/]/</span>);
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; fragments.length - <span class="hljs-number">1</span>; ++i) {
        <span class="hljs-keyword">if</span> (target[fragments[i]] === <span class="hljs-literal">undefined</span>) {
          target[fragments[i]] = {};
        }

        target = target[fragments[i]];
      }

      target[fragments[fragments.length - <span class="hljs-number">1</span>]] = ref;
    };

    expose(tinymce, <span class="hljs-string">'geom.Rect'</span>, Rect);
    expose(tinymce, <span class="hljs-string">'util.Promise'</span>, <span class="hljs-built_in">Promise</span>);
    expose(tinymce, <span class="hljs-string">'util.Delay'</span>, Delay);
    expose(tinymce, <span class="hljs-string">'Env'</span>, Env);
    expose(tinymce, <span class="hljs-string">'dom.EventUtils'</span>, EventUtils);
    expose(tinymce, <span class="hljs-string">'dom.Sizzle'</span>, Sizzle);
    expose(tinymce, <span class="hljs-string">'util.Tools'</span>, Tools);
    expose(tinymce, <span class="hljs-string">'dom.DomQuery'</span>, DomQuery);
    expose(tinymce, <span class="hljs-string">'html.Styles'</span>, Styles);
    expose(tinymce, <span class="hljs-string">'dom.TreeWalker'</span>, TreeWalker);
    expose(tinymce, <span class="hljs-string">'html.Entities'</span>, Entities);
    expose(tinymce, <span class="hljs-string">'dom.DOMUtils'</span>, DOMUtils);
    expose(tinymce, <span class="hljs-string">'dom.ScriptLoader'</span>, ScriptLoader);
    expose(tinymce, <span class="hljs-string">'AddOnManager'</span>, AddOnManager);
    expose(tinymce, <span class="hljs-string">'dom.RangeUtils'</span>, RangeUtils);
    expose(tinymce, <span class="hljs-string">'html.Node'</span>, Node);
    expose(tinymce, <span class="hljs-string">'html.Schema'</span>, Schema);
    expose(tinymce, <span class="hljs-string">'html.SaxParser'</span>, SaxParser);
    expose(tinymce, <span class="hljs-string">'html.DomParser'</span>, DomParser);
    expose(tinymce, <span class="hljs-string">'html.Writer'</span>, Writer);
    expose(tinymce, <span class="hljs-string">'html.Serializer'</span>, HtmlSerializer);
    expose(tinymce, <span class="hljs-string">'dom.Serializer'</span>, DomSerializer);
    expose(tinymce, <span class="hljs-string">'util.VK'</span>, VK);
    expose(tinymce, <span class="hljs-string">'dom.ControlSelection'</span>, ControlSelection);
    expose(tinymce, <span class="hljs-string">'dom.BookmarkManager'</span>, BookmarkManager);
    expose(tinymce, <span class="hljs-string">'dom.Selection'</span>, Selection);
    expose(tinymce, <span class="hljs-string">'Formatter'</span>, Formatter);
    expose(tinymce, <span class="hljs-string">'UndoManager'</span>, UndoManager);
    expose(tinymce, <span class="hljs-string">'EditorCommands'</span>, EditorCommands);
    expose(tinymce, <span class="hljs-string">'util.URI'</span>, URI);
    expose(tinymce, <span class="hljs-string">'util.Class'</span>, Class);
    expose(tinymce, <span class="hljs-string">'util.EventDispatcher'</span>, EventDispatcher);
    expose(tinymce, <span class="hljs-string">'util.Observable'</span>, Observable);
    expose(tinymce, <span class="hljs-string">'WindowManager'</span>, WindowManager);
    expose(tinymce, <span class="hljs-string">'NotificationManager'</span>, NotificationManager);
    expose(tinymce, <span class="hljs-string">'EditorObservable'</span>, EditorObservable);
    expose(tinymce, <span class="hljs-string">'Shortcuts'</span>, Shortcuts);
    expose(tinymce, <span class="hljs-string">'Editor'</span>, Editor);
    expose(tinymce, <span class="hljs-string">'util.I18n'</span>, I18n);
    expose(tinymce, <span class="hljs-string">'FocusManager'</span>, FocusManager);
    expose(tinymce, <span class="hljs-string">'EditorManager'</span>, EditorManager);
    expose(tinymce, <span class="hljs-string">'util.XHR'</span>, XHR);
    expose(tinymce, <span class="hljs-string">'util.JSON'</span>, <span class="hljs-built_in">JSON</span>);
    expose(tinymce, <span class="hljs-string">'util.JSONRequest'</span>, JSONRequest);
    expose(tinymce, <span class="hljs-string">'util.JSONP'</span>, JSONP);
    expose(tinymce, <span class="hljs-string">'util.LocalStorage'</span>, LocalStorage);
    expose(tinymce, <span class="hljs-string">'Compat'</span>, Compat);
    expose(tinymce, <span class="hljs-string">'util.Color'</span>, Color);

    Api.appendTo(tinymce);

    Compat.register(tinymce);

    <span class="hljs-keyword">return</span> tinymce;
  }
);

<span class="hljs-comment">/**
 * Register.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

<span class="hljs-comment">/**
 * This registers tinymce in common module loaders.
 *
 * @private
 * @class tinymce.Register
 */</span>
define(
  <span class="hljs-string">'tinymce.core.Register'</span>,
  [
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">/*eslint consistent-this: 0 */</span>
    <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span> || <span class="hljs-built_in">window</span>;

    <span class="hljs-keyword">var</span> exposeToModuleLoaders = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tinymce</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> context.define === <span class="hljs-string">"function"</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1911">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1911">&#182;</a>
              </div>
              <p>Bolt</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!context.define.amd) {
          context.define(<span class="hljs-string">"ephox/tinymce"</span>, [], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> tinymce;
          });

          context.define(<span class="hljs-string">"tinymce.core.EditorManager"</span>, [], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> tinymce;
          });
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> === <span class="hljs-string">'object'</span>) {
        <span class="hljs-comment">/* global module */</span>
        <span class="hljs-built_in">module</span>.exports = tinymce;
      }
    };

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">exposeToModuleLoaders</span>: exposeToModuleLoaders
    };
  }
);

<span class="hljs-comment">/**
 * Main.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */</span>

define(
  <span class="hljs-string">'tinymce.core.api.Main'</span>,
  [
    <span class="hljs-string">'tinymce.core.api.Tinymce'</span>,
    <span class="hljs-string">'tinymce.core.Register'</span>
  ],
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tinymce, Register</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">window</span>.tinymce = tinymce;
      <span class="hljs-built_in">window</span>.tinyMCE = tinymce;
      Register.exposeToModuleLoaders(tinymce);
      <span class="hljs-keyword">return</span> tinymce;
    };
  }
);

dem(<span class="hljs-string">'tinymce.core.api.Main'</span>)();
})();</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
